InCoderInputConfig = {
    "INCODER_COMPLETE_CODEFORM_NOCOMMENT": {
        "model_id": "incoder-1B/6B",
        "input": "whole buggy function, with the bugggy line masked by <|mask:0|>",
        "patch": "code generated by the model, which will replace the entire buggy function. need extra analysis to figure out where to stop"
    },
    "INCODER_COMPLETE_CODEFORM_COMMENTFORM_NOCOMMENT": {
        "model_id": "incoder-1B/6B",
        "input": "whole buggy function, with the bugggy line masked by <|mask:0|>",
        "patch": "the buggy function before the buggy lines, with buggy lines start with '// buggy line:'. remove all the other commonts and empty lines in the code"
    }
}

def incoder_output_to_patch(output):
    """
    find the } that matches the first { in the output
    """
    output = output.replace('<| file ext=.java |>', '')
    output = output.replace('<|endoftext|>', '')
    end_comment_ind = output.find('*/')
    end_comment_ind = 0 if end_comment_ind == -1 else end_comment_ind+2
    output = output[end_comment_ind:]
    output = output.split('<|mask:0|>')
    if len(output) < 3:
        return ''
    output = output[0] + output[2]
    output = output.strip().split('\n')
    no_comment_output = [line for line in output if not line.strip().startswith('//')]
    output = '\n'.join(no_comment_output)
    stack = ['{']
    try:
        start_index = output.index('{')
        patch = output[: start_index + 1]
        for c in output[start_index + 1: ]:
            patch += c
            if c == '}':
                top = stack.pop()
                if top != '{':
                    return ''
                if len(stack) == 0:
                    return patch.strip()
            elif c == '{':
                stack.append(c)
        return ''
    except Exception as e:
        return ''