{
  "config": "CODET5_REFINE_CODEFORM_NOCOMMENT",
  "data": {
    "Chart_4_source/org/jfree/chart/plot/XYPlot.java_4493-4493": {
      "loc": "4493-4493",
      "input": "public Range getDataRange(ValueAxis axis) {\n    Range result = null;\n    List mappedDatasets = new ArrayList();\n    List includedAnnotations = new ArrayList();\n    boolean isDomainAxis = true;\n    int domainIndex = getDomainAxisIndex(axis);\n    if (domainIndex >= 0) {\n        isDomainAxis = true;\n        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                new Integer(domainIndex)));\n        if (domainIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n    int rangeIndex = getRangeAxisIndex(axis);\n    if (rangeIndex >= 0) {\n        isDomainAxis = false;\n        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                new Integer(rangeIndex)));\n        if (rangeIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n    Iterator iterator = mappedDatasets.iterator();\n    while (iterator.hasNext()) {\n        XYDataset d = (XYDataset) iterator.next();\n        if (d != null) {\n            XYItemRenderer r = getRendererForDataset(d);\n            if (isDomainAxis) {\n                if (r != null) {\n                    result = Range.combine(result, r.findDomainBounds(d));\n                }\n                else {\n                    result = Range.combine(result,\n                            DatasetUtilities.findDomainBounds(d));\n                }\n            }\n            else {\n                if (r != null) {\n                    result = Range.combine(result, r.findRangeBounds(d));\n                }\n                else {\n                    result = Range.combine(result,\n                            DatasetUtilities.findRangeBounds(d));\n                }\n            }\n                Collection c = r.getAnnotations();\n                Iterator i = c.iterator();\n                while (i.hasNext()) {\n                    XYAnnotation a = (XYAnnotation) i.next();\n                    if (a instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(a);\n                    }\n                }\n        }\n    }\n    Iterator it = includedAnnotations.iterator();\n    while (it.hasNext()) {\n        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n        if (xyabi.getIncludeInDataBounds()) {\n            if (isDomainAxis) {\n                result = Range.combine(result, xyabi.getXRange());\n            }\n            else {\n                result = Range.combine(result, xyabi.getYRange());\n            }\n        }\n    }\n    return result;\n}",
      "target": "public Range getDataRange(ValueAxis axis) {\n    Range result = null;\n    List mappedDatasets = new ArrayList();\n    List includedAnnotations = new ArrayList();\n    boolean isDomainAxis = true;\n    int domainIndex = getDomainAxisIndex(axis);\n    if (domainIndex >= 0) {\n        isDomainAxis = true;\n        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                new Integer(domainIndex)));\n        if (domainIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n    int rangeIndex = getRangeAxisIndex(axis);\n    if (rangeIndex >= 0) {\n        isDomainAxis = false;\n        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                new Integer(rangeIndex)));\n        if (rangeIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n    Iterator iterator = mappedDatasets.iterator();\n    while (iterator.hasNext()) {\n        XYDataset d = (XYDataset) iterator.next();\n        if (d != null) {\n            XYItemRenderer r = getRendererForDataset(d);\n            if (isDomainAxis) {\n                if (r != null) {\n                    result = Range.combine(result, r.findDomainBounds(d));\n                }\n                else {\n                    result = Range.combine(result,\n                            DatasetUtilities.findDomainBounds(d));\n                }\n            }\n            else {\n                if (r != null) {\n                    result = Range.combine(result, r.findRangeBounds(d));\n                }\n                else {\n                    result = Range.combine(result,\n                            DatasetUtilities.findRangeBounds(d));\n                }\n            }\n            if (r != null) {\n                Collection c = r.getAnnotations();\n                Iterator i = c.iterator();\n                while (i.hasNext()) {\n                    XYAnnotation a = (XYAnnotation) i.next();\n                    if (a instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(a);\n                    }\n                }\n            }\n        }\n    }\n    Iterator it = includedAnnotations.iterator();\n    while (it.hasNext()) {\n        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n        if (xyabi.getIncludeInDataBounds()) {\n            if (isDomainAxis) {\n                result = Range.combine(result, xyabi.getXRange());\n            }\n            else {\n                result = Range.combine(result, xyabi.getYRange());\n            }\n        }\n    }\n    return result;\n}",
      "function range": "4425,5-4519,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_14_/src/com/google/javascript/jscomp/ControlFlowAnalysis.java_767-768": {
      "loc": "767-768",
      "input": "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa != null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa != null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n        }\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n  }\n  Node nextSibling = node.getNext();\n  while (nextSibling != null && nextSibling.isFunction()) {\n    nextSibling = nextSibling.getNext();\n  }\n  if (nextSibling != null) {\n    return computeFallThrough(nextSibling);\n  } else {\n    return computeFollowNode(fromNode, parent, cfa);\n  }\n}",
      "target": "private static Node computeFollowNode(\n    Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() ||\n      (cfa != null && node == cfa.root)) {\n    return null;\n  }\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      break;\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n    case Token.TRY:\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(parent.getLastChild());\n        } else { \n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node){\n        if (NodeUtil.hasFinally(parent)) { \n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node){\n        if (cfa != null) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n          }\n        }\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n  }\n  Node nextSibling = node.getNext();\n  while (nextSibling != null && nextSibling.isFunction()) {\n    nextSibling = nextSibling.getNext();\n  }\n  if (nextSibling != null) {\n    return computeFallThrough(nextSibling);\n  } else {\n    return computeFollowNode(fromNode, parent, cfa);\n  }\n}",
      "function range": "692,3-789,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_24_/src/java/org/apache/commons/cli/HelpFormatter.java_825-827": {
      "loc": "825-827",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n                                        \"- no room for the description\");\n    }\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(text);\n            return sb;\n        }\n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
      "target": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 1;\n    }\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(text);\n            return sb;\n        }\n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
      "function range": "809,5-852,5",
      "raw_output": [
        "String function ( final Map arg0, final String arg1, final Map arg2 ) { return render ( arg0. get ( arg1 ), arg2 ) ; }",
        "String function ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( final Renderable arg0, final Map < String, Object > arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
        "String function ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1. get ( arg0 ) ) ; }",
        "String function ( final String arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getText ( ) ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getAttributes ( ) ) ; }",
        "void function ( FacesContext arg0, UIComponent arg1 ) { render ( arg0, arg1. getText ( ) ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getChildren ( ) ) ; }",
        "StringBuffer function ( ) { StringBuffer loc0 = new StringBuffer ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0 ; }",
        "StringBuffer function ( ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( this. text ) ; return loc0 ; }",
        "StringBuffer function ( ) { StringBuffer loc0 = new StringBuffer ( ) ; render ( loc0, new StringBuffer ( ) ) ; return loc0 ; }",
        "StringBuffer function ( ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( \"srini_string\" ) ; return loc0 ; }",
        "StringBuffer function ( ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. append ( loc0 ) ; return loc0 ; }",
        "String function ( final String arg0, final Map < String, Object > arg1 ) { return wrap ( arg0, arg1, new StringBuilder ( ) ). toString ( ) ; }",
        "String function ( final String arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, new StringBuilder ( ) ). toString ( ) ; }",
        "String function ( final String arg0, final Map < String, Object > arg1 ) { return wrap ( arg0 ( arg0 ), arg1 ) ; }",
        "String function ( final Renderable arg0, final Map < String, Object > arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
        "String function ( final String arg0, final Map < String, Object > arg1 ) { return wrap ( arg0, arg1, new PrintStream ( ) ) ; }",
        "String function ( final Renderable arg0, final Attributes arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( final Renderable arg0, final Attributes arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
        "String function ( final Renderable arg0, final Attributes arg1 ) { return render ( arg0, null, arg1 ) ; }",
        "String function ( final Renderable arg0, final Attributes arg1 ) { return render ( arg0, new TextWrapper ( arg1 ) ) ; }",
        "String function ( final CharSequence arg0, final Attributes arg1 ) { return render ( arg0, arg1, null ) ; }"
      ],
      "mid_translation": [
        "Render wrapped text.",
        "Render the wrapped text.",
        "Render the text to a StringBuffer.",
        "Render the text that is wrapped in a single line.",
        "Render the text wrapped in a Sequence of Attributes."
      ],
      "output": [
        {
          "patch": "protected String renderWrappedText ( final Map arg0, final String arg1, final Map arg2 ) { return render ( arg0. get ( arg1 ), arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final Renderable arg0, final Map < String, Object > arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1. get ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final String arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getAttributes ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { render ( arg0, arg1. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getChildren ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( ) { StringBuffer loc0 = new StringBuffer ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( this. text ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( ) { StringBuffer loc0 = new StringBuffer ( ) ; render ( loc0, new StringBuffer ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( \"srini_string\" ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. append ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final String arg0, final Map < String, Object > arg1 ) { return wrap ( arg0, arg1, new StringBuilder ( ) ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final String arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, new StringBuilder ( ) ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final String arg0, final Map < String, Object > arg1 ) { return wrap ( arg0 ( arg0 ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final Renderable arg0, final Map < String, Object > arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final String arg0, final Map < String, Object > arg1 ) { return wrap ( arg0, arg1, new PrintStream ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final Renderable arg0, final Attributes arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final Renderable arg0, final Attributes arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final Renderable arg0, final Attributes arg1 ) { return render ( arg0, null, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final Renderable arg0, final Attributes arg1 ) { return render ( arg0, new TextWrapper ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final CharSequence arg0, final Attributes arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_32_/src/main/java/org/apache/commons/cli/HelpFormatter.java_937-939": {
      "loc": "937-939",
      "input": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n            && (c != '\\n') && (c != '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n           && (c != '\\n') && (c != '\\r'))\n    {\n        ++pos;\n    }        \n    return pos == text.length() ? -1 : pos;\n}",
      "target": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n            && (c != '\\n') && (c != '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n    return pos == text.length() ? -1 : pos;\n}",
      "function range": "902,5-943,5",
      "raw_output": [
        "WrapPos function ( T arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. size ( ) ; loc0 ++ ) if ( arg1. get ( loc0 ) == arg0 ) return new WrapPos ( arg0, arg1. get ( loc0 ) ) ; return null ; }",
        "WrapPos function ( T arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. size ( ) ; loc0 ++ ) { if ( arg1. get ( loc0 ) == arg0 ) return new WrapPos ( arg0, arg1. get ( loc0 ) ) ; } return null ; }",
        "WrapPos function ( T arg0, List < T > arg1 ) { for ( int loc0 = arg1. size ( ) - 1 ; loc0 >= 0 ; loc0 -- ) if ( arg0. get ( loc0 ) == arg0 ) return new WrapPos ( arg0, arg1. get ( loc0 ) ) ; return null ; }",
        "WrapPos function ( T arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. size ( ) ; loc0 ++ ) { T loc1 = arg1. get ( loc0 ) ; if ( loc1 instanceof WrapPos ) { return ( WrapPos ) loc0 ; } } return null ; }",
        "WrapPos function ( T arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. size ( ) ; loc0 ++ ) if ( arg1. get ( loc0 ) == arg0 ) return new WrapPos ( arg0, arg1. get ( loc0 + 1 ) ) ; return null ; }",
        "WrapPos function ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. equals ( arg0 ) ) { return new WrapPos ( arg0, arg1 [ loc0 ] ) ; } } return null ; }",
        "WrapPos function ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. equals ( arg0 ) ) { return ( WrapPos ) arg1 [ loc0 ] ; } } return null ; }",
        "WrapPos function ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. equals ( arg0 ) ) { return new WrapPos ( arg0, loc0 ) ; } } return null ; }",
        "WrapPos function ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. isInstance ( arg0 ) ) { return ( WrapPos ) arg1 [ loc0 ] ; } } return null ; }",
        "WrapPos function ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. isInstance ( arg0 ) ) { return new WrapPos ( arg0, arg1 [ loc0 ] ) ; } } return null ; }",
        "WrapPosition function ( T arg0, List < T > arg1 ) { for ( int loc0 = arg1. size ( ) - 1 ; loc0 >= 0 ; loc0 -- ) { if ( arg0. get ( loc0 ) == arg0 ) { return new WrapPosition ( arg0, loc0 - 1 ) ; } } return null ; }",
        "WrapPosition function ( int [ ] arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return new WrapPosition ( loc0 ) ; } } return null ; }",
        "WrapPosition function ( int [ ] arg0, int arg1 ) { for ( int loc0 = arg0. length - 1 ; loc0 >= 0 ; loc0 -- ) { if ( arg0 [ loc0 ] == arg1 ) { return new WrapPosition ( loc0 ) ; } } return null ; }",
        "WrapPosition function ( int arg0, int arg1 ) { for ( int loc0 = arg0 ; loc0 < arg1 ; loc0 ++ ) { if ( ( arg1 & ( 1 << loc0 ) )!= 0 ) { return new WrapPosition ( arg0, loc0 ) ; } } return null ; }",
        "WrapPosition function ( int [ ] arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return new WrapPosition ( arg0, loc0 ) ; } } return null ; }",
        "WrapPos function ( T arg0, List < T > arg1 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg1 ) { for ( int loc2 = 0 ; loc2 < loc0. size ( ) ; loc2 ++ ) loc0. add ( loc1 ) ; loc0. remove ( loc2 ) ; } return new WrapPos ( arg0, loc0 ) ; }",
        "WrapPos function ( T arg0, List < T > arg1 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg1 ) { for ( int loc2 = 0 ; loc2 < loc0. size ( ) ; loc2 ++ ) loc0. add ( loc1 ) ; } return new WrapPos ( arg0, loc0 ) ; }",
        "WrapPos function ( T arg0, List < T > arg1 ) { List < T > loc0 = Lists. newArrayList ( arg0 ) ; for ( T loc1 : arg1 ) { for ( int loc2 = 0 ; loc2 < loc0. size ( ) ; loc2 ++ ) loc0. add ( loc1 ) ; } return new WrapPos ( loc0, arg0 ) ; }",
        "WrapPos function ( T arg0, List < T > arg1 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg1 ) { for ( int loc2 = 0 ; loc2 < loc0. size ( ) ; loc2 ++ ) loc0. add ( loc1 ) ; } return new WrapPos ( arg0, loc0. get ( 0 ) ) ; }",
        "WrapPos function ( T arg0, List < T > arg1 ) { return new WrapPos ( arg0, arg1 ) ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { if ( arg0. charAt ( loc1 ) == arg2 ) { return loc1 ; } } return - 1 ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( wrapPos ( arg0, loc2, arg2 )!='' ) break ; } return loc0 ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( wrapPos ( arg0, loc2, arg2 )!= - 1 ) break ; } return loc0 ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( wrapPos ( arg0. charAt ( loc1 ), loc2 )!='' ) break ; } return loc0 ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0. charAt ( loc1 ) ; if ( wrapPos ( arg0. charAt ( loc1 ), loc2 )!='' ) break ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Find wrap pos.",
        "findWrapPos Method.",
        "Find wrap position.",
        "find wrap pos.",
        "Find wrap pos in text."
      ],
      "output": [
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. size ( ) ; loc0 ++ ) if ( arg1. get ( loc0 ) == arg0 ) return new WrapPos ( arg0, arg1. get ( loc0 ) ) ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. size ( ) ; loc0 ++ ) { if ( arg1. get ( loc0 ) == arg0 ) return new WrapPos ( arg0, arg1. get ( loc0 ) ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { for ( int loc0 = arg1. size ( ) - 1 ; loc0 >= 0 ; loc0 -- ) if ( arg0. get ( loc0 ) == arg0 ) return new WrapPos ( arg0, arg1. get ( loc0 ) ) ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. size ( ) ; loc0 ++ ) { T loc1 = arg1. get ( loc0 ) ; if ( loc1 instanceof WrapPos ) { return ( WrapPos ) loc0 ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. size ( ) ; loc0 ++ ) if ( arg1. get ( loc0 ) == arg0 ) return new WrapPos ( arg0, arg1. get ( loc0 + 1 ) ) ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. equals ( arg0 ) ) { return new WrapPos ( arg0, arg1 [ loc0 ] ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. equals ( arg0 ) ) { return ( WrapPos ) arg1 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. equals ( arg0 ) ) { return new WrapPos ( arg0, loc0 ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. isInstance ( arg0 ) ) { return ( WrapPos ) arg1 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( int arg0, Class <? > [ ] arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( arg1 [ loc0 ]. isInstance ( arg0 ) ) { return new WrapPos ( arg0, arg1 [ loc0 ] ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPosition findWrapPos ( T arg0, List < T > arg1 ) { for ( int loc0 = arg1. size ( ) - 1 ; loc0 >= 0 ; loc0 -- ) { if ( arg0. get ( loc0 ) == arg0 ) { return new WrapPosition ( arg0, loc0 - 1 ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPosition findWrapPos ( int [ ] arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return new WrapPosition ( loc0 ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPosition findWrapPos ( int [ ] arg0, int arg1 ) { for ( int loc0 = arg0. length - 1 ; loc0 >= 0 ; loc0 -- ) { if ( arg0 [ loc0 ] == arg1 ) { return new WrapPosition ( loc0 ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPosition findWrapPos ( int arg0, int arg1 ) { for ( int loc0 = arg0 ; loc0 < arg1 ; loc0 ++ ) { if ( ( arg1 & ( 1 << loc0 ) )!= 0 ) { return new WrapPosition ( arg0, loc0 ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPosition findWrapPos ( int [ ] arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return new WrapPosition ( arg0, loc0 ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg1 ) { for ( int loc2 = 0 ; loc2 < loc0. size ( ) ; loc2 ++ ) loc0. add ( loc1 ) ; loc0. remove ( loc2 ) ; } return new WrapPos ( arg0, loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg1 ) { for ( int loc2 = 0 ; loc2 < loc0. size ( ) ; loc2 ++ ) loc0. add ( loc1 ) ; } return new WrapPos ( arg0, loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { List < T > loc0 = Lists. newArrayList ( arg0 ) ; for ( T loc1 : arg1 ) { for ( int loc2 = 0 ; loc2 < loc0. size ( ) ; loc2 ++ ) loc0. add ( loc1 ) ; } return new WrapPos ( loc0, arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg1 ) { for ( int loc2 = 0 ; loc2 < loc0. size ( ) ; loc2 ++ ) loc0. add ( loc1 ) ; } return new WrapPos ( arg0, loc0. get ( 0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected WrapPos findWrapPos ( T arg0, List < T > arg1 ) { return new WrapPos ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { if ( arg0. charAt ( loc1 ) == arg2 ) { return loc1 ; } } return - 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected int findWrapPos ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( wrapPos ( arg0, loc2, arg2 )!='' ) break ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( wrapPos ( arg0, loc2, arg2 )!= - 1 ) break ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( wrapPos ( arg0. charAt ( loc1 ), loc2 )!='' ) break ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected int findWrapPos ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0. charAt ( loc1 ) ; if ( wrapPos ( arg0. charAt ( loc1 ), loc2 )!='' ) break ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_4_/src/java/org/apache/commons/cli/Parser.java_298-299": {
      "loc": "298-299",
      "input": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        StringBuffer buff = new StringBuffer();\n        while (iter.hasNext())\n        {\n            buff.append(iter.next());\n        }\n        throw new MissingOptionException(buff.toString());\n    }\n}",
      "target": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n        while (iter.hasNext())\n        {\n            buff.append(iter.next());\n        }\n        throw new MissingOptionException(buff.toString());\n    }\n}",
      "function range": "290,5-309,5",
      "raw_output": [
        "boolean function ( ) { return BuildConfiguration. class. hasOption ( \"srini_string\" ) || BuildConfiguration. class. hasOption ( \"srini_string\" ) ; }",
        "boolean function ( ) { return Boolean. TRUE. equals ( System. getProperty ( \"srini_string\" ) ) ; }",
        "boolean function ( ) { return! ( \"srini_string\". equals ( System. getProperty ( \"srini_string\" ) ) ) ; }",
        "boolean function ( String arg0 ) { return StringUtils. hasLength ( arg0 ) && StringUtils. hasLength ( arg0. trim ( ) ) ; }",
        "boolean function ( Options arg0 ) { return! ( \"srini_string\". equals ( arg0. getOptionName ( ) ) ) ; }",
        "boolean function ( String [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. startsWith ( \"srini_string\" ) ) { return true ; } } return false ; }",
        "boolean function ( Options arg0 ) { return ( arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ) ; }",
        "boolean function ( String [ ] arg0 ) { for ( String loc0 : arg0 ) { if ( loc0. startsWith ( \"srini_string\" ) || loc0. startsWith ( \"srini_string\" ) ) { return true ; } } return false ; }",
        "boolean function ( Options arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
        "boolean function ( String [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. equals ( \"srini_string\" ) ) { return true ; } } return false ; }",
        "boolean function ( ) { return BuildConfiguration. class. equals ( BuildConfiguration. class ) || BuildConfiguration. class. equals ( BuildConfiguration. class ) ; }",
        "boolean function ( ) { return BuildConfiguration. class. equals ( BuildConfiguration. class ) ; }",
        "boolean function ( ) { return BuildConfiguration. DEBUG || BuildConfiguration. DEBUG || BuildConfiguration. DEBUG || BuildConfiguration. DEBUG ; }",
        "boolean function ( OptionsProvider arg0 ) { return Boolean. getBoolean ( \"srini_string\", false ) ; }",
        "boolean function ( ) { return BuildConfig. class. equals ( BuildConfig. class ) || BuildConfig. class. equals ( BuildConfig. class ) ; }",
        "boolean function ( ) { return BuildConfiguration. class. equals ( BuildConfiguration. class ) || BuildConfiguration. class. equals ( BuildConfiguration. class ) ; }",
        "boolean function ( ) { return BuildConfiguration. class. equals ( BuildConfiguration. class ) ; }",
        "boolean function ( OptionsProvider arg0 ) { return Boolean. parseBoolean ( System. getProperty ( \"srini_string\" ) ) ; }",
        "boolean function ( OptionsProvider arg0 ) { return Boolean. parseBoolean ( System. getProperty ( \"srini_string\", \"srini_string\" ) ) ; }",
        "boolean function ( OptionsProvider arg0 ) { return arg0. hasOption ( \"srini_string\" ) ; }",
        "boolean function ( OptionsProvider arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
        "boolean function ( OptionsProvider arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
        "boolean function ( OptionsProviderConfiguration arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
        "boolean function ( OptionsProvider. OptionsProvider arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
        "boolean function ( OptionsProviderOptions arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }"
      ],
      "mid_translation": [
        "Checks if the required options are present.",
        "Check if the required options are present.",
        "Checks if the required options are set.",
        "Check if the required options are set.",
        "Check if required options are present."
      ],
      "output": [
        {
          "patch": "private boolean checkRequiredOptions ( ) { return BuildConfiguration. class. hasOption ( \"srini_string\" ) || BuildConfiguration. class. hasOption ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( ) { return Boolean. TRUE. equals ( System. getProperty ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean checkRequiredOptions ( ) { return! ( \"srini_string\". equals ( System. getProperty ( \"srini_string\" ) ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean checkRequiredOptions ( String arg0 ) { return StringUtils. hasLength ( arg0 ) && StringUtils. hasLength ( arg0. trim ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( Options arg0 ) { return! ( \"srini_string\". equals ( arg0. getOptionName ( ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( String [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. startsWith ( \"srini_string\" ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( Options arg0 ) { return ( arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( String [ ] arg0 ) { for ( String loc0 : arg0 ) { if ( loc0. startsWith ( \"srini_string\" ) || loc0. startsWith ( \"srini_string\" ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( Options arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( String [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. equals ( \"srini_string\" ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( ) { return BuildConfiguration. class. equals ( BuildConfiguration. class ) || BuildConfiguration. class. equals ( BuildConfiguration. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( ) { return BuildConfiguration. class. equals ( BuildConfiguration. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( ) { return BuildConfiguration. DEBUG || BuildConfiguration. DEBUG || BuildConfiguration. DEBUG || BuildConfiguration. DEBUG ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( OptionsProvider arg0 ) { return Boolean. getBoolean ( \"srini_string\", false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( ) { return BuildConfig. class. equals ( BuildConfig. class ) || BuildConfig. class. equals ( BuildConfig. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( ) { return BuildConfiguration. class. equals ( BuildConfiguration. class ) || BuildConfiguration. class. equals ( BuildConfiguration. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( ) { return BuildConfiguration. class. equals ( BuildConfiguration. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( OptionsProvider arg0 ) { return Boolean. parseBoolean ( System. getProperty ( \"srini_string\" ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( OptionsProvider arg0 ) { return Boolean. parseBoolean ( System. getProperty ( \"srini_string\", \"srini_string\" ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( OptionsProvider arg0 ) { return arg0. hasOption ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( OptionsProvider arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( OptionsProvider arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( OptionsProviderConfiguration arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( OptionsProvider. OptionsProvider arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean checkRequiredOptions ( OptionsProviderOptions arg0 ) { return arg0. hasOption ( \"srini_string\" ) || arg0. hasOption ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_10_src/main/java/org/apache/commons/lang3/time/FastDateParser.java_307-314": {
      "loc": "307-314",
      "input": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n        case '\\'':\n            if(unquote) {\n                if(++i==value.length()) {\n                    return regex;\n                }\n                c= value.charAt(i);\n            }\n            break;\n        case '?':\n        case '[':\n        case ']':\n        case '(':\n        case ')':\n        case '{':\n        case '}':\n        case '\\\\':\n        case '|':\n        case '*':\n        case '+':\n        case '^':\n        case '$':\n        case '.':\n            regex.append('\\\\');\n        }\n        regex.append(c);\n    }\n    return regex;\n}",
      "target": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n        switch(c) {\n        case '\\'':\n            if(unquote) {\n                if(++i==value.length()) {\n                    return regex;\n                }\n                c= value.charAt(i);\n            }\n            break;\n        case '?':\n        case '[':\n        case ']':\n        case '(':\n        case ')':\n        case '{':\n        case '}':\n        case '\\\\':\n        case '|':\n        case '*':\n        case '+':\n        case '^':\n        case '$':\n        case '.':\n            regex.append('\\\\');\n        }\n        regex.append(c);\n    }\n    return regex;\n}",
      "function range": "303,5-343,5",
      "raw_output": [
        "String function ( String arg0 ) { return arg0. replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { return arg0. replaceAll ( \"srini_string\", \"srini_string\" ). replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0. getMessage ( ) ) ; } }",
        "String function ( String arg0 ) { return arg0. replaceAll ( \"srini_string\", \"srini_string\" = \"srini_string\" ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { return arg0 ; } }",
        "String function ( String arg0 ) { if ( arg0. matches ( \"srini_string\" ) ) { return \"srini_string\" + arg0 + \"srini_string\" ; } else { return arg0 ; } }",
        "String function ( String arg0 ) { if ( arg0. matches ( \"srini_string\" ) ) { return \"srini_string\" + arg0 + \"srini_string\" ; } return arg0 ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
        "String function ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) || arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } return arg0 ; }",
        "String function ( String arg0 ) { return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; return RegexEscapeUtils. escapeRegex ( arg0 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegex ( arg0 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
        "String function ( String arg0 ) { return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; return RegexEscapeUtils. escapeRegex ( arg0 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegex ( arg0 ) ; }",
        "String function ( String arg0 ) { return Pattern. compile ( arg0 ). replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; return Regex. quote ( arg0 ) ; }",
        "String function ( String arg0 ) { return Regex. quote ( arg0 ) ; }",
        "Pattern function ( String arg0 ) { return Pattern. compile ( arg0, Pattern. MULTILINE ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } return Regex. quote ( arg0 ) ; }"
      ],
      "mid_translation": [
        "Escape regex.",
        "Escape regular expression.",
        "Escape the regular expression.",
        "Escape a regular expression.",
        "Escape a regex string."
      ],
      "output": [
        {
          "patch": "private static String escapeRegex ( String arg0 ) { return arg0. replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { return arg0. replaceAll ( \"srini_string\", \"srini_string\" ). replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0. getMessage ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { return arg0. replaceAll ( \"srini_string\", \"srini_string\" = \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) { return null ; } try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0. matches ( \"srini_string\" ) ) { return \"srini_string\" + arg0 + \"srini_string\" ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0. matches ( \"srini_string\" ) ) { return \"srini_string\" + arg0 + \"srini_string\" ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) || arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) return null ; return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) return null ; return RegexEscapeUtils. escapeRegex ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegex ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) return null ; return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { return RegexEscapeUtils. escapeRegularExpression ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) return null ; return RegexEscapeUtils. escapeRegex ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) { return null ; } return RegexEscapeUtils. escapeRegex ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { return Pattern. compile ( arg0 ). replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) return null ; return Regex. quote ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { return Regex. quote ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Pattern escapeRegex ( String arg0 ) { return Pattern. compile ( arg0, Pattern. MULTILINE ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String escapeRegex ( String arg0 ) { if ( arg0 == null ) { return null ; } return Regex. quote ( arg0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_65_src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java_254-255": {
      "loc": "254-255",
      "input": "\npublic double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual / residualsWeights[i];\n    }\n    return chiSquare;\n}",
      "target": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += residual * residual * residualsWeights[i];\n    }\n    return chiSquare;\n}",
      "function range": "254,5-261,5",
      "raw_output": [
        "double function ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 + loc2 * loc2 ) ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; double loc4 = Math. pow ( arg1 - arg0, 2 ) ; return ( loc0 * loc0 + loc1 * loc3 ) / loc4 ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; double loc4 = Math. pow ( arg1 - arg1, 2 ) ; return ( loc0 * loc0 + loc1 * loc3 ) / loc4 ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; double loc4 = Math. pow ( arg1 - arg0, 2 ) ; return ( loc0 * loc0 + loc1 * loc3 ) / loc2 ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; double loc4 = Math. pow ( arg1 - arg1, 2 ) ; return ( loc0 * loc0 + loc1 * loc3 ) / loc2 ; }",
        "ChiSquare function ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "ChiSquare function ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; return null ; }",
        "ChiSquare function ( ) { return new ChiSquare ( \"srini_string\" ) ; }",
        "ChiSquare function ( Square arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; return new ChiSquare ( ( ChiSquare ) arg0 ) ; }",
        "ChiSquare function ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else { return null ; } }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( ( loc2 < 0 ) || ( loc2 > 0 ) ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 || loc2 > 0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( ( loc2 < 0 ) || ( loc2 > 0 ) ) loc0 ++ ; } return loc0 ; }",
        "ChiSquare function ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else if ( arg0 instanceof Square ) { return ( ChiSquare ) arg0 ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "ChiSquare function ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof Square ) return ( Square ) arg0 ; return null ; }",
        "ChiSquare function ( Square arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; return new ChiSquare ( ( ChiSquare ) arg0 ) ; }",
        "ChiSquare function ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else { return null ; } }",
        "ChiSquare function ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof Square ) return ( Square ) arg0 ; else return null ; }",
        "float function ( float arg0, float arg1 ) { return ( float ) Math. sqrt ( arg0 * arg0 + arg1 * arg1 ) ; }",
        "float function ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; float loc1 = arg0 [ 1 ] ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { double loc3 = arg0 [ loc2 ] ; if ( loc3 < loc0 ) loc1 = loc3 ; else if ( loc3 > loc1 ) loc1 = loc3 ; } return loc1 ; }",
        "float function ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; float loc1 = arg0 [ 1 ] ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { double loc3 = arg0 [ loc2 ] ; if ( loc3 < loc0 ) loc1 = loc3 ; else if ( loc3 > loc1 ) loc1 = loc3 ; } return ( float ) loc1 ; }",
        "float function ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; float loc1 = arg0 [ 1 ] ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { double loc3 = arg0 [ loc2 ] ; arg0 [ loc2 ] = ( loc3 - loc2 ) / 2.0f ; } return ( float ) Math. sqrt ( loc0 ) ; }",
        "float function ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; float loc1 = arg0 [ 1 ] ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { float loc3 = arg0 [ loc2 ] ; if ( loc3 < loc0 ) loc1 = loc3 ; else if ( loc3 > loc1 ) loc1 = loc3 ; } return loc1 ; }"
      ],
      "mid_translation": [
        "Gets the chi square.",
        "Gets the Chi Square.",
        "Get the chi square.",
        "Get Chi Square.",
        "Gets the chi - square."
      ],
      "output": [
        {
          "patch": "public double getChiSquare ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 + loc2 * loc2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getChiSquare ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; double loc4 = Math. pow ( arg1 - arg0, 2 ) ; return ( loc0 * loc0 + loc1 * loc3 ) / loc4 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getChiSquare ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; double loc4 = Math. pow ( arg1 - arg1, 2 ) ; return ( loc0 * loc0 + loc1 * loc3 ) / loc4 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getChiSquare ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; double loc4 = Math. pow ( arg1 - arg0, 2 ) ; return ( loc0 * loc0 + loc1 * loc3 ) / loc2 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getChiSquare ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = Math. pow ( arg1, 2 ) ; double loc2 = Math. pow ( arg0 - arg1, 2 ) ; double loc3 = Math. pow ( arg1 - arg0, 2 ) ; double loc4 = Math. pow ( arg1 - arg1, 2 ) ; return ( loc0 * loc0 + loc1 * loc3 ) / loc2 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( ) { return new ChiSquare ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( Square arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; return new ChiSquare ( ( ChiSquare ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getChiSquare ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getChiSquare ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getChiSquare ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( ( loc2 < 0 ) || ( loc2 > 0 ) ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getChiSquare ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 || loc2 > 0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getChiSquare ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( ( loc2 < 0 ) || ( loc2 > 0 ) ) loc0 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else if ( arg0 instanceof Square ) { return ( ChiSquare ) arg0 ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof Square ) return ( Square ) arg0 ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( Square arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; return new ChiSquare ( ( ChiSquare ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else if ( arg0 instanceof ChiSquare ) { return ( ChiSquare ) arg0 ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ChiSquare getChiSquare ( Square arg0 ) { if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof ChiSquare ) return ( ChiSquare ) arg0 ; if ( arg0 instanceof Square ) return ( Square ) arg0 ; else return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public float getChiSquare ( float arg0, float arg1 ) { return ( float ) Math. sqrt ( arg0 * arg0 + arg1 * arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public float getChiSquare ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; float loc1 = arg0 [ 1 ] ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { double loc3 = arg0 [ loc2 ] ; if ( loc3 < loc0 ) loc1 = loc3 ; else if ( loc3 > loc1 ) loc1 = loc3 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public float getChiSquare ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; float loc1 = arg0 [ 1 ] ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { double loc3 = arg0 [ loc2 ] ; if ( loc3 < loc0 ) loc1 = loc3 ; else if ( loc3 > loc1 ) loc1 = loc3 ; } return ( float ) loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public float getChiSquare ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; float loc1 = arg0 [ 1 ] ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { double loc3 = arg0 [ loc2 ] ; arg0 [ loc2 ] = ( loc3 - loc2 ) / 2.0f ; } return ( float ) Math. sqrt ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public float getChiSquare ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; float loc1 = arg0 [ 1 ] ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { float loc3 = arg0 [ loc2 ] ; if ( loc3 < loc0 ) loc1 = loc3 ; else if ( loc3 > loc1 ) loc1 = loc3 ; } return loc1 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_73_/src/com/google/javascript/jscomp/CodeGenerator.java_1045-1046": {
      "loc": "1045-1046",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       \n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        final String END_SCRIPT = \"/script\";\n        final String START_COMMENT = \"!--\";\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "target": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       \n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        final String END_SCRIPT = \"/script\";\n        final String START_COMMENT = \"!--\";\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "function range": "988,3-1058,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_77_src/com/google/javascript/jscomp/CodeGenerator.java_967-967": {
      "loc": "967-967",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       \n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        final String END_SCRIPT = \"/script\";\n        final String START_COMMENT = \"!--\";\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "target": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       \n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        final String END_SCRIPT = \"/script\";\n        final String START_COMMENT = \"!--\";\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          if (c > 0x1f && c <= 0x7f) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "function range": "956,3-1025,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_8_/source/org/jfree/data/time/Week.java_175-176": {
      "loc": "175-176",
      "input": "public Week(Date time, TimeZone zone) {\n    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n\n}",
      "target": "public Week(Date time, TimeZone zone) {\n    this(time, zone, Locale.getDefault());\n\n}",
      "function range": "173,5-176,5",
      "raw_output": [
        "Weeks function ( ) { return new Weeks ( ) ; }",
        "Weekly. Builder function ( ) { return new Week. Builder ( ) ; }",
        "Weekly function ( ) { return new Week ( ) ; }",
        "Weekly. Start function ( ) { return new Week. Start ( ) ; }",
        "Weekly. Create function ( ) { return new Week. Create ( ) ; }",
        "Week function ( ) { return new Week ( ) ; }",
        "Week function ( ) { return SingletonHelper. create ( Week. class ) ; }",
        "Week function ( ) { return new Day ( ) ; }",
        "Week function ( ) { return Sponge. create ( \"srini_string\" ) ; }",
        "Weekly function ( ) { return new Week ( ) ; }",
        "Week function ( ) { return new Week ( ) ; }",
        "Weekly function ( ) { return new Week ( ) ; }",
        "Week function ( ) { return new Day ( ) ; }",
        "Weekday function ( ) { return new Week ( ) ; }",
        "Weeks function ( ) { return new Week ( ) ; }",
        "Wednesday function ( ) { return new Wednesday ( ) ; }",
        "Wednesday function ( int arg0, int arg1, int arg2 ) { return new Wednesday ( arg0, arg1, arg2 ) ; }",
        "Wednesday function ( int arg0, int arg1, int arg2 ) { return new Wednesday ( arg0, arg1, arg2, false ) ; }",
        "Wednesday function ( String arg0, int arg1, int arg2 ) { return new Wednesday ( arg0, arg1, arg2 ) ; }",
        "Wednesday function ( int arg0, int arg1 ) { return new Wednesday ( arg0, arg1 ) ; }",
        "Week function ( Date arg0, int arg1 ) { return new Week ( arg0. getTime ( ), arg1 ) ; }",
        "Week function ( Date arg0, int arg1, int arg2 ) { return new Week ( arg0. getTime ( ), arg1, arg2 ) ; }",
        "Week function ( Date arg0, Time arg1 ) { return new Week ( arg0. get ( ), arg1. get ( ) ) ; }",
        "Week function ( Date arg0, int arg1 ) { if ( arg0 == null || arg1 == 0 ) { return null ; } return new Week ( arg0. getTime ( ), arg1 ) ; }",
        "Week function ( Date arg0, Time arg1 ) { return new Week ( arg0. getTime ( ), arg1. getHour ( ) ) ; }"
      ],
      "mid_translation": [
        "Create a new instance of Week.",
        "Create a new instance of the Week class.",
        "Create an instance of the Week class.",
        "Create a new Wednesday.",
        "Construct a Week object from a date and time."
      ],
      "output": [
        {
          "patch": "public Weeks Week ( ) { return new Weeks ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Weekly. Builder Week ( ) { return new Week. Builder ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Weekly Week ( ) { return new Week ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Weekly. Start Week ( ) { return new Week. Start ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Weekly. Create Week ( ) { return new Week. Create ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( ) { return new Week ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Week Week ( ) { return SingletonHelper. create ( Week. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( ) { return new Day ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( ) { return Sponge. create ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Weekly Week ( ) { return new Week ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( ) { return new Week ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Weekly Week ( ) { return new Week ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( ) { return new Day ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Weekday Week ( ) { return new Week ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Weeks Week ( ) { return new Week ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Wednesday Week ( ) { return new Wednesday ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Wednesday Week ( int arg0, int arg1, int arg2 ) { return new Wednesday ( arg0, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Wednesday Week ( int arg0, int arg1, int arg2 ) { return new Wednesday ( arg0, arg1, arg2, false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Wednesday Week ( String arg0, int arg1, int arg2 ) { return new Wednesday ( arg0, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Wednesday Week ( int arg0, int arg1 ) { return new Wednesday ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( Date arg0, int arg1 ) { return new Week ( arg0. getTime ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( Date arg0, int arg1, int arg2 ) { return new Week ( arg0. getTime ( ), arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( Date arg0, Time arg1 ) { return new Week ( arg0. get ( ), arg1. get ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( Date arg0, int arg1 ) { if ( arg0 == null || arg1 == 0 ) { return null ; } return new Week ( arg0. getTime ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Week Week ( Date arg0, Time arg1 ) { return new Week ( arg0. getTime ( ), arg1. getHour ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_24_src/main/java/org/apache/commons/lang3/math/NumberUtils.java_1413-1414": {
      "loc": "1413-1414",
      "input": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; \n            }\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--; \n    int i = start;\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            foundDigit = false; \n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            return false;\n        }\n        if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns\n            && (chars[i] == 'd'\n                || chars[i] == 'D'\n                || chars[i] == 'f'\n                || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l'\n            || chars[i] == 'L') {\n            return foundDigit && !hasExp;\n        }\n        return false;\n    }\n    return !allowSigns && foundDigit;\n}",
      "target": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars = str.toCharArray();\n    int sz = chars.length;\n    boolean hasExp = false;\n    boolean hasDecPoint = false;\n    boolean allowSigns = false;\n    boolean foundDigit = false;\n    int start = (chars[0] == '-') ? 1 : 0;\n    if (sz > start + 1) {\n        if (chars[start] == '0' && chars[start + 1] == 'x') {\n            int i = start + 2;\n            if (i == sz) {\n                return false; \n            }\n            for (; i < chars.length; i++) {\n                if ((chars[i] < '0' || chars[i] > '9')\n                    && (chars[i] < 'a' || chars[i] > 'f')\n                    && (chars[i] < 'A' || chars[i] > 'F')) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--; \n    int i = start;\n    while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            foundDigit = true;\n            allowSigns = false;\n        } else if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint = true;\n        } else if (chars[i] == 'e' || chars[i] == 'E') {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp = true;\n            allowSigns = true;\n        } else if (chars[i] == '+' || chars[i] == '-') {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns = false;\n            foundDigit = false; \n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i < chars.length) {\n        if (chars[i] >= '0' && chars[i] <= '9') {\n            return true;\n        }\n        if (chars[i] == 'e' || chars[i] == 'E') {\n            return false;\n        }\n        if (chars[i] == '.') {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns\n            && (chars[i] == 'd'\n                || chars[i] == 'D'\n                || chars[i] == 'f'\n                || chars[i] == 'F')) {\n            return foundDigit;\n        }\n        if (chars[i] == 'l'\n            || chars[i] == 'L') {\n            return foundDigit && !hasExp && !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns && foundDigit;\n}",
      "function range": "1319,5-1421,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_67_/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java_318-319": {
      "loc": "318-319",
      "input": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      ) {\n    boolean isChainedProperty =\n        n.getFirstChild().getType() == Token.GETPROP;\n    if (isChainedProperty) {\n      Node child = n.getFirstChild().getFirstChild().getNext();\n      if (child.getType() == Token.STRING &&\n          child.getString().equals(\"prototype\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
      "target": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n      && assign.getParent().getType() == Token.EXPR_RESULT) {\n    boolean isChainedProperty =\n        n.getFirstChild().getType() == Token.GETPROP;\n    if (isChainedProperty) {\n      Node child = n.getFirstChild().getFirstChild().getNext();\n      if (child.getType() == Token.STRING &&\n          child.getString().equals(\"prototype\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
      "function range": "314,5-334,5",
      "raw_output": [
        "boolean function ( Assign arg0 ) { return arg0 instanceof PropertyAssignment && ( ( PropertyAssignment ) arg0 ). getPrototype ( ) == null ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PropertyAssignment &&! ( ( PropertyAssignment ) arg0 ). isPrototype ( ) ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PropertyAssignment && ( ( PropertyAssignment ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PropertyAssign && ( ( PropertyAssignment ) arg0 ). getPrototype ( ) == null ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PrototypeAssignment && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ) == null ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PrototypeAssignment && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PrototypeAssign && ( ( PrototypeAssign ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PrototypeAssignment && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ). equals ( PrototypeAssignment. class ) ; }",
        "boolean function ( final Assign arg0 ) { return arg0 instanceof PrototypeAssignment && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PrototypeAssign && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
        "boolean function ( AssignNode arg0 ) { return arg0. getFirstChild ( ) == arg0 ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof AssignNode && ( ( AssignNode ) arg0 ). getFirstChild ( ) == arg0 ) ; }",
        "boolean function ( Node arg0 ) { return arg0. getFirstChild ( ) == arg0 ; }",
        "boolean function ( AssignNode arg0 ) { return arg0 instanceof PropertyAssignmentNode && ( ( PropertyAssignmentNode ) arg0 ). getParent ( ) == null ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof AssignNode && ( ( AssignNode ) arg0 ). getParent ( ) == null ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PropertyAssign && ( ( PropertyAssign ) arg0 ). getPrototype ( )!= null ; }",
        "boolean function ( final Assign arg0 ) { return arg0 instanceof Assign && ( ( Assign ) arg0 ). getPrototype ( )!= null ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof Assign && ( ( Assign ) arg0 ). getPrototype ( )!= null ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PrototypeAssign && ( ( PrototypeAssign ) arg0 ). getPrototype ( )!= null ; }",
        "boolean function ( final Assign arg0 ) { return arg0 instanceof PropertyAssign && ( ( PropertyAssign ) arg0 ). getPrototype ( )!= null ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PropertyAssignment && ( ( PropertyAssignment ) arg0 ). getPrototype ( ) == null ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PropertyAssign && ( ( PropertyAssign ) arg0 ). getPrototype ( ) == null ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PropertyAssignment &&! ( ( PropertyAssignment ) arg0 ). isPrototype ( ) ; }",
        "boolean function ( Assign arg0 ) { return arg0 instanceof PropertyAssignment && ( ( PropertyAssignment ) arg0 ). getPrototype ( ) == arg0 ; }"
      ],
      "mid_translation": [
        "Returns true if the given assign is a prototype property assignment.",
        "Returns true if the given assign is an assignment to a prototype property.",
        "Returns true if the given assign node is an assignment to a prototype property.",
        "Returns true if the given assign is an assign to a prototype property.",
        "Returns true if the assign is a prototype property assignment."
      ],
      "output": [
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PropertyAssignment && ( ( PropertyAssignment ) arg0 ). getPrototype ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PropertyAssignment &&! ( ( PropertyAssignment ) arg0 ). isPrototype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PropertyAssignment && ( ( PropertyAssignment ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PropertyAssign && ( ( PropertyAssignment ) arg0 ). getPrototype ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PrototypeAssignment && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PrototypeAssignment && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PrototypeAssign && ( ( PrototypeAssign ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PrototypeAssignment && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ). equals ( PrototypeAssignment. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( final Assign arg0 ) { return arg0 instanceof PrototypeAssignment && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PrototypeAssign && ( ( PrototypeAssignment ) arg0 ). getPrototype ( ). equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( AssignNode arg0 ) { return arg0. getFirstChild ( ) == arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Node arg0 ) { return arg0 instanceof AssignNode && ( ( AssignNode ) arg0 ). getFirstChild ( ) == arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Node arg0 ) { return arg0. getFirstChild ( ) == arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( AssignNode arg0 ) { return arg0 instanceof PropertyAssignmentNode && ( ( PropertyAssignmentNode ) arg0 ). getParent ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Node arg0 ) { return arg0 instanceof AssignNode && ( ( AssignNode ) arg0 ). getParent ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PropertyAssign && ( ( PropertyAssign ) arg0 ). getPrototype ( )!= null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( final Assign arg0 ) { return arg0 instanceof Assign && ( ( Assign ) arg0 ). getPrototype ( )!= null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof Assign && ( ( Assign ) arg0 ). getPrototype ( )!= null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PrototypeAssign && ( ( PrototypeAssign ) arg0 ). getPrototype ( )!= null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( final Assign arg0 ) { return arg0 instanceof PropertyAssign && ( ( PropertyAssign ) arg0 ). getPrototype ( )!= null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PropertyAssignment && ( ( PropertyAssignment ) arg0 ). getPrototype ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PropertyAssign && ( ( PropertyAssign ) arg0 ). getPrototype ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PropertyAssignment &&! ( ( PropertyAssignment ) arg0 ). isPrototype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isPrototypePropertyAssign ( Assign arg0 ) { return arg0 instanceof PropertyAssignment && ( ( PropertyAssignment ) arg0 ). getPrototype ( ) == arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_1_/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java_1797-1798": {
      "loc": "1797-1798",
      "input": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset != null) {\n\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n        for (int i = 0; i < seriesCount; i++) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    else {\n        for (int i = seriesCount - 1; i >= 0; i--) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "target": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n    if (dataset == null) {\n\n        return result;\n    }\n    int seriesCount = dataset.getRowCount();\n    if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n        for (int i = 0; i < seriesCount; i++) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    else {\n        for (int i = seriesCount - 1; i >= 0; i--) {\n            if (isSeriesVisibleInLegend(i)) {\n                LegendItem item = getLegendItem(index, i);\n                if (item != null) {\n                    result.add(item);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "function range": "1790,5-1822,5",
      "raw_output": [
        "List < Item > function ( ) { return Lists. newArrayList ( ) ; }",
        "List < Item > function ( ) { return Collections. unmodifiableList ( new ArrayList < Item > ( ) ) ; }",
        "List < Item > function ( ) { return null ; }",
        "List < Item > function ( ) { return Lists. newArrayList ( \"srini_string\" ) ; }",
        "List < Item > function ( Pageable arg0 ) { return arg0. getItems ( ) ; }",
        "List < Item > function ( ) { return null ; }",
        "List < Item > function ( ) { List < Item > loc0 = new ArrayList < Item > ( ) ; return loc0 ; }",
        "List < Item > function ( Group arg0 ) { return arg0. getItems ( ) ; }",
        "List < Item > function ( ) { return Collections. emptyList ( ) ; }",
        "List < Item > function ( Context arg0 ) { return arg0. findElements ( Item. class ) ; }",
        "LegendItemCollection function ( ) { return LegendItemFactory. createLegendItemCollection ( ) ; }",
        "LegendItemCollection function ( ) { return LegendItemService. get ( this ) ; }",
        "LegendItemCollection function ( ) { return LegendItemFactory. createLegendendItemCollection ( ) ; }",
        "LegendItemCollection function ( ) { return LegendItemService. find ( this ) ; }",
        "LegendItemCollection function ( ) { return LegendItemService. create ( this ) ; }",
        "LegendItemCollection function ( ) { return LegendItemFactory. createLegendItemCollection ( ) ; }",
        "LegendItemCollection function ( ) { return LegendItemService. get ( this ) ; }",
        "LegendItemCollection function ( ) { return LegendItemService. create ( this ) ; }",
        "LegendItemCollection function ( ) { return LegendItemService. get ( ) ; }",
        "LegendItemCollection function ( ) { return new LegendItemCollection ( ) ; }",
        "LegendItem [ ] function ( ) { return null ; }",
        "LegendItems function ( ) { return new LegendItems ( ) ; }",
        "LegendItems function ( ) { return null ; }",
        "LegendItem [ ] function ( ) { return new LegendItem [ 0 ] ; }",
        "LegendItems function ( ) { return new LegendItems ( this ) ; }"
      ],
      "mid_translation": [
        "Gets the legend items.",
        "Get the legend items.",
        "Get the LegendItemCollection for this CategoryDataset.",
        "Gets the LegendItemCollection for this CategoryDataset.",
        "Gets the legend items for this category."
      ],
      "output": [
        {
          "patch": "public List < Item > getLegendItems ( ) { return Lists. newArrayList ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < Item > getLegendItems ( ) { return Collections. unmodifiableList ( new ArrayList < Item > ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < Item > getLegendItems ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < Item > getLegendItems ( ) { return Lists. newArrayList ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < Item > getLegendItems ( Pageable arg0 ) { return arg0. getItems ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < Item > getLegendItems ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < Item > getLegendItems ( ) { List < Item > loc0 = new ArrayList < Item > ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < Item > getLegendItems ( Group arg0 ) { return arg0. getItems ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < Item > getLegendItems ( ) { return Collections. emptyList ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < Item > getLegendItems ( Context arg0 ) { return arg0. findElements ( Item. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return LegendItemFactory. createLegendItemCollection ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return LegendItemService. get ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return LegendItemFactory. createLegendendItemCollection ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return LegendItemService. find ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return LegendItemService. create ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return LegendItemFactory. createLegendItemCollection ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return LegendItemService. get ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return LegendItemService. create ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return LegendItemService. get ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItemCollection getLegendItems ( ) { return new LegendItemCollection ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public LegendItem [ ] getLegendItems ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItems getLegendItems ( ) { return new LegendItems ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItems getLegendItems ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItem [ ] getLegendItems ( ) { return new LegendItem [ 0 ] ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LegendItems getLegendItems ( ) { return new LegendItems ( this ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_25_/src/java/org/apache/commons/cli/HelpFormatter.java_825-826": {
      "loc": "825-826",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = width - 1;\n    }\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(text);\n            return sb;\n        }\n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
      "target": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n        nextLineTabStop = 1;\n    }\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(text);\n            return sb;\n        }\n        if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n        {\n            pos = width;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
      "function range": "809,5-851,5",
      "raw_output": [
        "String function ( final Map arg0, final String arg1, final Map arg2 ) { return render ( arg0. get ( arg1 ), arg2 ) ; }",
        "String function ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( final Renderable arg0, final Map < String, Object > arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
        "String function ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1. get ( arg0 ) ) ; }",
        "String function ( final String arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getText ( ) ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getAttributes ( ) ) ; }",
        "void function ( FacesContext arg0, UIComponent arg1 ) { render ( arg0, arg1. getText ( ) ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getChildren ( ) ) ; }",
        "String function ( FacesContext arg0, RenderingContext arg1 ) { return renderWrappedText ( arg0, arg1 ) ; }",
        "String function ( FacesContext arg0, RenderingContext arg1 ) { String loc0 = renderWrappedText ( arg0, arg1 ) ; return loc0 ; }",
        "String function ( FacesContext arg0, RenderingContext arg1 ) { if ( arg1 == null ) throw new NullPointerException ( \"srini_string\" ) ; return renderWrappedText ( arg0, arg1 ) ; }",
        "String function ( FacesContext arg0, RenderingContext arg1 ) { if ( arg1 == null ) throw new NullPointerException ( \"srini_string\" ) ; return renderWrappedText ( arg0, arg1. getText ( ) ) ; }",
        "String function ( FacesContext arg0, RenderingContext arg1 ) { if ( arg1 == null ) throw new NullPointerException ( \"srini_string\" ) ; return renderWrappedText ( arg0, arg1. getBuffer ( ) ) ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, loc0 ) ; return loc0 ; }",
        "StringBuffer function ( FacesContext arg0, UIComponent arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, arg1, loc0 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. getChars ( 0, arg0. length ( ), loc0 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, StringBuffer arg1 ) { arg1. append ( arg0 ) ; return arg1 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, StringBuffer arg1 ) { arg1. append ( arg0 ) ; return arg1 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; ++ loc1 ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }"
      ],
      "mid_translation": [
        "Render wrapped text.",
        "Render the wrapped text.",
        "renderWrappedText Method.",
        "renderWrappedText This method is called to render the text to a StringBuffer.",
        "renderWrappedText This method is called to render the text to a StringBuffer. This method is used to render the text to a StringBuffer."
      ],
      "output": [
        {
          "patch": "protected String renderWrappedText ( final Map arg0, final String arg1, final Map arg2 ) { return render ( arg0. get ( arg1 ), arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final Renderable arg0, final Map < String, Object > arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1. get ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final String arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getAttributes ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { render ( arg0, arg1. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getChildren ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, RenderingContext arg1 ) { return renderWrappedText ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, RenderingContext arg1 ) { String loc0 = renderWrappedText ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, RenderingContext arg1 ) { if ( arg1 == null ) throw new NullPointerException ( \"srini_string\" ) ; return renderWrappedText ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, RenderingContext arg1 ) { if ( arg1 == null ) throw new NullPointerException ( \"srini_string\" ) ; return renderWrappedText ( arg0, arg1. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, RenderingContext arg1 ) { if ( arg1 == null ) throw new NullPointerException ( \"srini_string\" ) ; return renderWrappedText ( arg0, arg1. getBuffer ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, arg1, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. getChars ( 0, arg0. length ( ), loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0, StringBuffer arg1 ) { arg1. append ( arg0 ) ; return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0, StringBuffer arg1 ) { arg1. append ( arg0 ) ; return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; ++ loc1 ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_40_/src/main/java/org/apache/commons/cli/TypeHandler.java_103-104": {
      "loc": "103-104",
      "input": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        return null;\n    }\n}",
      "target": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n        throw new ParseException(\"Unable to handle the class: \" + clazz);\n    }\n}",
      "function range": "62,5-105,5",
      "raw_output": [
        "Value < K > function ( K arg0 ) { return new Value < K > ( arg0 ) ; }",
        "Value function ( ) { return new Value ( ) ; }",
        "Value < T > function ( T arg0 ) { return new Value < T > ( arg0 ) ; }",
        "Value < T > function ( T arg0 ) { return new Value < > ( arg0 ) ; }",
        "Value < T > function ( final T arg0 ) { return new Value < > ( arg0 ) ; }",
        "Value function ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { return Value. valueOf ( arg0 ) ; } }",
        "Value < String > function ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { return Value. valueOf ( arg0 ) ; } }",
        "Value function ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "Value function ( String arg0 ) { return Value. valueOf ( arg0 ) ; }",
        "Value < String > function ( String arg0 ) { return Value. valueOf ( arg0 ) ; }",
        "Value function ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "Value function ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return Long. valueOf ( Long. MAX_VALUE ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Long. valueOf ( Long. MAX_VALUE ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "Value function ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return Long. valueOf ( Long. MAX_VALUE ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return BigInteger. valueOf ( Long. MAX_VALUE ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "Value function ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "Value function ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { return Value. valueOf ( arg0 ) ; } }",
        "Value function ( Integer arg0 ) { throw new AbstractMethodError ( \"srini_string\" ) ; }",
        "Value function ( ) { throw new AbstractMethodError ( \"srini_string\" ) ; }",
        "Value function ( String arg0 ) { return Value. create ( arg0 ) ; }",
        "Value function ( String arg0 ) { return new ConstantImpl ( arg0 ) ; }",
        "Value function ( Class arg0 ) { return createValue ( arg0. getName ( ) ) ; }",
        "T function ( String arg0 ) { try { return Integer. valueOf ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
        "T function ( String arg0 ) { try { return Long. parseLong ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
        "T function ( String arg0 ) { if ( arg0 == null ) { return null ; } try { return Long. parseLong ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "T function ( String arg0 ) { try { return Integer. valueOf ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "T function ( String arg0 ) { try { return Long. parseLong ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }"
      ],
      "mid_translation": [
        "Create value.",
        "Create a value from a String.",
        "Create a value from a string.",
        "Method createValue.",
        "Creates a value from a String."
      ],
      "output": [
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value < K > createValue ( K arg0 ) { return new Value < K > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( ) { return new Value ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value < T > createValue ( T arg0 ) { return new Value < T > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value < T > createValue ( T arg0 ) { return new Value < > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value < T > createValue ( final T arg0 ) { return new Value < > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { return Value. valueOf ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value < String > createValue ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { return Value. valueOf ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { return Value. valueOf ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value < String > createValue ( String arg0 ) { return Value. valueOf ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return Long. valueOf ( Long. MAX_VALUE ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Long. valueOf ( Long. MAX_VALUE ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return Long. valueOf ( Long. MAX_VALUE ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return BigInteger. valueOf ( Long. MAX_VALUE ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { if ( arg0 == null ) { return Value. valueOf ( \"srini_string\" ) ; } else if ( arg0. equals ( \"srini_string\" ) ) { return Value. valueOf ( \"srini_string\" ) ; } else { return Value. valueOf ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( Integer arg0 ) { throw new AbstractMethodError ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( ) { throw new AbstractMethodError ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { return Value. create ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( String arg0 ) { return new ConstantImpl ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static Value createValue ( Class arg0 ) { return createValue ( arg0. getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static T createValue ( String arg0 ) { try { return Integer. valueOf ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static T createValue ( String arg0 ) { try { return Long. parseLong ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static T createValue ( String arg0 ) { if ( arg0 == null ) { return null ; } try { return Long. parseLong ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static T createValue ( String arg0 ) { try { return Integer. valueOf ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@SuppressWarnings(\"unchecked\") \npublic static T createValue ( String arg0 ) { try { return Long. parseLong ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_119_src/com/google/javascript/jscomp/GlobalNamespace.java_366-366": {
      "loc": "366-366",
      "input": "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent != null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getString();\n      break;\n    case Token.GETPROP:\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n              isPropAssign = true;\n            }\n            break;\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          case Token.GETPROP:\n            return;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getQualifiedName();\n      if (name == null) {\n        return;\n      }\n      break;\n    default:\n      return;\n  }\n  if (!isGlobalNameReference(name, scope)) {\n    return;\n  }\n  if (isSet) {\n    if (isGlobalScope(scope)) {\n      handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n    } else {\n      handleSetFromLocal(module, scope, n, parent, name);\n    }\n  } else {\n    handleGet(module, scope, n, parent, name);\n  }\n}",
      "target": "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent != null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.CATCH:\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getString();\n      break;\n    case Token.GETPROP:\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n              isPropAssign = true;\n            }\n            break;\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          case Token.GETPROP:\n            return;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getQualifiedName();\n      if (name == null) {\n        return;\n      }\n      break;\n    default:\n      return;\n  }\n  if (!isGlobalNameReference(name, scope)) {\n    return;\n  }\n  if (isSet) {\n    if (isGlobalScope(scope)) {\n      handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n    } else {\n      handleSetFromLocal(module, scope, n, parent, name);\n    }\n  } else {\n    handleGet(module, scope, n, parent, name);\n  }\n}",
      "function range": "306,5-430,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_8_/src/java/org/apache/commons/cli/HelpFormatter.java_812-813": {
      "loc": "812-813",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(text);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
      "target": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(text);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
      "function range": "792,5-823,5",
      "raw_output": [
        "String function ( final Map arg0, final String arg1, final Map arg2 ) { return render ( arg0. get ( arg1 ), arg2 ) ; }",
        "String function ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( final Renderable arg0, final Map < String, Object > arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
        "String function ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1. get ( arg0 ) ) ; }",
        "String function ( final String arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1, null ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getText ( ) ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getAttributes ( ) ) ; }",
        "void function ( FacesContext arg0, UIComponent arg1 ) { render ( arg0, arg1. getText ( ) ) ; }",
        "String function ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getChildren ( ) ) ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, loc0 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, StringBuffer arg1 ) { if ( arg0 == null ) { arg1. append ( \"srini_string\" ) ; } else { arg1. append ( arg0 ) ; } return arg1 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
        "StringBuffer function ( final String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, loc0 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( loc0, arg0 ) ; return loc0 ; }",
        "void function ( FacesContext arg0, UIComponent arg1 ) { render ( arg0, arg1. getText ( ) ) ; }",
        "void function ( final StringBuilder arg0 ) { render ( arg0. toString ( ) ) ; }",
        "void function ( final Graphics arg0, final String arg1 ) { render ( arg0. getText ( ), arg1 ) ; }",
        "void function ( final IText arg0 ) { render ( arg0. getText ( ) ) ; }",
        "void function ( final Graphics arg0, final String arg1 ) { render ( arg0, arg1, null ) ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, loc0 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, StringBuffer arg1 ) { if ( arg0 == null ) { arg1 = new StringBuffer ( ) ; } else { arg1. append ( arg0 ) ; } return arg1 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
        "StringBuffer function ( final String arg0, final StringBuffer arg1 ) { if ( arg0 == null ) { arg1 = new StringBuffer ( ) ; } else { arg1. append ( arg0 ) ; } return arg1 ; }",
        "StringBuffer function ( String arg0, StringBuffer arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } else { arg1. append ( arg0 ) ; } return arg1 ; }"
      ],
      "mid_translation": [
        "Render wrapped text.",
        "Render the wrapped text.",
        "renderWrappedText This method is used to render the text to a StringBuffer.",
        "Render the text in the wrapped text.",
        "renderWrappedText This method is used to render the text to a StringBuffer. This method is used to render the text to a StringBuffer."
      ],
      "output": [
        {
          "patch": "protected String renderWrappedText ( final Map arg0, final String arg1, final Map arg2 ) { return render ( arg0. get ( arg1 ), arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final Renderable arg0, final Map < String, Object > arg1 ) { return render ( arg0. getText ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final int arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1. get ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( final String arg0, final Map < String, Object > arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getAttributes ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { render ( arg0, arg1. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { return render ( arg0, arg1. getChildren ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0, StringBuffer arg1 ) { if ( arg0 == null ) { arg1. append ( \"srini_string\" ) ; } else { arg1. append ( arg0 ) ; } return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( final String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( loc0, arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void renderWrappedText ( FacesContext arg0, UIComponent arg1 ) { render ( arg0, arg1. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void renderWrappedText ( final StringBuilder arg0 ) { render ( arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void renderWrappedText ( final Graphics arg0, final String arg1 ) { render ( arg0. getText ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void renderWrappedText ( final IText arg0 ) { render ( arg0. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void renderWrappedText ( final Graphics arg0, final String arg1 ) { render ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; renderWrappedText ( arg0, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0, StringBuffer arg1 ) { if ( arg0 == null ) { arg1 = new StringBuffer ( ) ; } else { arg1. append ( arg0 ) ; } return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( final String arg0, final StringBuffer arg1 ) { if ( arg0 == null ) { arg1 = new StringBuffer ( ) ; } else { arg1. append ( arg0 ) ; } return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected StringBuffer renderWrappedText ( String arg0, StringBuffer arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } else { arg1. append ( arg0 ) ; } return arg1 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_17_/source/org/jfree/data/time/TimeSeries.java_857-858": {
      "loc": "857-858",
      "input": "public Object clone() throws CloneNotSupportedException {\n    Object clone = createCopy(0, getItemCount() - 1);\n\n    return clone;\n}",
      "target": "public Object clone() throws CloneNotSupportedException {\n    TimeSeries clone = (TimeSeries) super.clone();\n\n    clone.data = (List) ObjectUtilities.deepClone(this.data);\n    return clone;\n}",
      "function range": "856,5-859,5",
      "raw_output": [
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( ) ; } }",
        "Object function ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( \"srini_string\" ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
        "Object function ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ), loc0 ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( \"srini_string\" ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
        "Object function ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( \"srini_string\" ) ; } }",
        "Object function ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
        "Object function ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
        "Object function ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ), loc0 ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
        "Object function ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
        "Object function ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
        "Object function ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( ) ; } }"
      ],
      "mid_translation": [
        "Create a clone of this object.",
        "Create a deep copy of this object.",
        "Creates a deep copy of this object.",
        "Returns a clone of this object.",
        "Creates a clone of this object."
      ],
      "output": [
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( \"srini_string\" ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ), loc0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( \"srini_string\" ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( \"srini_string\" ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ), loc0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. toString ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Object clone ( ) { try { return super. loc0 ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( loc0. getMessage ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object clone ( ) { try { return super. clone ( ) ; } catch ( CloneNotSupportedException loc0 ) { throw new InternalError ( ) ; } }",
          "correctness": "wrong"
        }
      ]
    },
    "Chart_14_source/org/jfree/chart/plot/CategoryPlot.java_2166-2167": {
      "loc": "2166-2167",
      "input": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    boolean removed = markers.remove(marker);\n\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n}",
      "target": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n    if (markers == null) {\n\n        return false;\n    }\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        fireChangeEvent();\n    }\n    return removed;\n}",
      "function range": "2155,5-2171,5",
      "raw_output": [
        "Marker function ( String arg0 ) { return Marker. remove ( arg0 ) ; }",
        "Marker function ( String arg0 ) { return null ; }",
        "Marker function ( String arg0 ) { return remove ( arg0, null ) ; }",
        "String function ( String arg0 ) { return arg0 + \"srini_string\" ; }",
        "String function ( String arg0 ) { return arg0. substring ( 0, 1 ) ; }",
        "boolean function ( Object arg0, int arg1 ) { return arg0 == null? false : arg0. equals ( arg1 ) ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = arg0. substring ( arg1 + 1 ) ; return loc0 ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( ) ; } Marker loc0 = ( Marker ) arg0 ; arg0. setDomainMarker ( loc0 ) ; return loc0 ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. remove ( arg1 ) ; }",
        "Marker function ( Object arg0, int arg1 ) { return arg0. remove ( arg1 ) ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( \"srini_string\" ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = MarkerFactory. remove ( arg0, arg1 ) ; return loc0 ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = MarkerFactory. remove ( arg0, arg1 ) ; return loc0 ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = MarkerFactory. remove ( arg0, arg1 ) ; return loc0 ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( \"srini_string\" + arg1 ) ; } Marker loc0 = ( Marker ) arg0 ; arg0. set ( arg1, null ) ; return loc0 ; }",
        "boolean function ( Object arg0, int arg1 ) { return arg0 == null? false : arg0. remove ( arg1 ) ; }",
        "String function ( String arg0 ) { return arg0. substring ( 0, 1 ) ; }",
        "Marker function ( String arg0 ) { return Marker. remove ( arg0 ) ; }",
        "Marker function ( String arg0 ) { return null ; }",
        "Marker function ( String arg0 ) { return removeDomainMarker ( arg0, null ) ; }",
        "String function ( String arg0 ) { return arg0. substring ( 0, 1 ). toUpperCase ( ) ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. remove ( arg1 ) ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg0 instanceof Marker ) { Marker loc0 = ( Marker ) arg0 ; arg0 = ( Marker ) arg0 ; return arg0. remove ( loc0 ) ; } else { return null ; } }",
        "boolean function ( Object arg0, int arg1 ) { return arg0 == null? false : arg0. equals ( arg1 ) ; }",
        "Marker function ( Object arg0, int arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = arg0. remove ( arg1 ) ; return loc0 ; }",
        "boolean function ( Object arg0, int arg1 ) { return arg0 == null? false : arg0. remove ( arg1 ) ; }"
      ],
      "mid_translation": [
        "Remove a domain marker.",
        "Removes the domain marker at the specified index.",
        "Remove the domain marker at the specified index.",
        "Removes a domain marker.",
        "Removes the domain marker at the given index."
      ],
      "output": [
        {
          "patch": "public Marker removeDomainMarker ( String arg0 ) { return Marker. remove ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( String arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( String arg0 ) { return remove ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String removeDomainMarker ( String arg0 ) { return arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String removeDomainMarker ( String arg0 ) { return arg0. substring ( 0, 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean removeDomainMarker ( Object arg0, int arg1 ) { return arg0 == null? false : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = arg0. substring ( arg1 + 1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( ) ; } Marker loc0 = ( Marker ) arg0 ; arg0. setDomainMarker ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. remove ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { return arg0. remove ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( \"srini_string\" ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = MarkerFactory. remove ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = MarkerFactory. remove ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = MarkerFactory. remove ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg1 < 0 ) { throw new IndexOutOfBoundsException ( \"srini_string\" + arg1 ) ; } Marker loc0 = ( Marker ) arg0 ; arg0. set ( arg1, null ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean removeDomainMarker ( Object arg0, int arg1 ) { return arg0 == null? false : arg0. remove ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String removeDomainMarker ( String arg0 ) { return arg0. substring ( 0, 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( String arg0 ) { return Marker. remove ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( String arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( String arg0 ) { return removeDomainMarker ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String removeDomainMarker ( String arg0 ) { return arg0. substring ( 0, 1 ). toUpperCase ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. remove ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg0 instanceof Marker ) { Marker loc0 = ( Marker ) arg0 ; arg0 = ( Marker ) arg0 ; return arg0. remove ( loc0 ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean removeDomainMarker ( Object arg0, int arg1 ) { return arg0 == null? false : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker removeDomainMarker ( Object arg0, int arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } Marker loc0 = ( Marker ) arg0 ; arg0 = arg0. remove ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean removeDomainMarker ( Object arg0, int arg1 ) { return arg0 == null? false : arg0. remove ( arg1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_20_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_220-221": {
      "loc": "220-221",
      "input": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value != null) {\n      Node addition = IR.add(\n          IR.string(\"\").srcref(callTarget),\n          value.detachFromParent());\n      n.getParent().replaceChild(n, addition);\n      reportCodeChange();\n      return addition;\n    }\n  }\n  return n;\n}",
      "target": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n    if (value != null && value.getNext() == null &&\n        NodeUtil.isImmutableValue(value)) {\n      Node addition = IR.add(\n          IR.string(\"\").srcref(callTarget),\n          value.detachFromParent());\n      n.getParent().replaceChild(n, addition);\n      reportCodeChange();\n      return addition;\n    }\n  }\n  return n;\n}",
      "function range": "208,3-230,3",
      "raw_output": [
        "Try < T > function ( final Function <? super T,? extends T > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
        "Try < T > function ( final Function0 <? extends T > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
        "Try < T > function ( final Function <? super T,? extends R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
        "Try < R > function ( final R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
        "R function ( R arg0 ) { return Try. wrap ( ( ) -> arg0. fold ( ) ) ; }",
        "Try < R > function ( R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
        "Try < V > function ( final Function < V, R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
        "Try < T > function ( final Function < T, R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
        "Try < R > function ( final R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
        "Try < T > function ( final Try <? extends T > arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
        "R function ( R arg0 ) { return arg0. fold ( ) ; }",
        "R function ( Function0 arg0, R arg1 ) { return arg0. apply ( arg1 ) ; }",
        "R function ( Function0 arg0 ) { R loc0 = arg0. apply ( null ) ; return loc0 ; }",
        "R function ( Function0 arg0 ) { R loc0 = arg0. apply ( 1 ) ; return loc0 ; }",
        "R function ( final R arg0 ) { return arg0. fold ( ) ; }",
        "Try < T > function ( final Function <? super T,? extends T > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
        "Try < T > function ( final Try <? extends T > arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
        "Try < T > function ( final Function < T, R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
        "Try < R > function ( final R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
        "Try < T > function ( final Function <? super T,? extends R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
        "UnaryOperator function ( FunctionCall arg0 ) { return new UnaryOperator ( ) { @ Override public R apply ( R arg1 ) { return arg0. apply ( arg1 ) ; } } ; }",
        "UnaryOperator function ( FunctionCallExpression arg0 ) { return new UnaryOperator ( ) { @ Override public R apply ( R arg1 ) { return arg0. apply ( arg1 ) ; } } ; }",
        "R function ( Function < R, T > arg0 ) { R loc0 = null ; return fold ( arg0. apply ( ), loc0 ) ; }",
        "R function ( Function < R, T > arg0 ) { R loc0 = null ; return fold ( arg0. apply ( null ), loc0 ) ; }",
        "UnaryOperator function ( FunctionCallExpression arg0 ) { return new UnaryOperator ( arg0 ) ; }"
      ],
      "mid_translation": [
        "Try to fold a simple function call.",
        "Try to fold simple function calls.",
        "Tries to fold a simple function call.",
        "Try to fold simple function call.",
        "Try to fold a simple function call into a single call."
      ],
      "output": [
        {
          "patch": "private Try < T > tryFoldSimpleFunctionCall ( final Function <? super T,? extends T > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < T > tryFoldSimpleFunctionCall ( final Function0 <? extends T > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < T > tryFoldSimpleFunctionCall ( final Function <? super T,? extends R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < R > tryFoldSimpleFunctionCall ( final R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( R arg0 ) { return Try. wrap ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < R > tryFoldSimpleFunctionCall ( R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < V > tryFoldSimpleFunctionCall ( final Function < V, R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < T > tryFoldSimpleFunctionCall ( final Function < T, R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < R > tryFoldSimpleFunctionCall ( final R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < T > tryFoldSimpleFunctionCall ( final Try <? extends T > arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( R arg0 ) { return arg0. fold ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( Function0 arg0, R arg1 ) { return arg0. apply ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( Function0 arg0 ) { R loc0 = arg0. apply ( null ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( Function0 arg0 ) { R loc0 = arg0. apply ( 1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( final R arg0 ) { return arg0. fold ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < T > tryFoldSimpleFunctionCall ( final Function <? super T,? extends T > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < T > tryFoldSimpleFunctionCall ( final Try <? extends T > arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < T > tryFoldSimpleFunctionCall ( final Function < T, R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < R > tryFoldSimpleFunctionCall ( final R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < T > tryFoldSimpleFunctionCall ( final Function <? super T,? extends R > arg0 ) { return Try. of ( ( ) -> arg0. apply ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( R arg1 ) { return arg0. apply ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( R arg1 ) { return arg0. apply ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( Function < R, T > arg0 ) { R loc0 = null ; return fold ( arg0. apply ( ), loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldSimpleFunctionCall ( Function < R, T > arg0 ) { R loc0 = null ; return fold ( arg0. apply ( null ), loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private UnaryOperator tryFoldSimpleFunctionCall ( FunctionCallExpression arg0 ) { return new UnaryOperator ( arg0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_5_/src/com/google/javascript/jscomp/InlineObjectLiterals.java_176-177": {
      "loc": "176-177",
      "input": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      String propName = parent.getLastChild().getString();\n      if (!validProperties.contains(propName)) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n          validProperties.add(propName);\n        } else {\n          return false;\n        }\n      }\n      continue;\n    }\n    if (!isVarOrAssignExprLhs(name)) {\n       return false;\n    }\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      continue;\n    }\n    if (!val.isObjectLit()) {\n      return false;\n    }\n    for (Node child = val.getFirstChild(); child != null;\n         child = child.getNext()) {\n      if (child.isGetterDef() ||\n          child.isSetterDef()) {\n        return false;\n      }\n      validProperties.add(child.getString());\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n    ret = true;\n  }\n  return ret;\n}",
      "target": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      if (gramps.isDelProp()) {\n        return false;\n      }\n      String propName = parent.getLastChild().getString();\n      if (!validProperties.contains(propName)) {\n        if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n          validProperties.add(propName);\n        } else {\n          return false;\n        }\n      }\n      continue;\n    }\n    if (!isVarOrAssignExprLhs(name)) {\n       return false;\n    }\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      continue;\n    }\n    if (!val.isObjectLit()) {\n      return false;\n    }\n    for (Node child = val.getFirstChild(); child != null;\n         child = child.getNext()) {\n      if (child.isGetterDef() ||\n          child.isSetterDef()) {\n        return false;\n      }\n      validProperties.add(child.getString());\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n    ret = true;\n  }\n  return ret;\n}",
      "function range": "155,5-253,5",
      "raw_output": [
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; return true ; }",
        "boolean function ( Object arg0 ) { return ( arg0 instanceof Inlinable ) ; }",
        "boolean function ( Object arg0 ) { return arg0 instanceof Inlinable ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Inlinable ) return true ; return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; return ( arg0 instanceof Inlinable ) ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) { return true ; } } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) return true ; } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) { return true ; } } return false ; }",
        "boolean function ( List <? extends Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) { return true ; } } return false ; }",
        "boolean function ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] instanceof InlinableReference ) return true ; } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) { return true ; } } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) return true ; } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0. isInlinable ( ) ) { return true ; } } return false ; }",
        "boolean function ( List <? extends Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) { return true ; } } return false ; }",
        "boolean function ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] instanceof Inlinable ) { return true ; } } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) { return true ; } } return false ; }",
        "boolean function ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] instanceof InlinableReference ) return true ; } return false ; }",
        "boolean function ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] instanceof Inlinable ) { return true ; } } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) return true ; } return false ; }",
        "boolean function ( ReferenceList arg0 ) { if ( arg0 == null ) { return false ; } for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) { return true ; } } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) { return true ; } } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0. isInlinable ( ) ) { return true ; } } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0. getInlinable ( ) ) { return true ; } } return false ; }",
        "boolean function ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) return true ; } return false ; }",
        "boolean function ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. inline ) { return true ; } } return false ; }"
      ],
      "mid_translation": [
        "Checks if an object is inlinable.",
        "Checks if a list of references is inlinable object.",
        "Checks if a list of references is inlinable.",
        "Checks if the list of references is inlinable object.",
        "Checks if the list of references is inlinable."
      ],
      "output": [
        {
          "patch": "private boolean isInlinableObject ( Object arg0 ) { if ( arg0 == null ) return false ; return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private boolean isInlinableObject ( Object arg0 ) { return ( arg0 instanceof Inlinable ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( Object arg0 ) { return arg0 instanceof Inlinable ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( Object arg0 ) { if ( arg0 instanceof Inlinable ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( Object arg0 ) { if ( arg0 == null ) return false ; return ( arg0 instanceof Inlinable ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List <? extends Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] instanceof InlinableReference ) return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0. isInlinable ( ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List <? extends Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] instanceof Inlinable ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] instanceof InlinableReference ) return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] instanceof Inlinable ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( ReferenceList arg0 ) { if ( arg0 == null ) { return false ; } for ( Reference loc0 : arg0 ) { if ( loc0 instanceof InlinableReference ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0. isInlinable ( ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0. getInlinable ( ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( List < Reference > arg0 ) { for ( Reference loc0 : arg0 ) { if ( loc0 instanceof Inlinable ) return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean isInlinableObject ( Reference [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. inline ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_35_/src/com/google/javascript/jscomp/TypeInference.java_1121-1123": {
      "loc": "1121-1123",
      "input": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj != null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType != null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}",
      "target": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj != null) {\n    type.matchConstraint(constraintObj);\n  }\n}",
      "function range": "1113,3-1137,3",
      "raw_output": [
        "Set < PropertyType > function ( Set < PropertyType > arg0, Constraint arg1 ) { Set < PropertyType > loc0 = new HashSet < PropertyType > ( arg0 ) ; for ( PropertyType loc1 : arg0 ) { loc0. add ( loc1. asProperty ( ) ) ; } return loc0 ; }",
        "Set < PropertyType > function ( Set < PropertyType > arg0, Constraint arg1 ) { Set < PropertyType > loc0 = new HashSet < PropertyType > ( ) ; for ( PropertyType loc1 : arg0 ) { loc0. add ( loc1. asProperty ( ) ) ; } return loc0 ; }",
        "Set < PropertyType > function ( Set < PropertyType > arg0, Constraint arg1 ) { Set < PropertyType > loc0 = new HashSet < PropertyType > ( arg0 ) ; for ( PropertyType loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "InferPropertyTypes function ( Type arg0, Constraint arg1 ) { InferPropertyTypes loc0 = new InferPropertyTypes ( arg0 ) ; if ( arg1 instanceof PropertyType ) { loc0. add ( ( PropertyType ) arg1 ) ; } return loc0 ; }",
        "Type function ( Type arg0, Constraint arg1 ) { if ( arg0 instanceof PropertyType ) { PropertyType loc0 = ( PropertyType ) arg0 ; if ( arg1 instanceof PropertyType ) { loc0 = ( PropertyType ) arg1 ; } } return loc0 ; }",
        "Map < String, Object > function ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < String, Object > function ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < String, Object > function ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < String, Object > function ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < String, Object > function ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toString ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "RecordType function ( PropertyType arg0 ) { if ( arg0 instanceof PropertyType ) { return ( PropertyType ) arg0 ; } if ( arg0 instanceof PropertyType ) { return ( PropertyType ) arg0 ; } if ( arg0 instanceof PropertyType ) { return ( PropertyType ) arg0 ; } return null ; }",
        "RecordType function ( PropertyType arg0 ) { if ( arg0 instanceof PropertyType ) { return ( PropertyType ) arg0 ; } if ( arg0 instanceof PropertyType ) { return ( ( PropertyType ) arg0 ). getPropertyType ( ) ; } return null ; }",
        "RecordType function ( PropertyType arg0, Map < String, Object > arg1 ) { if ( arg0 instanceof PropertyType ) { PropertyType loc0 = ( PropertyType ) arg0 ; if ( arg1. containsKey ( loc0. getName ( ) ) ) { return loc0 ; } } return null ; }",
        "RecordType function ( PropertyType arg0, Map < String, Object > arg1 ) { if ( arg0 instanceof PropertyType ) { PropertyType loc0 = ( PropertyType ) arg0 ; if ( arg1. containsKey ( loc0. getName ( ) ) ) { return loc0 ; } } return arg0 ; }",
        "RecordType function ( PropertyType arg0, Map < String,? > arg1 ) { if ( arg0 instanceof PropertyType ) { PropertyType loc0 = ( PropertyType ) arg0 ; if ( arg1. containsKey ( loc0. getName ( ) ) ) { return loc0 ; } } return null ; }",
        "InferPropertyTypes function ( Type arg0, Constraint arg1 ) { if ( arg0 instanceof PropertyType ) { InferPropertyTypes loc0 = ( InferPropertyTypes ) arg0 ; if ( arg1 instanceof PropertyType ) { loc0 = ( ( PropertyType ) arg1 ) ; } } return loc0 ; }",
        "InferPropertyTypes function ( Type arg0, Constraint arg1 ) { if ( arg0 instanceof PropertyType ) { InferPropertyTypes loc0 = ( InferPropertyTypes ) arg0 ; if ( arg1 instanceof PropertyType ) { loc0 = ( PropertyType ) arg1 ; } } return loc0 ; }",
        "Type function ( Type arg0, Constraint arg1 ) { if ( arg0 instanceof PropertyType ) { return ( ( PropertyType ) arg0 ). getPropertyType ( ) ; } if ( arg1 instanceof PropertyType ) { return ( ( PropertyType ) arg1 ). getPropertyType ( ) ; } return arg0 ; }",
        "InferPropertyTypes function ( Type arg0, Constraint arg1 ) { InferPropertyTypes loc0 = new InferPropertyTypes ( arg0 ) ; if ( arg1 instanceof PropertyType ) { loc0. add ( arg1. getPropertyType ( ) ) ; } return loc0 ; }",
        "InferPropertyTypes function ( Type arg0, Constraint arg1 ) { InferPropertyTypes loc0 = new InferPropertyTypes ( arg0 ) ; loc0. add ( arg1 ) ; return loc0 ; }",
        "PropertyTypes function ( PropertyTypes arg0 ) { if ( arg0 == null ) { return new PropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return ( PropertyTypes ) arg0 ; } if ( arg0 instanceof PropertyTypes ) { return ( PropertyTypes ) arg0 ; } return arg0 ; }",
        "PropertyTypes function ( PropertyTypes arg0 ) { if ( arg0 == null ) { return new PropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return ( PropertyTypes ) arg0 ; } if ( arg0 instanceof PropertyTypes ) { return new PropertyTypes ( ( PropertyTypes ) arg0 ) ; } return arg0 ; }",
        "PropertyTypes function ( PropertyTypes arg0 ) { if ( arg0 instanceof PropertyTypes ) { PropertyTypes loc0 = ( PropertyTypes ) arg0 ; return loc0. getPropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return PropertyTypes. asPropertyTypes ( ( PropertyTypes ) arg0 ) ; } return arg0 ; }",
        "PropertyTypes function ( PropertyTypes arg0 ) { if ( arg0 instanceof PropertyTypes ) { PropertyTypes loc0 = ( PropertyTypes ) arg0 ; return loc0. getPropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return ( PropertyTypes ) arg0 ; } return arg0 ; }",
        "PropertyTypes function ( PropertyTypes arg0 ) { if ( arg0 instanceof PropertyTypes ) { PropertyTypes loc0 = ( PropertyTypes ) arg0 ; return loc0. getPropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return new PropertyTypes ( ( PropertyTypes ) arg0 ) ; } return arg0 ; }"
      ],
      "mid_translation": [
        "Infer property types from the type to the constraint.",
        "Infer property types to record types.",
        "Infer property types to record type.",
        "Infer property types from the type to the constraint type.",
        "Infer property types to record type constraints."
      ],
      "output": [
        {
          "patch": "private Set < PropertyType > inferPropertyTypesToMatchConstraint ( Set < PropertyType > arg0, Constraint arg1 ) { Set < PropertyType > loc0 = new HashSet < PropertyType > ( arg0 ) ; for ( PropertyType loc1 : arg0 ) { loc0. add ( loc1. asProperty ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Set < PropertyType > inferPropertyTypesToMatchConstraint ( Set < PropertyType > arg0, Constraint arg1 ) { Set < PropertyType > loc0 = new HashSet < PropertyType > ( ) ; for ( PropertyType loc1 : arg0 ) { loc0. add ( loc1. asProperty ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Set < PropertyType > inferPropertyTypesToMatchConstraint ( Set < PropertyType > arg0, Constraint arg1 ) { Set < PropertyType > loc0 = new HashSet < PropertyType > ( arg0 ) ; for ( PropertyType loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private InferPropertyTypes inferPropertyTypesToMatchConstraint ( Type arg0, Constraint arg1 ) { InferPropertyTypes loc0 = new InferPropertyTypes ( arg0 ) ; if ( arg1 instanceof PropertyType ) { loc0. add ( ( PropertyType ) arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Type inferPropertyTypesToMatchConstraint ( Type arg0, Constraint arg1 ) { if ( arg0 instanceof PropertyType ) { PropertyType loc0 = ( PropertyType ) arg0 ; if ( arg1 instanceof PropertyType ) { loc0 = ( PropertyType ) arg1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, Object > inferPropertyTypesToMatchConstraint ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, Object > inferPropertyTypesToMatchConstraint ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, Object > inferPropertyTypesToMatchConstraint ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, Object > inferPropertyTypesToMatchConstraint ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, Object > inferPropertyTypesToMatchConstraint ( Map < String,? > arg0 ) { Map < String, Object > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < String, Object > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toString ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private RecordType inferPropertyTypesToMatchConstraint ( PropertyType arg0 ) { if ( arg0 instanceof PropertyType ) { return ( PropertyType ) arg0 ; } if ( arg0 instanceof PropertyType ) { return ( PropertyType ) arg0 ; } if ( arg0 instanceof PropertyType ) { return ( PropertyType ) arg0 ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private RecordType inferPropertyTypesToMatchConstraint ( PropertyType arg0 ) { if ( arg0 instanceof PropertyType ) { return ( PropertyType ) arg0 ; } if ( arg0 instanceof PropertyType ) { return ( ( PropertyType ) arg0 ). getPropertyType ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private RecordType inferPropertyTypesToMatchConstraint ( PropertyType arg0, Map < String, Object > arg1 ) { if ( arg0 instanceof PropertyType ) { PropertyType loc0 = ( PropertyType ) arg0 ; if ( arg1. containsKey ( loc0. getName ( ) ) ) { return loc0 ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private RecordType inferPropertyTypesToMatchConstraint ( PropertyType arg0, Map < String, Object > arg1 ) { if ( arg0 instanceof PropertyType ) { PropertyType loc0 = ( PropertyType ) arg0 ; if ( arg1. containsKey ( loc0. getName ( ) ) ) { return loc0 ; } } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private RecordType inferPropertyTypesToMatchConstraint ( PropertyType arg0, Map < String,? > arg1 ) { if ( arg0 instanceof PropertyType ) { PropertyType loc0 = ( PropertyType ) arg0 ; if ( arg1. containsKey ( loc0. getName ( ) ) ) { return loc0 ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private InferPropertyTypes inferPropertyTypesToMatchConstraint ( Type arg0, Constraint arg1 ) { if ( arg0 instanceof PropertyType ) { InferPropertyTypes loc0 = ( InferPropertyTypes ) arg0 ; if ( arg1 instanceof PropertyType ) { loc0 = ( ( PropertyType ) arg1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private InferPropertyTypes inferPropertyTypesToMatchConstraint ( Type arg0, Constraint arg1 ) { if ( arg0 instanceof PropertyType ) { InferPropertyTypes loc0 = ( InferPropertyTypes ) arg0 ; if ( arg1 instanceof PropertyType ) { loc0 = ( PropertyType ) arg1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Type inferPropertyTypesToMatchConstraint ( Type arg0, Constraint arg1 ) { if ( arg0 instanceof PropertyType ) { return ( ( PropertyType ) arg0 ). getPropertyType ( ) ; } if ( arg1 instanceof PropertyType ) { return ( ( PropertyType ) arg1 ). getPropertyType ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private InferPropertyTypes inferPropertyTypesToMatchConstraint ( Type arg0, Constraint arg1 ) { InferPropertyTypes loc0 = new InferPropertyTypes ( arg0 ) ; if ( arg1 instanceof PropertyType ) { loc0. add ( arg1. getPropertyType ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private InferPropertyTypes inferPropertyTypesToMatchConstraint ( Type arg0, Constraint arg1 ) { InferPropertyTypes loc0 = new InferPropertyTypes ( arg0 ) ; loc0. add ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PropertyTypes inferPropertyTypesToMatchConstraint ( PropertyTypes arg0 ) { if ( arg0 == null ) { return new PropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return ( PropertyTypes ) arg0 ; } if ( arg0 instanceof PropertyTypes ) { return ( PropertyTypes ) arg0 ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PropertyTypes inferPropertyTypesToMatchConstraint ( PropertyTypes arg0 ) { if ( arg0 == null ) { return new PropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return ( PropertyTypes ) arg0 ; } if ( arg0 instanceof PropertyTypes ) { return new PropertyTypes ( ( PropertyTypes ) arg0 ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PropertyTypes inferPropertyTypesToMatchConstraint ( PropertyTypes arg0 ) { if ( arg0 instanceof PropertyTypes ) { PropertyTypes loc0 = ( PropertyTypes ) arg0 ; return loc0. getPropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return PropertyTypes. asPropertyTypes ( ( PropertyTypes ) arg0 ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PropertyTypes inferPropertyTypesToMatchConstraint ( PropertyTypes arg0 ) { if ( arg0 instanceof PropertyTypes ) { PropertyTypes loc0 = ( PropertyTypes ) arg0 ; return loc0. getPropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return ( PropertyTypes ) arg0 ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PropertyTypes inferPropertyTypesToMatchConstraint ( PropertyTypes arg0 ) { if ( arg0 instanceof PropertyTypes ) { PropertyTypes loc0 = ( PropertyTypes ) arg0 ; return loc0. getPropertyTypes ( ) ; } if ( arg0 instanceof PropertyTypes ) { return new PropertyTypes ( ( PropertyTypes ) arg0 ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_38_src/java/org/apache/commons/lang3/time/FastDateFormat.java_871-872": {
      "loc": "871-872",
      "input": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return applyRules(calendar, buf);\n}",
      "target": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n        calendar.getTime(); \n        calendar = (Calendar) calendar.clone();\n        calendar.setTimeZone(mTimeZone);\n    }\n    return applyRules(calendar, buf);\n}",
      "function range": "870,5-876,5",
      "raw_output": [
        "StringBuffer function ( Calendar arg0 ) { if ( arg0 == null ) return null ; StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
        "StringBuffer function ( final Calendar arg0 ) { final StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
        "StringBuffer function ( final Calendar arg0 ) { if ( arg0 == null ) return null ; StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
        "StringBuffer function ( Calendar arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
        "StringBuffer function ( Calendar arg0 ) { return arg0 == null? null : new StringBuffer ( ) ; }",
        "String function ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. toString ( ) ; }",
        "String function ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. getTime ( ). toString ( ) ; }",
        "String function ( final GregorianCalendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. format ( new GregorianCalendar ( ) ) ; }",
        "String function ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. toGregorianCalendar ( ). toString ( ) ; }",
        "String function ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. format ( ) ; }",
        "String function ( final T arg0 ) { return arg0 == null? \"srini_string\" : arg0. toString ( ) ; }",
        "String function ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. getTimeZone ( ). toString ( ) ; }",
        "String function ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. get ( Calendar. YEAR ). toString ( ) ; }",
        "String function ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. format ( new Date ( ) ) ; }",
        "String function ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. format ( new GregorianCalendar ( ) ) ; }",
        "StringBuffer function ( Calendar arg0 ) { if ( arg0 == null ) return null ; StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
        "StringBuffer function ( final Calendar arg0 ) { final StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
        "StringBuffer function ( final Calendar arg0 ) { if ( arg0 == null ) return null ; StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
        "StringBuffer function ( Calendar arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
        "StringBuffer function ( Calendar arg0 ) { return arg0 == null? null : new StringBuffer ( ) ; }",
        "String function ( Calendar arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return FormatUtil. format ( arg0 ) ; }",
        "String function ( Calendar arg0 ) { return FormatUtil. format ( arg0 ) ; }",
        "String function ( Calendar arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. getTime ( ). getTime ( ) ; }",
        "String function ( Calendar arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. getTime ( ) ; }",
        "String function ( Calendar arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. getTime ( ). format ( DateFormat. SHORT ) ; }"
      ],
      "mid_translation": [
        "Format a calendar into a StringBuffer.",
        "Format a calendar.",
        "Format the calendar.",
        "Format a calendar into a StringBuffer.",
        "Format the given calendar using the rules defined in this class."
      ],
      "output": [
        {
          "patch": "public StringBuffer format ( Calendar arg0 ) { if ( arg0 == null ) return null ; StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format ( final Calendar arg0 ) { final StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format ( final Calendar arg0 ) { if ( arg0 == null ) return null ; StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format ( Calendar arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format ( Calendar arg0 ) { return arg0 == null? null : new StringBuffer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. getTime ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final GregorianCalendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. format ( new GregorianCalendar ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. toGregorianCalendar ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. format ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final T arg0 ) { return arg0 == null? \"srini_string\" : arg0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. getTimeZone ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. get ( Calendar. YEAR ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. format ( new Date ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( final Calendar arg0 ) { return arg0 == null? \"srini_string\" : arg0. format ( new GregorianCalendar ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format ( Calendar arg0 ) { if ( arg0 == null ) return null ; StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format ( final Calendar arg0 ) { final StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format ( final Calendar arg0 ) { if ( arg0 == null ) return null ; StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format ( Calendar arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. setTime ( arg0. getTime ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuffer format ( Calendar arg0 ) { return arg0 == null? null : new StringBuffer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( Calendar arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return FormatUtil. format ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( Calendar arg0 ) { return FormatUtil. format ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( Calendar arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. getTime ( ). getTime ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( Calendar arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. getTime ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( Calendar arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. getTime ( ). format ( DateFormat. SHORT ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_9_/source/org/jfree/data/time/TimeSeries.java_944-945": {
      "loc": "944-945",
      "input": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {\n\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        return copy;\n    }\n    else {\n        return createCopy(startIndex, endIndex);\n    }\n}",
      "target": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if ((endIndex < 0)  || (endIndex < startIndex)) {\n\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        return copy;\n    }\n    else {\n        return createCopy(startIndex, endIndex);\n    }\n}",
      "function range": "918,5-956,5",
      "raw_output": [
        "TimeSeries function ( ) { TimeSeries loc0 = null ; try { loc0 = ( TimeSeries ) clone ( ) ; } catch ( CloneNotSupportedException loc1 ) { throw new Error ( loc1. toString ( ) ) ; } return loc0 ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return loc0 ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = null ; try { loc0 = ( TimeSeries ) super. loc0 ( ) ; } catch ( Exception loc1 ) { loc1. printStackTrace ( ) ; } return loc0 ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { loc0 = new TimeSeries ( ) ; loc0. setSeries ( this ) ; } return loc0 ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { return ( TimeSeries ) super. clone ( ) ; }",
        "Timeseries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ). loc0 ( ) ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; return loc0 ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { return null ; } return new TimeSeriesImpl ( loc0 ) ; }",
        "TimeSeries function ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { return null ; } return new TimeSeries ( loc0 ) ; }",
        "TimeSeries function ( ) { return ( TimeSeries ) super. clone ( ) ; }",
        "TimeSeries function ( TimePeriod arg0, TimePeriod arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTime ( arg1 ) ; return loc0 ; }",
        "TimeSeries function ( Date arg0, TimePeriod arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTimePeriod ( arg1 ) ; return loc0 ; }",
        "TimeSeries function ( TimePeriod arg0, StartTime arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTime ( arg1 ) ; return loc0 ; }",
        "TimeSeries function ( TimeSeriesStart arg0, TimeSeriesEnd arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTime ( arg1 ) ; return loc0 ; }",
        "TimeSeries function ( Date arg0, TimePeriod arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTime ( arg1 ) ; return loc0 ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. setSeries ( new TimeSeries ( \"srini_string\" ) ) ; return loc0 ; }",
        "TimeSeries function ( ) { return ( TimeSeries ) super. clone ( ) ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. clear ( ) ; return loc0 ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. setSeries ( new TimeSeries ( ) ) ; return loc0 ; }"
      ],
      "mid_translation": [
        "Create a copy of this TimeSeries.",
        "Create a copy of this time series.",
        "Creates a copy of this TimeSeries.",
        "Create a copy of this TimeSeries with the specified start and end time period.",
        "Create a copy of the TimeSeries."
      ],
      "output": [
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = null ; try { loc0 = ( TimeSeries ) clone ( ) ; } catch ( CloneNotSupportedException loc1 ) { throw new Error ( loc1. toString ( ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = null ; try { loc0 = ( TimeSeries ) super. loc0 ( ) ; } catch ( Exception loc1 ) { loc1. printStackTrace ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { loc0 = new TimeSeries ( ) ; loc0. setSeries ( this ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return ( TimeSeries ) super. clone ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Timeseries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ). loc0 ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { return null ; } return new TimeSeriesImpl ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { return null ; } return new TimeSeries ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return ( TimeSeries ) super. clone ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( TimePeriod arg0, TimePeriod arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTime ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( Date arg0, TimePeriod arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTimePeriod ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( TimePeriod arg0, StartTime arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTime ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( TimeSeriesStart arg0, TimeSeriesEnd arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTime ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( Date arg0, TimePeriod arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } TimeSeries loc0 = new TimeSeries ( ) ; loc0. setStartTime ( arg0 ) ; loc0. setEndTime ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. setSeries ( new TimeSeries ( \"srini_string\" ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return ( TimeSeries ) super. clone ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. clear ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. setSeries ( new TimeSeries ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_15_/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java_102-103": {
      "loc": "102-103",
      "input": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "target": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isDelProp()) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "function range": "83,7-109,7",
      "raw_output": [
        "boolean function ( Node arg0 ) { switch ( arg0 ) { case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : return true ; default : return false ; } }",
        "boolean function ( Node arg0 ) { switch ( arg0 ) { case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : return true ; default : return false ; } }",
        "boolean function ( Node arg0 ) { switch ( arg0 ) { case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'F' : return true ; default : return false ; } }",
        "boolean function ( Node arg0 ) { switch ( arg0 ) { case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'O' : case 'U' : return true ; default : return false ; } }",
        "boolean function ( Node arg0 ) { switch ( arg0 ) { case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'O' : return true ; default : return false ; } }",
        "boolean function ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. matches ( \"srini_string\" ) || loc0. matches ( \"srini_string\" ) || loc0. matches ( \"srini_string\" ) ; }",
        "boolean function ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. equals ( \"srini_string\" ) || loc0. equals ( \"srini_string\" ) || loc0. equals ( \"srini_string\" ) ; }",
        "boolean function ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. matches ( \"srini_string\" ) || loc0. matches ( \"srini_string\" ) ; }",
        "boolean function ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. matches ( \"srini_string\" ) ; }",
        "boolean function ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. equals ( \"srini_string\" ) || loc0. equals ( \"srini_string\" ) ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
        "boolean function ( Node arg0 ) { return ( arg0 instanceof CID    ) ; }",
        "boolean function ( ASTNode arg0 ) { return arg0 instanceof CID    ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof CID    ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == Token. CDATA_SECTION_NODE ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
        "boolean function ( ASTNode arg0 ) { return arg0 instanceof CID    ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof CID    ; }",
        "boolean function ( Node arg0 ) { return ( arg0 instanceof CID    ) ; }",
        "boolean function ( Node arg0 ) { if ( arg0 instanceof CID    ) { return ( ( CID    ) arg0 ). getLHS ( ) ; } return false ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { return this instanceof CID    ; }",
        "boolean function ( ) { return this == CID    ; }",
        "boolean function ( ) { return true ; }",
        "boolean function ( ) { return ( this instanceof CID    ) ; }"
      ],
      "mid_translation": [
        "Returns true if the node n is a CID   .",
        "Returns true if n is a CID   .",
        "Checks if the node n is a CID    node.",
        "Returns true if n is a CID    node.",
        "Returns true if this node is a CID    node."
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. matches ( \"srini_string\" ) || loc0. matches ( \"srini_string\" ) || loc0. matches ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. equals ( \"srini_string\" ) || loc0. equals ( \"srini_string\" ) || loc0. equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. matches ( \"srini_string\" ) || loc0. matches ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. matches ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Number arg0 ) { if ( arg0 == null ) return false ; String loc0 = Integer. toString ( arg0 ) ; return loc0. equals ( \"srini_string\" ) || loc0. equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Node arg0 ) { return ( arg0 instanceof CID    ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ASTNode arg0 ) { return arg0 instanceof CID    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Node arg0 ) { return arg0 instanceof CID    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ASTNode arg0 ) { return arg0. getType ( ) == Token. CDATA_SECTION_NODE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ASTNode arg0 ) { return arg0 instanceof CID    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Node arg0 ) { return arg0 instanceof CID    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Node arg0 ) { return ( arg0 instanceof CID    ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( Node arg0 ) { if ( arg0 instanceof CID    ) { return ( ( CID    ) arg0 ). getLHS ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ) { return this instanceof CID    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ) { return this == CID    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean apply ( ) { return ( this instanceof CID    ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_26_source/org/jfree/chart/axis/Axis.java_1192-1193": {
      "loc": "1192-1193",
      "input": "protected AxisState drawLabel(String label, Graphics2D g2, \n        Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n        AxisState state, PlotRenderingInfo plotState) {\n    if (state == null) {\n        throw new IllegalArgumentException(\"Null 'state' argument.\");\n    }\n    if ((label == null) || (label.equals(\"\"))) {\n        return state;\n    }\n    Font font = getLabelFont();\n    RectangleInsets insets = getLabelInsets();\n    g2.setFont(font);\n    g2.setPaint(getLabelPaint());\n    FontMetrics fm = g2.getFontMetrics();\n    Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n    Shape hotspot = null;\n    if (edge == RectangleEdge.TOP) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() - insets.getBottom() \n                - h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.BOTTOM) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() + insets.getTop() \n                + h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.LEFT) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() - insets.getRight() \n                - w / 2.0);\n        float labely = (float) dataArea.getCenterY();\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n    }\n    else if (edge == RectangleEdge.RIGHT) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() + Math.PI / 2.0, \n                labelBounds.getCenterX(), labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() \n                        + insets.getLeft() + w / 2.0);\n        float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n    }\n    if (plotState != null && hotspot != null) {\n        ChartRenderingInfo owner = plotState.getOwner();\n            EntityCollection entities = owner.getEntityCollection();\n\n            if (entities != null) {\n                entities.add(new AxisLabelEntity(this, hotspot, \n                        this.labelToolTip, this.labelURL));\n            }\n    }\n    return state;\n}",
      "target": "protected AxisState drawLabel(String label, Graphics2D g2, \n        Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n        AxisState state, PlotRenderingInfo plotState) {\n    if (state == null) {\n        throw new IllegalArgumentException(\"Null 'state' argument.\");\n    }\n    if ((label == null) || (label.equals(\"\"))) {\n        return state;\n    }\n    Font font = getLabelFont();\n    RectangleInsets insets = getLabelInsets();\n    g2.setFont(font);\n    g2.setPaint(getLabelPaint());\n    FontMetrics fm = g2.getFontMetrics();\n    Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n    Shape hotspot = null;\n    if (edge == RectangleEdge.TOP) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() - insets.getBottom() \n                - h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.BOTTOM) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() + insets.getTop() \n                + h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.LEFT) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() - insets.getRight() \n                - w / 2.0);\n        float labely = (float) dataArea.getCenterY();\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n    }\n    else if (edge == RectangleEdge.RIGHT) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() + Math.PI / 2.0, \n                labelBounds.getCenterX(), labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() \n                        + insets.getLeft() + w / 2.0);\n        float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n    }\n    if (plotState != null && hotspot != null) {\n        ChartRenderingInfo owner = plotState.getOwner();\n        if (owner != null) {\n\n            EntityCollection entities = owner.getEntityCollection();\n            if (entities != null) {\n                entities.add(new AxisLabelEntity(this, hotspot, \n                        this.labelToolTip, this.labelURL));\n            }\n        }\n    }\n    return state;\n}",
      "function range": "1092,5-1200,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_28_/src/java/org/apache/commons/cli/Parser.java_290-291": {
      "loc": "290-291",
      "input": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                break;\n            }\n            cmd.addOption(opt);\n        }\n    }\n}",
      "target": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n                continue;\n            }\n            cmd.addOption(opt);\n        }\n    }\n}",
      "function range": "252,5-296,5",
      "raw_output": [
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; return loc0 ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; return loc0 ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; return loc0 ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; return loc0 ; }",
        "void function ( Map arg0 ) { }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; return loc0 ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ). trim ( ) ) ; } return loc0 ; }",
        "void function ( Map < String, String > arg0 ) { }",
        "void function ( Properties arg0 ) { }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; return loc0 ; }",
        "void function ( Map arg0 ) { }",
        "void function ( Map < String,? > arg0 ) { }",
        "List < Map < String, String >> function ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) loc0. add ( loc1. getKey ( ). toUpperCase ( ) ) ; return loc0 ; }",
        "List < Map < String, String >> function ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) { loc0. add ( loc1. getKey ( ). toUpperCase ( ) ) ; } return loc0 ; }",
        "List < Map < String, String >> function ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) { loc0. add ( loc1. getKey ( ) ) ; } return loc0 ; }",
        "List < Map < String, String >> function ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) loc0. add ( loc1. getKey ( ). toLowerCase ( ) ) ; return loc0 ; }",
        "List < Map < String, String >> function ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) { loc0. add ( loc1. getKey ( ). toString ( ) ) ; } return loc0 ; }",
        "void function ( Map arg0 ) { }",
        "Map function ( Map arg0 ) { Map loc0 = new HashMap ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ). toString ( ) ) ; } return loc0 ; }",
        "Map function ( Map arg0 ) { Map loc0 = new HashMap ( ) ; Map loc1 = arg0 ; for ( Map. Entry < String, String > loc2 : loc1. entrySet ( ) ) { String loc3 = loc2. getKey ( ) ; loc0. put ( loc3, loc2. getValue ( ) ) ; } return loc0 ; }",
        "Map function ( Map arg0 ) { Map loc0 = new HashMap ( ) ; Map loc1 = arg0 ; for ( Map. Entry < String, String > loc2 : loc1. entrySet ( ) ) { String loc3 = loc2. getKey ( ) ; loc0. put ( loc3, loc2. getValue ( ). trim ( ) ) ; } return loc0 ; }",
        "Map function ( Map arg0 ) { Map loc0 = new HashMap ( ) ; Map loc1 = new HashMap ( ) ; for ( Map. Entry < String, String > loc2 : arg0. entrySet ( ) ) { String loc3 = loc2. getKey ( ) ; loc0. put ( loc3, loc2. getValue ( ) ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Process properties.",
        "Process the properties.",
        "Process the specified properties.",
        "Process a list of properties.",
        "Method processProperties."
      ],
      "output": [
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void processProperties ( Map arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ). trim ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void processProperties ( Map < String, String > arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void processProperties ( Properties arg0 ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "protected Map < String, String > processProperties ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void processProperties ( Map arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void processProperties ( Map < String,? > arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected List < Map < String, String >> processProperties ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) loc0. add ( loc1. getKey ( ). toUpperCase ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected List < Map < String, String >> processProperties ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) { loc0. add ( loc1. getKey ( ). toUpperCase ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected List < Map < String, String >> processProperties ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) { loc0. add ( loc1. getKey ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected List < Map < String, String >> processProperties ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) loc0. add ( loc1. getKey ( ). toLowerCase ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected List < Map < String, String >> processProperties ( List < Map < String, String >> arg0 ) { List < Map < String, String >> loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < String, String > loc1 : arg0 ) { loc0. add ( loc1. getKey ( ). toString ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void processProperties ( Map arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map processProperties ( Map arg0 ) { Map loc0 = new HashMap ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ). toString ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map processProperties ( Map arg0 ) { Map loc0 = new HashMap ( ) ; Map loc1 = arg0 ; for ( Map. Entry < String, String > loc2 : loc1. entrySet ( ) ) { String loc3 = loc2. getKey ( ) ; loc0. put ( loc3, loc2. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map processProperties ( Map arg0 ) { Map loc0 = new HashMap ( ) ; Map loc1 = arg0 ; for ( Map. Entry < String, String > loc2 : loc1. entrySet ( ) ) { String loc3 = loc2. getKey ( ) ; loc0. put ( loc3, loc2. getValue ( ). trim ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Map processProperties ( Map arg0 ) { Map loc0 = new HashMap ( ) ; Map loc1 = new HashMap ( ) ; for ( Map. Entry < String, String > loc2 : arg0. entrySet ( ) ) { String loc3 = loc2. getKey ( ) ; loc0. put ( loc3, loc2. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Cli_11_/src/java/org/apache/commons/cli/HelpFormatter.java_632-633": {
      "loc": "632-633",
      "input": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && (option.getArgName() != null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
      "target": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n    if (option.hasArg() && option.hasArgName())\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}",
      "function range": "613,5-642,5",
      "raw_output": [
        "StringBuffer function ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, char arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" = \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; if ( arg1 ) { loc0. append ( \"srini_string\" ) ; } else { loc0. append ( arg0 ) ; } return loc0 ; }",
        "StringBuffer function ( String arg0, char arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ('' ) ; loc0. append ( arg1 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, boolean arg1, StringBuffer arg2 ) { arg2. append ( arg0 ) ; arg2. append ( \"srini_string\" ) ; return arg2 ; }",
        "StringBuffer function ( String arg0, String arg1 ) { return append ( \"srini_string\", arg0, arg1 ) ; }",
        "StringBuffer function ( String arg0 ) { return append ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
        "StringBuffer function ( String arg0, boolean arg1, StringBuffer arg2 ) { arg2. append ( \"srini_string\" ) ; arg0. append ( arg1 ) ; return arg2 ; }",
        "StringBuffer function ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1? \"srini_string\" : \"srini_string\" ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" = \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, String arg1, String arg2 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; loc0. append ( arg2 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, Option arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1. getValue ( ) ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, Option arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1. getOptionName ( ) ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, Option arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1. getOptionValue ( ) ) ; return loc0 ; }",
        "StringBuffer function ( Option arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0. loc0 ( ) ) ; return loc0 ; }",
        "StringBuffer function ( Option arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0. getValue ( ) ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1? \"srini_string\" : \"srini_string\" ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, char arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; if ( arg1 ) { loc0. append ( \"srini_string\" ) ; } else { loc0. append ( arg0 ) ; } return loc0 ; }",
        "StringBuffer function ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; if ( arg1 ) { loc0. append ( \"srini_string\" ) ; } else { loc0. append ( arg0 ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Append an option to a StringBuffer.",
        "Append an option to the StringBuffer.",
        "Appends an option to a StringBuffer.",
        "Append an Option to a StringBuffer.",
        "Append an option to a StringBuffer"
      ],
      "output": [
        {
          "patch": "private static StringBuffer appendOption ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, char arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" = \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; if ( arg1 ) { loc0. append ( \"srini_string\" ) ; } else { loc0. append ( arg0 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, char arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ('' ) ; loc0. append ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, boolean arg1, StringBuffer arg2 ) { arg2. append ( arg0 ) ; arg2. append ( \"srini_string\" ) ; return arg2 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, String arg1 ) { return append ( \"srini_string\", arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0 ) { return append ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, boolean arg1, StringBuffer arg2 ) { arg2. append ( \"srini_string\" ) ; arg0. append ( arg1 ) ; return arg2 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1? \"srini_string\" : \"srini_string\" ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" = \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, String arg1, String arg2 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; loc0. append ( arg2 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, Option arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1. getValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, Option arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1. getOptionName ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, Option arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1. getOptionValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( Option arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0. loc0 ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( Option arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0. getValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1? \"srini_string\" : \"srini_string\" ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, String arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, char arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( arg0 ) ; if ( arg1 ) { loc0. append ( \"srini_string\" ) ; } else { loc0. append ( arg0 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static StringBuffer appendOption ( String arg0, boolean arg1 ) { StringBuffer loc0 = new StringBuffer ( ) ; if ( arg1 ) { loc0. append ( \"srini_string\" ) ; } else { loc0. append ( arg0 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_3_/source/org/jfree/data/time/TimeSeries.java_1057-1058": {
      "loc": "1057-1058",
      "input": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.data = new java.util.ArrayList();\n\n    if (this.data.size() > 0) {\n        for (int index = start; index <= end; index++) {\n            TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n            try {\n                copy.add(clone);\n            }\n            catch (SeriesException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return copy;\n}",
      "target": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n    copy.minY = Double.NaN;\n\n    copy.maxY = Double.NaN;\n    copy.data = new java.util.ArrayList();\n    if (this.data.size() > 0) {\n        for (int index = start; index <= end; index++) {\n            TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n            TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n            try {\n                copy.add(clone);\n            }\n            catch (SeriesException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return copy;\n}",
      "function range": "1048,5-1072,5",
      "raw_output": [
        "TimeSeries function ( ) { TimeSeries loc0 = null ; try { loc0 = ( TimeSeries ) clone ( ) ; } catch ( CloneNotSupportedException loc1 ) { throw new Error ( loc1. toString ( ) ) ; } return loc0 ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return loc0 ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = null ; try { loc0 = ( TimeSeries ) super. loc0 ( ) ; } catch ( Exception loc1 ) { loc1. printStackTrace ( ) ; } return loc0 ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { loc0 = new TimeSeries ( ) ; loc0. setSeries ( this ) ; } return loc0 ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; return loc0 ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { return null ; } return new TimeSeriesImpl ( loc0 ) ; }",
        "TimeSeries function ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { return null ; } return new TimeSeries ( loc0 ) ; }",
        "TimeSeries function ( ) { return ( TimeSeries ) super. clone ( ) ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { return ( TimeSeries ) super. clone ( ) ; }",
        "Timeseries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ). loc0 ( ) ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. setSeries ( new TimeSeries ( \"srini_string\" ) ) ; return loc0 ; }",
        "TimeSeries function ( ) { return ( TimeSeries ) super. clone ( ) ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. clear ( ) ; return loc0 ; }",
        "TimeSeries function ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. setSeries ( new TimeSeries ( ) ) ; return loc0 ; }",
        "Object function ( ) { return super. clone ( ) ; }",
        "TimeSeries function ( ) { return new TimeSeries ( ) ; }",
        "Object function ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; return loc0 ; }",
        "Object function ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; loc0. _parent = null ; return loc0 ; }",
        "TimeSeries function ( ) { return ( TimeSeries ) super. clone ( ) ; }"
      ],
      "mid_translation": [
        "Create a copy of this TimeSeries.",
        "Creates a copy of this TimeSeries.",
        "Create a copy of this time series.",
        "Create a copy of the TimeSeries.",
        "Creates a copy of this time series."
      ],
      "output": [
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = null ; try { loc0 = ( TimeSeries ) clone ( ) ; } catch ( CloneNotSupportedException loc1 ) { throw new Error ( loc1. toString ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = null ; try { loc0 = ( TimeSeries ) super. loc0 ( ) ; } catch ( Exception loc1 ) { loc1. printStackTrace ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { loc0 = new TimeSeries ( ) ; loc0. setSeries ( this ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { return null ; } return new TimeSeriesImpl ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { final TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; if ( loc0 == null ) { return null ; } return new TimeSeries ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return ( TimeSeries ) super. clone ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return ( TimeSeries ) super. clone ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Timeseries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ). loc0 ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. setSeries ( new TimeSeries ( \"srini_string\" ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return ( TimeSeries ) super. clone ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. clear ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { TimeSeries loc0 = new TimeSeries ( ) ; loc0. setSeries ( new TimeSeries ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object createCopy ( ) { return super. clone ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return new TimeSeries ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object createCopy ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object createCopy ( ) { TimeSeries loc0 = ( TimeSeries ) super. loc0 ( ) ; loc0. _parent = null ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TimeSeries createCopy ( ) { return ( TimeSeries ) super. clone ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_59_/src/com/google/javascript/jscomp/Compiler.java_255-256": {
      "loc": "255-256",
      "input": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn()) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  }\n  List<WarningsGuard> guards = Lists.newArrayList();\n  guards.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  guards.add(options.getWarningsGuard());\n  ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n  if (!options.checkSymbols &&\n      !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n    composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n        DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n  }\n  this.warningsGuard = composedGuards;\n}",
      "target": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n  if (options.checkGlobalThisLevel.isOn() &&\n      !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n    options.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        options.checkGlobalThisLevel);\n  }\n  if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n    options.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  }\n  List<WarningsGuard> guards = Lists.newArrayList();\n  guards.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  guards.add(options.getWarningsGuard());\n  ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n  if (!options.checkSymbols &&\n      !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n    composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n        DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n  }\n  this.warningsGuard = composedGuards;\n}",
      "function range": "226,3-288,3",
      "raw_output": [
        "CompilerOptions function ( ) { return new CompilerOptions ( ) ; }",
        "void function ( ) { }",
        "void function ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; CompilerUtils. init ( loc0 ) ; }",
        "void function ( String [ ] arg0 ) { }",
        "void function ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; loc0. addExtension ( \"srini_string\", \"srini_string\" ) ; }",
        "void function ( ) { }",
        "CompilerOptions function ( ) { return new CompilerOptions ( ) ; }",
        "void function ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; }",
        "void function ( ) { Log. debug ( \"srini_string\" ) ; }",
        "CompilerOptions function ( ) { return new CompilerOptions ( \"srini_string\" ) ; }",
        "void function ( ) { }",
        "CompilerOptions function ( ) { return new CompilerOptions ( ) ; }",
        "void function ( ) { LogManager. getRootLogger ( ). info ( \"srini_string\" ) ; }",
        "void function ( ) { Log. debug ( \"srini_string\" ) ; }",
        "CompilerOptions function ( ) { return new CompilerOptions ( \"srini_string\" ) ; }",
        "void function ( ) { }",
        "void function ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; CompilerOptions loc1 = new CompilerOptions ( ) ; loc1. addDirectory ( \"srini_string\" ) ; loc1. addDirectory ( \"srini_string\" ) ; }",
        "void function ( String [ ] arg0 ) { }",
        "void function ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; CompilerUtils. init ( loc0 ) ; }",
        "CompilerOptions function ( ) { return new CompilerOptions ( ) ; }",
        "void function ( ) { }",
        "CompilerOptions function ( ) { return new CompilerOptions ( ) ; }",
        "void function ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. init ( ) ; }",
        "void function ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; init ( loc0 ) ; }",
        "void function ( ) { Log. info ( \"srini_string\" ) ; }"
      ],
      "mid_translation": [
        "Initializes the compiler options.",
        "Initialize the compiler options.",
        "Initialize the compiler options",
        "Initializes the compiler options",
        "Init the compiler options."
      ],
      "output": [
        {
          "patch": "public CompilerOptions initOptions ( ) { return new CompilerOptions ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; CompilerUtils. init ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( String [ ] arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; loc0. addExtension ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CompilerOptions initOptions ( ) { return new CompilerOptions ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { Log. debug ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CompilerOptions initOptions ( ) { return new CompilerOptions ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CompilerOptions initOptions ( ) { return new CompilerOptions ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { LogManager. getRootLogger ( ). info ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { Log. debug ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CompilerOptions initOptions ( ) { return new CompilerOptions ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; CompilerOptions loc1 = new CompilerOptions ( ) ; loc1. addDirectory ( \"srini_string\" ) ; loc1. addDirectory ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( String [ ] arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. addDirectory ( \"srini_string\" ) ; CompilerUtils. init ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CompilerOptions initOptions ( ) { return new CompilerOptions ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CompilerOptions initOptions ( ) { return new CompilerOptions ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; loc0. init ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { CompilerOptions loc0 = new CompilerOptions ( ) ; init ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void initOptions ( ) { Log. info ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_123_src/com/google/javascript/jscomp/CodeGenerator.java_285-286": {
      "loc": "285-286",
      "input": "void add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n    Context rhsContext = getContextForNoInOperator(context);\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n  cc.startSourceMapping(n);\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n      cc.endStatement(true);\n      break;\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n      break;\n    }\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n      add(\"function\");\n      add(first);\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n    case Token.CALL:\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n      add(\"if(\");\n      add(first);\n      add(\")\");\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n  cc.endSourceMapping(n);\n}",
      "target": "void add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n    Context rhsContext = getContextForNoInOperator(context);\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n  cc.startSourceMapping(n);\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n      cc.endStatement(true);\n      break;\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n      break;\n    }\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = getContextForNoInOperator(context);\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n      add(\"function\");\n      add(first);\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n    case Token.CALL:\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n      add(\"if(\");\n      add(first);\n      add(\")\");\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n  cc.endSourceMapping(n);\n}",
      "function range": "107,3-771,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_31_/src/com/google/javascript/jscomp/Compiler.java_1285-1286": {
      "loc": "1285-1286",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n        !options.skipAllPasses &&\n        options.closurePass) {\n      for (CompilerInput input : inputs) {\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n      if (n.getJSDocInfo() != null) {\n        JSDocInfo info = n.getJSDocInfo();\n        if (info.isExterns()) {\n          externsRoot.addChildToBack(n);\n          input.setIsExtern(true);\n          input.getModule().remove(input);\n          externs.add(input);\n          staleInputs = true;\n        } else if (info.isNoCompile()) {\n          input.getModule().remove(input);\n          staleInputs = true;\n        }\n      }\n    }\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n      jsRoot.addChildToBack(n);\n    }\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
      "target": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n        options.closurePass) {\n      for (CompilerInput input : inputs) {\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n      if (n.getJSDocInfo() != null) {\n        JSDocInfo info = n.getJSDocInfo();\n        if (info.isExterns()) {\n          externsRoot.addChildToBack(n);\n          input.setIsExtern(true);\n          input.getModule().remove(input);\n          externs.add(input);\n          staleInputs = true;\n        } else if (info.isNoCompile()) {\n          input.getModule().remove(input);\n          staleInputs = true;\n        }\n      }\n    }\n    if (staleInputs) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n      jsRoot.addChildToBack(n);\n    }\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
      "function range": "1236,3-1387,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_20_/source/org/jfree/chart/plot/ValueMarker.java_95-96": {
      "loc": "95-96",
      "input": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n    super(paint, stroke, paint, stroke, alpha);\n\n    this.value = value;\n}",
      "target": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n    super(paint, stroke, outlinePaint, outlineStroke, alpha);\n\n    this.value = value;\n}",
      "function range": "93,5-97,5",
      "raw_output": [
        "void function ( Marker arg0 ) { this. marker = arg0 ; }",
        "Marker function ( String arg0 ) { this. arg0 = arg0 ; return this ; }",
        "Marker function ( String arg0 ) { this. marker = new Marker ( arg0 ) ; }",
        "Marker function ( String arg0 ) { this. markerId = arg0 ; return this ; }",
        "Marker function ( Marker arg0 ) { this. marker = arg0 ; return this ; }",
        "void function ( Marker arg0 ) { this. marker = arg0 ; }",
        "void function ( String arg0 ) { this. marker = new Marker ( arg0 ) ; }",
        "void function ( Mark arg0 ) { this. marker = arg0 ; }",
        "void function ( final Marker arg0 ) { this. marker = arg0 ; }",
        "void function ( marker arg0 ) { this. marker = arg0 ; }",
        "ValueMarker function ( ) { return ValueMarker. INSTANCE ; }",
        "void function ( ValueMarker arg0 ) { this. valueMarker = arg0 ; }",
        "ValueMarker function ( ) { return new ValueMarker ( ) ; }",
        "Marker function ( ) { return ValueMarker. INSTANCE ; }",
        "ValueMarker function ( ValueMarker arg0 ) { this. valueMarker = arg0 ; }",
        "void function ( Marker arg0 ) { this. marker = arg0 ; }",
        "Marker function ( String arg0 ) { this. arg0 = arg0 ; return this ; }",
        "void function ( String arg0 ) { this. marker. setText ( arg0 ) ; }",
        "Marker function ( String arg0 ) { this. marker. setText ( arg0 ) ; return this ; }",
        "Marker function ( String arg0 ) { this. marker = new Marker ( arg0 ) ; return this ; }",
        "void function ( Marker arg0 ) { this. marker = arg0 ; }",
        "void function ( String arg0 ) { this. marker. setText ( arg0 ) ; }",
        "void function ( String arg0 ) { this. marker = new Marker ( arg0 ) ; }",
        "void function ( String arg0 ) { this. marker. setValue ( arg0 ) ; }",
        "void function ( final Marker arg0 ) { this. marker = arg0 ; }"
      ],
      "mid_translation": [
        "Set the value of the marker.",
        "Sets the value of the marker.",
        "Set the value marker.",
        "Set the value of this marker.",
        "Sets the value of this marker."
      ],
      "output": [
        {
          "patch": "public void ValueMarker ( Marker arg0 ) { this. marker = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker ValueMarker ( String arg0 ) { this. arg0 = arg0 ; return this ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker ValueMarker ( String arg0 ) { this. marker = new Marker ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker ValueMarker ( String arg0 ) { this. markerId = arg0 ; return this ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker ValueMarker ( Marker arg0 ) { this. marker = arg0 ; return this ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( Marker arg0 ) { this. marker = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( String arg0 ) { this. marker = new Marker ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( Mark arg0 ) { this. marker = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( final Marker arg0 ) { this. marker = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( marker arg0 ) { this. marker = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker ValueMarker ( ) { return ValueMarker. INSTANCE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( ValueMarker arg0 ) { this. valueMarker = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker ValueMarker ( ) { return new ValueMarker ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker ValueMarker ( ) { return ValueMarker. INSTANCE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ValueMarker ValueMarker ( ValueMarker arg0 ) { this. valueMarker = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( Marker arg0 ) { this. marker = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker ValueMarker ( String arg0 ) { this. arg0 = arg0 ; return this ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( String arg0 ) { this. marker. setText ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker ValueMarker ( String arg0 ) { this. marker. setText ( arg0 ) ; return this ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Marker ValueMarker ( String arg0 ) { this. marker = new Marker ( arg0 ) ; return this ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( Marker arg0 ) { this. marker = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( String arg0 ) { this. marker. setText ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( String arg0 ) { this. marker = new Marker ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( String arg0 ) { this. marker. setValue ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void ValueMarker ( final Marker arg0 ) { this. marker = arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_79_src/main/java/org/apache/commons/math/util/MathUtils.java_1624-1625": {
      "loc": "1624-1625",
      "input": "public static double distance(int[] p1, int[] p2) {\n  int sum = 0;\n  for (int i = 0; i < p1.length; i++) {\n      final int dp = p1[i] - p2[i];\n      sum += dp * dp;\n  }\n  return Math.sqrt(sum);\n}",
      "target": "public static double distance(int[] p1, int[] p2) {\n  double sum = 0;\n  for (int i = 0; i < p1.length; i++) {\n      final double dp = p1[i] - p2[i];\n      sum += dp * dp;\n  }\n  return Math.sqrt(sum);\n}",
      "function range": "1623,5-1630,5",
      "raw_output": [
        "double function ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2 ) { double loc0 = arg2 - arg0 ; double loc1 = arg1 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2, double arg3 ) { double loc0 = arg2 - arg0 ; double loc1 = arg3 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Vector arg0, Vector arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg0. y - arg1. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg1 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2 ) { double loc0 = arg2 - arg0 ; double loc1 = arg1 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg2 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 + loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg1 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = arg1 - arg0 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg0. y - arg1. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg1. x - arg0. x ; double loc1 = arg1. y - arg0. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg1. y - arg0. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. distance ( arg1 ) ; double loc1 = arg1. distance ( arg0 ) ; double loc2 = arg1. distance ( arg0 ) ; return Math. sqrt ( loc0 + loc1 ) ; }",
        "double function ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Vector arg0, Vector arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg0. y - arg1. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2 ) { double loc0 = arg2 - arg0 ; double loc1 = arg1 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg2 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2, double arg3 ) { double loc0 = arg2 - arg0 ; double loc1 = arg3 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2 ) { double loc0 = arg2 - arg0 ; double loc1 = arg1 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( Vector arg0, Vector arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg0. y - arg1. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2, double arg3 ) { double loc0 = arg2 - arg0 ; double loc1 = arg3 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
        "double function ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg2 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }"
      ],
      "mid_translation": [
        "Compute the Euclidean distance between two vectors.",
        "Get the Euclidean distance between two vectors.",
        "Compute the Euclidean distance between two points.",
        "Calculate the Euclidean distance between two vectors.",
        "Compute the Euclidean distance between two vectors"
      ],
      "output": [
        {
          "patch": "public static double distance ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2 ) { double loc0 = arg2 - arg0 ; double loc1 = arg1 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2, double arg3 ) { double loc0 = arg2 - arg0 ; double loc1 = arg3 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( Vector arg0, Vector arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg0. y - arg1. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg1 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2 ) { double loc0 = arg2 - arg0 ; double loc1 = arg1 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg2 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 + loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg1 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; double loc1 = arg1 - arg0 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg0. y - arg1. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg1. x - arg0. x ; double loc1 = arg1. y - arg0. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg1. y - arg0. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. distance ( arg1 ) ; double loc1 = arg1. distance ( arg0 ) ; double loc2 = arg1. distance ( arg0 ) ; return Math. sqrt ( loc0 + loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( Vector arg0, Vector arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg0. y - arg1. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2 ) { double loc0 = arg2 - arg0 ; double loc1 = arg1 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg2 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2, double arg3 ) { double loc0 = arg2 - arg0 ; double loc1 = arg3 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( Vector arg0, Vector arg1 ) { double loc0 = arg0. length ( ) ; double loc1 = arg1. length ( ) ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2 ) { double loc0 = arg2 - arg0 ; double loc1 = arg1 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( Vector arg0, Vector arg1 ) { double loc0 = arg0. x - arg1. x ; double loc1 = arg0. y - arg1. y ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2, double arg3 ) { double loc0 = arg2 - arg0 ; double loc1 = arg3 - arg1 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double distance ( double arg0, double arg1, double arg2 ) { double loc0 = arg0 - arg1 ; double loc1 = arg2 - arg2 ; return Math. sqrt ( loc0 * loc0 + loc1 * loc1 ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_126_/src/com/google/javascript/jscomp/MinimizeExitPoints.java_141-142": {
      "loc": "141-142",
      "input": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    if (NodeUtil.hasFinally(n)) {\n      Node finallyBlock = n.getLastChild();\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n    }\n  }\n  if (n.isLabel()) {\n    Node labelBlock = n.getLastChild();\n    tryMinimizeExits(labelBlock, exitType, labelName);\n  }\n  if (!n.isBlock() || n.getLastChild() == null) {\n    return;\n  }\n  for (Node c : n.children()) {\n    if (c.isIf()) {\n      Node ifTree = c;\n      Node trueBlock, falseBlock;\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      tryMinimizeIfBlockExits(trueBlock, falseBlock,\n          ifTree, exitType, labelName);\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      if (falseBlock != null) {\n        tryMinimizeIfBlockExits(falseBlock, trueBlock,\n            ifTree, exitType, labelName);\n      }\n    }\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n  for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n    tryMinimizeExits(c, exitType, labelName);\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n}",
      "target": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n  }\n  if (n.isLabel()) {\n    Node labelBlock = n.getLastChild();\n    tryMinimizeExits(labelBlock, exitType, labelName);\n  }\n  if (!n.isBlock() || n.getLastChild() == null) {\n    return;\n  }\n  for (Node c : n.children()) {\n    if (c.isIf()) {\n      Node ifTree = c;\n      Node trueBlock, falseBlock;\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      tryMinimizeIfBlockExits(trueBlock, falseBlock,\n          ifTree, exitType, labelName);\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      if (falseBlock != null) {\n        tryMinimizeIfBlockExits(falseBlock, trueBlock,\n            ifTree, exitType, labelName);\n      }\n    }\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n  for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n    tryMinimizeExits(c, exitType, labelName);\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n}",
      "function range": "106,3-201,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_18_/src/com/google/javascript/jscomp/Compiler.java_1288-1289": {
      "loc": "1288-1289",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n      for (CompilerInput input : inputs) {\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n    hoistNoCompileFiles();\n    if (staleInputs) {\n      repartitionInputs();\n    }\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n      jsRoot.addChildToBack(n);\n    }\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
      "target": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement()) {\n      for (CompilerInput input : inputs) {\n        for (String provide : input.getProvides()) {\n          getTypeRegistry().forwardDeclareType(provide);\n        }\n      }\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        staleInputs = true;\n      } catch (CircularDependencyException e) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n        if (hasErrors()) {\n          return null;\n        }\n      } catch (MissingProvideException e) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, e.getMessage()));\n        if (hasErrors()) {\n          return null;\n        }\n      }\n    }\n    hoistNoCompileFiles();\n    if (staleInputs) {\n      repartitionInputs();\n    }\n    for (CompilerInput input : inputs) {\n      Node n = input.getAstRoot(this);\n      if (n == null) {\n        continue;\n      }\n      if (devMode) {\n        runSanityCheck();\n        if (hasErrors()) {\n          return null;\n        }\n      }\n      if (options.sourceMapOutputPath != null ||\n          options.nameReferenceReportPath != null) {\n        SourceInformationAnnotator sia =\n            new SourceInformationAnnotator(\n                input.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, n, sia);\n      }\n      jsRoot.addChildToBack(n);\n    }\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer, \"parseInputs\");\n  }\n}",
      "function range": "1240,3-1362,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_70_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1745-1746": {
      "loc": "1745-1746",
      "input": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}",
      "target": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,\n              jsDocParameter.getJSType(), false);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}",
      "function range": "1734,5-1753,5",
      "raw_output": [
        "DeclareFunction2D function ( Function2D arg0, Object... arg1 ) { return new DeclareFunction2D ( arg0, arg1 ) ; }",
        "DeclareFunction2D function ( Function2D arg0 ) { return new DeclareFunction2D ( arg0 ) ; }",
        "DeclareFunction2D function ( Function2D arg0, Object... arg1 ) { return newDeclareFunction2D ( arg0, arg1 ) ; }",
        "DeclareFunction2Args function (DeclareFunction2Args arg0 ) { return newDeclareFunction2Args ( arg0 ) ; }",
        "DeclareFunction2Args function (DeclareFunction2Args arg0 ) { return new DeclareFunction2Args ( arg0 ) ; }",
        "DeclareFunctionArguments function (DeclareFunctionArguments arg0 ) { return newDeclareFunctionArguments ( arg0 ) ; }",
        "DeclareFunctionArguments function (DeclareFunctionArguments arg0 ) { return new DeclareFunctionArguments ( arg0 ) ; }",
        "DeclareFunctionArguments function ( final Class... arg0 ) { return new DeclareFunctionArguments ( arg0 ) ; }",
        "DeclareFunctionArguments function ( final FunctionArguments arg0 ) { return new DeclareFunctionArguments ( arg0 ) ; }",
        "DeclareFunctionArguments function ( Class... arg0 ) { return new DeclareFunctionArguments ( arg0 ) ; }",
        "DeclareArguments function ( Class <? extends DeclareArguments > arg0,DeclareArguments... arg1 ) { return new DeclareArguments ( arg0, arg1 ) ; }",
        "DeclareArguments function ( Class <? > arg0, Class <? >... arg1 ) { return new DeclareArguments ( arg0, arg1 ) ; }",
        "DeclareArguments function ( final Class <? > arg0, final Class <? >... arg1 ) { return new DeclareArguments ( arg0, arg1 ) ; }",
        "DeclareArguments function ( Class <? extends DeclareArguments > arg0,DeclareArguments... arg1 ) { return newDeclareArguments ( arg0, arg1 ) ; }",
        "DeclareArguments function ( Class <? extends DeclareArguments > arg0, DeclareArguments... arg1 ) { return new DeclareArguments ( arg0, arg1 ) ; }",
        "FunctionDeclaration function ( FunctionDeclaration arg0, Object... arg1 ) { return new FunctionDeclaration ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg1 ) ; }",
        "DeclareFunctionArguments function ( FunctionDeclaration arg0, Object... arg1 ) { return new DeclareFunctionArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg1 ) ; }",
        "DeclareFunctionArgs function ( FunctionDeclaration arg0, Object... arg1 ) { return new DeclareFunctionArgs ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg1 ) ; }",
        "DeclareArguments function ( FunctionDeclaration arg0, Object... arg1 ) { returnDeclareArguments ( null, arg0, arg1 ) ; }",
        "FunctionDeclaration function ( FunctionDeclaration arg0, Object... arg1 ) { return new FunctionDeclaration ( arg0. getName ( ), arg0. getParameterTypes ( ), arg1 ) ; }",
        "DeclareArguments function ( Function < T, A > arg0, A arg1 ) { return new DeclareArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg1 ) ; }",
        "DeclareArguments function ( FunctionDeclaration arg0, A arg1 ) { return new DeclareArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg0. getParameterTypes ( ) ) ; }",
        "DeclareArguments function ( Function < T, A > arg0 ) { return new DeclareArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg0. getParameterTypes ( ) ) ; }",
        "DeclareArguments function ( FunctionDeclaration arg0, A arg1 ) { return newDeclareArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg0. getParameterTypes ( ) ) ; }",
        "DeclareArguments function ( Function < T, A > arg0, A... arg1 ) { returnDeclareArguments ( null, arg0, arg1 ) ; }"
      ],
      "mid_translation": [
        "Declare the arguments of a function.",
        "Declare function arguments.",
        "Declare arguments.",
        "Declare the arguments for a function.",
        "Declare arguments for a function."
      ],
      "output": [
        {
          "patch": "private DeclareFunction2D declareArguments ( Function2D arg0, Object... arg1 ) { return new DeclareFunction2D ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunction2D declareArguments ( Function2D arg0 ) { return new DeclareFunction2D ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunction2D declareArguments ( Function2D arg0, Object... arg1 ) { return newDeclareFunction2D ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunction2Args declareArguments (DeclareFunction2Args arg0 ) { return newDeclareFunction2Args ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunction2Args declareArguments (DeclareFunction2Args arg0 ) { return new DeclareFunction2Args ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunctionArguments declareArguments (DeclareFunctionArguments arg0 ) { return newDeclareFunctionArguments ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunctionArguments declareArguments (DeclareFunctionArguments arg0 ) { return new DeclareFunctionArguments ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunctionArguments declareArguments ( final Class... arg0 ) { return new DeclareFunctionArguments ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunctionArguments declareArguments ( final FunctionArguments arg0 ) { return new DeclareFunctionArguments ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunctionArguments declareArguments ( Class... arg0 ) { return new DeclareFunctionArguments ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( Class <? extends DeclareArguments > arg0,DeclareArguments... arg1 ) { return new DeclareArguments ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( Class <? > arg0, Class <? >... arg1 ) { return new DeclareArguments ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( final Class <? > arg0, final Class <? >... arg1 ) { return new DeclareArguments ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( Class <? extends DeclareArguments > arg0,DeclareArguments... arg1 ) { return newDeclareArguments ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( Class <? extends DeclareArguments > arg0, DeclareArguments... arg1 ) { return new DeclareArguments ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private FunctionDeclaration declareArguments ( FunctionDeclaration arg0, Object... arg1 ) { return new FunctionDeclaration ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunctionArguments declareArguments ( FunctionDeclaration arg0, Object... arg1 ) { return new DeclareFunctionArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareFunctionArgs declareArguments ( FunctionDeclaration arg0, Object... arg1 ) { return new DeclareFunctionArgs ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( FunctionDeclaration arg0, Object... arg1 ) { returnDeclareArguments ( null, arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private FunctionDeclaration declareArguments ( FunctionDeclaration arg0, Object... arg1 ) { return new FunctionDeclaration ( arg0. getName ( ), arg0. getParameterTypes ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( Function < T, A > arg0, A arg1 ) { return new DeclareArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( FunctionDeclaration arg0, A arg1 ) { return new DeclareArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg0. getParameterTypes ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( Function < T, A > arg0 ) { return new DeclareArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg0. getParameterTypes ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( FunctionDeclaration arg0, A arg1 ) { return newDeclareArguments ( arg0. getDeclaringClass ( ), arg0. getName ( ), arg0. getParameterTypes ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private DeclareArguments declareArguments ( Function < T, A > arg0, A... arg1 ) { returnDeclareArguments ( null, arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_10_/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java_65-66": {
      "loc": "65-66",
      "input": "public String generateToolTipFragment(String toolTipText) {\n    return \" title=\\\"\" + toolTipText\n\n        + \"\\\" alt=\\\"\\\"\";\n}",
      "target": "public String generateToolTipFragment(String toolTipText) {\n    return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \n\n        + \"\\\" alt=\\\"\\\"\";\n}",
      "function range": "64,5-67,5",
      "raw_output": [
        "String function ( ) { if ( \"srini_string\". equals ( this. getClass ( ). getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( this. getClass ( ). getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( this. getClass ( ). getName ( ) ) ) { return \"srini_string\" ; } return \"srini_string\" ; }",
        "String function ( ) { if ( \"srini_string\". equals ( this. getClass ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( this. getClass ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( this. getClass ( ) ) ) { return \"srini_string\" ; } return \"srini_string\" ; }",
        "String function ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg1 == 2 ) { return \"srini_string\" ; } if ( arg1 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg0 == 2 ) { return \"srini_string\" ; } if ( arg1 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg0 == 2 ) { return \"srini_string\" ; } if ( arg0 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "ToolTipFragment function ( TagSetCTYPE arg0 ) { return new ToolTipFragment ( arg0 ) ; }",
        "ToolTipFragment function ( ) { return new ToolTipFragment ( ) ; }",
        "ToolTipFragment function ( final ClusterNode arg0 ) { return new ToolTipFragment ( ) ; }",
        "ToolTipFragment function ( ClusterNode arg0 ) { return new ToolTipFragment ( ) ; }",
        "String function ( TagSetCTYPE arg0 ) { return ToolTipFactory. createToolTipFragment ( arg0 ) ; }",
        "ToolTipFragment function ( TagSet arg0 ) { return new ToolTipFragment ( arg0 ) ; }",
        "ToolTipFragment function ( URL arg0, TagSet arg1 ) { return new ToolTipFragment ( arg0. toString ( ), arg1 ) ; }",
        "ToolTipFragment function ( TagSet arg0, String arg1 ) { return new ToolTipFragment ( arg0, arg1 ) ; }",
        "ToolTipFragment function ( Tag arg0 ) { return new ToolTipFragment ( arg0 ) ; }",
        "ToolTipFragment function ( Tag arg0, URL arg1 ) { return new ToolTipFragment ( arg0. toString ( ), arg1. toString ( ) ) ; }",
        "ToolTipFragment function ( ) { return new ToolTipFragment ( \"srini_string\" ) ; }",
        "ToolTipFragment function ( ) { return new ToolTipFragment ( \"srini_string\", \"srini_string\" ) ; }",
        "ToolTipFragment function ( ) { return new ToolTipFragment ( \"srini_string\", \"srini_string\", \"srini_string\" ) ; }",
        "ToolTipFragment function ( Container arg0 ) { return new ToolTipFragment ( \"srini_string\", arg0 ) ; }",
        "ToolTipFragment function ( ToolTip arg0 ) { return new ToolTipFragment ( \"srini_string\", arg0 ) ; }",
        "String function ( int arg0, int arg1 ) { if ( arg1 == 0 ) { return \"srini_string\" ; } else if ( arg1 == 1 ) { return \"srini_string\" ; } else if ( arg1 == 2 ) { return \"srini_string\" ; } else if ( arg1 == 3 ) { return \"srini_string\" ; } else if ( arg1 == 4 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg0 == 2 ) { return \"srini_string\" ; } if ( arg1 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg1 == 2 ) { return \"srini_string\" ; } if ( arg1 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg0 == 2 ) { return \"srini_string\" ; } if ( arg0 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( int arg0, int arg1 ) { if ( arg1 == 0 ) { return \"srini_string\" ; } else if ( arg1 == 1 ) { return \"srini_string\" ; } else if ( arg1 == 2 ) { return \"srini_string\" ; } else if ( arg1 == 3 ) { return \"srini_string\" ; } else if ( arg1 == 4 ) { return \"srini_string\" ; } else if ( arg1 == 5 ) { return \"srini_string\" ; } return \"srini_string\" ; }"
      ],
      "mid_translation": [
        "Generate a tooltip fragment for the\nCTYPE element.",
        "Generate the ToolTipFragment for the\nCTYPE element.",
        "Generate a ToolTipFragment for the\n        tag.",
        "Generate a ToolTipFragment for the\n        button.",
        "Generate a tooltip fragment for the\nCTYPE."
      ],
      "output": [
        {
          "patch": "public String generateToolTipFragment ( ) { if ( \"srini_string\". equals ( this. getClass ( ). getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( this. getClass ( ). getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( this. getClass ( ). getName ( ) ) ) { return \"srini_string\" ; } return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( ) { if ( \"srini_string\". equals ( this. getClass ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( this. getClass ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( this. getClass ( ) ) ) { return \"srini_string\" ; } return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg1 == 2 ) { return \"srini_string\" ; } if ( arg1 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg0 == 2 ) { return \"srini_string\" ; } if ( arg1 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg0 == 2 ) { return \"srini_string\" ; } if ( arg0 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( TagSetCTYPE arg0 ) { return new ToolTipFragment ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( ) { return new ToolTipFragment ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( final ClusterNode arg0 ) { return new ToolTipFragment ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( ClusterNode arg0 ) { return new ToolTipFragment ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( TagSetCTYPE arg0 ) { return ToolTipFactory. createToolTipFragment ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( TagSet arg0 ) { return new ToolTipFragment ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( URL arg0, TagSet arg1 ) { return new ToolTipFragment ( arg0. toString ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( TagSet arg0, String arg1 ) { return new ToolTipFragment ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( Tag arg0 ) { return new ToolTipFragment ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( Tag arg0, URL arg1 ) { return new ToolTipFragment ( arg0. toString ( ), arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( ) { return new ToolTipFragment ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( ) { return new ToolTipFragment ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( ) { return new ToolTipFragment ( \"srini_string\", \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( Container arg0 ) { return new ToolTipFragment ( \"srini_string\", arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ToolTipFragment generateToolTipFragment ( ToolTip arg0 ) { return new ToolTipFragment ( \"srini_string\", arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( int arg0, int arg1 ) { if ( arg1 == 0 ) { return \"srini_string\" ; } else if ( arg1 == 1 ) { return \"srini_string\" ; } else if ( arg1 == 2 ) { return \"srini_string\" ; } else if ( arg1 == 3 ) { return \"srini_string\" ; } else if ( arg1 == 4 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg0 == 2 ) { return \"srini_string\" ; } if ( arg1 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg1 == 2 ) { return \"srini_string\" ; } if ( arg1 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( int arg0, int arg1 ) { if ( arg0 == 0 ) { return \"srini_string\" ; } if ( arg1 == 0 ) { return \"srini_string\" ; } if ( arg1 == 1 ) { return \"srini_string\" ; } if ( arg0 == 2 ) { return \"srini_string\" ; } if ( arg0 == 3 ) { return \"srini_string\" ; } return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String generateToolTipFragment ( int arg0, int arg1 ) { if ( arg1 == 0 ) { return \"srini_string\" ; } else if ( arg1 == 1 ) { return \"srini_string\" ; } else if ( arg1 == 2 ) { return \"srini_string\" ; } else if ( arg1 == 3 ) { return \"srini_string\" ; } else if ( arg1 == 4 ) { return \"srini_string\" ; } else if ( arg1 == 5 ) { return \"srini_string\" ; } return \"srini_string\" ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_1_/src/com/google/javascript/jscomp/RemoveUnusedVars.java_379-380": {
      "loc": "379-380",
      "input": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n  Node function = fnScope.getRootNode();\n  Preconditions.checkState(function.isFunction());\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n    return;\n  }\n  Node argList = getFunctionArgList(function);\n  boolean modifyCallers = modifyCallSites\n      && callSiteOptimizer.canModifyCallers(function);\n  if (!modifyCallers) {\n    Node lastArg;\n    while ((lastArg = argList.getLastChild()) != null) {\n      Var var = fnScope.getVar(lastArg.getString());\n      if (!referenced.contains(var)) {\n        argList.removeChild(lastArg);\n        compiler.reportCodeChange();\n      } else {\n        break;\n      }\n    }\n  } else {\n    callSiteOptimizer.optimize(fnScope, referenced);\n  }\n}",
      "target": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n  if (!removeGlobals) {\n    return;\n  }\n  Node function = fnScope.getRootNode();\n  Preconditions.checkState(function.isFunction());\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n    return;\n  }\n  Node argList = getFunctionArgList(function);\n  boolean modifyCallers = modifyCallSites\n      && callSiteOptimizer.canModifyCallers(function);\n  if (!modifyCallers) {\n    Node lastArg;\n    while ((lastArg = argList.getLastChild()) != null) {\n      Var var = fnScope.getVar(lastArg.getString());\n      if (!referenced.contains(var)) {\n        argList.removeChild(lastArg);\n        compiler.reportCodeChange();\n      } else {\n        break;\n      }\n    }\n  } else {\n    callSiteOptimizer.optimize(fnScope, referenced);\n  }\n}",
      "function range": "369,3-406,3",
      "raw_output": [
        "R function ( T [ ] arg0 ) { R loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] instanceof R ) { loc0 = ( R ) arg0 [ loc1 ] ; } arg0 [ loc1 ] = null ; } return loc0 ; }",
        "R function ( T [ ] arg0 ) { R loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { arg0 [ loc1 ] = null ; } else { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "R function ( T [ ] arg0 ) { R loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] instanceof R ) { loc0 = ( R ) arg0 [ loc1 ] ; arg0 [ loc1 ] = null ; } } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } else { loc0 = ( R ) loc1 ; } } return loc0 ; }",
        "R function ( T [ ] arg0 ) { R loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] instanceof R ) { loc0 = ( R ) arg0 [ loc1 ] ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] == null ) { loc0 [ loc1 ] = null ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } else { loc0 = ( R ) loc1 ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( RubyObject ) loc1 ; } else { loc0 = ( RubyObject ) loc1 ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( RubyObject ) loc1 ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] == null ) { loc0 [ loc1 ] = null ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } else { loc0 = ( R ) loc1 ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = arg0. getFunctionArguments ( ) ; if ( loc0!= null ) { for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. remove ( loc1 ) ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] instanceof Integer ) { loc0 [ loc1 ] = null ; } } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } else { loc0 = ( R ) loc1 ; } } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof T ) { loc0 = ( T ) loc1 ; } else { loc0 = ( T ) loc1 ; } } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( RubyObject ) loc1 ; } } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. values ( ) ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( RubyObject ) loc1 ; } } return loc0 ; }",
        "IRubyObject function ( IRubyObject arg0 ) { IRubyObject loc0 = null ; if ( arg0!= null ) { for ( IRubyObject loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( IRubyObject ) loc1 ; } } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] == null ) { loc0 [ loc1 ] = null ; } } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof Class ) { loc0 = ( Class ) loc1 ; } else { loc0 = ( Class ) loc1 ; } arg0. setArguments ( loc0 ) ; } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof Class ) { loc0 = ( Class ) loc1 ; } else { loc0 = ( Class ) loc1 ; } } return loc0 ; }",
        "R function ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] instanceof Integer ) { loc0 [ loc1 ] = null ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Remove unreferenced function arguments.",
        "Remove unreferenced function arguments from function.",
        "Remove unreferenced function arguments from the function.",
        "Remove uncreferenced function arguments.",
        "Remove uncreferenced function arguments from the function."
      ],
      "output": [
        {
          "patch": "private R removeUnreferencedFunctionArgs ( T [ ] arg0 ) { R loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] instanceof R ) { loc0 = ( R ) arg0 [ loc1 ] ; } arg0 [ loc1 ] = null ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( T [ ] arg0 ) { R loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { arg0 [ loc1 ] = null ; } else { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( T [ ] arg0 ) { R loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] instanceof R ) { loc0 = ( R ) arg0 [ loc1 ] ; arg0 [ loc1 ] = null ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } else { loc0 = ( R ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( T [ ] arg0 ) { R loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] instanceof R ) { loc0 = ( R ) arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] == null ) { loc0 [ loc1 ] = null ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } else { loc0 = ( R ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( RubyObject ) loc1 ; } else { loc0 = ( RubyObject ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( RubyObject ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] == null ) { loc0 [ loc1 ] = null ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } else { loc0 = ( R ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = arg0. getFunctionArguments ( ) ; if ( loc0!= null ) { for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. remove ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] instanceof Integer ) { loc0 [ loc1 ] = null ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } else { loc0 = ( R ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof T ) { loc0 = ( T ) loc1 ; } else { loc0 = ( T ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof R ) { loc0 = ( R ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( RubyObject ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. values ( ) ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( RubyObject ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private IRubyObject removeUnreferencedFunctionArgs ( IRubyObject arg0 ) { IRubyObject loc0 = null ; if ( arg0!= null ) { for ( IRubyObject loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof IRubyObject ) { loc0 = ( IRubyObject ) loc1 ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] == null ) { loc0 [ loc1 ] = null ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof Class ) { loc0 = ( Class ) loc1 ; } else { loc0 = ( Class ) loc1 ; } arg0. setArguments ( loc0 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( R arg0 ) { R loc0 = null ; for ( Object loc1 : arg0. getArguments ( ) ) { if ( loc1 instanceof Class ) { loc0 = ( Class ) loc1 ; } else { loc0 = ( Class ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R removeUnreferencedFunctionArgs ( FunctionCallExpression arg0 ) { R loc0 = ( R ) arg0. getParameters ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { if ( loc0 [ loc1 ] instanceof Integer ) { loc0 [ loc1 ] = null ; } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_132_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_782-783": {
      "loc": "782-783",
      "input": "private Node tryMinimizeIf(Node n) {\n  Node parent = n.getParent();\n  Node cond = n.getFirstChild();\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n  if (elseBranch == null) {\n    if (isFoldableExpressBlock(thenBranch)) {\n      Node expr = getBlockExpression(thenBranch);\n      if (!late && isPropertyAssignmentInExpression(expr)) {\n        return n;\n      }\n      if (cond.isNot()) {\n        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                OR_PRECEDENCE)) {\n          return n;\n        }\n        Node or = IR.or(\n            cond.removeFirstChild(),\n            expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(or);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      }\n      if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n          isLowerPrecedenceInExpression(expr.getFirstChild(),\n              AND_PRECEDENCE)) {\n        return n;\n      }\n      n.removeChild(cond);\n      Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n      Node newExpr = NodeUtil.newExpr(and);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n      return newExpr;\n    } else {\n      if (NodeUtil.isStatementBlock(thenBranch) &&\n          thenBranch.hasOneChild()) {\n        Node innerIf = thenBranch.getFirstChild();\n        if (innerIf.isIf()) {\n          Node innerCond = innerIf.getFirstChild();\n          Node innerThenBranch = innerCond.getNext();\n          Node innerElseBranch = innerThenBranch.getNext();\n          if (innerElseBranch == null &&\n               !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                 isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n            n.detachChildren();\n            n.addChildToBack(\n                IR.and(\n                    cond,\n                    innerCond.detachFromParent())\n                    .srcref(cond));\n            n.addChildrenToBack(innerThenBranch.detachFromParent());\n            reportCodeChange();\n            return n;\n          }\n        }\n      }\n    }\n    return n;\n  }\n  tryRemoveRepeatedStatements(n);\n  if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n    n.replaceChild(cond, cond.removeFirstChild());\n    n.removeChild(thenBranch);\n    n.addChildToBack(thenBranch);\n    reportCodeChange();\n    return n;\n  }\n  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n    Node thenExpr = getBlockReturnExpression(thenBranch);\n    Node elseExpr = getBlockReturnExpression(elseBranch);\n    n.removeChild(cond);\n    thenExpr.detachFromParent();\n    elseExpr.detachFromParent();\n    Node returnNode = IR.returnNode(\n                          IR.hook(cond, thenExpr, elseExpr)\n                              .srcref(n));\n    parent.replaceChild(n, returnNode);\n    reportCodeChange();\n    return returnNode;\n  }\n  boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n  boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n    if (thenOp.getType() == elseOp.getType()) {\n      if (NodeUtil.isAssignmentOp(thenOp)) {\n        Node lhs = thenOp.getFirstChild();\n        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n            !mayEffectMutableState(lhs)) {\n          n.removeChild(cond);\n          Node assignName = thenOp.removeFirstChild();\n          Node thenExpr = thenOp.removeFirstChild();\n          Node elseExpr = elseOp.getLastChild();\n          elseOp.removeChild(elseExpr);\n          Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n          Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                            .srcref(thenOp);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n          return expr;\n        }\n      }\n    }\n    n.removeChild(cond);\n    thenOp.detachFromParent();\n    elseOp.detachFromParent();\n    Node expr = IR.exprResult(\n        IR.hook(cond, thenOp, elseOp).srcref(n));\n    parent.replaceChild(n, expr);\n    reportCodeChange();\n    return expr;\n  }\n  boolean thenBranchIsVar = isVarBlock(thenBranch);\n  boolean elseBranchIsVar = isVarBlock(elseBranch);\n  if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n      getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n    Node var = getBlockVar(thenBranch);\n    Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n    Node name1 = var.getFirstChild();\n    Node maybeName2 = elseAssign.getFirstChild();\n    if (name1.hasChildren()\n        && maybeName2.isName()\n        && name1.getString().equals(maybeName2.getString())) {\n      Node thenExpr = name1.removeChildren();\n      Node elseExpr = elseAssign.getLastChild().detachFromParent();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                          .srcref(n);\n      var.detachFromParent();\n      name1.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n  } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n      getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n    Node var = getBlockVar(elseBranch);\n    Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n    Node maybeName1 = thenAssign.getFirstChild();\n    Node name2 = var.getFirstChild();\n    if (name2.hasChildren()\n        && maybeName1.isName()\n        && maybeName1.getString().equals(name2.getString())) {\n      Node thenExpr = thenAssign.getLastChild().detachFromParent();\n      Node elseExpr = name2.removeChildren();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                          .srcref(n);\n      var.detachFromParent();\n      name2.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n  }\n  return n;\n}",
      "target": "private Node tryMinimizeIf(Node n) {\n  Node parent = n.getParent();\n  Node cond = n.getFirstChild();\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n  if (elseBranch == null) {\n    if (isFoldableExpressBlock(thenBranch)) {\n      Node expr = getBlockExpression(thenBranch);\n      if (!late && isPropertyAssignmentInExpression(expr)) {\n        return n;\n      }\n      if (cond.isNot()) {\n        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                OR_PRECEDENCE)) {\n          return n;\n        }\n        Node or = IR.or(\n            cond.removeFirstChild(),\n            expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(or);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      }\n      if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n          isLowerPrecedenceInExpression(expr.getFirstChild(),\n              AND_PRECEDENCE)) {\n        return n;\n      }\n      n.removeChild(cond);\n      Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n      Node newExpr = NodeUtil.newExpr(and);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n      return newExpr;\n    } else {\n      if (NodeUtil.isStatementBlock(thenBranch) &&\n          thenBranch.hasOneChild()) {\n        Node innerIf = thenBranch.getFirstChild();\n        if (innerIf.isIf()) {\n          Node innerCond = innerIf.getFirstChild();\n          Node innerThenBranch = innerCond.getNext();\n          Node innerElseBranch = innerThenBranch.getNext();\n          if (innerElseBranch == null &&\n               !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                 isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n            n.detachChildren();\n            n.addChildToBack(\n                IR.and(\n                    cond,\n                    innerCond.detachFromParent())\n                    .srcref(cond));\n            n.addChildrenToBack(innerThenBranch.detachFromParent());\n            reportCodeChange();\n            return n;\n          }\n        }\n      }\n    }\n    return n;\n  }\n  tryRemoveRepeatedStatements(n);\n  if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n    n.replaceChild(cond, cond.removeFirstChild());\n    n.removeChild(thenBranch);\n    n.addChildToBack(thenBranch);\n    reportCodeChange();\n    return n;\n  }\n  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n    Node thenExpr = getBlockReturnExpression(thenBranch);\n    Node elseExpr = getBlockReturnExpression(elseBranch);\n    n.removeChild(cond);\n    thenExpr.detachFromParent();\n    elseExpr.detachFromParent();\n    Node returnNode = IR.returnNode(\n                          IR.hook(cond, thenExpr, elseExpr)\n                              .srcref(n));\n    parent.replaceChild(n, returnNode);\n    reportCodeChange();\n    return returnNode;\n  }\n  boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n  boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n    if (thenOp.getType() == elseOp.getType()) {\n      if (NodeUtil.isAssignmentOp(thenOp)) {\n        Node lhs = thenOp.getFirstChild();\n        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n            !mayEffectMutableState(lhs) &&\n            (!mayHaveSideEffects(cond) ||\n                (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n          n.removeChild(cond);\n          Node assignName = thenOp.removeFirstChild();\n          Node thenExpr = thenOp.removeFirstChild();\n          Node elseExpr = elseOp.getLastChild();\n          elseOp.removeChild(elseExpr);\n          Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n          Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                            .srcref(thenOp);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n          return expr;\n        }\n      }\n    }\n    n.removeChild(cond);\n    thenOp.detachFromParent();\n    elseOp.detachFromParent();\n    Node expr = IR.exprResult(\n        IR.hook(cond, thenOp, elseOp).srcref(n));\n    parent.replaceChild(n, expr);\n    reportCodeChange();\n    return expr;\n  }\n  boolean thenBranchIsVar = isVarBlock(thenBranch);\n  boolean elseBranchIsVar = isVarBlock(elseBranch);\n  if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n      getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n    Node var = getBlockVar(thenBranch);\n    Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n    Node name1 = var.getFirstChild();\n    Node maybeName2 = elseAssign.getFirstChild();\n    if (name1.hasChildren()\n        && maybeName2.isName()\n        && name1.getString().equals(maybeName2.getString())) {\n      Node thenExpr = name1.removeChildren();\n      Node elseExpr = elseAssign.getLastChild().detachFromParent();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                          .srcref(n);\n      var.detachFromParent();\n      name1.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n  } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n      getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n    Node var = getBlockVar(elseBranch);\n    Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n    Node maybeName1 = thenAssign.getFirstChild();\n    Node name2 = var.getFirstChild();\n    if (name2.hasChildren()\n        && maybeName1.isName()\n        && maybeName1.getString().equals(name2.getString())) {\n      Node thenExpr = thenAssign.getLastChild().detachFromParent();\n      Node elseExpr = name2.removeChildren();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                          .srcref(n);\n      var.detachFromParent();\n      name2.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n  }\n  return n;\n}",
      "function range": "636,3-868,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_6_/source/org/jfree/chart/util/ShapeList.java_111-112": {
      "loc": "111-112",
      "input": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    return super.equals(obj);\n}",
      "target": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n    ShapeList that = (ShapeList) obj;\n    int listSize = size();\n    for (int i = 0; i < listSize; i++) {\n       if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n           return false;\n       }\n    }\n    return true;\n}",
      "function range": "103,5-113,5",
      "raw_output": [
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equal ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equalTo ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYDataset ) ) { return false ; } StandardXYDataset loc0 = ( StandardXYDataset ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if ( this. getClass ( ) == loc0. getClass ( ) ) { return true ; } return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if ( this. getClass ( ) == loc0. getClass ( ) ) { return true ; } return false ; }",
        "boolean function ( final Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYDataset ) ) { return false ; } StandardXYDataset loc0 = ( StandardXYDataset ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equal ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equal ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. getClass ( ). equals ( loc0. getClass ( ) ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. getClass ( ). equals ( loc0. getClass ( ) ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if ( this. getClass ( ) == loc0. getClass ( ) ) { return true ; } return false ; }"
      ],
      "mid_translation": [
        "Returns true if this object is equal to the specified object.",
        "Returns true if this is the same as the specified object.",
        "Returns true if this is equal to the specified object.",
        "Returns true if this object equals the specified object.",
        "Returns true if this is the same as the given object."
      ],
      "output": [
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equal ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equalTo ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYDataset ) ) { return false ; } StandardXYDataset loc0 = ( StandardXYDataset ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if ( this. getClass ( ) == loc0. getClass ( ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if ( this. getClass ( ) == loc0. getClass ( ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYDataset ) ) { return false ; } StandardXYDataset loc0 = ( StandardXYDataset ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equal ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equal ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. getClass ( ). equals ( loc0. getClass ( ) ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. getClass ( ). equals ( loc0. getClass ( ) ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if ( this. getClass ( ) == loc0. getClass ( ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_24_/source/org/jfree/chart/renderer/GrayPaintScale.java_126-127": {
      "loc": "126-127",
      "input": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((value - this.lowerBound) / (this.upperBound \n\n            - this.lowerBound) * 255.0);\n    return new Color(g, g, g);\n}",
      "target": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound \n\n            - this.lowerBound) * 255.0);\n    return new Color(g, g, g);\n}",
      "function range": "123,5-129,5",
      "raw_output": [
        "Paint function ( int arg0 ) { if ( arg0 < 0 ) { return Color. red ; } else if ( arg0 < 1 ) { return Color. green ; } else if ( arg0 < 2 ) { return Color. blue ; } else if ( arg0 == 3 ) { return Color. red ; } else { return Color. green ; } }",
        "Paint function ( int arg0 ) { if ( arg0 < 0 ) { return Color. red ; } else if ( arg0 < 1 ) { return Color. green ; } else if ( arg0 < 2 ) { return Color. blue ; } else if ( arg0 == 3 ) { return Color. yellow ; } else { return Color. red ; } }",
        "Paint function ( int arg0 ) { if ( arg0 < 0 ) { return Color. red ; } else if ( arg0 < 1 ) { return Color. green ; } else if ( arg0 > 1 ) { return Color. blue ; } else { return Color. red ; } }",
        "Paint function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 < 1 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 == 1 ) { return Paint. CENTER ; } else { return Paint. TRANSPARENT ; } }",
        "Paint function ( int arg0 ) { if ( arg0 < 0 ) { return Color. red ; } else if ( arg0 < 1 ) { return Color. green ; } else if ( arg0 > 1 ) { return Color. blue ; } else { return Color. yellow ; } }",
        "Paint function ( ) { return new Paint ( ) ; }",
        "Paint function ( ) { return Color. BLACK ; }",
        "Paint function ( ) { return Paint. BLACK ; }",
        "Paint function ( int arg0 ) { return new Paint ( ) ; }",
        "Paint function ( Integer arg0 ) { return new Paint ( arg0 ) ; }",
        "Paint function ( float arg0 ) { if ( arg0 == 0.0f ) { return Color. red ; } else if ( arg0 == 1.0f ) { return Color. green ; } else if ( arg0 == 2.0f ) { return Color. blue ; } else { return Color. red ; } }",
        "Paint function ( float arg0 ) { if ( arg0 == 0.0f ) { return Color. red ; } else if ( arg0 == 1.0f ) { return Color. green ; } else if ( arg0 == 2.0f ) { return Color. blue ; } else { return Color. yellow ; } }",
        "Paint function ( ColorModel arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof GrayPaintModel ) { return ( ( GrayPaintModel ) arg0 ). paint ( ) ; } else { return null ; } }",
        "Paint function ( ColorModel arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof GrayPaintModel ) { return ( ( GrayPaintModel ) arg0 ). getPaint ( ) ; } else { return null ; } }",
        "Paint function ( float arg0 ) { if ( arg0 == 0.0f ) { return Color. red ; } else if ( arg0 == 1.0f ) { return Color. green ; } else if ( arg0 == 2.0f ) { return Color. blue ; } else { return Color. blue ; } }",
        "Paint function ( int arg0 ) { switch ( arg0 ) { case 0 : return Paint. MITER ; case 1 : return Paint. CENTER ; case 2 : return Paint. CENTER ; default : throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
        "Paint function ( int arg0 ) { switch ( arg0 ) { case 0 : return Paint. BLACK ; case 1 : return Paint. WHITE ; case 2 : return Paint. BLACK ; default : throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "Paint function ( int arg0 ) { switch ( arg0 ) { case 0 : return Paint. MITER ; case 1 : return Paint. CENTER ; case 2 : return Paint. CENTER ; default : throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "Paint function ( int arg0 ) { switch ( arg0 ) { case 0 : return Paint. MITER ; case 1 : return Paint. MITER ; case 2 : return Paint. MITER ; default : throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "Paint function ( int arg0 ) { switch ( arg0 ) { case 0 : return Paint. BLACK ; case 1 : return Paint. WHITE ; case 2 : return Paint. BLACK ; case 3 : return Paint. BLACK ; default : throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "T function ( T arg0 ) { return ( T ) arg0 ; }",
        "T function ( T arg0 ) { return arg0 ; }",
        "T function ( T arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
        "T function ( T arg0 ) { if ( arg0 == null ) return null ; return ( T ) arg0 ; }",
        "T function ( T arg0 ) { if ( arg0 == null ) { return null ; } return ( T ) arg0 ; }"
      ],
      "mid_translation": [
        "Get the paint for the given value.",
        "Get the paint for the value.",
        "Get the paint for the specified value.",
        "Get the paint for a given value.",
        "Get the paint for a single value."
      ],
      "output": [
        {
          "patch": "public Paint getPaint ( int arg0 ) { if ( arg0 < 0 ) { return Color. red ; } else if ( arg0 < 1 ) { return Color. green ; } else if ( arg0 < 2 ) { return Color. blue ; } else if ( arg0 == 3 ) { return Color. red ; } else { return Color. green ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( int arg0 ) { if ( arg0 < 0 ) { return Color. red ; } else if ( arg0 < 1 ) { return Color. green ; } else if ( arg0 < 2 ) { return Color. blue ; } else if ( arg0 == 3 ) { return Color. yellow ; } else { return Color. red ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( int arg0 ) { if ( arg0 < 0 ) { return Color. red ; } else if ( arg0 < 1 ) { return Color. green ; } else if ( arg0 > 1 ) { return Color. blue ; } else { return Color. red ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 < 1 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 == 1 ) { return Paint. CENTER ; } else { return Paint. TRANSPARENT ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( int arg0 ) { if ( arg0 < 0 ) { return Color. red ; } else if ( arg0 < 1 ) { return Color. green ; } else if ( arg0 > 1 ) { return Color. blue ; } else { return Color. yellow ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( ) { return new Paint ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( ) { return Color. BLACK ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( ) { return Paint. BLACK ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( int arg0 ) { return new Paint ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( Integer arg0 ) { return new Paint ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( float arg0 ) { if ( arg0 == 0.0f ) { return Color. red ; } else if ( arg0 == 1.0f ) { return Color. green ; } else if ( arg0 == 2.0f ) { return Color. blue ; } else { return Color. red ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( float arg0 ) { if ( arg0 == 0.0f ) { return Color. red ; } else if ( arg0 == 1.0f ) { return Color. green ; } else if ( arg0 == 2.0f ) { return Color. blue ; } else { return Color. yellow ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( ColorModel arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof GrayPaintModel ) { return ( ( GrayPaintModel ) arg0 ). paint ( ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( ColorModel arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof GrayPaintModel ) { return ( ( GrayPaintModel ) arg0 ). getPaint ( ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Paint getPaint ( float arg0 ) { if ( arg0 == 0.0f ) { return Color. red ; } else if ( arg0 == 1.0f ) { return Color. green ; } else if ( arg0 == 2.0f ) { return Color. blue ; } else { return Color. blue ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T getPaint ( T arg0 ) { return ( T ) arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T getPaint ( T arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T getPaint ( T arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T getPaint ( T arg0 ) { if ( arg0 == null ) return null ; return ( T ) arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T getPaint ( T arg0 ) { if ( arg0 == null ) { return null ; } return ( T ) arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_98_src/java/org/apache/commons/math/linear/BigMatrixImpl.java_991-992": {
      "loc": "991-992",
      "input": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[v.length];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = ZERO;\n        for (int i = 0; i < nCols; i++) {\n            sum = sum.add(data[row][i].multiply(v[i]));\n        }\n        out[row] = sum;\n    }\n    return out;\n}",
      "target": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int row = 0; row < nRows; row++) {\n        BigDecimal sum = ZERO;\n        for (int i = 0; i < nCols; i++) {\n            sum = sum.add(data[row][i].multiply(v[i]));\n        }\n        out[row] = sum;\n    }\n    return out;\n}",
      "function range": "985,5-1000,5",
      "raw_output": [
        "Vector function ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. addElement ( arg0. elementAt ( loc1 ) ) ; } return loc0 ; }",
        "Vector function ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. addElement ( arg0. elementAt ( loc1 ) ) ; return loc0 ; }",
        "Vector function ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. addElement ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "Vector function ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. addElement ( arg0. get ( loc1 ) ) ; return loc0 ; }",
        "Vector function ( Vector arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { arg0. set ( loc0, arg0. get ( loc0 ) ) ; } return arg0 ; }",
        "Vector function ( Vector arg0 ) { Vector loc0 = new Vector ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. addElement ( arg0. elementAt ( loc1 ) ) ; return loc0 ; }",
        "Vector function ( Vector arg0 ) { return arg0. sub ( new Vector ( 1, arg0. size ( ) ) ) ; }",
        "Vector function ( Vector arg0 ) { return new Vector ( arg0 ) ; }",
        "Vector function ( Vector arg0 ) { return new Vector ( arg0. size ( ) ) ; }",
        "Vector function ( Vector arg0 ) { return apply ( arg0. x, arg0. y, arg0. z ) ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof BigDecimal ) { loc0 = ( BigDecimal ) loc1 ; } else { loc0 = ( BigDecimal ) loc1 ; } } return loc0 ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ). equals ( BigDecimal. class ) ) { loc0 = ( BigDecimal ) arg0. get ( loc1 ) ; } } return loc0 ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof BigDecimal ) { loc0 = ( BigDecimal ) loc1 ; } else if ( loc1 instanceof BigDecimal ) { loc0 = ( BigDecimal ) loc1 ; } } return loc0 ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ). multiply ( BigDecimal. valueOf ( loc1 ) ) ; if ( loc0!= null ) { return loc0 ; } } return null ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0, loc2 = arg0. size ( ) ; loc1 < loc2 ; loc1 ++ ) { loc0 = arg0. get ( loc1 ). multiply ( loc0 ) ; if ( loc0 == null ) { break ; } } return loc0 ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; if ( loc0 == null ) { break ; } } return loc0 ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = new BigDecimal ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = new BigDecimal ( arg0. get ( loc1 ). toString ( ) ) ; } return loc0 ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ). multiply ( BigDecimal. valueOf ( loc1 ) ) ; } return loc0 ; }",
        "BigDecimal function ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; if ( loc0 == null ) { throw new ArithmeticException ( \"srini_string\" ) ; } } return loc0 ; }",
        "void function ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) arg0. data [ loc0 * arg0. dim2 + loc1 ] = arg0 [ loc0 * arg0. dim2 + loc1 ] ; }",
        "void function ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) arg0. matrix [ loc0 + loc2 ] [ loc3 ] = arg0. matrix [ loc1 ] [ loc3 ] ; } }",
        "void function ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) arg0. matrix [ loc0 + loc2 ] [ loc3 ] = arg0 [ loc1 ] [ loc3 ] ; } }",
        "void function ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) arg0 [ loc0 + loc2 ] [ loc3 ] = arg0. data [ loc1 ] [ loc3 ] ; } }",
        "void function ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) arg0. matrix [ loc0 + loc1 ] [ loc2 ] = arg0 [ loc3 ] ; } }"
      ],
      "mid_translation": [
        "This method operate on a vector.",
        "Operate on a vector.",
        "Operate on a vector of BigDecimal objects.",
        "Operate on a vector of BigDecimal values.",
        "This method operate on the matrix v."
      ],
      "output": [
        {
          "patch": "public Vector operate ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. addElement ( arg0. elementAt ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector operate ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. addElement ( arg0. elementAt ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector operate ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. addElement ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector operate ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. addElement ( arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector operate ( Vector arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { arg0. set ( loc0, arg0. get ( loc0 ) ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector operate ( Vector arg0 ) { Vector loc0 = new Vector ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. addElement ( arg0. elementAt ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector operate ( Vector arg0 ) { return arg0. sub ( new Vector ( 1, arg0. size ( ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector operate ( Vector arg0 ) { return new Vector ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector operate ( Vector arg0 ) { return new Vector ( arg0. size ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector operate ( Vector arg0 ) { return apply ( arg0. x, arg0. y, arg0. z ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof BigDecimal ) { loc0 = ( BigDecimal ) loc1 ; } else { loc0 = ( BigDecimal ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ). equals ( BigDecimal. class ) ) { loc0 = ( BigDecimal ) arg0. get ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof BigDecimal ) { loc0 = ( BigDecimal ) loc1 ; } else if ( loc1 instanceof BigDecimal ) { loc0 = ( BigDecimal ) loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ). multiply ( BigDecimal. valueOf ( loc1 ) ) ; if ( loc0!= null ) { return loc0 ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0, loc2 = arg0. size ( ) ; loc1 < loc2 ; loc1 ++ ) { loc0 = arg0. get ( loc1 ). multiply ( loc0 ) ; if ( loc0 == null ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; if ( loc0 == null ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = new BigDecimal ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = new BigDecimal ( arg0. get ( loc1 ). toString ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ). multiply ( BigDecimal. valueOf ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal operate ( Vector arg0 ) { BigDecimal loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; if ( loc0 == null ) { throw new ArithmeticException ( \"srini_string\" ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void operate ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) arg0. data [ loc0 * arg0. dim2 + loc1 ] = arg0 [ loc0 * arg0. dim2 + loc1 ] ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void operate ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) arg0. matrix [ loc0 + loc2 ] [ loc3 ] = arg0. matrix [ loc1 ] [ loc3 ] ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void operate ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) arg0. matrix [ loc0 + loc2 ] [ loc3 ] = arg0 [ loc1 ] [ loc3 ] ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void operate ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) arg0 [ loc0 + loc2 ] [ loc3 ] = arg0. data [ loc1 ] [ loc3 ] ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void operate ( Matrix arg0, int arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. dim2 ; loc0 ++ ) for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) arg0. matrix [ loc0 + loc1 ] [ loc2 ] = arg0 [ loc3 ] ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_86_/src/com/google/javascript/jscomp/NodeUtil.java_2465-2466": {
      "loc": "2465-2466",
      "input": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return true;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}",
      "target": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}",
      "function range": "2424,3-2489,3",
      "raw_output": [
        "boolean function ( Object arg0 ) { return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) { return false ; } return ( ( Boolean ) arg0 ). booleanValue ( ) ; }",
        "boolean function ( Object arg0 ) { return true ; }",
        "boolean function ( Object arg0 ) { if (! ( arg0 instanceof Local ) ) { return false ; } Local loc0 = ( Local ) arg0 ; return loc0 == null ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Number ) { Number loc0 = ( Number ) arg0 ; return ( loc0 == null || loc0. longValue ( ) == 0 ) ; } return false ; }",
        "boolean function ( Expression arg0 ) { return false ; }",
        "boolean function ( Expression arg0 ) { return true ; }",
        "boolean function ( FunctionCallExpression arg0 ) { return true ; }",
        "boolean function ( Expression arg0 ) { return arg0 instanceof Local ; }",
        "boolean function ( GroovyExpression arg0 ) { return true ; }",
        "boolean function ( Object arg0 ) { return ( arg0 instanceof Local ) ; }",
        "boolean function ( Object arg0 ) { return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Local ) { return ( ( Local ) arg0 ). isLocal ( ) ; } return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Local ) { return ( ( Local ) arg0 ). getLocal ( ) ; } return false ; }",
        "boolean function ( Object arg0 ) { return ( arg0 instanceof ConstantImpl ) ; }",
        "boolean function ( Node arg0 ) { return true ; }",
        "boolean function ( Node arg0 ) { return false ; }",
        "boolean function ( ASTNode arg0 ) { return true ; }",
        "boolean function ( Node arg0 ) { return arg0. getJSDocInfo ( )!= null && arg0. getJSDocInfo ( ). getType ( ) == Token. NAME || arg0. getJSDocInfo ( ). getType ( ) == Token. NAME ; }",
        "boolean function ( Node arg0 ) { return arg0. getJSDocInfo ( )!= null && arg0. getJSDocInfo ( ). getType ( ) == Token. NAME || arg0. getJSDocInfo ( ). getType ( ) == Token. NAME || arg0. isVariableType ( ) ; }",
        "boolean function ( Expression arg0 ) { return false ; }",
        "boolean function ( Expression arg0 ) { return ( arg0 instanceof Local ) ; }",
        "boolean function ( Expression arg0 ) { return arg0 instanceof Local ; }",
        "boolean function ( Expression arg0 ) { return arg0 instanceof LocalValueExpression ; }",
        "boolean function ( Expression arg0 ) { return true ; }"
      ],
      "mid_translation": [
        "Returns true if the given value evaluates to a local value.",
        "Returns true if the given expression evaluates to a local value.",
        "Checks if the given value evaluates to a local value.",
        "Returns true if the given node evaluates to a local value.",
        "Checks if the given expression evaluates to a local value."
      ],
      "output": [
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { if ( arg0 == null ) { return false ; } return ( ( Boolean ) arg0 ). booleanValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { if (! ( arg0 instanceof Local ) ) { return false ; } Local loc0 = ( Local ) arg0 ; return loc0 == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { if ( arg0 instanceof Number ) { Number loc0 = ( Number ) arg0 ; return ( loc0 == null || loc0. longValue ( ) == 0 ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Expression arg0 ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Expression arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( FunctionCallExpression arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Expression arg0 ) { return arg0 instanceof Local ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( GroovyExpression arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { return ( arg0 instanceof Local ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { if ( arg0 instanceof Local ) { return ( ( Local ) arg0 ). isLocal ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { if ( arg0 instanceof Local ) { return ( ( Local ) arg0 ). getLocal ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Object arg0 ) { return ( arg0 instanceof ConstantImpl ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Node arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Node arg0 ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( ASTNode arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Node arg0 ) { return arg0. getJSDocInfo ( )!= null && arg0. getJSDocInfo ( ). getType ( ) == Token. NAME || arg0. getJSDocInfo ( ). getType ( ) == Token. NAME ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Node arg0 ) { return arg0. getJSDocInfo ( )!= null && arg0. getJSDocInfo ( ). getType ( ) == Token. NAME || arg0. getJSDocInfo ( ). getType ( ) == Token. NAME || arg0. isVariableType ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Expression arg0 ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Expression arg0 ) { return ( arg0 instanceof Local ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Expression arg0 ) { return arg0 instanceof Local ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Expression arg0 ) { return arg0 instanceof LocalValueExpression ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean evaluatesToLocalValue ( Expression arg0 ) { return true ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_10_/src/java/org/apache/commons/codec/language/Caverphone.java_76-77": {
      "loc": "76-77",
      "input": "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"cq\", \"2q\");\n    txt = txt.replaceAll(\"ci\", \"si\");\n    txt = txt.replaceAll(\"ce\", \"se\");\n    txt = txt.replaceAll(\"cy\", \"sy\");\n    txt = txt.replaceAll(\"tch\", \"2ch\");\n    txt = txt.replaceAll(\"c\", \"k\");\n    txt = txt.replaceAll(\"q\", \"k\");\n    txt = txt.replaceAll(\"x\", \"k\");\n    txt = txt.replaceAll(\"v\", \"f\");\n    txt = txt.replaceAll(\"dg\", \"2g\");\n    txt = txt.replaceAll(\"tio\", \"sio\");\n    txt = txt.replaceAll(\"tia\", \"sia\");\n    txt = txt.replaceAll(\"d\", \"t\");\n    txt = txt.replaceAll(\"ph\", \"fh\");\n    txt = txt.replaceAll(\"b\", \"p\");\n    txt = txt.replaceAll(\"sh\", \"s2\");\n    txt = txt.replaceAll(\"z\", \"s\");\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\n    txt = txt.replaceAll(\"j\", \"y\");        \n    txt = txt.replaceAll(\"^y3\", \"Y3\");     \n    txt = txt.replaceAll(\"^y\", \"A\");       \n    txt = txt.replaceAll(\"y\", \"3\");        \n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n    txt = txt.replaceAll(\"gh\", \"22\");\n    txt = txt.replaceAll(\"g\", \"k\");\n    txt = txt.replaceAll(\"s+\", \"S\");\n    txt = txt.replaceAll(\"t+\", \"T\");\n    txt = txt.replaceAll(\"p+\", \"P\");\n    txt = txt.replaceAll(\"k+\", \"K\");\n    txt = txt.replaceAll(\"f+\", \"F\");\n    txt = txt.replaceAll(\"m+\", \"M\");\n    txt = txt.replaceAll(\"n+\", \"N\");\n    txt = txt.replaceAll(\"w3\", \"W3\");\n    txt = txt.replaceAll(\"wh3\", \"Wh3\");\n    txt = txt.replaceAll(\"w$\", \"3\");       \n    txt = txt.replaceAll(\"w\", \"2\");\n    txt = txt.replaceAll(\"^h\", \"A\");\n    txt = txt.replaceAll(\"h\", \"2\");\n    txt = txt.replaceAll(\"r3\", \"R3\");\n    txt = txt.replaceAll(\"r$\", \"3\");       \n    txt = txt.replaceAll(\"r\", \"2\");\n    txt = txt.replaceAll(\"l3\", \"L3\");\n    txt = txt.replaceAll(\"l$\", \"3\");       \n    txt = txt.replaceAll(\"l\", \"2\");\n    txt = txt.replaceAll(\"2\", \"\");\n    txt = txt.replaceAll(\"3$\", \"A\");       \n    txt = txt.replaceAll(\"3\", \"\");\n    txt = txt + \"111111\" + \"1111\";        \n    return txt.substring(0, 10);          \n}",
      "target": "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"mb$\", \"m2\");\n    txt = txt.replaceAll(\"cq\", \"2q\");\n    txt = txt.replaceAll(\"ci\", \"si\");\n    txt = txt.replaceAll(\"ce\", \"se\");\n    txt = txt.replaceAll(\"cy\", \"sy\");\n    txt = txt.replaceAll(\"tch\", \"2ch\");\n    txt = txt.replaceAll(\"c\", \"k\");\n    txt = txt.replaceAll(\"q\", \"k\");\n    txt = txt.replaceAll(\"x\", \"k\");\n    txt = txt.replaceAll(\"v\", \"f\");\n    txt = txt.replaceAll(\"dg\", \"2g\");\n    txt = txt.replaceAll(\"tio\", \"sio\");\n    txt = txt.replaceAll(\"tia\", \"sia\");\n    txt = txt.replaceAll(\"d\", \"t\");\n    txt = txt.replaceAll(\"ph\", \"fh\");\n    txt = txt.replaceAll(\"b\", \"p\");\n    txt = txt.replaceAll(\"sh\", \"s2\");\n    txt = txt.replaceAll(\"z\", \"s\");\n    txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n    txt = txt.replaceAll(\"[aeiou]\", \"3\");\n    txt = txt.replaceAll(\"j\", \"y\");        \n    txt = txt.replaceAll(\"^y3\", \"Y3\");     \n    txt = txt.replaceAll(\"^y\", \"A\");       \n    txt = txt.replaceAll(\"y\", \"3\");        \n    txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n    txt = txt.replaceAll(\"gh\", \"22\");\n    txt = txt.replaceAll(\"g\", \"k\");\n    txt = txt.replaceAll(\"s+\", \"S\");\n    txt = txt.replaceAll(\"t+\", \"T\");\n    txt = txt.replaceAll(\"p+\", \"P\");\n    txt = txt.replaceAll(\"k+\", \"K\");\n    txt = txt.replaceAll(\"f+\", \"F\");\n    txt = txt.replaceAll(\"m+\", \"M\");\n    txt = txt.replaceAll(\"n+\", \"N\");\n    txt = txt.replaceAll(\"w3\", \"W3\");\n    txt = txt.replaceAll(\"wh3\", \"Wh3\");\n    txt = txt.replaceAll(\"w$\", \"3\");       \n    txt = txt.replaceAll(\"w\", \"2\");\n    txt = txt.replaceAll(\"^h\", \"A\");\n    txt = txt.replaceAll(\"h\", \"2\");\n    txt = txt.replaceAll(\"r3\", \"R3\");\n    txt = txt.replaceAll(\"r$\", \"3\");       \n    txt = txt.replaceAll(\"r\", \"2\");\n    txt = txt.replaceAll(\"l3\", \"L3\");\n    txt = txt.replaceAll(\"l$\", \"3\");       \n    txt = txt.replaceAll(\"l\", \"2\");\n    txt = txt.replaceAll(\"2\", \"\");\n    txt = txt.replaceAll(\"3$\", \"A\");       \n    txt = txt.replaceAll(\"3\", \"\");\n    txt = txt + \"111111\" + \"1111\";        \n    return txt.substring(0, 10);          \n}",
      "function range": "50,5-142,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_36_/src/com/google/javascript/jscomp/InlineVariables.java_575-576": {
      "loc": "575-576",
      "input": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      || !isValidInitialization(initialization)\n      || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration != initialization &&\n      !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock() != initialization.getBasicBlock()\n      || declaration.getBasicBlock() != reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value != null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship != null) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) ||\n      canMoveModerately(initialization, reference);\n}",
      "target": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      || !isValidInitialization(initialization)\n      || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration != initialization &&\n      !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock() != initialization.getBasicBlock()\n      || declaration.getBasicBlock() != reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value != null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship != null) {\n        return false;\n      }\n      if (convention.getSingletonGetterClassName(callNode) != null) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) ||\n      canMoveModerately(initialization, reference);\n}",
      "function range": "519,5-580,5",
      "raw_output": [
        "boolean function ( PsiElement arg0, PsiElement arg1 ) { return true ; }",
        "boolean function ( @ NotNull PsiElement arg0 ) { return true ; }",
        "boolean function ( PsiElement arg0 ) { return true ; }",
        "boolean function ( PsiElement arg0, PsiElement arg1 ) { return false ; }",
        "boolean function ( @ NotNull PsiElement arg0 ) { return false ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( @ NotNull PsiElement arg0 ) { return true ; }",
        "boolean function ( VariableDeclaration arg0, VariableDeclaration arg1 ) { return true ; }",
        "boolean function ( @ NotNull PsiElement arg0 ) { return false ; }",
        "boolean function ( PsiElement arg0 ) { return true ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( PsiElement arg0 ) { return true ; }",
        "boolean function ( @ NotNull PsiElement arg0 ) { return true ; }",
        "boolean function ( RuleContext arg0 ) { return true ; }",
        "boolean function ( Variable arg0 ) { return true ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( @ NotNull PsiElement arg0, @ NotNull PsiElement arg1, @ NotNull PsiElement arg2 ) { return true ; }",
        "boolean function ( ) { return true ; }",
        "boolean function ( PsiElement arg0, PsiElement arg1 ) { if ( arg0 == null ) { return true ; } if ( arg1 == null ) { return true ; } return arg0. getParent ( ). getType ( ) == PsiElement. Type. INLINE_REF ; }",
        "boolean function ( @ NotNull PsiElement arg0, @ NotNull PsiElement arg1 ) { return true ; }",
        "boolean function ( VariableDeclaration arg0 ) { return arg0. getParent ( ) == null ; }",
        "boolean function ( VariableDeclaration arg0 ) { return arg0. isInline ( ) ; }",
        "boolean function ( VariableDeclaration arg0 ) { return arg0. getType ( ) == VariableDeclaration. Type. INLINE_REF ; }",
        "boolean function ( VariableDeclaration arg0 ) { return arg0. getType ( ) == Variable. INLINE_REF ; }",
        "boolean function ( VariableDeclaration arg0 ) { return arg0. isReferenced ( ) ; }"
      ],
      "mid_translation": [
        "Returns true if the declaration and initialization can be inline into the reference.",
        "Returns true if the declaration and initialization can be inline with the reference.",
        "Returns true if the declaration and initialization can be inline to the reference.",
        "Returns true if the declaration and initialization reference can be inline.",
        "Checks if the declaration and initialization have an inline reference."
      ],
      "output": [
        {
          "patch": "private boolean canInline ( PsiElement arg0, PsiElement arg1 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( @ NotNull PsiElement arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( PsiElement arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( PsiElement arg0, PsiElement arg1 ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( @ NotNull PsiElement arg0 ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( @ NotNull PsiElement arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( VariableDeclaration arg0, VariableDeclaration arg1 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( @ NotNull PsiElement arg0 ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( PsiElement arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( PsiElement arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( @ NotNull PsiElement arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( RuleContext arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( Variable arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( @ NotNull PsiElement arg0, @ NotNull PsiElement arg1, @ NotNull PsiElement arg2 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( PsiElement arg0, PsiElement arg1 ) { if ( arg0 == null ) { return true ; } if ( arg1 == null ) { return true ; } return arg0. getParent ( ). getType ( ) == PsiElement. Type. INLINE_REF ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( @ NotNull PsiElement arg0, @ NotNull PsiElement arg1 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( VariableDeclaration arg0 ) { return arg0. getParent ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( VariableDeclaration arg0 ) { return arg0. isInline ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( VariableDeclaration arg0 ) { return arg0. getType ( ) == VariableDeclaration. Type. INLINE_REF ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( VariableDeclaration arg0 ) { return arg0. getType ( ) == Variable. INLINE_REF ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean canInline ( VariableDeclaration arg0 ) { return arg0. isReferenced ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_71_/src/com/google/javascript/jscomp/CheckAccessControls.java_416-417": {
      "loc": "416-417",
      "input": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType != null) {\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n    if (objectType == null) {\n      return;\n    }\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}",
      "target": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType != null) {\n    boolean isOverride = parent.getJSDocInfo() != null &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n    if (isOverride) {\n      objectType = objectType.getImplicitPrototype();\n    }\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n    if (objectType == null) {\n      return;\n    }\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n    if (isOverride) {\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                objectType.toString()));\n      } else if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), objectType.toString(),\n                overridingVisibility.name()));\n      }\n    } else {\n      if (sameInput) {\n        return;\n      } else if (visibility == Visibility.PRIVATE &&\n          (currentClass == null || ownerType.differsFrom(currentClass))) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n        compiler.report(\n            t.makeError(getprop,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(\n                    getprop.getFirstChild(), true)));\n      } else if (visibility == Visibility.PROTECTED) {\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}",
      "function range": "407,3-500,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_11_/source/org/jfree/chart/util/ShapeUtilities.java_275-276": {
      "loc": "275-276",
      "input": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p1.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}",
      "target": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}",
      "function range": "264,5-296,5",
      "raw_output": [
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null || arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null || arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return ( new Path ( arg0 ) ). equals ( new Path ( arg1 ) ) ; }",
        "void function ( Path arg0, Path arg1 ) { Path loc0 = arg0. resolve ( \"srini_string\" ) ; Path loc1 = arg1. resolve ( \"srini_string\" ) ; assertTrue ( loc0. equals ( loc1 ) ) ; }",
        "void function ( Path arg0, Path arg1 ) { Path loc0 = arg0. resolve ( \"srini_string\" ) ; Path loc1 = arg1. resolve ( \"srini_string\" ) ; assertEquals ( loc0, loc1 ) ; }",
        "boolean function ( Path arg0, Path arg1 ) { if ( arg0. toString ( ). equals ( arg1. toString ( ) ) ) { return true ; } else { return false ; } }",
        "boolean function ( Path arg0, Path arg1 ) { return ( new Path ( arg0 ) ). equals ( new Path ( arg1 ) ) ; }",
        "boolean function ( Path arg0, Path arg1 ) { return ( arg0. toString ( ). equals ( arg1. toString ( ) ) ) ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return false ; } else { return arg0. equals ( arg1 ) ; } } else { return arg0. equals ( arg1 ) ; } }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. equals ( arg1 ) ) { return true ; } else if ( arg0. equals ( arg1 ) ) { return true ; } else { return false ; } }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return equals ( arg0. getGeneralPath ( ), arg1. getGeneralPath ( ) ) ; }",
        "boolean function ( GeneralPath arg0, GeneralPath arg1 ) { return equals ( new Path ( arg0 ), new Path ( arg1 ) ) ; }",
        "boolean function ( Path arg0, Path arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null || arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Path arg0, Path arg1 ) { return equals ( arg0. toString ( ), arg1. toString ( ) ) ; }"
      ],
      "mid_translation": [
        "Returns true if two general paths are equal.",
        "Checks if two general paths are equal.",
        "Test if two general paths are equal.",
        "Tests if two general paths are equal.",
        "Check if two general paths are equal."
      ],
      "output": [
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null || arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null || arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return ( new Path ( arg0 ) ). equals ( new Path ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void equal ( Path arg0, Path arg1 ) { Path loc0 = arg0. resolve ( \"srini_string\" ) ; Path loc1 = arg1. resolve ( \"srini_string\" ) ; assertTrue ( loc0. equals ( loc1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void equal ( Path arg0, Path arg1 ) { Path loc0 = arg0. resolve ( \"srini_string\" ) ; Path loc1 = arg1. resolve ( \"srini_string\" ) ; assertEquals ( loc0, loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equal ( Path arg0, Path arg1 ) { if ( arg0. toString ( ). equals ( arg1. toString ( ) ) ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equal ( Path arg0, Path arg1 ) { return ( new Path ( arg0 ) ). equals ( new Path ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equal ( Path arg0, Path arg1 ) { return ( arg0. toString ( ). equals ( arg1. toString ( ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equal ( String arg0, String arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return false ; } else { return arg0. equals ( arg1 ) ; } } else { return arg0. equals ( arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( String arg0, String arg1 ) { if ( arg0. equals ( arg1 ) ) { return true ; } else if ( arg0. equals ( arg1 ) ) { return true ; } else { return false ; } }",
          "correctness": "timeout"
        },
        {
          "patch": "public static boolean equal ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return equals ( arg0. getGeneralPath ( ), arg1. getGeneralPath ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equal ( GeneralPath arg0, GeneralPath arg1 ) { return equals ( new Path ( arg0 ), new Path ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equal ( Path arg0, Path arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null || arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equal ( String arg0, String arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equal ( Path arg0, Path arg1 ) { return equals ( arg0. toString ( ), arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_10_/src/com/google/javascript/jscomp/NodeUtil.java_1417-1418": {
      "loc": "1417-1418",
      "input": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n  } else {\n    return mayBeStringHelper(n);\n  }\n}",
      "target": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n    return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n  } else {\n    return mayBeStringHelper(n);\n  }\n}",
      "function range": "1415,3-1421,3",
      "raw_output": [
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING_NODE ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. STRING_NODE ; }",
        "boolean function ( Node arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( Node arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof StringNode ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( Node arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
        "boolean function ( Node arg0 ) { return \"srini_string\". equals ( arg0. getType ( ) ) ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. STRING_TYPE ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( ASTNode arg0 ) { return arg0 instanceof StringNode ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == TokenTypes. STRING ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. STRING_NODE ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
        "boolean function ( Node arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING_NODE ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }"
      ],
      "mid_translation": [
        "Returns true if the node may be a string.",
        "Checks if a node may be a string.",
        "Returns true if the node n may be a string.",
        "Returns true if the given node may be a string.",
        "Checks if the node may be a string."
      ],
      "output": [
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING_NODE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return arg0. getType ( ) == Token. STRING_NODE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return arg0 instanceof StringNode ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return \"srini_string\". equals ( arg0. getType ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return arg0. getType ( ) == Token. STRING_TYPE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return arg0 instanceof StringNode ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return arg0. getType ( ) == TokenTypes. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return arg0. getType ( ) == Token. STRING_NODE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( Node arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return arg0. getType ( ) == Token. STRING_NODE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static boolean mayBeString ( ASTNode arg0 ) { return ( arg0. getType ( ) == Token. STRING ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_113_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_329-330": {
      "loc": "329-330",
      "input": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n    if (provided != null) {\n      parent.detachFromParent();\n      compiler.reportCodeChange();\n    }\n  }\n}",
      "target": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n    if (provided != null || requiresLevel.isOn()) {\n      parent.detachFromParent();\n      compiler.reportCodeChange();\n    }\n  }\n}",
      "function range": "295,3-334,3",
      "raw_output": [
        "R function ( A arg0, Map < String, Object > arg1 ) { R loc0 = null ; for ( Map. Entry < String, Object > loc1 : arg1. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; if ( loc2. startsWith ( \"srini_string\" ) ) loc0 = loc2. getValue ( ) ; } return loc0 ; }",
        "void function ( A arg0 ) { System. out. println ( \"srini_string\" + arg0. getModule ( ). getName ( ) + \"srini_string\" ) ; }",
        "void function ( A arg0 ) { System. out. println ( \"srini_string\" + arg0. toString ( ) + \"srini_string\" ) ; }",
        "R function ( A arg0, Map < String, Object > arg1 ) { R loc0 = arg1. get ( arg0. getName ( ) ) ; return loc0 ; }",
        "void function ( A arg0 ) { System. out. println ( \"srini_string\" + arg0. toString ( ) ) ; }",
        "void function ( A arg0, Map < String, Object > arg1 ) { }",
        "void function ( A arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( RequireCall arg0, Map < String, Object > arg1 ) { }",
        "void function ( Context arg0, A arg1, Map < String, Object > arg2 ) { }",
        "void function ( Context arg0, A arg1, RequireCall arg2 ) { }",
        "RequireCall function ( RequireCall arg0 ) { return arg0 ; }",
        "RequireCall function ( Context arg0, RequireCall arg1 ) { return arg1 ; }",
        "RequireCall function ( RequireCall arg0, Map < String, Object > arg1 ) { return arg0 ; }",
        "void function ( RequireCall arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "RequireCall function ( Map arg0, RequireCall arg1 ) { return arg1 ; }",
        "void function ( RequireCallNode arg0 ) { }",
        "void function ( RequireCall arg0 ) { }",
        "void function ( RequireCallNode arg0 ) { System. out. println ( \"srini_string\" ) ; System. out. println ( \"srini_string\" ) ; }",
        "void function ( RequireCallNode arg0 ) { System. out. println ( \"srini_string\" + arg0. getName ( ) + \"srini_string\" ) ; }",
        "void function ( RequireCallNode arg0 ) { System. out. println ( \"srini_string\" + arg0. getModule ( ). getName ( ) ) ; }",
        "R function ( R arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }",
        "void function ( REQUIRE arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }",
        "R function ( R arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0. toString ( ) ) ; }",
        "void function ( REQUIRE arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0. getMessage ( ) ) ; }",
        "void function ( REQUIRE arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0. toString ( ) ) ; }"
      ],
      "mid_translation": [
        "Process a require call.",
        "Processes a require call.",
        "Process a Require call.",
        "Process a require call node.",
        "Process a REQUIRE call."
      ],
      "output": [
        {
          "patch": "private R processRequireCall ( A arg0, Map < String, Object > arg1 ) { R loc0 = null ; for ( Map. Entry < String, Object > loc1 : arg1. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; if ( loc2. startsWith ( \"srini_string\" ) ) loc0 = loc2. getValue ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( A arg0 ) { System. out. println ( \"srini_string\" + arg0. getModule ( ). getName ( ) + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( A arg0 ) { System. out. println ( \"srini_string\" + arg0. toString ( ) + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R processRequireCall ( A arg0, Map < String, Object > arg1 ) { R loc0 = arg1. get ( arg0. getName ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( A arg0 ) { System. out. println ( \"srini_string\" + arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( A arg0, Map < String, Object > arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( A arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( RequireCall arg0, Map < String, Object > arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( Context arg0, A arg1, Map < String, Object > arg2 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( Context arg0, A arg1, RequireCall arg2 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private RequireCall processRequireCall ( RequireCall arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private RequireCall processRequireCall ( Context arg0, RequireCall arg1 ) { return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private RequireCall processRequireCall ( RequireCall arg0, Map < String, Object > arg1 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( RequireCall arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private RequireCall processRequireCall ( Map arg0, RequireCall arg1 ) { return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( RequireCallNode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( RequireCall arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( RequireCallNode arg0 ) { System. out. println ( \"srini_string\" ) ; System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( RequireCallNode arg0 ) { System. out. println ( \"srini_string\" + arg0. getName ( ) + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( RequireCallNode arg0 ) { System. out. println ( \"srini_string\" + arg0. getModule ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R processRequireCall ( R arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( REQUIRE arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R processRequireCall ( R arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( REQUIRE arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void processRequireCall ( REQUIRE arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_150_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1451-1452": {
      "loc": "1451-1452",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n}",
      "target": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n  super.visit(t, n, parent);\n}",
      "function range": "1443,5-1466,5",
      "raw_output": [
        "void function ( CID arg0, P arg1 ) { arg0. accept ( this, arg1 ) ; }",
        "void function ( ID arg0, P arg1 ) { arg0. accept ( this, arg1 ) ; }",
        "void function ( CID arg0, A arg1 ) { arg0. accept ( this, arg1 ) ; }",
        "void function ( CID arg0 ) { arg0. accept ( this ) ; }",
        "void function ( ID arg0 ) { arg0. accept ( this ) ; }",
        "void function ( Visitor arg0 ) { visit ( arg0 ) ; }",
        "void function ( Element arg0, VisitorContext arg1 ) { visit ( arg0, arg1 ) ; }",
        "void function ( Visitor arg0 ) { arg0. visit ( this ) ; }",
        "void function ( Element arg0, VisitorContext arg1 ) { arg1. visit ( this ) ; }",
        "void function ( VisitorContext arg0 ) { visit ( arg0 ) ; }",
        "void function ( PsiBuilder arg0 ) { }",
        "void function ( Node arg0 ) { }",
        "void function ( LiteralTypeVisitor arg0 ) { }",
        "void function ( TypeVisitor arg0 ) { }",
        "void function ( JCTree arg0 ) { }",
        "void function ( Node arg0 ) { }",
        "void function ( PsiBuilder arg0 ) { }",
        "void function ( PsiBuilder arg0, Node arg1 ) { }",
        "void function ( LiteralTypeVisitor arg0 ) { }",
        "void function ( int arg0, Node arg1 ) { }",
        "void function ( Node arg0 ) { }",
        "void function ( LiteralType arg0, Node arg1 ) { }",
        "void function ( PsiBuilder arg0 ) { }",
        "void function ( PsiBuilder arg0, Node arg1 ) { }",
        "void function ( PsiNode arg0 ) { }"
      ],
      "mid_translation": [
        "Visit a CID node.",
        "Override the default implementation of the visit method.",
        "Override the visitor to attach literal types to the node.",
        "Override the visitor to attach literal types to the node if necessary.",
        "implement the visitor to attach literal types to the node."
      ],
      "output": [
        {
          "patch": "@Override public void visit ( CID arg0, P arg1 ) { arg0. accept ( this, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( ID arg0, P arg1 ) { arg0. accept ( this, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( CID arg0, A arg1 ) { arg0. accept ( this, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( CID arg0 ) { arg0. accept ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( ID arg0 ) { arg0. accept ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( Visitor arg0 ) { visit ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( Element arg0, VisitorContext arg1 ) { visit ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( Visitor arg0 ) { arg0. visit ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( Element arg0, VisitorContext arg1 ) { arg1. visit ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( VisitorContext arg0 ) { visit ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( PsiBuilder arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( Node arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( LiteralTypeVisitor arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( TypeVisitor arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( JCTree arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( Node arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( PsiBuilder arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( PsiBuilder arg0, Node arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( LiteralTypeVisitor arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( int arg0, Node arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( Node arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( LiteralType arg0, Node arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( PsiBuilder arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( PsiBuilder arg0, Node arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public void visit ( PsiNode arg0 ) { }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_4_/src/java/org/apache/commons/codec/binary/Base64.java_225-226": {
      "loc": "225-226",
      "input": "public Base64() {\n    this(false);\n}",
      "target": "public Base64() {\n    this(0);\n}",
      "function range": "224,5-226,5",
      "raw_output": [
        "String function ( ) { return Base64. getEncoder ( ). encodeToString ( this ) ; }",
        "String function ( ) { byte [ ] loc0 = Base64. encodeBase64 ( this. toString ( ) ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
        "String function ( ) { byte [ ] loc0 = Base64. getEncoder ( ). encodeToString ( this ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
        "String function ( ) { byte [ ] loc0 = Base64. encodeBase64 ( this. toString ( ) ) ; return Base64. toBase64 ( loc0 ) ; }",
        "String function ( ) { byte [ ] loc0 = Base64. encodeBase64 ( this. getClass ( ). getName ( ). getBytes ( ) ) ; return Base64. encode ( loc0 ) ; }",
        "String function ( ) { return Base64. getEncoder ( ). encodeToString ( this ) ; }",
        "String function ( ) { return Base64. getEncoder ( ). encode ( this ) ; }",
        "String function ( ) { return Base64. getEncoder ( ). encode ( this. toString ( ) ) ; }",
        "String function ( ) { return Base64. getEncoder ( ). encodeToString ( this, true ) ; }",
        "String function ( ) { return Base64. getEncoder ( ). encode ( toString ( ) ) ; }",
        "String function ( String arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
        "String function ( String arg0 ) { byte [ ] loc0 = arg0. getBytes ( ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
        "String function ( String arg0 ) { try { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( String arg0 ) { byte [ ] loc0 = arg0. getBytes ( ) ; return Base64. getEncoder ( ). encode ( loc0 ) ; }",
        "String function ( String arg0 ) { return Base64. getEncoder ( ). encode ( arg0. getBytes ( ) ) ; }",
        "String function ( ) { return Base64. getEncoder ( ). encodeToString ( ) ; }",
        "String function ( ) { String loc0 = \"srini_string\" ; byte [ ] loc1 = Base64. encode ( loc0. getBytes ( ) ) ; return Base64. getEncoder ( ). encodeToString ( loc1 ) ; }",
        "String function ( ) { String loc0 = \"srini_string\" ; byte [ ] loc1 = Base64. getEncoder ( ). encode ( loc0 ) ; String loc2 = Base64. getEncoder ( ). encode ( loc1 ) ; return loc2 ; }",
        "String function ( ) { byte [ ] loc0 = Base64. getEncoder ( ). encodeToString ( ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
        "String function ( ) { try { return Base64. getEncoder ( ). encodeToString ( new ByteArrayInputStream ( \"srini_string\". getBytes ( ) ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( ) { return Base64. getEncoder ( ). encodeToString ( this ) ; }",
        "String function ( ) { byte [ ] loc0 = Base64. encodeBase64 ( this. getClass ( ). getName ( ). getBytes ( ) ) ; byte [ ] loc1 = Base64. decodeBase64 ( loc0 ) ; return \"srini_string\" + loc1 [ 0 ] + \"srini_string\" + loc1 [ 1 ] ; }",
        "String function ( ) { byte [ ] loc0 = Base64. encodeBase64 ( ) ; String loc1 = \"srini_string\" ; for ( int loc2 = 0 ; loc2 < loc0. length ; loc2 ++ ) { loc1 += loc0 [ loc2 ] ; } return loc1 ; }",
        "String function ( ) { byte [ ] loc0 = Base64. encode ( this. getClass ( ). getName ( ). getBytes ( ) ) ; String loc1 = Base64. encode ( loc0 ) ; return \"srini_string\" + loc1 ; }",
        "String function ( ) { byte [ ] loc0 = Base64. getEncoder ( ). encodeToString ( this ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }"
      ],
      "mid_translation": [
        "The base64 version of this method.",
        "Returns the base64 version of this object.",
        "This method is used to encode a base64 string.",
        "This method is used to generate a base64 encoded string.",
        "This is the base64 version of this class."
      ],
      "output": [
        {
          "patch": "public String Base64 ( ) { return Base64. getEncoder ( ). encodeToString ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { byte [ ] loc0 = Base64. encodeBase64 ( this. toString ( ) ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { byte [ ] loc0 = Base64. getEncoder ( ). encodeToString ( this ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { byte [ ] loc0 = Base64. encodeBase64 ( this. toString ( ) ) ; return Base64. toBase64 ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { byte [ ] loc0 = Base64. encodeBase64 ( this. getClass ( ). getName ( ). getBytes ( ) ) ; return Base64. encode ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { return Base64. getEncoder ( ). encodeToString ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { return Base64. getEncoder ( ). encode ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { return Base64. getEncoder ( ). encode ( this. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { return Base64. getEncoder ( ). encodeToString ( this, true ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { return Base64. getEncoder ( ). encode ( toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( String arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( String arg0 ) { byte [ ] loc0 = arg0. getBytes ( ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( String arg0 ) { try { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( String arg0 ) { byte [ ] loc0 = arg0. getBytes ( ) ; return Base64. getEncoder ( ). encode ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( String arg0 ) { return Base64. getEncoder ( ). encode ( arg0. getBytes ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { return Base64. getEncoder ( ). encodeToString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { String loc0 = \"srini_string\" ; byte [ ] loc1 = Base64. encode ( loc0. getBytes ( ) ) ; return Base64. getEncoder ( ). encodeToString ( loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { String loc0 = \"srini_string\" ; byte [ ] loc1 = Base64. getEncoder ( ). encode ( loc0 ) ; String loc2 = Base64. getEncoder ( ). encode ( loc1 ) ; return loc2 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { byte [ ] loc0 = Base64. getEncoder ( ). encodeToString ( ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { try { return Base64. getEncoder ( ). encodeToString ( new ByteArrayInputStream ( \"srini_string\". getBytes ( ) ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { return Base64. getEncoder ( ). encodeToString ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { byte [ ] loc0 = Base64. encodeBase64 ( this. getClass ( ). getName ( ). getBytes ( ) ) ; byte [ ] loc1 = Base64. decodeBase64 ( loc0 ) ; return \"srini_string\" + loc1 [ 0 ] + \"srini_string\" + loc1 [ 1 ] ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { byte [ ] loc0 = Base64. encodeBase64 ( ) ; String loc1 = \"srini_string\" ; for ( int loc2 = 0 ; loc2 < loc0. length ; loc2 ++ ) { loc1 += loc0 [ loc2 ] ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { byte [ ] loc0 = Base64. encode ( this. getClass ( ). getName ( ). getBytes ( ) ) ; String loc1 = Base64. encode ( loc0 ) ; return \"srini_string\" + loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String Base64 ( ) { byte [ ] loc0 = Base64. getEncoder ( ). encodeToString ( this ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_19_src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java_169-172": {
      "loc": "169-172",
      "input": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n  switch (node.getType()) {\n    case Token.NAME:\n      scope.inferSlotType(node.getString(), type);\n      break;\n    case Token.GETPROP:\n      String qualifiedName = node.getQualifiedName();\n      Preconditions.checkNotNull(qualifiedName);\n      JSType origType = node.getJSType();\n      origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n      scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n      break;\n    default:\n      throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n          node.toStringTree());\n  }\n}",
      "target": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n  switch (node.getType()) {\n    case Token.NAME:\n      scope.inferSlotType(node.getString(), type);\n      break;\n    case Token.GETPROP:\n      String qualifiedName = node.getQualifiedName();\n      Preconditions.checkNotNull(qualifiedName);\n      JSType origType = node.getJSType();\n      origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n      scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n      break;\n    case Token.THIS:\n      break;\n    default:\n      throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n          node.toStringTree());\n  }\n}",
      "function range": "157,3-178,3",
      "raw_output": [
        "void function ( Name arg0 ) { System. out. println ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
        "void function ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( \"srini_string\", arg0 ) ; }",
        "void function ( Name arg0 ) { System. out. println ( \"srini_string\" + arg0 ) ; }",
        "void function ( Name arg0, ScopedMap arg1 ) { arg1. declareVariable ( arg0, arg0. getClassifierID ( ) ) ; }",
        "void function ( NameContext arg0, Class <? > arg1 ) { arg0. declareVariable ( arg1. getName ( ) ) ; }",
        "void function ( String arg0, FlowScope arg1 ) { arg1. declareNameForFlowScope ( arg0 ) ; }",
        "void function ( String arg0, FlowScope arg1 ) { arg1. declareName ( arg0 ) ; }",
        "String function ( String arg0, FlowScope arg1 ) { return \"srini_string\" + arg0 + \"srini_string\" + arg1. toString ( ) ; }",
        "String function ( String arg0, FlowScope arg1 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( String arg0, FlowScope arg1 ) { return \"srini_string\" = \"srini_string\" ; }",
        "void function ( final NameScope arg0, final Class <? > arg1, final String arg2 ) { declare ( arg0, arg1, arg2, null ) ; }",
        "void function ( final Class <? > arg0, final NameScope arg1 ) { declare ( arg0, arg1, null ) ; }",
        "void function ( final NameScope arg0, final Class <? > arg1, final String arg2 ) { arg0. declareNameInScope ( arg1, arg2 ) ; }",
        "void function ( final NameScope arg0, final Class <? > arg1 ) { arg0. declareNameInScope ( arg1 ) ; }",
        "void function ( NameScope arg0, PsiElement arg1 ) { arg0. declareName ( arg1. getName ( ), arg1. getScopeInstance ( ) ) ; }",
        "void function ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( \"srini_string\", arg0 ) ; }",
        "void function ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( \"srini_string\", new NameValuePair ( arg0 ) ) ; }",
        "void function ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( arg0, new NameScope ( arg0 ) ) ; }",
        "void function ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( arg0, new NameBinding ( arg0 ) ) ; }",
        "void function ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( arg0, new ScopeDeclareScope ( arg0 ) ) ; }",
        "void function ( FlowScope arg0, String arg1 ) { arg0. declareName ( arg1 ) ; }",
        "void function ( FlowScope arg0, String arg1 ) { arg0. declareNameForFlowScope ( arg1 ) ; }",
        "void function ( FlowScope arg0, Name arg1 ) { arg0. declareNameForFlowScope ( arg1 ) ; }",
        "void function ( final FlowScope arg0, final String arg1 ) { arg0. declareNameForFlowScope ( arg1 ) ; }",
        "void function ( final FlowScope arg0, final String arg1 ) { arg0. declareName ( arg1 ) ; }"
      ],
      "mid_translation": [
        "Declare name in scope.",
        "Declare a name in a flow scope.",
        "Declare a name in the given scope.",
        "Declare a name in the scope.",
        "Declare a name in the given flow scope."
      ],
      "output": [
        {
          "patch": "protected void declareNameInScope ( Name arg0 ) { System. out. println ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( \"srini_string\", arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( Name arg0 ) { System. out. println ( \"srini_string\" + arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( Name arg0, ScopedMap arg1 ) { arg1. declareVariable ( arg0, arg0. getClassifierID ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( NameContext arg0, Class <? > arg1 ) { arg0. declareVariable ( arg1. getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( String arg0, FlowScope arg1 ) { arg1. declareNameForFlowScope ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( String arg0, FlowScope arg1 ) { arg1. declareName ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String declareNameInScope ( String arg0, FlowScope arg1 ) { return \"srini_string\" + arg0 + \"srini_string\" + arg1. toString ( ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "protected String declareNameInScope ( String arg0, FlowScope arg1 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "timeout"
        },
        {
          "patch": "protected String declareNameInScope ( String arg0, FlowScope arg1 ) { return \"srini_string\" = \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( final NameScope arg0, final Class <? > arg1, final String arg2 ) { declare ( arg0, arg1, arg2, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( final Class <? > arg0, final NameScope arg1 ) { declare ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( final NameScope arg0, final Class <? > arg1, final String arg2 ) { arg0. declareNameInScope ( arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( final NameScope arg0, final Class <? > arg1 ) { arg0. declareNameInScope ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( NameScope arg0, PsiElement arg1 ) { arg0. declareName ( arg1. getName ( ), arg1. getScopeInstance ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( \"srini_string\", arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( \"srini_string\", new NameValuePair ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( arg0, new NameScope ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( arg0, new NameBinding ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( String arg0, Map < String, Scope > arg1 ) { arg1. put ( arg0, new ScopeDeclareScope ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( FlowScope arg0, String arg1 ) { arg0. declareName ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( FlowScope arg0, String arg1 ) { arg0. declareNameForFlowScope ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( FlowScope arg0, Name arg1 ) { arg0. declareNameForFlowScope ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( final FlowScope arg0, final String arg1 ) { arg0. declareNameForFlowScope ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void declareNameInScope ( final FlowScope arg0, final String arg1 ) { arg0. declareName ( arg1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_62_/src/com/google/javascript/jscomp/LightweightMessageFormatter.java_98-99": {
      "loc": "98-99",
      "input": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno && charno < sourceExcerpt.length()) {\n      for (int i = 0; i < charno; i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (Character.isWhitespace(c)) {\n          b.append(c);\n        } else {\n          b.append(' ');\n        }\n      }\n      b.append(\"^\\n\");\n    }\n  }\n  return b.toString();\n}",
      "target": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n        && 0 <= charno && charno <= sourceExcerpt.length()) {\n      for (int i = 0; i < charno; i++) {\n        char c = sourceExcerpt.charAt(i);\n        if (Character.isWhitespace(c)) {\n          b.append(c);\n        } else {\n          b.append(' ');\n        }\n      }\n      b.append(\"^\\n\");\n    }\n  }\n  return b.toString();\n}",
      "function range": "66,3-111,3",
      "raw_output": [
        "String function ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( new PrintWriter ( loc0 ) ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
        "String function ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? null : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
        "String function ( JSError arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { return String. arg0 ( arg0 ) ; }",
        "String function ( JSError arg0 ) { return \"srini_string\" + arg0. getMessage ( ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. arg0 ( arg0. getMessage ( ) ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? \"srini_string\" : MessageFormat. arg0 ( arg0. getMessage ( ) ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? \"srini_string\" : arg0. getMessage ( ) ; }",
        "String function ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( new PrintWriter ( loc0 ) ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { return arg0. getMessage ( ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
        "String function ( JSError arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? null : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
        "String function ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( new PrintWriter ( loc0 ) ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( new PrintWriter ( loc0 ) ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
        "String function ( JSError arg0 ) { return arg0 == null? null : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
        "String function ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
        "String function ( JSError arg0 ) { return arg0. getMessage ( ) ; }"
      ],
      "mid_translation": [
        "Format a JSError into a string.",
        "Format a JSError.",
        "Formats a JSError into a string.",
        "Format a JSError into a String.",
        "Formats a JSError into a String."
      ],
      "output": [
        {
          "patch": "private String format ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( new PrintWriter ( loc0 ) ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? null : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return String. arg0 ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return \"srini_string\" + arg0. getMessage ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. arg0 ( arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? \"srini_string\" : MessageFormat. arg0 ( arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? \"srini_string\" : arg0. getMessage ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( new PrintWriter ( loc0 ) ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0. getMessage ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? null : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( new PrintWriter ( loc0 ) ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( new PrintWriter ( loc0 ) ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0 == null? null : String. format ( \"srini_string\", arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { StringWriter loc0 = new StringWriter ( ) ; arg0. printStackTrace ( loc0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String format ( JSError arg0 ) { return arg0. getMessage ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Collections_26_/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java_277-278": {
      "loc": "277-278",
      "input": "\nprivate Object readResolve() {\n    calculateHashCode(keys);\n    return this;\n}",
      "target": "\nprotected Object readResolve() {\n    calculateHashCode(keys);\n    return this;\n}",
      "function range": "277,5-280,5",
      "raw_output": [
        "long function ( ) { return HashCodeFactory. hash ( this. getClass ( ). hashCode ( ) ) ; }",
        "long function ( ) { return HashCode. fromBytes ( this. getClass ( ). hashCode ( ) ) ; }",
        "int function ( ) { return HashCode. fromBytes ( this. getClass ( ). hashCode ( ) ) ; }",
        "long function ( ) { return HashCodeFactory. getHashCode ( this ) ; }",
        "long function ( ) { return HashCodeFactory. getHashCode ( ) ; }",
        "int function ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
        "int function ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0 == null? 0 : arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
        "long function ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0 == null? 0 : arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
        "long function ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
        "long function ( Map < K, V > arg0 ) { return arg0 == null? 0 : arg0. hashCode ( ) ; }",
        "int function ( ) { return HashCode. fromBytes ( System. currentTimeMillis ( ) ). hashCode ( ) ; }",
        "int function ( Map < K, V > arg0 ) { return arg0 == null? 0 : arg0. hashCode ( ) ; }",
        "int function ( ) { return Arrays. hashCode ( keys ( ) ) ; }",
        "int function ( Map < K, V > arg0 ) { return arg0. hashCode ( ) ; }",
        "int function ( ) { return Arrays. hashCode ( this. keys ) ; }",
        "long function ( ) { return hashCode ( ) ; }",
        "int function ( ) { return hashCode ( ) ; }",
        "int function ( ) { return this. hashCode ( ) ; }",
        "Object function ( ) { return hashCode ( ) ; }",
        "long function ( ) { return this. hashCode ( ) ; }",
        "long function ( Map < K, V > arg0 ) { return arg0 == null? 0 : arg0. hashCode ( ) ; }",
        "long function ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0 == null? 0 : arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
        "long function ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
        "int function ( Map < K, V > arg0 ) { return HashCode. fromBytes ( arg0. get ( this. getClass ( ). getName ( ) ). hashCode ( ) ) ; }",
        "long function ( Map < K, V > arg0 ) { return HashCode. fromBytes ( arg0. get ( this. getClass ( ). getName ( ) ). hashCode ( ) ) ; }"
      ],
      "mid_translation": [
        "This method is called by the readResolve method. It calculates the hash code of this object and returns it.",
        "This method is called by the readResolve method. It calculates the hash code of the keys and returns it.",
        "This method is called by the readResolve method. It calculates the hashcode of the keys and returns the result.",
        "This method is called by the readResolve method. It calculates the hashCode of this object and returns it.",
        "This method is called by the readResolve method. It calculates the hash code of the keys and returns this."
      ],
      "output": [
        {
          "patch": "private long readResolve ( ) { return HashCodeFactory. hash ( this. getClass ( ). hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private long readResolve ( ) { return HashCode. fromBytes ( this. getClass ( ). hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int readResolve ( ) { return HashCode. fromBytes ( this. getClass ( ). hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private long readResolve ( ) { return HashCodeFactory. getHashCode ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private long readResolve ( ) { return HashCodeFactory. getHashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int readResolve ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int readResolve ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0 == null? 0 : arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private long readResolve ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0 == null? 0 : arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private long readResolve ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private long readResolve ( Map < K, V > arg0 ) { return arg0 == null? 0 : arg0. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int readResolve ( ) { return HashCode. fromBytes ( System. currentTimeMillis ( ) ). hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int readResolve ( Map < K, V > arg0 ) { return arg0 == null? 0 : arg0. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int readResolve ( ) { return Arrays. hashCode ( keys ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int readResolve ( Map < K, V > arg0 ) { return arg0. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int readResolve ( ) { return Arrays. hashCode ( this. keys ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private long readResolve ( ) { return hashCode ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private int readResolve ( ) { return hashCode ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private int readResolve ( ) { return this. hashCode ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private Object readResolve ( ) { return hashCode ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private long readResolve ( ) { return this. hashCode ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private long readResolve ( Map < K, V > arg0 ) { return arg0 == null? 0 : arg0. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private long readResolve ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0 == null? 0 : arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private long readResolve ( Map < K, V > arg0, Map < K, V > arg1 ) { return arg0. hashCode ( ) ^ arg1. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int readResolve ( Map < K, V > arg0 ) { return HashCode. fromBytes ( arg0. get ( this. getClass ( ). getName ( ) ). hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private long readResolve ( Map < K, V > arg0 ) { return HashCode. fromBytes ( arg0. get ( this. getClass ( ). getName ( ) ). hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_92_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_789-790": {
      "loc": "789-790",
      "input": "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      int indexOfDot = namespace.indexOf('.');\n      if (indexOfDot == -1) {\n        compiler.getNodeForCodeInsertion(minimumModule)\n            .addChildToBack(replacementNode);\n      } else {\n        ProvidedName parentName =\n            providedNames.get(namespace.substring(0, indexOfDot));\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        parentName.replacementNode.getParent().addChildAfter(\n            replacementNode, parentName.replacementNode);\n      }\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}",
      "target": "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      int indexOfDot = namespace.lastIndexOf('.');\n      if (indexOfDot == -1) {\n        compiler.getNodeForCodeInsertion(minimumModule)\n            .addChildToBack(replacementNode);\n      } else {\n        ProvidedName parentName =\n            providedNames.get(namespace.substring(0, indexOfDot));\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        parentName.replacementNode.getParent().addChildAfter(\n            replacementNode, parentName.replacementNode);\n      }\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}",
      "function range": "747,5-809,5",
      "raw_output": [
        "AbstractCandidate function ( AbstractCandidate arg0 ) { return arg0 ; }",
        "IPosOnlyCandidate function ( IPosOnlyCandidate arg0 ) { return arg0 ; }",
        "Candidate function ( RuleContext arg0 ) { return new RuleContext ( arg0 ) ; }",
        "Candidate function ( MatchedCandidate arg0 ) { return arg0 ; }",
        "Candidate function ( RuleContext arg0, T arg1 ) { return new RuleContext ( arg0, arg1 ) ; }",
        "Node function ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg0 = replaceNode ( loc0, arg1 ) ; return loc0 ; }",
        "Node function ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg1. replaceNode ( loc0, arg1 ) ; return loc0 ; }",
        "Node function ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg1. replaceNode ( loc0, null ) ; return loc0 ; }",
        "Node function ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg1. replaceNode ( loc0, arg0 ) ; return loc0 ; }",
        "Node function ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg1. replaceNode ( loc0 ) ; return loc0 ; }",
        "AbstractDeclaration function ( AbstractDeclaration arg0 ) { return arg0 ; }",
        "AbstractDeclaration function ( AbstractDeclaration arg0, Definition arg1 ) { return arg0 ; }",
        "AbstractDeclaration function ( AbstractDeclaration arg0, AbstractDeclaration arg1 ) { return arg0 ; }",
        "void function ( PsiElement arg0, PsiElement arg1 ) { PsiElement loc0 = arg0. loc0 ( ) ; PsiElement loc1 = arg1. loc1 ( ) ; PsiElement loc2 = arg1. loc2 ( ) ; PsiElement loc3 = ( PsiElement ) loc0. getParent ( ) ; loc3. replaceParent ( loc2 ) ; arg0. setLeft ( loc1 ) ; arg0. setRight ( loc3 ) ; }",
        "void function ( PsiElement arg0, PsiElement arg1 ) { PsiElement loc0 = arg0. loc0 ( ) ; PsiElement loc1 = arg1. loc1 ( ) ; PsiElement loc2 = arg1. loc2 ( ) ; PsiElement loc3 = ( PsiElement ) loc0. getParent ( ) ; loc3. replaceParent ( loc2 ) ; arg0. setLeft ( loc1 ) ; arg1. setRight ( loc3 ) ; }",
        "AbstractDeclaration function ( AbstractDeclaration arg0 ) { return arg0 ; }",
        "void function ( DeclarationNode arg0, DefinitionNode arg1 ) { arg0. replaceParent ( arg1 ) ; }",
        "AbstractDeclaration function ( AbstractDeclaration arg0, Node arg1 ) { return arg0 ; }",
        "AbstractDeclaration function ( AbstractDeclaration arg0, Node arg1 ) { return replaceDeclarationNode ( arg0, arg1, null ) ; }",
        "AbstractDeclaration function ( AbstractDeclaration arg0, Definition arg1 ) { return arg0 ; }",
        "Node function ( PsiElement arg0 ) { PsiElement loc0 = arg0. getParentNode ( ) ; if ( loc0 instanceof PsiElement ) { PsiElement loc1 = ( PsiElement ) loc0 ; PsiElement loc2 = ( PsiElement ) loc1 ; return replaceNode ( loc0, loc2 ) ; } else { return null ; } }",
        "Node function ( PsiElement arg0 ) { PsiElement loc0 = arg0. getParentNode ( ) ; if ( loc0 instanceof PsiElement ) { PsiElement loc1 = ( PsiElement ) loc0 ; PsiElement loc2 = ( PsiElement ) loc1 ; return replaceNode ( loc2, loc0 ) ; } else { return null ; } }",
        "Node function ( PsiElement arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; Node loc1 = ( PsiElement ) loc0. getParent ( ) ; return replaceNode ( loc1, arg0 ) ; }",
        "Node function ( PsiElement arg0, PsiElement arg1 ) { PsiElement loc0 = arg0. getParent ( ) ; Node loc1 = ( PsiElement ) loc0. getParent ( ) ; return replaceNode ( loc1, arg1 ) ; }",
        "Node function ( PsiElement arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; Node loc1 = ( PsiElement ) loc0. getParent ( ) ; return replaceNode ( loc1, loc0 ) ; }"
      ],
      "mid_translation": [
        "Replaces the candidate definition with the explicit definition.",
        "Replaces the declaration node with a replacement node.",
        "Replaces the declaration with the candidate definition.",
        "Replaces the declaration node with the candidate definition.",
        "Replaces the candidate definition with a replacement node."
      ],
      "output": [
        {
          "patch": "AbstractCandidate replace ( AbstractCandidate arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "IPosOnlyCandidate replace ( IPosOnlyCandidate arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Candidate replace ( RuleContext arg0 ) { return new RuleContext ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Candidate replace ( MatchedCandidate arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Candidate replace ( RuleContext arg0, T arg1 ) { return new RuleContext ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg0 = replaceNode ( loc0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg1. replaceNode ( loc0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg1. replaceNode ( loc0, null ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg1. replaceNode ( loc0, arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( TypeDeclaration arg0, Node arg1 ) { Node loc0 = arg0 ; arg1. replaceNode ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "AbstractDeclaration replace ( AbstractDeclaration arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "AbstractDeclaration replace ( AbstractDeclaration arg0, Definition arg1 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "AbstractDeclaration replace ( AbstractDeclaration arg0, AbstractDeclaration arg1 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void replace ( PsiElement arg0, PsiElement arg1 ) { PsiElement loc0 = arg0. loc0 ( ) ; PsiElement loc1 = arg1. loc1 ( ) ; PsiElement loc2 = arg1. loc2 ( ) ; PsiElement loc3 = ( PsiElement ) loc0. getParent ( ) ; loc3. replaceParent ( loc2 ) ; arg0. setLeft ( loc1 ) ; arg0. setRight ( loc3 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void replace ( PsiElement arg0, PsiElement arg1 ) { PsiElement loc0 = arg0. loc0 ( ) ; PsiElement loc1 = arg1. loc1 ( ) ; PsiElement loc2 = arg1. loc2 ( ) ; PsiElement loc3 = ( PsiElement ) loc0. getParent ( ) ; loc3. replaceParent ( loc2 ) ; arg0. setLeft ( loc1 ) ; arg1. setRight ( loc3 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "AbstractDeclaration replace ( AbstractDeclaration arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void replace ( DeclarationNode arg0, DefinitionNode arg1 ) { arg0. replaceParent ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "AbstractDeclaration replace ( AbstractDeclaration arg0, Node arg1 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "AbstractDeclaration replace ( AbstractDeclaration arg0, Node arg1 ) { return replaceDeclarationNode ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "AbstractDeclaration replace ( AbstractDeclaration arg0, Definition arg1 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( PsiElement arg0 ) { PsiElement loc0 = arg0. getParentNode ( ) ; if ( loc0 instanceof PsiElement ) { PsiElement loc1 = ( PsiElement ) loc0 ; PsiElement loc2 = ( PsiElement ) loc1 ; return replaceNode ( loc0, loc2 ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( PsiElement arg0 ) { PsiElement loc0 = arg0. getParentNode ( ) ; if ( loc0 instanceof PsiElement ) { PsiElement loc1 = ( PsiElement ) loc0 ; PsiElement loc2 = ( PsiElement ) loc1 ; return replaceNode ( loc2, loc0 ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( PsiElement arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; Node loc1 = ( PsiElement ) loc0. getParent ( ) ; return replaceNode ( loc1, arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( PsiElement arg0, PsiElement arg1 ) { PsiElement loc0 = arg0. getParent ( ) ; Node loc1 = ( PsiElement ) loc0. getParent ( ) ; return replaceNode ( loc1, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Node replace ( PsiElement arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; Node loc1 = ( PsiElement ) loc0. getParent ( ) ; return replaceNode ( loc1, loc0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_14_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_65-67": {
      "loc": "65-67",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i] != 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer;\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, end-1, trailer));\n    }\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); \n    }\n    return result;\n}",
      "target": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer;\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, end-1, trailer));\n    }\n    trailer = buffer[end-1];\n    if (trailer == 0 || trailer == ' '){\n        end--;\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); \n    }\n    return result;\n}",
      "function range": "56,5-112,5",
      "raw_output": [
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } arg0 [ arg1 + loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return arg2 + loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } else if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) ; } return loc0 ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = 'a' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '7' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { loc0 [ arg1 + loc1 ] -='' ; } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] ='' ; } } return new String ( loc0 ) ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { break ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Parse an octal value from the byte array.",
        "Parse an octal value from a byte array.",
        "Parse an octal string from the byte array.",
        "Parse an octal from the byte array.",
        "Parses an octal value from the byte array."
      ],
      "output": [
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } arg0 [ arg1 + loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return arg2 + loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } else if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = 'a' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '7' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { loc0 [ arg1 + loc1 ] -='' ; } } return new String ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] ='' ; } } return new String ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_12_/source/org/jfree/chart/plot/MultiplePiePlot.java_145-146": {
      "loc": "145-146",
      "input": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    this.dataset = dataset;\n\n    PiePlot piePlot = new PiePlot(null);\n    this.pieChart = new JFreeChart(piePlot);\n    this.pieChart.removeLegend();\n    this.dataExtractOrder = TableOrder.BY_COLUMN;\n    this.pieChart.setBackgroundPaint(null);\n    TextTitle seriesTitle = new TextTitle(\"Series Title\",\n            new Font(\"SansSerif\", Font.BOLD, 12));\n    seriesTitle.setPosition(RectangleEdge.BOTTOM);\n    this.pieChart.setTitle(seriesTitle);\n    this.aggregatedItemsKey = \"Other\";\n    this.aggregatedItemsPaint = Color.lightGray;\n    this.sectionPaints = new HashMap();\n}",
      "target": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n    setDataset(dataset);\n\n    PiePlot piePlot = new PiePlot(null);\n    this.pieChart = new JFreeChart(piePlot);\n    this.pieChart.removeLegend();\n    this.dataExtractOrder = TableOrder.BY_COLUMN;\n    this.pieChart.setBackgroundPaint(null);\n    TextTitle seriesTitle = new TextTitle(\"Series Title\",\n            new Font(\"SansSerif\", Font.BOLD, 12));\n    seriesTitle.setPosition(RectangleEdge.BOTTOM);\n    this.pieChart.setTitle(seriesTitle);\n    this.aggregatedItemsKey = \"Other\";\n    this.aggregatedItemsPaint = Color.lightGray;\n    this.sectionPaints = new HashMap();\n}",
      "function range": "143,5-158,5",
      "raw_output": [
        "MultiplePiePlot function ( ) { return new MultiplePiePlot ( ) ; }",
        "MultiplePiePlot function ( int arg0, int arg1 ) { MultiplePiePlot_N loc0 = new MultiplePiePlot_N ( arg0, arg1 ) ; return loc0 ; }",
        "MultiplePiePlot function ( int arg0, int arg1 ) { MultiplePiePlot_Object loc0 = new MultiplePiePlot_Object ( arg0, arg1 ) ; return loc0 ; }",
        "MultiplePiePlot function ( ) { return new MultiplePiePlotImpl ( ) ; }",
        "MultiplePiePlot function ( PiePlot [ ] arg0 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0 ) ; return loc0 ; }",
        "MultiplePiePlot function ( ) { return new MultiplePiePlot ( ) ; }",
        "MultiplePiePlot function ( int arg0, int arg1 ) { MultiplePiePlot_Object loc0 = new MultiplePiePlot_Object ( arg0, arg1 ) ; return loc0 ; }",
        "MultiplePiePlot function ( ) { MultiplePiePlot loc0 = new MultiplePiePlot ( ) ; loc0. setXAxis ( \"srini_string\" ) ; loc0. setYAxis ( \"srini_string\" ) ; return loc0 ; }",
        "MultiplePiePlot function ( int arg0, int arg1 ) { MultiplePiePlot_N loc0 = new MultiplePiePlot_N ( arg0, arg1 ) ; return loc0 ; }",
        "MultiplePiePlot function ( ) { MultiplePiePlot loc0 = null ; try { loc0 = new MultiplePiePlot ( ) ; } catch ( Exception loc1 ) { loc1. printStackTrace ( ) ; } return loc0 ; }",
        "MultiplePiePlot function ( ) { return new MultiplePiePlot ( ) ; }",
        "MultiplePiePlot function ( int arg0, int arg1 ) { MultiplePiePlot_N loc0 = new MultiplePiePlot_N ( arg0, arg1 ) ; return loc0 ; }",
        "MultiplePiePlot function ( ) { return new MultiplePiePlotImpl ( ) ; }",
        "MultiplePiePlot function ( int arg0, int arg1 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0, arg1 ) ; return loc0 ; }",
        "MultiplePiePlot function ( int arg0, int arg1 ) { MultiplePiePlot_MS loc0 = new MultiplePiePlot_MS ( arg0, arg1 ) ; return loc0 ; }",
        "MultiplePiePlot function ( ) { return new MultiplePiePlot ( ) ; }",
        "MultiplePiePlot function ( int arg0, int arg1 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0, arg1 ) ; return loc0 ; }",
        "MultiplePiePlot function ( int arg0 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0 ) ; return loc0 ; }",
        "MultiplePiePlot function ( int arg0, int arg1, int arg2 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0, arg1, arg2 ) ; return loc0 ; }",
        "MultiplePiePlot function ( int arg0, int arg1, int arg2 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0, arg1, arg2 ) ; loc0. setMaximumFractionDigits ( arg2 ) ; return loc0 ; }",
        "MultiplePiePlot function ( ) { return new MultiplePiePlot ( ) ; }",
        "MultiplePiePlot function ( ) { return new MultiplePiePlotImpl ( ) ; }",
        "MultiplePiePlot function ( ) { return PiePlot_N. create ( ) ; }",
        "MultiplePiePlot function ( ) { return null ; }",
        "MultiplePiePlot function ( ) { return Plots. newMultiplePiePlot ( ) ; }"
      ],
      "mid_translation": [
        "Create a MultiplePiePlot object.",
        "Creates a MultiplePiePlot object.",
        "Create a MultiplePiePlot.",
        "Create a MultiplePiePlot",
        "Create a new MultiplePiePlot object."
      ],
      "output": [
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return new MultiplePiePlot ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1 ) { MultiplePiePlot_N loc0 = new MultiplePiePlot_N ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1 ) { MultiplePiePlot_Object loc0 = new MultiplePiePlot_Object ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return new MultiplePiePlotImpl ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( PiePlot [ ] arg0 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return new MultiplePiePlot ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1 ) { MultiplePiePlot_Object loc0 = new MultiplePiePlot_Object ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { MultiplePiePlot loc0 = new MultiplePiePlot ( ) ; loc0. setXAxis ( \"srini_string\" ) ; loc0. setYAxis ( \"srini_string\" ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1 ) { MultiplePiePlot_N loc0 = new MultiplePiePlot_N ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { MultiplePiePlot loc0 = null ; try { loc0 = new MultiplePiePlot ( ) ; } catch ( Exception loc1 ) { loc1. printStackTrace ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return new MultiplePiePlot ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1 ) { MultiplePiePlot_N loc0 = new MultiplePiePlot_N ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return new MultiplePiePlotImpl ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1 ) { MultiplePiePlot_MS loc0 = new MultiplePiePlot_MS ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return new MultiplePiePlot ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1, int arg2 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0, arg1, arg2 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( int arg0, int arg1, int arg2 ) { MultiplePiePlot loc0 = new MultiplePiePlot ( arg0, arg1, arg2 ) ; loc0. setMaximumFractionDigits ( arg2 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return new MultiplePiePlot ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return new MultiplePiePlotImpl ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return PiePlot_N. create ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MultiplePiePlot MultiplePiePlot ( ) { return Plots. newMultiplePiePlot ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_33_/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java_557-558": {
      "loc": "557-558",
      "input": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n  if (constraintObj.isRecordType()) {\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      JSType propType = constraintObj.getPropertyType(prop);\n      if (!isPropertyTypeDeclared(prop)) {\n        JSType typeToInfer = propType;\n        if (!hasProperty(prop)) {\n          typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n              .getLeastSupertype(propType);\n        }\n        defineInferredProperty(prop, typeToInfer, null);\n      }\n    }\n  }\n}",
      "target": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n  if (hasReferenceName()) {\n    return;\n  }\n  if (constraintObj.isRecordType()) {\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      JSType propType = constraintObj.getPropertyType(prop);\n      if (!isPropertyTypeDeclared(prop)) {\n        JSType typeToInfer = propType;\n        if (!hasProperty(prop)) {\n          typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n              .getLeastSupertype(propType);\n        }\n        defineInferredProperty(prop, typeToInfer, null);\n      }\n    }\n  }\n}",
      "function range": "554,3-580,3",
      "raw_output": [
        "MatchConstraintResult function ( Constraints arg0 ) { return new MatchConstraintResult ( ) ; }",
        "MatchConstraintResult function ( Constraints arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
        "MatchConstraintResult function ( Geometry arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
        "MatchConstraintResult function ( Geometry arg0 ) { return new MatchConstraintResult ( ) ; }",
        "MatchConstraintResult function ( MatchConstraint arg0 ) { return MatchConstraintResult. MATCH ; }",
        "boolean function ( Record arg0, Type arg1 ) { if ( arg0. getRecordType ( ) == arg1. getRecordType ( ) ) { return true ; } else if ( arg0. getRecordType ( ) == arg1. getRecordType ( ) ) { return true ; } return false ; }",
        "boolean function ( Record arg0, Type arg1 ) { if ( arg0. getRecordType ( ) == arg1. getRecordType ( ) ) { return true ; } if ( arg0. getRecordType ( ) == arg1. getRecordType ( ) ) { return true ; } return false ; }",
        "boolean function ( Record arg0 ) { return arg0. getRecordType ( ). equals ( arg0. getRecordType ( ) ) ; }",
        "boolean function ( Record arg0, Type arg1 ) { if ( arg0. getType ( ) == arg1. getType ( ) ) { return true ; } else if ( arg0. getType ( ) == arg1. getType ( ) ) { return true ; } return false ; }",
        "boolean function ( Record arg0, Type arg1 ) { if ( arg0. getType ( ) == arg1. getType ( ) ) { return true ; } else if ( arg0. getType ( ) == arg1. getType ( ) ) { return true ; } else { return false ; } }",
        "MatchConstraint function ( Constraints arg0 ) { return new MatchConstraint ( arg0 ) ; }",
        "MatchConstraintResult function ( MatchConstraint arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
        "MatchConstraint function ( MatchPattern arg0 ) { return new MatchConstraint ( arg0 ) ; }",
        "MatchConstraint function ( ConstraintSet arg0 ) { return new MatchConstraint ( arg0 ) ; }",
        "MatchConstraint function ( MatchClause arg0 ) { return new MatchConstraint ( arg0 ) ; }",
        "MatchConstraint function ( RecordType arg0, ConstraintSet arg1 ) { return new MatchConstraint ( ) ; }",
        "MatchConstraint function ( RecordType arg0, ConstraintContext arg1 ) { return new MatchConstraint ( ) ; }",
        "MatchConstraint function ( P arg0 ) { return new MatchConstraint ( ) ; }",
        "MatchConstraint function ( P arg0, Type arg1 ) { return new MatchConstraint ( ) ; }",
        "MatchConstraint function ( RecordType arg0 ) { return new MatchConstraint ( ) ; }",
        "MatchConstraint function ( Constraints arg0 ) { return new MatchConstraint ( arg0 ) ; }",
        "MatchConstraintResult function ( Constraints arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
        "MatchConstraintResult function ( Geometry arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
        "MatchConstraintResult function ( Conjunction arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
        "MatchConstraint function ( Constraints arg0 ) { return new MatchConstraint ( ) ; }"
      ],
      "mid_translation": [
        "Override the default implementation of the matchConstraint method.",
        "Override this method to match a record type with another record type.",
        "Override the default implementation of matchConstraint.",
        "Override the default implementation of matchConstraint for a record type.",
        "Override the default matchConstraint method."
      ],
      "output": [
        {
          "patch": "@Override\npublic MatchConstraintResult matchConstraint ( Constraints arg0 ) { return new MatchConstraintResult ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraintResult matchConstraint ( Constraints arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraintResult matchConstraint ( Geometry arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraintResult matchConstraint ( Geometry arg0 ) { return new MatchConstraintResult ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraintResult matchConstraint ( MatchConstraint arg0 ) { return MatchConstraintResult. MATCH ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean matchConstraint ( Record arg0, Type arg1 ) { if ( arg0. getRecordType ( ) == arg1. getRecordType ( ) ) { return true ; } else if ( arg0. getRecordType ( ) == arg1. getRecordType ( ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean matchConstraint ( Record arg0, Type arg1 ) { if ( arg0. getRecordType ( ) == arg1. getRecordType ( ) ) { return true ; } if ( arg0. getRecordType ( ) == arg1. getRecordType ( ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean matchConstraint ( Record arg0 ) { return arg0. getRecordType ( ). equals ( arg0. getRecordType ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean matchConstraint ( Record arg0, Type arg1 ) { if ( arg0. getType ( ) == arg1. getType ( ) ) { return true ; } else if ( arg0. getType ( ) == arg1. getType ( ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean matchConstraint ( Record arg0, Type arg1 ) { if ( arg0. getType ( ) == arg1. getType ( ) ) { return true ; } else if ( arg0. getType ( ) == arg1. getType ( ) ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( Constraints arg0 ) { return new MatchConstraint ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraintResult matchConstraint ( MatchConstraint arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( MatchPattern arg0 ) { return new MatchConstraint ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( ConstraintSet arg0 ) { return new MatchConstraint ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( MatchClause arg0 ) { return new MatchConstraint ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( RecordType arg0, ConstraintSet arg1 ) { return new MatchConstraint ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( RecordType arg0, ConstraintContext arg1 ) { return new MatchConstraint ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( P arg0 ) { return new MatchConstraint ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( P arg0, Type arg1 ) { return new MatchConstraint ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( RecordType arg0 ) { return new MatchConstraint ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( Constraints arg0 ) { return new MatchConstraint ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraintResult matchConstraint ( Constraints arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraintResult matchConstraint ( Geometry arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraintResult matchConstraint ( Conjunction arg0 ) { return new MatchConstraintResult ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic MatchConstraint matchConstraint ( Constraints arg0 ) { return new MatchConstraint ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_7_/src/java/org/apache/commons/codec/binary/Base64.java_670-671": {
      "loc": "670-671",
      "input": "public static String encodeBase64String(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n}",
      "target": "public static String encodeBase64String(byte[] binaryData) {\n    return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n}",
      "function range": "669,5-671,5",
      "raw_output": [
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ), \"srini_string\" ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encode ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
        "String function ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encode ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encodeToString ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
        "String function ( byte [ ] arg0 ) { return toBase64 ( arg0, 0, arg0. length ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encode ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( encode ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encodeToString ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { return new String ( Base64. getEncoder ( ). encode ( arg0, arg1, arg2 ) ) ; }",
        "String function ( String arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
        "String function ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\" ) ; } }",
        "String function ( String arg0 ) { try { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( String arg0 ) { try { return Base64. getEncoder ( ). encodeToString ( arg0, Base64. DEFAULT ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( String arg0 ) { try { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( String arg0 ) { try { return Base64. getEncoder ( ). encode ( arg0. getBytes ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( String arg0 ) { try { return Base64. getEncoder ( ). encode ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( String arg0 ) { byte [ ] loc0 = arg0. getBytes ( ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
        "String function ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }"
      ],
      "mid_translation": [
        "Encode binary data to base64 string.",
        "Encodes a byte array into a base 64 string.",
        "Encodes a byte array into a base64 string.",
        "Encode base 64 string.",
        "Encode base64 string."
      ],
      "output": [
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ), \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encode ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encode ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encodeToString ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return toBase64 ( arg0, 0, arg0. length ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encode ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( encode ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encodeToString ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String encodeBase64String ( byte [ ] arg0, int arg1, int arg2 ) { return new String ( Base64. getEncoder ( ). encode ( arg0, arg1, arg2 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { try { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { try { return Base64. getEncoder ( ). encodeToString ( arg0, Base64. DEFAULT ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { try { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { try { return Base64. getEncoder ( ). encode ( arg0. getBytes ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { try { return Base64. getEncoder ( ). encode ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { byte [ ] loc0 = arg0. getBytes ( ) ; return Base64. getEncoder ( ). encodeToString ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64String ( String arg0 ) { try { return URLEncoder. encode ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_129_/src/com/google/javascript/jscomp/PrepareAst.java_166-167": {
      "loc": "166-167",
      "input": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!NodeUtil.isGet(first)) {\n    n.putBooleanProp(Node.FREE_CALL, true);\n  }\n  if (first.isName() &&\n      \"eval\".equals(first.getString())) {\n    first.putBooleanProp(Node.DIRECT_EVAL, true);\n  }\n}",
      "target": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  while (first.isCast()) {\n    first = first.getFirstChild();\n  }\n  if (!NodeUtil.isGet(first)) {\n    n.putBooleanProp(Node.FREE_CALL, true);\n  }\n  if (first.isName() &&\n      \"eval\".equals(first.getString())) {\n    first.putBooleanProp(Node.DIRECT_EVAL, true);\n  }\n}",
      "function range": "158,5-177,5",
      "raw_output": [
        "Call < R > function ( List <? extends R > arg0 ) { return null ; }",
        "Call < A > function ( List < A > arg0 ) { return new Call < A > ( arg0 ) ; }",
        "Call < V > function ( List <? extends R > arg0 ) { return null ; }",
        "Call < A > function ( List <? extends R > arg0 ) { return null ; }",
        "Call < A > function ( List <? extends A > arg0 ) { return null ; }",
        "CallNode function ( Node arg0, List < Node > arg1 ) { return new CallNode ( arg0, arg1 ) ; }",
        "CallNode [ ] function ( CallNode [ ] arg0 ) { return arg0 ; }",
        "CallNode function ( CallNode arg0 ) { return arg0 ; }",
        "CallNode [ ] function ( CallNode [ ] arg0, Map < String, Node > arg1 ) { return arg0 ; }",
        "CallNode [ ] function ( CallNode [ ] arg0 ) { return null ; }",
        "void function ( MethodInvocation... arg0 ) { for ( MethodInvocation loc0 : arg0 ) { loc0. annotate ( ) ; } }",
        "List < A > function ( List <? extends A > arg0 ) { return arg0 ; }",
        "List < T > function ( List < T > arg0 ) { return arg0 ; }",
        "void function ( MethodInvocation [ ] arg0 ) { for ( MethodInvocation loc0 : arg0 ) { annotate ( loc0 ) ; } }",
        "void function ( MethodInvocation... arg0 ) { for ( MethodInvocation loc0 : arg0 ) { annotate ( loc0 ) ; } }",
        "T function ( Callable < T > arg0 ) { return arg0. call ( ) ; }",
        "T function ( Callable < T > arg0, T arg1 ) { return arg0. call ( ) ; }",
        "T function ( T arg0 ) { return arg0 ; }",
        "R function ( Callable < T > arg0 ) { R loc0 = arg0. call ( ) ; return loc0 ; }",
        "R function ( Callable < T > arg0 ) { return arg0. call ( ) ; }",
        "List < Node > function ( List < Node > arg0 ) { return arg0 ; }",
        "String function ( Call arg0 ) { return arg0. getClass ( ). getName ( ) ; }",
        "List < Node > function ( List < Node > arg0 ) { return Lists. newArrayList ( Arrays. asList ( arg0 ) ) ; }",
        "String function ( CallNode arg0 ) { return arg0. getClass ( ). getName ( ) ; }",
        "List < Node > function ( Call arg0 ) { return Lists. newArrayList ( ) ; }"
      ],
      "mid_translation": [
        "Annotate calls.",
        "Annotate call nodes.",
        "annotate calls.",
        "Enrich calls.",
        "Annotations call nodes."
      ],
      "output": [
        {
          "patch": "private Call < R > annotateCalls ( List <? extends R > arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Call < A > annotateCalls ( List < A > arg0 ) { return new Call < A > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Call < V > annotateCalls ( List <? extends R > arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Call < A > annotateCalls ( List <? extends R > arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Call < A > annotateCalls ( List <? extends A > arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private CallNode annotateCalls ( Node arg0, List < Node > arg1 ) { return new CallNode ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private CallNode [ ] annotateCalls ( CallNode [ ] arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private CallNode annotateCalls ( CallNode arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private CallNode [ ] annotateCalls ( CallNode [ ] arg0, Map < String, Node > arg1 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private CallNode [ ] annotateCalls ( CallNode [ ] arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls ( MethodInvocation... arg0 ) { for ( MethodInvocation loc0 : arg0 ) { loc0. annotate ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < A > annotateCalls ( List <? extends A > arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < T > annotateCalls ( List < T > arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls ( MethodInvocation [ ] arg0 ) { for ( MethodInvocation loc0 : arg0 ) { annotate ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void annotateCalls ( MethodInvocation... arg0 ) { for ( MethodInvocation loc0 : arg0 ) { annotate ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T annotateCalls ( Callable < T > arg0 ) { return arg0. call ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T annotateCalls ( Callable < T > arg0, T arg1 ) { return arg0. call ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T annotateCalls ( T arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R annotateCalls ( Callable < T > arg0 ) { R loc0 = arg0. call ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R annotateCalls ( Callable < T > arg0 ) { return arg0. call ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < Node > annotateCalls ( List < Node > arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String annotateCalls ( Call arg0 ) { return arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < Node > annotateCalls ( List < Node > arg0 ) { return Lists. newArrayList ( Arrays. asList ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String annotateCalls ( CallNode arg0 ) { return arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < Node > annotateCalls ( Call arg0 ) { return Lists. newArrayList ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_17_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_339-340": {
      "loc": "339-340",
      "input": "public static String newStringIso8859_1(final byte[] bytes) {\n    return new String(bytes, Charsets.ISO_8859_1);\n}",
      "target": "public static String newStringIso8859_1(final byte[] bytes) {\n    return newString(bytes, Charsets.ISO_8859_1);\n}",
      "function range": "338,5-340,5",
      "raw_output": [
        "String function ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; char [ ] loc0 = arg0. toCharArray ( ) ; return new String ( loc0, 0, arg0. length ( ) ) ; }",
        "String function ( String arg0 ) { return \"srini_string\" + arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( String arg0 ) { return \"srini_string\" + arg0 ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0. toUpperCase ( ) ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { return \"srini_string\" + arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return arg0. replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; try { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { return \"srini_string\" ; } }",
        "String function ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; try { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { return arg0 ; } }",
        "String function ( String arg0 ) { try { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; try { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( char ) arg0 [ arg1 + loc1 ] ; } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0 [ loc1 ] = ( char ) arg0 [ arg1 + loc1 ] ; return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0 ) { int loc0 = arg0. length ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( char ) arg0 [ loc2 ] ; } return new String ( loc1 ) ; }",
        "String function ( byte [ ] arg0 ) { char [ ] loc0 = new char [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( char ) arg0 [ loc1 ] ; } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0 [ loc1 ] = Character. forDigit ( ( arg0 [ loc1 ] & 0xff, 16 ) ) ; return new String ( loc0 ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( ) { return ISO_8859_1_STRING ; }",
        "String function ( ) { return ISO8859_1_STRING ; }",
        "String function ( int arg0, int arg1 ) { return new ISO8859_1String ( arg0, arg1 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; return ISO8859_1. getString ( arg0 ) ; }"
      ],
      "mid_translation": [
        "New string in ISO - 8859 - 1.",
        "New string in ISO - 8859 - 1 format.",
        "New string in ISO - 8859 - 1 encoding.",
        "Creates a new String from the given byte array.",
        "Creates a new ISO - 8859 - 1 string."
      ],
      "output": [
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; char [ ] loc0 = arg0. toCharArray ( ) ; return new String ( loc0, 0, arg0. length ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { return \"srini_string\" + arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { return \"srini_string\" + arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0. toUpperCase ( ) ) ; return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { return \"srini_string\" + arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return arg0. replaceAll ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) return null ; try { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { return \"srini_string\" ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) return null ; try { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { try { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) return null ; try { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String newStringIso8859_1 ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( char ) arg0 [ arg1 + loc1 ] ; } return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0 [ loc1 ] = ( char ) arg0 [ arg1 + loc1 ] ; return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( byte [ ] arg0 ) { int loc0 = arg0. length ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( char ) arg0 [ loc2 ] ; } return new String ( loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( byte [ ] arg0 ) { char [ ] loc0 = new char [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( char ) arg0 [ loc1 ] ; } return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0 [ loc1 ] = Character. forDigit ( ( arg0 [ loc1 ] & 0xff, 16 ) ) ; return new String ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String newStringIso8859_1 ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String newStringIso8859_1 ( ) { return ISO_8859_1_STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String newStringIso8859_1 ( ) { return ISO8859_1_STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String newStringIso8859_1 ( int arg0, int arg1 ) { return new ISO8859_1String ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String newStringIso8859_1 ( String arg0 ) { if ( arg0 == null ) return null ; return ISO8859_1. getString ( arg0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Chart_13_/source/org/jfree/chart/block/BorderArrangement.java_455-456": {
      "loc": "455-456",
      "input": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth() - w[2]),\n\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.rightBlock.arrange(g2, c4);\n        w[3] = size.width;\n    }\n    h[4] = h[2];\n    w[4] = constraint.getWidth() - w[3] - w[2];\n    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n    if (this.centerBlock != null) {\n        this.centerBlock.arrange(g2, c5);\n    }\n    if (this.topBlock != null) {\n        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                h[0]));\n    }\n    if (this.bottomBlock != null) {\n        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                w[1], h[1]));\n    }\n    if (this.leftBlock != null) {\n        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                h[2]));\n    }\n    if (this.rightBlock != null) {\n        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                w[3], h[3]));\n    }\n    if (this.centerBlock != null) {\n        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                h[4]));\n    }\n    return new Size2D(constraint.getWidth(), constraint.getHeight());\n}",
      "target": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n                new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.rightBlock.arrange(g2, c4);\n        w[3] = size.width;\n    }\n    h[4] = h[2];\n    w[4] = constraint.getWidth() - w[3] - w[2];\n    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n    if (this.centerBlock != null) {\n        this.centerBlock.arrange(g2, c5);\n    }\n    if (this.topBlock != null) {\n        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                h[0]));\n    }\n    if (this.bottomBlock != null) {\n        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                w[1], h[1]));\n    }\n    if (this.leftBlock != null) {\n        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                h[2]));\n    }\n    if (this.rightBlock != null) {\n        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                w[3], h[3]));\n    }\n    if (this.centerBlock != null) {\n        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                h[4]));\n    }\n    return new Size2D(constraint.getWidth(), constraint.getHeight());\n}",
      "function range": "422,5-489,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_5_/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java_239-241": {
      "loc": "239-241",
      "input": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read == 0 && inf.finished()) {\n            return -1;\n        }\n        crc.update(buffer, start, read);\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}",
      "target": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        if (read == 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (lengthOfLastRead == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n        }\n        crc.update(buffer, start, read);\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}",
      "function range": "191,5-246,5",
      "raw_output": [
        "byte [ ] function ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_octet ( ) ; } return loc1 ; }",
        "byte [ ] function ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_long ( ) ; } return loc1 ; }",
        "byte [ ] function ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_byte ( ) ; } return loc1 ; }",
        "int function ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_octet ( ) ; } return loc1. length ; }",
        "int function ( InputStream arg0 ) { int loc0 = arg0. read ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read ( ) ; } return loc1. length ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } return loc0 ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; while ( arg0. available ( ) > 0 ) { int loc1 = arg0. read ( arg1 ) ; if ( loc1 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc1 ; } return loc0 ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new IOException ( ) ; } loc0 += loc2 << loc1 ; } return loc0 ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } if ( loc0 < 0 ) { throw new EOFException ( ) ; } return loc0 ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } if ( loc0 < arg1. length ) { throw new EOFException ( ) ; } return loc0 ; }",
        "byte [ ] function ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_octet ( ) ; } return loc1 ; }",
        "byte [ ] function ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_byte ( ) ; } return loc1 ; }",
        "byte [ ] function ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_long ( ) ; } return loc1 ; }",
        "int function ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_octet ( ) ; } return loc1. length ; }",
        "byte [ ] function ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0. read_byte ( ) ; } return loc1 ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } arg1 [ loc0 ] = ( byte ) loc2 ; return loc0 ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new IOException ( ) ; } loc0 += loc2 << loc1 ; } arg1 [ loc0 ] = ( byte ) loc2 ; return loc0 ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; while ( arg0. available ( ) > 0 ) { int loc1 = arg0. read ( arg1 ) ; if ( loc1 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc1 ; } return loc0 ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } if ( loc0 < arg1. length ) { throw new EOFException ( ) ; } return loc0 ; }",
        "int function ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } return loc0 ; }",
        "byte [ ] function ( InputStream arg0 ) { byte [ ] loc0 = new byte [ arg0. read_long ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. read_long ( ) ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) arg0. read_byte ( ) ; } return loc0 ; }",
        "byte [ ] function ( InputStream arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 [ loc1 ] = ( byte ) loc2 ; } return loc0 ; }",
        "byte [ ] function ( InputStream arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { break ; } loc0 [ loc1 ] = ( byte ) loc2 ; } return loc0 ; }",
        "byte [ ] function ( InputStream arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new IOException ( ) ; } loc0 [ loc1 ] = ( byte ) loc2 ; } return loc0 ; }",
        "byte [ ] function ( InputStream arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 [ arg1 + loc1 ] = ( byte ) loc2 ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Read an array of bytes from the input stream.",
        "Read a block of bytes from the input stream.",
        "Read an array of bytes from the stream.",
        "Read a block of bytes from the stream.",
        "Read a block of bytes from the input stream into a byte array."
      ],
      "output": [
        {
          "patch": "public byte [ ] read ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_octet ( ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_long ( ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_byte ( ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_octet ( ) ; } return loc1. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0 ) { int loc0 = arg0. read ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read ( ) ; } return loc1. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; while ( arg0. available ( ) > 0 ) { int loc1 = arg0. read ( arg1 ) ; if ( loc1 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new IOException ( ) ; } loc0 += loc2 << loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } if ( loc0 < 0 ) { throw new EOFException ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } if ( loc0 < arg1. length ) { throw new EOFException ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_octet ( ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_byte ( ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_long ( ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = ( byte ) arg0. read_octet ( ) ; } return loc1. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0 ) { int loc0 = arg0. read_long ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0. read_byte ( ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } arg1 [ loc0 ] = ( byte ) loc2 ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new IOException ( ) ; } loc0 += loc2 << loc1 ; } arg1 [ loc0 ] = ( byte ) loc2 ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; while ( arg0. available ( ) > 0 ) { int loc1 = arg0. read ( arg1 ) ; if ( loc1 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } if ( loc0 < arg1. length ) { throw new EOFException ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int read ( InputStream arg0, byte [ ] arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 += loc2 << loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0 ) { byte [ ] loc0 = new byte [ arg0. read_long ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. read_long ( ) ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) arg0. read_byte ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 [ loc1 ] = ( byte ) loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { break ; } loc0 [ loc1 ] = ( byte ) loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new IOException ( ) ; } loc0 [ loc1 ] = ( byte ) loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] read ( InputStream arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new EOFException ( ) ; } loc0 [ arg1 + loc1 ] = ( byte ) loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_168_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1996-1997": {
      "loc": "1996-1997",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 2) {\n    return;\n  }\n  if (n.isName() && NodeUtil.isLValue(n) &&\n      !NodeUtil.isBleedingFunctionName(n)) {\n    String name = n.getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordAssignedName(name);\n      }\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n      }\n    }\n  } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n      NodeUtil.isLValue(n)) {\n    String name = NodeUtil.getRootOfQualifiedName(n).getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode())\n            .recordEscapedQualifiedName(n.getQualifiedName());\n      }\n    }\n  }\n}",
      "target": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n  if (t.getScopeDepth() <= 1) {\n    return;\n  }\n  if (n.isName() && NodeUtil.isLValue(n) &&\n      !NodeUtil.isBleedingFunctionName(n)) {\n    String name = n.getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordAssignedName(name);\n      }\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n      }\n    }\n  } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n      NodeUtil.isLValue(n)) {\n    String name = NodeUtil.getRootOfQualifiedName(n).getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (scope != ownerScope && ownerScope.isLocal()) {\n        data.get(ownerScope.getRootNode())\n            .recordEscapedQualifiedName(n.getQualifiedName());\n      }\n    }\n  }\n}",
      "function range": "1987,5-2038,5",
      "raw_output": [
        "R function ( GetPropStmt arg0 ) { R loc0 = arg0. getLastChild ( ) ; R loc1 = loc0. getValue ( ) ; return loc1 ; }",
        "R function ( GetPROP arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
        "R function ( GetPropTree arg0 ) { R loc0 = arg0. getLastChild ( ) ; R loc1 = arg0. getLastChild ( ) ; return loc0 ; }",
        "R function ( GetPROP arg0 ) { R loc0 = arg0. getProperty ( ) ; return loc0 ; }",
        "R function ( GetPropContext arg0 ) { R loc0 = arg0. getProperty ( ) ; return loc0 ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CIDatabaseNode ) ; }",
        "boolean function ( ASTNode arg0 ) { switch ( arg0. getType ( ) ) { case CDATA : return true ; case BINARY : return false ; default : return false ; } }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID   ) ; }",
        "boolean function ( Node arg0 ) { return ( arg0 instanceof CIDatabaseNode ) ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CSSNode ) ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
        "boolean function ( ASTNode arg0 ) { return arg0 instanceof CID    ; }",
        "boolean function ( Node arg0 ) { return ( arg0 instanceof CID    ) ; }",
        "boolean function ( ASTNode arg0 ) { if ( arg0 instanceof CID    ) return true ; else return false ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof CID    ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
        "int function ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
        "boolean function ( ASTNode arg0 ) { return arg0 instanceof CID    ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CSSDeclaration ) ; }",
        "boolean function ( Node arg0 ) { return ( arg0 instanceof CID    ) ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CID   ) ; }",
        "boolean function ( Node arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CID   ) ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CIDHtml ) ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID    || arg0 instanceof CID   ) ; }",
        "boolean function ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CIDhl ) ; }"
      ],
      "mid_translation": [
        "Visits a GETPROP node.",
        "Checks if the node is a CID   .",
        "Checks if the node is a CID    node.",
        "Checks if the node is a CID    or CID    node.",
        "Checks if the node is a CID    or CID   ."
      ],
      "output": [
        {
          "patch": "@Override public R visit ( GetPropStmt arg0 ) { R loc0 = arg0. getLastChild ( ) ; R loc1 = loc0. getValue ( ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public R visit ( GetPROP arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public R visit ( GetPropTree arg0 ) { R loc0 = arg0. getLastChild ( ) ; R loc1 = arg0. getLastChild ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public R visit ( GetPROP arg0 ) { R loc0 = arg0. getProperty ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public R visit ( GetPropContext arg0 ) { R loc0 = arg0. getProperty ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CIDatabaseNode ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CID   ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( Node arg0 ) { return ( arg0 instanceof CIDatabaseNode ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CSSNode ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return arg0 instanceof CID    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( Node arg0 ) { return ( arg0 instanceof CID    ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { if ( arg0 instanceof CID    ) return true ; else return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( Node arg0 ) { return arg0 instanceof CID    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public int visit ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return arg0 instanceof CID    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CSSDeclaration ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( Node arg0 ) { return ( arg0 instanceof CID    ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CID   ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( Node arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CID   ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CIDHtml ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CID    || arg0 instanceof CID   ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override public boolean visit ( ASTNode arg0 ) { return ( arg0 instanceof CID    ) || ( arg0 instanceof CIDhl ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_65_/src/com/google/javascript/jscomp/CodeGenerator.java_1015-1016": {
      "loc": "1015-1016",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       \n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        final String END_SCRIPT = \"/script\";\n        final String START_COMMENT = \"!--\";\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "target": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\0': sb.append(\"\\\\000\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '>':                       \n        if (i >= 2 &&\n            ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n             (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n          sb.append(\"\\\\>\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      case '<':\n        final String END_SCRIPT = \"/script\";\n        final String START_COMMENT = \"!--\";\n        if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                            END_SCRIPT.length())) {\n          sb.append(\"<\\\\\");\n        } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                   START_COMMENT.length())) {\n          sb.append(\"<\\\\\");\n        } else {\n          sb.append(c);\n        }\n        break;\n      default:\n        if (outputCharsetEncoder != null) {\n          if (outputCharsetEncoder.canEncode(c)) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        } else {\n          if (c > 0x1f && c < 0x7f) {\n            sb.append(c);\n          } else {\n            appendHexJavaScriptRepresentation(sb, c);\n          }\n        }\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}",
      "function range": "1005,3-1075,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_2_/src/java/org/apache/commons/codec/binary/Base64.java_446-447": {
      "loc": "446-447",
      "input": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) { b += 256; }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                buf[pos++] = encodeTable[x & MASK_6BITS];\n                currentLinePos += 4;\n                if (lineLength > 0 && lineLength <= currentLinePos) {\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                    pos += lineSeparator.length;\n                    currentLinePos = 0;\n                }\n            }\n        }\n    }\n}",
      "target": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n        if (lineLength > 0 && pos > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) { b += 256; }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                buf[pos++] = encodeTable[x & MASK_6BITS];\n                currentLinePos += 4;\n                if (lineLength > 0 && lineLength <= currentLinePos) {\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                    pos += lineSeparator.length;\n                    currentLinePos = 0;\n                }\n            }\n        }\n    }\n}",
      "function range": "414,5-473,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_19_/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java_259-260": {
      "loc": "259-260",
      "input": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);\n        if (rawCentralDirectoryData.length != expectedLength) {\n            throw new ZipException(\"central directory zip64 extended\"\n                                   + \" information extra field's length\"\n                                   + \" doesn't match central directory\"\n                                   + \" data.  Expected length \"\n                                   + expectedLength + \" but is \"\n                                   + rawCentralDirectoryData.length);\n        }\n        int offset = 0;\n        if (hasUncompressedSize) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                     offset);\n            offset += DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset =\n                new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart = new ZipLong(rawCentralDirectoryData, offset);\n            offset += WORD;\n        }\n    }\n}",
      "target": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);\n        if (rawCentralDirectoryData.length < expectedLength) {\n            throw new ZipException(\"central directory zip64 extended\"\n                                   + \" information extra field's length\"\n                                   + \" doesn't match central directory\"\n                                   + \" data.  Expected length \"\n                                   + expectedLength + \" but is \"\n                                   + rawCentralDirectoryData.length);\n        }\n        int offset = 0;\n        if (hasUncompressedSize) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasCompressedSize) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                     offset);\n            offset += DWORD;\n        }\n        if (hasRelativeHeaderOffset) {\n            relativeHeaderOffset =\n                new ZipEightByteInteger(rawCentralDirectoryData, offset);\n            offset += DWORD;\n        }\n        if (hasDiskStart) {\n            diskStart = new ZipLong(rawCentralDirectoryData, offset);\n            offset += WORD;\n        }\n    }\n}",
      "function range": "249,5-287,5",
      "raw_output": [
        "CentralDirectoryData function ( ) { try { CentralDirectoryData loc0 = new CentralDirectoryData ( ) ; loc0. parse ( ) ; } catch ( Exception loc0 ) { Logger. getLogger ( getClass ( ). getName ( ) ). log ( Level. SEVERE, \"srini_string\", loc0 ) ; } return loc0 ; }",
        "CentralDirectoryData function ( ) { try { CentralDirectoryData loc0 = new CentralDirectoryData ( ) ; loc0. parse ( ) ; } catch ( Exception loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
        "CentralDirectoryData function ( String arg0 ) { try { CentralDirectoryData loc0 = new CentralDirectoryData ( arg0 ) ; return loc0 ; } catch ( Exception loc0 ) { Logger. getLogger ( getClass ( ). getName ( ) ). debug ( \"srini_string\", loc0 ) ; } return null ; }",
        "CentralDirectoryData function ( String arg0 ) { try { CentralDirectoryData loc0 = new CentralDirectoryData ( arg0 ) ; return loc0 ; } catch ( Exception loc0 ) { Logger. getLogger ( getClass ( ). getName ( ) ). debug ( \"srini_string\" + arg0 ) ; } return null ; }",
        "CentralDirectoryData function ( ) { CentralDirectoryData loc0 = null ; try { loc0 = new CentralDirectoryData ( new File ( \"srini_string\" ) ) ; } catch ( Exception loc1 ) { loc1. printStackTrace ( ) ; } return loc0 ; }",
        "CentralDirectoryData function ( ) { try { CentralDirectory loc0 = ReparseCentralDirectoryData ( new File ( \"srini_string\" ) ) ; return loc0 ; } catch ( Exception loc0 ) { Logger. getLogger ( getClass ( ). getName ( ) ). log ( Level. SEVERE, \"srini_string\", loc0 ) ; } return null ; }",
        "CentralDirectoryData function ( ) { CentralDirectoryData loc0 = ReparseCentralDirectoryData ( new File ( \"srini_string\" ) ) ; return loc0 ; }",
        "CentralDirectoryData function ( ) { try { CentralDirectory loc0 = new CentralDirectoryData ( ) ; loc0. parse ( ) ; } catch ( Exception loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
        "CentralDirectoryData function ( ) { CentralDirectoryData loc0 = ReparseCentralDirectoryData ( new File ( \"srini_string\" ), new File ( \"srini_string\" ) ) ; return loc0 ; }",
        "CentralDirectoryData function ( ) { try { CentralDirectory loc0 = ReparseCentralDirectoryData ( new File ( \"srini_string\" ), new File ( \"srini_string\" ) ) ; return loc0 ; } catch ( Exception loc0 ) { Throwables. propagate ( loc0 ) ; } }",
        "void function ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 || loc3 > loc2 ) { throw new IOException ( \"srini_string\" ) ; } arg0. read ( loc1 ) ; } }",
        "void function ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 ) { throw new IOException ( \"srini_string\" ) ; } arg0. read ( loc1, 0, loc3 ) ; } }",
        "void function ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 ) { throw new IOException ( \"srini_string\" + loc3 ) ; } arg0. read ( loc1, 0, loc3 ) ; } }",
        "void function ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 || loc3 > loc2 ) { throw new IOException ( \"srini_string\" + loc3 ) ; } arg0. read ( loc1 ) ; } }",
        "void function ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 ) { throw new IOException ( \"srini_string\" ) ; } arg0. read ( loc1 ) ; } }",
        "void function ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 == - 1 ) { System. err. println ( \"srini_string\" ) ; } else { System. err. println ( \"srini_string\" + arg0. getAbsolutePath ( ) ) ; } }",
        "void function ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 < 0 ) { System. err. println ( \"srini_string\" + arg0 ) ; } else { System. err. println ( \"srini_string\" + arg0 ) ; } }",
        "void function ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 == - 1 ) { System. err. println ( \"srini_string\" + arg0 ) ; } else { System. err. println ( \"srini_string\" + arg0 ) ; } }",
        "void function ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 < 0 ) { System. err. println ( \"srini_string\" ) ; } else if ( loc0 < 0 ) { System. err. println ( \"srini_string\" ) ; } else { System. exit ( - 1 ) ; } }",
        "void function ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 < 0 ) { System. err. println ( \"srini_string\" ) ; } else if ( loc0 < 0 ) { System. err. println ( \"srini_string\" ) ; } else { System. exit ( 0 ) ; } }",
        "void function ( File arg0 ) { if ( arg0. isDirectory ( ) ) { String [ ] loc0 = arg0. loc0 ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) ReparseDir ( loc0 [ loc1 ] ) ; } }",
        "void function ( File arg0 ) { if ( arg0. isDirectory ( ) ) { String [ ] loc0 = arg0. loc0 ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { ReparseDir ( loc0 [ loc1 ] ) ; } } }",
        "void function ( File arg0 ) { if ( arg0. isDirectory ( ) ) { String [ ] loc0 = arg0. loc0 ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) Reparse ( loc0 [ loc1 ] ) ; } }",
        "void function ( File arg0 ) { String [ ] loc0 = arg0. split ( \"srini_string\" ) ; int loc1 = loc0. length ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { reparse ( loc0 [ loc2 ] ) ; } }",
        "void function ( File arg0 ) { if ( arg0. isDirectory ( ) ) { String [ ] loc0 = arg0. loc0 ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { reparse ( loc0 [ loc1 ] ) ; } } }"
      ],
      "mid_translation": [
        "reparseCentralDirectoryData Method.",
        "ReparseCentralDirectoryData Method.",
        "Reparse Central Directory data.",
        "Reparse Central Directory information.",
        "Reparse the central directory data."
      ],
      "output": [
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( ) { try { CentralDirectoryData loc0 = new CentralDirectoryData ( ) ; loc0. parse ( ) ; } catch ( Exception loc0 ) { Logger. getLogger ( getClass ( ). getName ( ) ). log ( Level. SEVERE, \"srini_string\", loc0 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( ) { try { CentralDirectoryData loc0 = new CentralDirectoryData ( ) ; loc0. parse ( ) ; } catch ( Exception loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( String arg0 ) { try { CentralDirectoryData loc0 = new CentralDirectoryData ( arg0 ) ; return loc0 ; } catch ( Exception loc0 ) { Logger. getLogger ( getClass ( ). getName ( ) ). debug ( \"srini_string\", loc0 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( String arg0 ) { try { CentralDirectoryData loc0 = new CentralDirectoryData ( arg0 ) ; return loc0 ; } catch ( Exception loc0 ) { Logger. getLogger ( getClass ( ). getName ( ) ). debug ( \"srini_string\" + arg0 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( ) { CentralDirectoryData loc0 = null ; try { loc0 = new CentralDirectoryData ( new File ( \"srini_string\" ) ) ; } catch ( Exception loc1 ) { loc1. printStackTrace ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( ) { try { CentralDirectory loc0 = ReparseCentralDirectoryData ( new File ( \"srini_string\" ) ) ; return loc0 ; } catch ( Exception loc0 ) { Logger. getLogger ( getClass ( ). getName ( ) ). log ( Level. SEVERE, \"srini_string\", loc0 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( ) { CentralDirectoryData loc0 = ReparseCentralDirectoryData ( new File ( \"srini_string\" ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( ) { try { CentralDirectory loc0 = new CentralDirectoryData ( ) ; loc0. parse ( ) ; } catch ( Exception loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( ) { CentralDirectoryData loc0 = ReparseCentralDirectoryData ( new File ( \"srini_string\" ), new File ( \"srini_string\" ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CentralDirectoryData reparseCentralDirectoryData ( ) { try { CentralDirectory loc0 = ReparseCentralDirectoryData ( new File ( \"srini_string\" ), new File ( \"srini_string\" ) ) ; return loc0 ; } catch ( Exception loc0 ) { Throwables. propagate ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 || loc3 > loc2 ) { throw new IOException ( \"srini_string\" ) ; } arg0. read ( loc1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 ) { throw new IOException ( \"srini_string\" ) ; } arg0. read ( loc1, 0, loc3 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 ) { throw new IOException ( \"srini_string\" + loc3 ) ; } arg0. read ( loc1, 0, loc3 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 || loc3 > loc2 ) { throw new IOException ( \"srini_string\" + loc3 ) ; } arg0. read ( loc1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( InputStream arg0 ) { int loc0 = arg0. available ( ) ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. read ( ) ; if ( loc3 < 0 ) { throw new IOException ( \"srini_string\" ) ; } arg0. read ( loc1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 == - 1 ) { System. err. println ( \"srini_string\" ) ; } else { System. err. println ( \"srini_string\" + arg0. getAbsolutePath ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 < 0 ) { System. err. println ( \"srini_string\" + arg0 ) ; } else { System. err. println ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 == - 1 ) { System. err. println ( \"srini_string\" + arg0 ) ; } else { System. err. println ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 < 0 ) { System. err. println ( \"srini_string\" ) ; } else if ( loc0 < 0 ) { System. err. println ( \"srini_string\" ) ; } else { System. exit ( - 1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { int loc0 = arg0. lastIndexOf ( '/' ) ; if ( loc0 < 0 ) { System. err. println ( \"srini_string\" ) ; } else if ( loc0 < 0 ) { System. err. println ( \"srini_string\" ) ; } else { System. exit ( 0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { if ( arg0. isDirectory ( ) ) { String [ ] loc0 = arg0. loc0 ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) ReparseDir ( loc0 [ loc1 ] ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { if ( arg0. isDirectory ( ) ) { String [ ] loc0 = arg0. loc0 ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { ReparseDir ( loc0 [ loc1 ] ) ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { if ( arg0. isDirectory ( ) ) { String [ ] loc0 = arg0. loc0 ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) Reparse ( loc0 [ loc1 ] ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { String [ ] loc0 = arg0. split ( \"srini_string\" ) ; int loc1 = loc0. length ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { reparse ( loc0 [ loc2 ] ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void reparseCentralDirectoryData ( File arg0 ) { if ( arg0. isDirectory ( ) ) { String [ ] loc0 = arg0. loc0 ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { reparse ( loc0 [ loc1 ] ) ; } } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_97_/src/com/google/javascript/jscomp/PeepholeFoldConstants.java_698-699": {
      "loc": "698-699",
      "input": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt != lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt != rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Node.tokenToName(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}",
      "target": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt != lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt != rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n        long lvalLong = lvalInt & 0xffffffffL;\n        result = lvalLong >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Node.tokenToName(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}",
      "function range": "652,3-713,3",
      "raw_output": [
        "R function ( R arg0, BiFunction < R, R > arg1, R arg2 ) { R loc0 = arg0 ; arg0 = arg1. apply ( loc0, arg2 ) ; return loc0 ; }",
        "Try < R > function ( R arg0 ) { return Try ( ( ) -> arg0. fold ( ) ) ; }",
        "R function ( R arg0, BiFunction < R, R > arg1 ) { R loc0 = arg0 ; arg0 = arg1. apply ( loc0 ) ; return loc0 ; }",
        "R function ( R arg0, BiFunction < R, R > arg1 ) { R loc0 = arg0 ; arg0 = arg0. apply ( loc0, arg1 ) ; return loc0 ; }",
        "R function ( R arg0, BiFunction < R, R > arg1, R arg2 ) { R loc0 = arg0 ; arg0 = arg1. apply ( loc0, arg0 ) ; return loc0 ; }",
        "R function ( R arg0, R arg1 ) { R loc0 = arg0. fold ( ) ; arg0. fold ( ) ; return loc0 ; }",
        "R function ( R arg0 ) { return arg0. fold ( ) ; }",
        "R function ( R arg0, R arg1 ) { R loc0 = arg0 ; arg0 = arg0. fold ( ) ; arg1 = arg1. fold ( ) ; return loc0 ; }",
        "R function ( R arg0, R arg1 ) { R loc0 = arg0 ; arg0 = arg0. fold ( ) ; arg1. fold ( ) ; return loc0 ; }",
        "R function ( R arg0, R arg1 ) { return arg0. fold ( ) ; }",
        "R function ( R arg0 ) { return arg0. fold ( ) ; }",
        "R function ( R arg0, R arg1 ) { return arg0. fold ( ) ; }",
        "R function ( R arg0, R arg1 ) { return arg0. fold ( )? arg1 : arg0 ; }",
        "R function ( R arg0 ) { R loc0 = arg0. fold ( ) ; arg0. fold ( ) ; return loc0 ; }",
        "int function ( int arg0, int arg1 ) { return arg0 < 0? - arg1 : arg0 + arg1 ; }",
        "Try < R > function ( R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
        "Try < R > function ( R arg0 ) { return Try ( ( ) -> arg0. fold ( ) ) ; }",
        "Try < R > function ( R arg0, R arg1 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
        "Try < T > function ( final R arg0, final R arg1 ) { return Try. of ( ( ) -> arg0. fold ( ), arg1 ) ; }",
        "Try < R > function ( R arg0, R arg1 ) { return Try. of ( ( ) -> arg0. fold ( ), arg1 ) ; }",
        "R function ( R arg0, R arg1, R arg2 ) { R loc0 = arg0 ; R loc1 = arg1 ; for ( int loc2 = 0 ; loc2 < arg0. length ( ) ; loc2 ++ ) { loc0 = arg0 [ loc2 ] ; arg0 [ loc2 ] = loc0 ; arg1 [ loc2 ] = loc1 ; } return loc0 ; }",
        "R function ( R arg0, R arg1, R arg2 ) { R loc0 = arg0 ; R loc1 = arg1 ; for ( int loc2 = 0 ; loc2 < arg0. length ( ) ; loc2 ++ ) { loc0 = arg0 [ loc2 ] ; arg0 [ loc2 ] = loc0 ; arg0 [ loc2 ] = loc1 ; } return loc0 ; }",
        "R function ( R arg0, R arg1, R arg2 ) { R loc0 = arg0. fold ( ) ; R loc1 = arg0. fold ( ) ; R loc2 = arg0. fold ( ) ; R loc3 = arg0. fold ( ) ; return new R ( loc0, loc1, loc2, loc3 ) ; }",
        "R function ( R arg0, R arg1, R arg2 ) { R loc0 = arg0. fold ( ) ; R loc1 = arg0. fold ( ) ; R loc2 = arg0. fold ( ) ; return arg0. fold ( )? loc0 : loc1 ; }",
        "R function ( R arg0, R arg1, R arg2 ) { R loc0 = arg0 ; R loc1 = arg1 ; for ( int loc2 = 0 ; loc2 < arg0. length ( ) ; loc2 ++ ) { loc0 = arg0 [ loc2 ] ; arg0 [ loc2 ] = loc0 [ loc2 ] ; arg0 [ loc2 ] = loc1 ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Try to fold a shift.",
        "Try to fold a shift operator.",
        "Try to fold the shift operator.",
        "Try to fold a shift operation.",
        "Try to fold two shift operators."
      ],
      "output": [
        {
          "patch": "private R tryFoldShift ( R arg0, BiFunction < R, R > arg1, R arg2 ) { R loc0 = arg0 ; arg0 = arg1. apply ( loc0, arg2 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < R > tryFoldShift ( R arg0 ) { return Try ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, BiFunction < R, R > arg1 ) { R loc0 = arg0 ; arg0 = arg1. apply ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, BiFunction < R, R > arg1 ) { R loc0 = arg0 ; arg0 = arg0. apply ( loc0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, BiFunction < R, R > arg1, R arg2 ) { R loc0 = arg0 ; arg0 = arg1. apply ( loc0, arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1 ) { R loc0 = arg0. fold ( ) ; arg0. fold ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0 ) { return arg0. fold ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1 ) { R loc0 = arg0 ; arg0 = arg0. fold ( ) ; arg1 = arg1. fold ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1 ) { R loc0 = arg0 ; arg0 = arg0. fold ( ) ; arg1. fold ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1 ) { return arg0. fold ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0 ) { return arg0. fold ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1 ) { return arg0. fold ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1 ) { return arg0. fold ( )? arg1 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0 ) { R loc0 = arg0. fold ( ) ; arg0. fold ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int tryFoldShift ( int arg0, int arg1 ) { return arg0 < 0? - arg1 : arg0 + arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < R > tryFoldShift ( R arg0 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < R > tryFoldShift ( R arg0 ) { return Try ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < R > tryFoldShift ( R arg0, R arg1 ) { return Try. of ( ( ) -> arg0. fold ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < T > tryFoldShift ( final R arg0, final R arg1 ) { return Try. of ( ( ) -> arg0. fold ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Try < R > tryFoldShift ( R arg0, R arg1 ) { return Try. of ( ( ) -> arg0. fold ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1, R arg2 ) { R loc0 = arg0 ; R loc1 = arg1 ; for ( int loc2 = 0 ; loc2 < arg0. length ( ) ; loc2 ++ ) { loc0 = arg0 [ loc2 ] ; arg0 [ loc2 ] = loc0 ; arg1 [ loc2 ] = loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1, R arg2 ) { R loc0 = arg0 ; R loc1 = arg1 ; for ( int loc2 = 0 ; loc2 < arg0. length ( ) ; loc2 ++ ) { loc0 = arg0 [ loc2 ] ; arg0 [ loc2 ] = loc0 ; arg0 [ loc2 ] = loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1, R arg2 ) { R loc0 = arg0. fold ( ) ; R loc1 = arg0. fold ( ) ; R loc2 = arg0. fold ( ) ; R loc3 = arg0. fold ( ) ; return new R ( loc0, loc1, loc2, loc3 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1, R arg2 ) { R loc0 = arg0. fold ( ) ; R loc1 = arg0. fold ( ) ; R loc2 = arg0. fold ( ) ; return arg0. fold ( )? loc0 : loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R tryFoldShift ( R arg0, R arg1, R arg2 ) { R loc0 = arg0 ; R loc1 = arg1 ; for ( int loc2 = 0 ; loc2 < arg0. length ( ) ; loc2 ++ ) { loc0 = arg0 [ loc2 ] ; arg0 [ loc2 ] = loc0 [ loc2 ] ; arg0 [ loc2 ] = loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_3_/src/java/org/apache/commons/codec/language/DoubleMetaphone.java_455-456": {
      "loc": "455-456",
      "input": "private int handleG(String value, \n                    DoubleMetaphoneResult result, \n                    int index, \n                    boolean slavoGermanic) {\n    if (charAt(value, index + 1) == 'H') {\n        index = handleGH(value, result, index);\n    } else if (charAt(value, index + 1) == 'N') {\n        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n            result.append(\"KN\", \"N\");\n        } else if (!contains(value, index + 2, 2, \"EY\") && \n                   charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n            result.append(\"N\", \"KN\");\n        } else {\n            result.append(\"KN\");\n        }\n        index = index + 2;\n    } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n        result.append(\"KL\", \"L\");\n        index += 2;\n    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n        result.append('K', 'J');\n        index += 2;\n    } else if ((contains(value, index + 1, 2, \"ER\") || \n                charAt(value, index + 1) == 'Y') &&\n               !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n               !contains(value, index - 1, 1, \"E\", \"I\") && \n               !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n        result.append('K', 'J');\n        index += 2;\n    } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n               contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n        if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n            result.append('K');\n        } else if (contains(value, index + 1, 4, \"IER\")) {\n            result.append('J');\n        } else {\n            result.append('J', 'K');\n        }\n        index += 2;\n    } else if (charAt(value, index + 1) == 'G') {\n        index += 2;\n        result.append('K');\n    } else {\n        index++;\n        result.append('K');\n    }\n    return index;\n}",
      "target": "private int handleG(String value, \n                    DoubleMetaphoneResult result, \n                    int index, \n                    boolean slavoGermanic) {\n    if (charAt(value, index + 1) == 'H') {\n        index = handleGH(value, result, index);\n    } else if (charAt(value, index + 1) == 'N') {\n        if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n            result.append(\"KN\", \"N\");\n        } else if (!contains(value, index + 2, 2, \"EY\") && \n                   charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n            result.append(\"N\", \"KN\");\n        } else {\n            result.append(\"KN\");\n        }\n        index = index + 2;\n    } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n        result.append(\"KL\", \"L\");\n        index += 2;\n    } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n        result.append('K', 'J');\n        index += 2;\n    } else if ((contains(value, index + 1, 2, \"ER\") || \n                charAt(value, index + 1) == 'Y') &&\n               !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n               !contains(value, index - 1, 1, \"E\", \"I\") && \n               !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n        result.append('K', 'J');\n        index += 2;\n    } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n               contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n        if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n            result.append('K');\n        } else if (contains(value, index + 1, 3, \"IER\")) {\n            result.append('J');\n        } else {\n            result.append('J', 'K');\n        }\n        index += 2;\n    } else if (charAt(value, index + 1) == 'G') {\n        index += 2;\n        result.append('K');\n    } else {\n        index++;\n        result.append('K');\n    }\n    return index;\n}",
      "function range": "418,5-469,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_104_/src/com/google/javascript/rhino/jstype/UnionType.java_291-292": {
      "loc": "291-292",
      "input": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  if (result != null) {\n    return result;\n  } else if (this.isObject() && that.isObject()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  } else {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n}",
      "target": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n  if (!result.isNoType()) {\n    return result;\n  } else if (this.isObject() && that.isObject()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  } else {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n}",
      "function range": "273,3-298,3",
      "raw_output": [
        "org. omg. CORBA. Object function ( ) { return null ; }",
        "Meet function ( ) { return this ; }",
        "Object function ( ) { return null ; }",
        "Encounter function ( org. omg. CORBA. Object arg0 ) { return null ; }",
        "org. omg. CORBA. Object function ( Object arg0 ) { return null ; }",
        "boolean function ( IType arg0 ) { if ( arg0 instanceof ParameterizedTypeImpl ) { ParameterizedTypeImpl loc0 = ( ParameterizedTypeImpl ) arg0 ; return loc0. meet ( this ) ; } throw new ClassCastException ( \"srini_string\" + arg0. toString ( ) + \"srini_string\" ) ; }",
        "boolean function ( IType arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; if ( arg0 instanceof IType ) return true ; IType loc0 = ( IType ) arg0 ; if ( loc0 instanceof IType ) return true ; return false ; }",
        "boolean function ( Type arg0 ) { if ( arg0 instanceof ParameterizedTypeImpl ) { ParameterizedTypeImpl loc0 = ( ParameterizedTypeImpl ) arg0 ; return loc0. meet ( this ) ; } throw new ClassCastException ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
        "boolean function ( IType arg0 ) { if ( arg0 instanceof ParameterizedTypeImpl ) { ParameterizedTypeImpl loc0 = ( ParameterizedTypeImpl ) arg0 ; return ( ( ParameterizedTypeImpl ) loc0 ). getUpperBounds ( ). contains ( loc0. getUpperBounds ( ) ) ; } return false ; }",
        "boolean function ( IType arg0 ) { if ( arg0 instanceof ParameterizedTypeImpl ) { ParameterizedTypeImpl loc0 = ( ParameterizedTypeImpl ) arg0 ; return loc0. meet ( this ) ; } throw new ClassCastException ( \"srini_string\" + arg0. toString ( ) ) ; }",
        "TypeMeet function ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else { return null ; } }",
        "TypeMeet function ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else { return null ; } }",
        "TypeMeet function ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } return null ; }",
        "TypeMeet function ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else if ( arg0 instanceof TypeMeet ) { return getTypeMeet ( ( TypeMeet ) arg0 ) ; } else { return null ; } }",
        "TypeMeet function ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } if ( arg0 instanceof TypeMeet ) { return Types. erasure ( ( TypeMeet ) arg0 ) ; } return null ; }",
        "Meet function ( ) { return this ; }",
        "Meet function ( Object arg0 ) { if ( arg0 instanceof Meet ) return ( Meet ) arg0 ; return null ; }",
        "Meet function ( Object arg0 ) { return ( Meet ) arg0 ; }",
        "Meet < T > function ( T arg0 ) { return ( Meet < T > ) arg0 ; }",
        "Meet function ( ) { throw new Error ( \"srini_string\" ) ; }",
        "boolean function ( PsiElement arg0 ) { if ( arg0. getType ( ) == arg0. getType ( ) ) return true ; if ( arg0. getType ( ) == arg0. getType ( ) ) return false ; if ( arg0. getType ( ) == arg0. getType ( ) ) return true ; return false ; }",
        "boolean function ( Type arg0, Type arg1 ) { if ( arg0 == null ) return false ; if ( arg1 == null ) return true ; if ( arg0. equals ( this. getClass ( ) ) ) return true ; if ( arg1. equals ( this. getClass ( ) ) ) return true ; return false ; }",
        "boolean function ( Type arg0, Type arg1 ) { if ( arg0 == null ) return false ; if ( arg1 == null ) return true ; if ( arg0. equals ( this. getClass ( ) ) ) return true ; if ( arg0. equals ( this. getClass ( ) ) ) return true ; return false ; }",
        "boolean function ( IType arg0 ) { if ( arg0 == null ) return false ; if ( arg0. getType ( ) == this. getClass ( ) ) return true ; if ( arg0. getType ( ) == this. getClass ( ) ) return true ; return false ; }",
        "boolean function ( PsiElement arg0 ) { if ( arg0. getType ( ) == arg0. getType ( ) ) return true ; if ( arg0. getType ( ) == arg0. getType ( ) ) return true ; return false ; }"
      ],
      "mid_translation": [
        "Meet that is a subtype of this type",
        "Meet this type meet that type.",
        "Meet this type with another type.",
        "Meet that is a subtype of this.",
        "Meet this type meet another type."
      ],
      "output": [
        {
          "patch": "org. omg. CORBA. Object meet ( ) { return null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "Meet meet ( ) { return this ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object meet ( ) { return null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "Encounter meet ( org. omg. CORBA. Object arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "org. omg. CORBA. Object meet ( Object arg0 ) { return null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean meet ( IType arg0 ) { if ( arg0 instanceof ParameterizedTypeImpl ) { ParameterizedTypeImpl loc0 = ( ParameterizedTypeImpl ) arg0 ; return loc0. meet ( this ) ; } throw new ClassCastException ( \"srini_string\" + arg0. toString ( ) + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean meet ( IType arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; if ( arg0 instanceof IType ) return true ; IType loc0 = ( IType ) arg0 ; if ( loc0 instanceof IType ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean meet ( Type arg0 ) { if ( arg0 instanceof ParameterizedTypeImpl ) { ParameterizedTypeImpl loc0 = ( ParameterizedTypeImpl ) arg0 ; return loc0. meet ( this ) ; } throw new ClassCastException ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean meet ( IType arg0 ) { if ( arg0 instanceof ParameterizedTypeImpl ) { ParameterizedTypeImpl loc0 = ( ParameterizedTypeImpl ) arg0 ; return ( ( ParameterizedTypeImpl ) loc0 ). getUpperBounds ( ). contains ( loc0. getUpperBounds ( ) ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean meet ( IType arg0 ) { if ( arg0 instanceof ParameterizedTypeImpl ) { ParameterizedTypeImpl loc0 = ( ParameterizedTypeImpl ) arg0 ; return loc0. meet ( this ) ; } throw new ClassCastException ( \"srini_string\" + arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeMeet meet ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeMeet meet ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeMeet meet ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeMeet meet ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } else if ( arg0 instanceof TypeMeet ) { return getTypeMeet ( ( TypeMeet ) arg0 ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TypeMeet meet ( Type arg0 ) { if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } if ( arg0 instanceof TypeMeet ) { return ( TypeMeet ) arg0 ; } if ( arg0 instanceof TypeMeet ) { return Types. erasure ( ( TypeMeet ) arg0 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Meet meet ( ) { return this ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Meet meet ( Object arg0 ) { if ( arg0 instanceof Meet ) return ( Meet ) arg0 ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Meet meet ( Object arg0 ) { return ( Meet ) arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Meet < T > meet ( T arg0 ) { return ( Meet < T > ) arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Meet meet ( ) { throw new Error ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean meet ( PsiElement arg0 ) { if ( arg0. getType ( ) == arg0. getType ( ) ) return true ; if ( arg0. getType ( ) == arg0. getType ( ) ) return false ; if ( arg0. getType ( ) == arg0. getType ( ) ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean meet ( Type arg0, Type arg1 ) { if ( arg0 == null ) return false ; if ( arg1 == null ) return true ; if ( arg0. equals ( this. getClass ( ) ) ) return true ; if ( arg1. equals ( this. getClass ( ) ) ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean meet ( Type arg0, Type arg1 ) { if ( arg0 == null ) return false ; if ( arg1 == null ) return true ; if ( arg0. equals ( this. getClass ( ) ) ) return true ; if ( arg0. equals ( this. getClass ( ) ) ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean meet ( IType arg0 ) { if ( arg0 == null ) return false ; if ( arg0. getType ( ) == this. getClass ( ) ) return true ; if ( arg0. getType ( ) == this. getClass ( ) ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean meet ( PsiElement arg0 ) { if ( arg0. getType ( ) == arg0. getType ( ) ) return true ; if ( arg0. getType ( ) == arg0. getType ( ) ) return true ; return false ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_152_/src/com/google/javascript/rhino/jstype/FunctionType.java_871-872": {
      "loc": "871-872",
      "input": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n  return super.resolveInternal(t, scope);\n}",
      "target": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n  JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n  if (maybeTypeOfThis instanceof ObjectType) {\n    typeOfThis = (ObjectType) maybeTypeOfThis;\n  }\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n  return super.resolveInternal(t, scope);\n}",
      "function range": "861,3-892,3",
      "raw_output": [
        "PicoContainer function ( PicoContainer arg0 ) { return arg0 ; }",
        "T function ( Context arg0, Class < T > arg1 ) { return resolveInternal ( arg0, arg1 ) ; }",
        "T function ( Class < T > arg0, P arg1 ) { return resolveInternal ( arg0, arg1 ) ; }",
        "T function ( T arg0 ) { return arg0 ; }",
        "T function ( Class < T > arg0, P arg1 ) { return resolve ( arg0, arg1 ) ; }",
        "List < JSTypes > function ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( loc1. resolve ( ) ) ; } return loc0 ; }",
        "List < JSTypes > function ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
        "List < JSTypes > function ( List <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( loc1. resolve ( ) ) ; } return loc0 ; }",
        "JSTypes function ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( loc1. resolve ( ) ) ; } return loc0 ; }",
        "List < JSTypes > function ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) loc0. add ( loc1. resolve ( ) ) ; return loc0 ; }",
        "JSTypeSequence function ( Collection <? extends JSTypeSequence > arg0 ) { if ( arg0 == null ) { return null ; } for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
        "JSTypeSequence function ( List <? extends JSTypeSequence > arg0 ) { if ( arg0 == null ) { return null ; } for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
        "JSTypeSequence function ( List <? extends JSTypeSequence > arg0 ) { if ( arg0 == null ) return null ; for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
        "JSTypeSequence function ( List < JSTypeSequence > arg0 ) { if ( arg0 == null ) { return null ; } for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
        "JSTypeSequence function ( Collection <? extends JSTypeSequence > arg0 ) { if ( arg0 == null ) return null ; for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
        "List < JSTypes > function ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < JSTypes > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
        "List < JSTypes > function ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < JSTypes > function ( Collection <? extends JSTypes > arg0 ) { ArrayList < JSTypes > loc0 = new ArrayList < JSTypes > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
        "List < JSTypes > function ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( loc1. resolve ( ) ) ; } return loc0 ; }",
        "ArrayList < JSTypes > function ( Collection <? extends JSTypes > arg0 ) { ArrayList < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
        "JSTypes function ( Collection < JSTypes > arg0 ) { for ( JSTypes loc0 : arg0 ) { resolveInternal ( loc0 ) ; } return null ; }",
        "JSTypes function ( Collection < JSTypes > arg0, Context arg1 ) { for ( JSTypes loc0 : arg0 ) { resolveInternal ( loc0, arg1 ) ; } return null ; }",
        "JSTypes function ( Collection <? extends JSTypes > arg0 ) { for ( JSTypes loc0 : arg0 ) { resolveInternal ( loc0 ) ; } return null ; }",
        "JSTypes function ( Collection <? extends JSTypes > arg0, Context arg1 ) { for ( JSTypes loc0 : arg0 ) { resolveInternal ( loc0, arg1 ) ; } return null ; }",
        "JSTypes function ( Collection < JSTypes > arg0 ) { for ( JSTypes loc0 : arg0 ) { resolve ( loc0 ) ; } return null ; }"
      ],
      "mid_translation": [
        "Override resolveInternal.",
        "Resolves a sequence of JSTypes.",
        "Resolves a sequence of JSType objects.",
        "Resolve a sequence of JSTypes.",
        "Override resolveInternal in order to resolve a sequence of JSTypes."
      ],
      "output": [
        {
          "patch": "PicoContainer resolveInternal ( PicoContainer arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "T resolveInternal ( Context arg0, Class < T > arg1 ) { return resolveInternal ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "T resolveInternal ( Class < T > arg0, P arg1 ) { return resolveInternal ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "T resolveInternal ( T arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "T resolveInternal ( Class < T > arg0, P arg1 ) { return resolve ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < JSTypes > resolveInternal ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( loc1. resolve ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < JSTypes > resolveInternal ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < JSTypes > resolveInternal ( List <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( loc1. resolve ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypes resolveInternal ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( loc1. resolve ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < JSTypes > resolveInternal ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) loc0. add ( loc1. resolve ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypeSequence resolveInternal ( Collection <? extends JSTypeSequence > arg0 ) { if ( arg0 == null ) { return null ; } for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypeSequence resolveInternal ( List <? extends JSTypeSequence > arg0 ) { if ( arg0 == null ) { return null ; } for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypeSequence resolveInternal ( List <? extends JSTypeSequence > arg0 ) { if ( arg0 == null ) return null ; for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypeSequence resolveInternal ( List < JSTypeSequence > arg0 ) { if ( arg0 == null ) { return null ; } for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypeSequence resolveInternal ( Collection <? extends JSTypeSequence > arg0 ) { if ( arg0 == null ) return null ; for ( JSTypeSequence loc0 : arg0 ) { loc0. resolve ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < JSTypes > resolveInternal ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < JSTypes > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < JSTypes > resolveInternal ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "ArrayList < JSTypes > resolveInternal ( Collection <? extends JSTypes > arg0 ) { ArrayList < JSTypes > loc0 = new ArrayList < JSTypes > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < JSTypes > resolveInternal ( Collection <? extends JSTypes > arg0 ) { List < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( loc1. resolve ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "ArrayList < JSTypes > resolveInternal ( Collection <? extends JSTypes > arg0 ) { ArrayList < JSTypes > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( JSTypes loc1 : arg0 ) { loc0. add ( resolve ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypes resolveInternal ( Collection < JSTypes > arg0 ) { for ( JSTypes loc0 : arg0 ) { resolveInternal ( loc0 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypes resolveInternal ( Collection < JSTypes > arg0, Context arg1 ) { for ( JSTypes loc0 : arg0 ) { resolveInternal ( loc0, arg1 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypes resolveInternal ( Collection <? extends JSTypes > arg0 ) { for ( JSTypes loc0 : arg0 ) { resolveInternal ( loc0 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypes resolveInternal ( Collection <? extends JSTypes > arg0, Context arg1 ) { for ( JSTypes loc0 : arg0 ) { resolveInternal ( loc0, arg1 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "JSTypes resolveInternal ( Collection < JSTypes > arg0 ) { for ( JSTypes loc0 : arg0 ) { resolve ( loc0 ) ; } return null ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_9_/src/java/org/apache/commons/codec/binary/Base64.java_827-828": {
      "loc": "827-828",
      "input": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maxium size of \" +\n            maxResultSize);\n    }\n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}",
      "target": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n    long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maxium size of \" +\n            maxResultSize);\n    }\n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}",
      "function range": "822,5-837,5",
      "raw_output": [
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
        "String function ( byte [ ] arg0 ) { return encode ( arg0, 0, arg0. length ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ), \"srini_string\" ) ; }",
        "String function ( final byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ), \"srini_string\" ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encode ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
        "String function ( final byte [ ] arg0 ) { try { return new String ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( byte [ ] arg0 ) { try { return new String ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( final byte [ ] arg0 ) { try { return Base64. getEncoder ( ). encode ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( byte [ ] arg0 ) { try { return Base64. getEncoder ( ). encode ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { return new String ( encode ( arg0 ) ) ; }",
        "String function ( byte [ ] arg0 ) { try { return new String ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "String function ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ), \"srini_string\" ) ; }",
        "String function ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
        "String function ( byte [ ] arg0 ) { return encode ( arg0, 0, arg0. length ) ; }",
        "String function ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0, 0, arg0. length ) ; }",
        "String function ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
        "String function ( final byte [ ] arg0 ) { return encode ( arg0, 0, arg0. length ) ; }",
        "String function ( byte [ ] arg0, int arg1 ) { return encode ( arg0, arg1, arg0. length ) ; }"
      ],
      "mid_translation": [
        "Encode a byte array to base64.",
        "Encode binary data to base64.",
        "Encode a byte array to Base64.",
        "Encode a byte array into Base64.",
        "Encode a byte array to base 64."
      ],
      "output": [
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return encode ( arg0, 0, arg0. length ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ), \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( final byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ), \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return new String ( Base64. getEncoder ( ). encode ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encodeToString ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( final byte [ ] arg0 ) { try { return new String ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { try { return new String ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( final byte [ ] arg0 ) { try { return Base64. getEncoder ( ). encode ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { try { return Base64. getEncoder ( ). encode ( arg0 ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return new String ( encode ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { try { return new String ( arg0, \"srini_string\" ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return new String ( Base64. encodeBase64 ( arg0 ), \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return encode ( arg0, 0, arg0. length ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0, 0, arg0. length ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0 ) { return Base64. getEncoder ( ). encode ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( final byte [ ] arg0 ) { return encode ( arg0, 0, arg0. length ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String encodeBase64 ( byte [ ] arg0, int arg1 ) { return encode ( arg0, arg1, arg0. length ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_114_/src/com/google/javascript/jscomp/NameAnalyzer.java_578-579": {
      "loc": "578-579",
      "input": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
      "target": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
      "function range": "558,5-588,5",
      "raw_output": [
        "Assignment function ( PsiElement arg0, PsiElement arg1, List < R > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; arg2. add ( loc0 ) ; return loc0 ; }",
        "Assignment function ( PsiElement arg0, PsiElement arg1, Collection <? extends PsiElement > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; return loc0 ; }",
        "Assignment function ( PsiElement arg0, PsiElement arg1, Collection < R > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; arg2. add ( loc0 ) ; return loc0 ; }",
        "Assignment function ( PsiElement arg0, PsiElement arg1, Collection < R > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; return loc0 ; }",
        "Assignment function ( PsiElement arg0, PsiElement arg1, List < R > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; return loc0 ; }",
        "Assignment function ( String arg0, A arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "Assignment function ( String arg0, T arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "Assignment function ( P arg0, R arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "Assignment function ( AssignmentType arg0, A arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
        "Assignment function ( AssignmentType arg0, A arg1 ) { return new Assignment ( arg0. toString ( ), arg1. toString ( ) ) ; }",
        "Assignment function ( String arg0, T arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "Assignment function ( String arg0, Object... arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "Assignment function ( String arg0, R arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "Assignment function ( String arg0, A arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "Assignment function ( String arg0, String arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "Assignment function ( AssignmentType arg0, T arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
        "Assignment function ( AssignmentType arg0, Item arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
        "Assignment function ( AssignmentType arg0, P arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
        "Assignment function ( AssignmentType arg0, A arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
        "Assignment function ( AssignmentType arg0, AssignmentValue arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
        "NameAssignment function ( String arg0, int arg1 ) { return new NameAssignment ( arg0, arg1 ) ; }",
        "Assignment function ( String arg0, String arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "NameAssignment function ( String arg0, String arg1 ) { return new NameAssignment ( arg0, arg1 ) ; }",
        "Assignment function ( String arg0, A arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
        "NameAssignment function ( String arg0, int arg1, int arg2 ) { return new NameAssignment ( arg0, arg1, arg2 ) ; }"
      ],
      "mid_translation": [
        "Records an assignment.",
        "Record an assignment.",
        "Record a single assignment.",
        "Records a single assignment.",
        "Record a name assignment."
      ],
      "output": [
        {
          "patch": "private Assignment recordAssignment ( PsiElement arg0, PsiElement arg1, List < R > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; arg2. add ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( PsiElement arg0, PsiElement arg1, Collection <? extends PsiElement > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( PsiElement arg0, PsiElement arg1, Collection < R > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; arg2. add ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( PsiElement arg0, PsiElement arg1, Collection < R > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( PsiElement arg0, PsiElement arg1, List < R > arg2 ) { Assignment loc0 = new Assignment ( arg0, arg1, arg2 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( String arg0, A arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( String arg0, T arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( P arg0, R arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( AssignmentType arg0, A arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( AssignmentType arg0, A arg1 ) { return new Assignment ( arg0. toString ( ), arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( String arg0, T arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( String arg0, Object... arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( String arg0, R arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( String arg0, A arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( String arg0, String arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( AssignmentType arg0, T arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( AssignmentType arg0, Item arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( AssignmentType arg0, P arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( AssignmentType arg0, A arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( AssignmentType arg0, AssignmentValue arg1 ) { return new Assignment ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NameAssignment recordAssignment ( String arg0, int arg1 ) { return new NameAssignment ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( String arg0, String arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NameAssignment recordAssignment ( String arg0, String arg1 ) { return new NameAssignment ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Assignment recordAssignment ( String arg0, A arg1 ) { Assignment loc0 = new Assignment ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NameAssignment recordAssignment ( String arg0, int arg1, int arg2 ) { return new NameAssignment ( arg0, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_27_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_133-134": {
      "loc": "133-134",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); \n    }\n    return result;\n}",
      "target": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); \n    }\n    return result;\n}",
      "function range": "102,5-150,5",
      "raw_output": [
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } arg0 [ arg1 + loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return arg2 + loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } else if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) ; } return loc0 ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = 'a' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '7' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { loc0 [ arg1 + loc1 ] -='' ; } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] ='' ; } } return new String ( loc0 ) ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { break ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Parse an octal value from the byte array.",
        "Parse an octal value from a byte array.",
        "Parse an octal string from the byte array.",
        "Parse an octal from the byte array.",
        "Parses an octal value from the byte array."
      ],
      "output": [
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } arg0 [ arg1 + loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return arg2 + loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } else if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = 'a' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '7' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { loc0 [ arg1 + loc1 ] -='' ; } } return new String ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] ='' ; } } return new String ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_40_src/com/google/javascript/jscomp/NameAnalyzer.java_635-636": {
      "loc": "635-636",
      "input": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns != null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns != null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, false);\n      if (name != null) {\n      refNodes.add(new ClassDefiningFunctionNode(\n          name, n, parent, parent.getParent()));\n      }\n    }\n  }\n}",
      "target": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns != null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns != null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null && ns.onlyAffectsClassDef) {\n      JsName name = getName(ns.name, true);\n      refNodes.add(new ClassDefiningFunctionNode(\n          name, n, parent, parent.getParent()));\n    }\n  }\n}",
      "function range": "595,5-642,5",
      "raw_output": [
        "IDE function ( ) { return new IDE ( ) ; }",
        "IDE. Delete function ( ) { return new Delete ( ) ; }",
        "IDE function ( ) { return new DummyIDE ( ) ; }",
        "IDE function ( ) { return new ComboBoxIDE ( ) ; }",
        "IDE function ( ) { return new DefaultIDE ( ) ; }",
        "void function ( Tree arg0, int arg1 ) { }",
        "void function ( Tree arg0 ) { }",
        "void function ( int arg0, int arg1 ) { }",
        "void function ( TreePath arg0, int arg1 ) { }",
        "void function ( ASTNode arg0, int arg1 ) { }",
        "void function ( Tree arg0, int arg1 ) { }",
        "void function ( Tree arg0, int arg1, int arg2 ) { }",
        "void function ( Tree arg0 ) { }",
        "void function ( TreeNode arg0 ) { }",
        "void function ( Tree arg0, int arg1, Object arg2 ) { }",
        "void function ( Configuration arg0 ) { }",
        "void function ( OutputStream arg0 ) { }",
        "void function ( Context arg0 ) { }",
        "void function ( PicoContainer arg0 ) { }",
        "void function ( World arg0, int arg1 ) { }",
        "void function ( ASTNode arg0 ) { }",
        "void function ( ASTNode arg0, int arg1 ) { }",
        "void function ( Tree arg0, int arg1 ) { }",
        "void function ( int arg0, int arg1 ) { }",
        "void function ( GUID arg0, int arg1 ) { }"
      ],
      "mid_translation": [
        "Override the default implementation of the IDE.",
        "This method is called for every node in the tree that is being visited.",
        "This method is called for every node in the tree.",
        "Override the default implementation of this class.",
        "This method is called for every node in the tree that is a CID."
      ],
      "output": [
        {
          "patch": "@Override\npublic IDE visit ( ) { return new IDE ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic IDE. Delete visit ( ) { return new Delete ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic IDE visit ( ) { return new DummyIDE ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic IDE visit ( ) { return new ComboBoxIDE ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic IDE visit ( ) { return new DefaultIDE ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( Tree arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( Tree arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( int arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( TreePath arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( ASTNode arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( Tree arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( Tree arg0, int arg1, int arg2 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( Tree arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( TreeNode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( Tree arg0, int arg1, Object arg2 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( Configuration arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( OutputStream arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( Context arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( PicoContainer arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( World arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( ASTNode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( ASTNode arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( Tree arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( int arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void visit ( GUID arg0, int arg1 ) { }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_12_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java_198-199": {
      "loc": "198-199",
      "input": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n    if (currEntry.isPaxHeader()){ \n        paxHeaders();\n    }\n    if (currEntry.isGNUSparse()){ \n        readGNUSparse();\n    }\n    entrySize = currEntry.getSize();\n    return currEntry;\n}",
      "target": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        IOException ioe = new IOException(\"Error detected parsing the header\");\n        ioe.initCause(e);\n        throw ioe;\n    }\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n    if (currEntry.isPaxHeader()){ \n        paxHeaders();\n    }\n    if (currEntry.isGNUSparse()){ \n        readGNUSparse();\n    }\n    entrySize = currEntry.getSize();\n    return currEntry;\n}",
      "function range": "172,5-238,5",
      "raw_output": [
        "TarArchiveEntry function ( TarArchiveInputStream arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( ) ) { arg0. next ( ) ; loc0 = arg0. getNextEntry ( ) ; } return loc0 ; }",
        "TarArchiveEntry function ( TarArchiveInputStream arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( ) ) { arg0. next ( ) ; loc0 = arg0. next ( ) ; } return loc0 ; }",
        "Object function ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; if ( loc0 == null ) { throw new NoSuchElementException ( \"srini_string\" ) ; } return loc0. getNextEntry ( ) ; }",
        "TarArchiveEntry function ( TarArchiveInputStream arg0 ) { arg0. reset ( ) ; TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. closeEntry ( ) ; return loc0 ; }",
        "TarArchiveEntry function ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. setNextEntry ( null ) ; arg0. setPreviousEntry ( null ) ; return loc0 ; }",
        "TarEntry function ( TarFile arg0 ) { TarEntry loc0 = arg0. getTar ( ) ; arg0. setTar ( null ) ; while ( loc0. next!= null ) { arg0 = loc0. next ; } return loc0 ; }",
        "TarEntry function ( TarFile arg0 ) { if ( arg0. hasNext ( ) ) { arg0 = arg0. getNext ( ) ; } else if ( arg0. hasNext ( ) ) { arg0 = arg0. getNext ( ) ; } return arg0 ; }",
        "TarEntry function ( TarFile arg0 ) { TarEntry loc0 = arg0. getTar ( ) ; arg0. setTar ( null ) ; while ( loc0!= null ) { arg0 = loc0. getNext ( ) ; } return loc0 ; }",
        "TarEntry function ( TarFile arg0 ) { TarEntry loc0 = arg0. getTar ( ) ; arg0. setTar ( null ) ; while ( loc0!= null ) { arg0 = loc0. next ; } return loc0 ; }",
        "TarEntry function ( TarFile arg0 ) { TarEntry loc0 = arg0. getTar ( ) ; arg0. setTar ( null ) ; while ( loc0!= null ) { arg0 = loc0. getNextEntry ( ) ; } return loc0 ; }",
        "ArchiveEntry function ( TarArchive arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( TarArchiveEntry. class ) ) { arg0. next ( TarArchiveEntry. class ) ; loc0 = arg0. next ( TarArchiveEntry. class ) ; } return loc0 ; }",
        "Object function ( TarArchive arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( TarArchiveEntry. class ) ) { arg0. next ( TarArchiveEntry. class ) ; loc0 = arg0. getNextEntry ( TarArchiveEntry. class ) ; } return loc0 ; }",
        "ArchiveEntry function ( TarArchive arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( TarArchiveEntry. class ) ) { arg0. next ( TarArchiveEntry. class ) ; loc0 = arg0. getNext ( TarArchiveEntry. class ) ; } return loc0 ; }",
        "Object function ( TarArchive arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( TarArchiveEntry. class ) ) { arg0. next ( TarArchiveEntry. class ) ; loc0 = arg0. next ( TarArchiveEntry. class ) ; } return loc0 ; }",
        "TarArchiveEntry function ( TarArchive arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; if ( loc0 == null ) { throw new NoSuchElementException ( \"srini_string\" ) ; } return loc0 ; }",
        "TarArchiveEntry function ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. setNextEntry ( null ) ; return loc0 ; }",
        "TarArchiveEntry function ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. setNextEntry ( null ) ; arg0. setPreviousEntry ( null ) ; return loc0 ; }",
        "TarArchiveEntry function ( TarArchiveInputStream arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( ) ) { arg0. next ( ) ; loc0 = arg0. getNextEntry ( ) ; } return loc0 ; }",
        "TarArchiveEntry function ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. setPreviousEntry ( null ) ; arg0. setNextEntry ( null ) ; return loc0 ; }",
        "TarArchiveEntry function ( TarArchiveInputStream arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. closeEntry ( ) ; return loc0 ; }",
        "TarEntry function ( TarFile arg0 ) { TarEntry loc0 = arg0. getNextEntry ( ) ; if ( loc0 == null ) { throw new NoSuchElementException ( \"srini_string\" ) ; } return loc0 ; }",
        "TarEntry function ( TarFile arg0 ) { try { arg0 = arg0. getNextEntry ( ) ; } catch ( IOException loc0 ) { throw new RuntimeException ( loc0. getMessage ( ), loc0 ) ; } return arg0 ; }",
        "TarEntry function ( TarFile arg0 ) { try { arg0 = arg0. getNextEntry ( ) ; } catch ( IOException loc0 ) { throw new RuntimeException ( loc0 ) ; } arg0. closeEntry ( ) ; return arg0 ; }",
        "TarEntry function ( TarFile arg0 ) { try { arg0 = arg0. getNextEntry ( ) ; } catch ( IOException loc0 ) { throw new RuntimeException ( loc0. getMessage ( ), loc0 ) ; } }",
        "TarEntry function ( TarFile arg0 ) { TarEntry loc0 = arg0. getNextEntry ( ) ; if ( loc0 == null ) { throw new NoSuchElementException ( ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Get the next TarArchiveEntry.",
        "Get the next tar entry.",
        "Get the next TarArchiveEntry in the archive.",
        "Gets the next TarArchiveEntry.",
        "Gets the next tar entry."
      ],
      "output": [
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchiveInputStream arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( ) ) { arg0. next ( ) ; loc0 = arg0. getNextEntry ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchiveInputStream arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( ) ) { arg0. next ( ) ; loc0 = arg0. next ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object getNextTarEntry ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; if ( loc0 == null ) { throw new NoSuchElementException ( \"srini_string\" ) ; } return loc0. getNextEntry ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchiveInputStream arg0 ) { arg0. reset ( ) ; TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. closeEntry ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. setNextEntry ( null ) ; arg0. setPreviousEntry ( null ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { TarEntry loc0 = arg0. getTar ( ) ; arg0. setTar ( null ) ; while ( loc0. next!= null ) { arg0 = loc0. next ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { if ( arg0. hasNext ( ) ) { arg0 = arg0. getNext ( ) ; } else if ( arg0. hasNext ( ) ) { arg0 = arg0. getNext ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { TarEntry loc0 = arg0. getTar ( ) ; arg0. setTar ( null ) ; while ( loc0!= null ) { arg0 = loc0. getNext ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { TarEntry loc0 = arg0. getTar ( ) ; arg0. setTar ( null ) ; while ( loc0!= null ) { arg0 = loc0. next ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { TarEntry loc0 = arg0. getTar ( ) ; arg0. setTar ( null ) ; while ( loc0!= null ) { arg0 = loc0. getNextEntry ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ArchiveEntry getNextTarEntry ( TarArchive arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( TarArchiveEntry. class ) ) { arg0. next ( TarArchiveEntry. class ) ; loc0 = arg0. next ( TarArchiveEntry. class ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object getNextTarEntry ( TarArchive arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( TarArchiveEntry. class ) ) { arg0. next ( TarArchiveEntry. class ) ; loc0 = arg0. getNextEntry ( TarArchiveEntry. class ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ArchiveEntry getNextTarEntry ( TarArchive arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( TarArchiveEntry. class ) ) { arg0. next ( TarArchiveEntry. class ) ; loc0 = arg0. getNext ( TarArchiveEntry. class ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object getNextTarEntry ( TarArchive arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( TarArchiveEntry. class ) ) { arg0. next ( TarArchiveEntry. class ) ; loc0 = arg0. next ( TarArchiveEntry. class ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchive arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; if ( loc0 == null ) { throw new NoSuchElementException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. setNextEntry ( null ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. setNextEntry ( null ) ; arg0. setPreviousEntry ( null ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchiveInputStream arg0 ) { TarArchiveEntry loc0 = null ; while ( arg0. hasNext ( ) ) { arg0. next ( ) ; loc0 = arg0. getNextEntry ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchiveEntry arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. setPreviousEntry ( null ) ; arg0. setNextEntry ( null ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarArchiveEntry getNextTarEntry ( TarArchiveInputStream arg0 ) { TarArchiveEntry loc0 = arg0. getNextEntry ( ) ; arg0. closeEntry ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { TarEntry loc0 = arg0. getNextEntry ( ) ; if ( loc0 == null ) { throw new NoSuchElementException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { try { arg0 = arg0. getNextEntry ( ) ; } catch ( IOException loc0 ) { throw new RuntimeException ( loc0. getMessage ( ), loc0 ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { try { arg0 = arg0. getNextEntry ( ) ; } catch ( IOException loc0 ) { throw new RuntimeException ( loc0 ) ; } arg0. closeEntry ( ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { try { arg0 = arg0. getNextEntry ( ) ; } catch ( IOException loc0 ) { throw new RuntimeException ( loc0. getMessage ( ), loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public TarEntry getNextTarEntry ( TarFile arg0 ) { TarEntry loc0 = arg0. getNextEntry ( ) ; if ( loc0 == null ) { throw new NoSuchElementException ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_11_/src/main/java/org/apache/commons/csv/CSVParser.java_384-385": {
      "loc": "384-385",
      "input": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}",
      "target": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header == null || header.trim().isEmpty();\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n    }\n    return hdrMap;\n}",
      "function range": "359,5-394,5",
      "raw_output": [
        "void function ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( HttpServletResponse. SC_OK ) ; arg0. setContentLength ( 0 ) ; }",
        "void function ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( HttpServletResponse. SC_INTERNAL_SERVER_ERROR ) ; }",
        "void function ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( HttpServletResponse. SC_OK ) ; }",
        "void function ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( SC_INTERNAL_SERVER_ERROR ) ; }",
        "void function ( StaplerRequest arg0, StaplerResponse arg1 ) { }",
        "void function ( OutputStream arg0 ) { }",
        "void function ( JFrame arg0 ) { }",
        "void function ( Map arg0 ) { }",
        "void function ( final JFrame arg0 ) { }",
        "void function ( URL arg0, String arg1 ) { }",
        "void function ( final HttpParams arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } this. arg0 = arg0 ; }",
        "void function ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( HttpServletResponse. SC_OK ) ; }",
        "void function ( OutputStream arg0 ) { }",
        "void function ( final HttpParams arg0 ) { }",
        "void function ( StaplerRequest arg0, StaplerResponse arg1 ) { }",
        "void function ( Map < String, String > arg0 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { String loc2 = arg0. get ( loc1 ) ; String loc3 = arg0. get ( loc2 ) ; arg0. put ( loc2, loc3 ) ; } }",
        "void function ( Map < String, String > arg0 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { String loc2 = arg0. get ( loc1 ) ; String loc3 = arg0. get ( loc1 ) ; arg0. put ( loc2, loc3 ) ; } }",
        "void function ( Map arg0 ) { }",
        "void function ( Map < String, String > arg0 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { String loc2 = arg0. get ( loc1 ) ; String loc3 = arg0. get ( loc1 ) ; arg0. put ( loc1, loc2 ) ; } }",
        "void function ( Map arg0 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { String loc2 = arg0. get ( loc1 ) ; String loc3 = arg0. get ( loc1 ) ; arg0. put ( loc1, loc2 ) ; } }",
        "HeaderMap function ( ) { return new HeaderMap ( ) ; }",
        "HeaderMap function ( Configuration arg0 ) { return new HeaderMap ( arg0 ) ; }",
        "HeaderMap function ( Map < String, String > arg0 ) { return new HeaderMap ( arg0 ) ; }",
        "HeaderMap function ( Map arg0 ) { return new HeaderMap ( arg0 ) ; }",
        "void function ( Map arg0 ) { }"
      ],
      "mid_translation": [
        "Initialize header.",
        "Initialize the header.",
        "Initializes the header.",
        "Initialize the header map.",
        "Initialize header map."
      ],
      "output": [
        {
          "patch": "private void initializeHeader ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( HttpServletResponse. SC_OK ) ; arg0. setContentLength ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( HttpServletResponse. SC_INTERNAL_SERVER_ERROR ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( HttpServletResponse. SC_OK ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( SC_INTERNAL_SERVER_ERROR ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( StaplerRequest arg0, StaplerResponse arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( OutputStream arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( JFrame arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( Map arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( final JFrame arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( URL arg0, String arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( final HttpParams arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } this. arg0 = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( StaplerRequest arg0, StaplerResponse arg1 ) { arg1. setStatus ( HttpServletResponse. SC_OK ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( OutputStream arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( final HttpParams arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( StaplerRequest arg0, StaplerResponse arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( Map < String, String > arg0 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { String loc2 = arg0. get ( loc1 ) ; String loc3 = arg0. get ( loc2 ) ; arg0. put ( loc2, loc3 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( Map < String, String > arg0 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { String loc2 = arg0. get ( loc1 ) ; String loc3 = arg0. get ( loc1 ) ; arg0. put ( loc2, loc3 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( Map arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( Map < String, String > arg0 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { String loc2 = arg0. get ( loc1 ) ; String loc3 = arg0. get ( loc1 ) ; arg0. put ( loc1, loc2 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( Map arg0 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { String loc2 = arg0. get ( loc1 ) ; String loc3 = arg0. get ( loc1 ) ; arg0. put ( loc1, loc2 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private HeaderMap initializeHeader ( ) { return new HeaderMap ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private HeaderMap initializeHeader ( Configuration arg0 ) { return new HeaderMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private HeaderMap initializeHeader ( Map < String, String > arg0 ) { return new HeaderMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private HeaderMap initializeHeader ( Map arg0 ) { return new HeaderMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void initializeHeader ( Map arg0 ) { }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_23_/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java_112-113": {
      "loc": "112-113",
      "input": "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] << (8 * i));\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}",
      "target": "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n        dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n    }\n    if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n}",
      "function range": "106,9-118,9",
      "raw_output": [
        "boolean function ( byte [ ] arg0 ) { return decode ( arg0 ) ; }",
        "Buffer function ( BinaryBitmap arg0 ) { return null ; }",
        "boolean function ( byte [ ] arg0 ) { return decode ( arg0, ( int ) arg0. length ) ; }",
        "boolean function ( byte [ ] arg0 ) { return decode ( arg0, 0, arg0. length ) ; }",
        "boolean function ( byte [ ] arg0, int arg1 ) { return decode ( arg0, arg1 ) ; }",
        "LZMAInputStream function ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMACodec loc1 = LZMACodec. getInstance ( ) ; loc1. decode ( arg0 ) ; return loc0 ; }",
        "LZMAInputStream function ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMACodec loc1 = LZMACodec. getInstance ( ) ; loc0. decode ( arg0 ) ; return loc0 ; }",
        "LZMAInputStream function ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = new LZMAInputStream ( loc0 ) ; return loc1 ; }",
        "LZMAInputStream function ( final Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = ( LZMAInputStream ) decode ( arg0 ) ; return loc0 ; }",
        "LZMAInputStream function ( Coder arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMACodec loc1 = LZMACodec. getInstance ( ) ; loc1. decode ( arg0 ) ; return loc0 ; }",
        "LZMAInputStream function ( final Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = ( LZMAInputStream ) decode ( arg0 ) ; return loc0 ; }",
        "LZMAInputStream function ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = new LZMAInputStream ( loc0 ) ; return loc1 ; }",
        "LZMAInputStream function ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = ( LZMAInputStream ) decode ( arg0 ) ; return loc0 ; }",
        "LZMAInputStream function ( final Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = new LZMAInputStream ( loc0 ) ; return loc1 ; }",
        "LZMAInputStream function ( final Coder arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = ( LZMAInputStream ) decode ( arg0 ) ; return loc0 ; }",
        "Object function ( Object arg0 ) { if ( arg0 instanceof ByteArrayInputStream ) { ByteArrayInputStream loc0 = ( ByteArrayInputStream ) arg0 ; return decode ( loc0 ) ; } else if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else { throw new DecoderException ( \"srini_string\" ) ; } }",
        "Object function ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof ByteArrayInputStream ) { ByteArrayInputStream loc0 = ( ByteArrayInputStream ) arg0 ; return decode ( loc0 ) ; } else { throw new DecoderException ( \"srini_string\" + arg0. getClass ( ). getName ( ), loc0 ) ; } }",
        "Object function ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else { throw new DecoderException ( \"srini_string\" ) ; } }",
        "Object function ( Object arg0 ) { if ( arg0 == null ) { return null ; } else if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else { throw new DecoderException ( \"srini_string\" ) ; } }",
        "Object function ( Object arg0 ) { if ( arg0 instanceof ByteArrayInputStream ) { ByteArrayInputStream loc0 = ( ByteArrayInputStream ) arg0 ; return decode ( loc0 ) ; } else if ( arg0 instanceof Coder ) { return ( Coder ) arg0 ; } else { throw new DecoderException ( \"srini_string\" ) ; } }",
        "InputStream function ( Coder arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0. decode ( ) ; }",
        "InputStream function ( Coder arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0. getInputStream ( ) ; }",
        "InputStream function ( Coder arg0 ) { ByteArrayOutputStream loc0 = new ByteArrayOutputStream ( ) ; arg0. decode ( loc0 ) ; return loc0. toByteArray ( ) ; }",
        "InputStream function ( Coder arg0 ) { if ( arg0 == null ) { return null ; } else { return arg0. getInputStream ( ) ; } }",
        "InputStream function ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. decode ( ) ; }"
      ],
      "mid_translation": [
        "Implementation of the decode method.",
        "Decode a Coder object into an LZMAInputStream.",
        "Decode a Coder object into a LZMAInputStream.",
        "Decode a Coder object into a Coder object.",
        "Decode a Coder object into an input stream."
      ],
      "output": [
        {
          "patch": "boolean decode ( byte [ ] arg0 ) { return decode ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Buffer decode ( BinaryBitmap arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean decode ( byte [ ] arg0 ) { return decode ( arg0, ( int ) arg0. length ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean decode ( byte [ ] arg0 ) { return decode ( arg0, 0, arg0. length ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean decode ( byte [ ] arg0, int arg1 ) { return decode ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMACodec loc1 = LZMACodec. getInstance ( ) ; loc1. decode ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMACodec loc1 = LZMACodec. getInstance ( ) ; loc0. decode ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = new LZMAInputStream ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( final Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = ( LZMAInputStream ) decode ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( Coder arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMACodec loc1 = LZMACodec. getInstance ( ) ; loc1. decode ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( final Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = ( LZMAInputStream ) decode ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = new LZMAInputStream ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = ( LZMAInputStream ) decode ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( final Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = new LZMAInputStream ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "LZMAInputStream decode ( final Coder arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } LZMAInputStream loc0 = new LZMAInputStream ( ) ; LZMAInputStream loc1 = ( LZMAInputStream ) decode ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object decode ( Object arg0 ) { if ( arg0 instanceof ByteArrayInputStream ) { ByteArrayInputStream loc0 = ( ByteArrayInputStream ) arg0 ; return decode ( loc0 ) ; } else if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else { throw new DecoderException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object decode ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof ByteArrayInputStream ) { ByteArrayInputStream loc0 = ( ByteArrayInputStream ) arg0 ; return decode ( loc0 ) ; } else { throw new DecoderException ( \"srini_string\" + arg0. getClass ( ). getName ( ), loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object decode ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else { throw new DecoderException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object decode ( Object arg0 ) { if ( arg0 == null ) { return null ; } else if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else if ( arg0 instanceof ByteArrayInputStream ) { return decode ( ( ByteArrayInputStream ) arg0 ) ; } else { throw new DecoderException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object decode ( Object arg0 ) { if ( arg0 instanceof ByteArrayInputStream ) { ByteArrayInputStream loc0 = ( ByteArrayInputStream ) arg0 ; return decode ( loc0 ) ; } else if ( arg0 instanceof Coder ) { return ( Coder ) arg0 ; } else { throw new DecoderException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "InputStream decode ( Coder arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0. decode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "InputStream decode ( Coder arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0. getInputStream ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "InputStream decode ( Coder arg0 ) { ByteArrayOutputStream loc0 = new ByteArrayOutputStream ( ) ; arg0. decode ( loc0 ) ; return loc0. toByteArray ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "InputStream decode ( Coder arg0 ) { if ( arg0 == null ) { return null ; } else { return arg0. getInputStream ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "InputStream decode ( Coder arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. decode ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_14_/src/main/java/org/apache/commons/csv/CSVFormat.java_1039-1040": {
      "loc": "1039-1040",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n    if (!quote) {\n        out.append(value, start, end);\n        return;\n    }\n    out.append(quoteChar);\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            out.append(value, start, pos + 1);\n            start = pos;\n        }\n        pos++;\n    }\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
      "target": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n    if (!quote) {\n        out.append(value, start, end);\n        return;\n    }\n    out.append(quoteChar);\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            out.append(value, start, pos + 1);\n            start = pos;\n        }\n        pos++;\n    }\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
      "function range": "1001,5-1106,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Gson_10_/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java_122-124": {
      "loc": "122-124",
      "input": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  TypeAdapter t =\n    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}",
      "target": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n  TypeAdapter t = jsonAdapterPresent ? typeAdapter\n      : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}",
      "function range": "118,7-125,7",
      "raw_output": [
        "void function ( JSONWriter arg0, Object arg1 ) { arg0. writeObject ( arg1 ) ; }",
        "void function ( JSONWriter arg0, Object arg1 ) { arg0. write ( arg1. toString ( ) ) ; }",
        "void function ( JSONWriter arg0, Object arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
        "void function ( JSONWriter arg0, Object arg1 ) { if ( arg1 == null ) { arg0. writeNull ( ) ; } else { arg0. write ( arg1. toString ( ) ) ; } }",
        "void function ( Writer arg0, Object arg1 ) { if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } arg0. write ( arg1. toString ( ) ) ; }",
        "void function ( Object arg0, Writer arg1 ) { arg1. write ( arg0 ) ; }",
        "void function ( Writer arg0, Object arg1 ) { arg0. write ( arg1. getClass ( ). getName ( ) ) ; arg0. write ( arg1. toString ( ) ) ; }",
        "void function ( Object arg0, Writer arg1 ) { arg1. write ( arg0. toString ( ) ) ; }",
        "void function ( Object arg0, Writer arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg1. write ( arg0 ) ; }",
        "void function ( Object arg0, Writer arg1 ) { arg1. write ( arg0. getClass ( ). getName ( ) ) ; arg1. write ( arg0. toString ( ) ) ; }",
        "void function ( Writer arg0, T arg1 ) { arg0. write_long ( arg1. longValue ( ) ) ; }",
        "void function ( Writer arg0, T arg1 ) { arg0. write ( arg1. toString ( ) ) ; }",
        "void function ( Writer arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
        "void function ( Writer arg0, float arg1 ) { arg0. writeFloat ( arg1 ) ; }",
        "void function ( Writer arg0, long arg1 ) { arg0. write_long ( arg1 ) ; }",
        "void function ( JSONWriter arg0, Object arg1 ) { arg0. writeObject ( arg1 ) ; }",
        "void function ( JSONWriter arg0, Object arg1 ) { if ( arg1 == null ) { arg0. writeNull ( ) ; } else { arg0. writeObject ( arg1 ) ; } }",
        "void function ( JSONWriter arg0, Object arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
        "void function ( JSONWriter arg0, Object arg1 ) { arg0. write ( arg1. toString ( ) ) ; }",
        "void function ( Writer arg0, Object arg1 ) { arg0. write ( arg1. toString ( ) ) ; }",
        "void function ( Object arg0, Writer arg1 ) { arg1. write_long ( arg0. hashCode ( ) ) ; }",
        "void function ( Object arg0, Writer arg1 ) { arg1. write ( arg0 ) ; }",
        "void function ( Object arg0, Writer arg1 ) { arg1. writeObject ( arg0 ) ; }",
        "void function ( Object arg0, Writer arg1 ) { arg1. write ( arg0. getClass ( ). getName ( ) ) ; }",
        "void function ( Object arg0, Writer arg1 ) { arg1. writeVInt ( arg0. hashCode ( ) ) ; }"
      ],
      "mid_translation": [
        "Write an object to a JSON writer.",
        "Write an object to a writer.",
        "Write a value to a writer.",
        "Write an object to the JSON writer.",
        "Write an object to the writer."
      ],
      "output": [
        {
          "patch": "void @SuppressWarnings ( JSONWriter arg0, Object arg1 ) { arg0. writeObject ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( JSONWriter arg0, Object arg1 ) { arg0. write ( arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( JSONWriter arg0, Object arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( JSONWriter arg0, Object arg1 ) { if ( arg1 == null ) { arg0. writeNull ( ) ; } else { arg0. write ( arg1. toString ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Writer arg0, Object arg1 ) { if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } arg0. write ( arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Object arg0, Writer arg1 ) { arg1. write ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Writer arg0, Object arg1 ) { arg0. write ( arg1. getClass ( ). getName ( ) ) ; arg0. write ( arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Object arg0, Writer arg1 ) { arg1. write ( arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Object arg0, Writer arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg1. write ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Object arg0, Writer arg1 ) { arg1. write ( arg0. getClass ( ). getName ( ) ) ; arg1. write ( arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Writer arg0, T arg1 ) { arg0. write_long ( arg1. longValue ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Writer arg0, T arg1 ) { arg0. write ( arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Writer arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Writer arg0, float arg1 ) { arg0. writeFloat ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Writer arg0, long arg1 ) { arg0. write_long ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( JSONWriter arg0, Object arg1 ) { arg0. writeObject ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( JSONWriter arg0, Object arg1 ) { if ( arg1 == null ) { arg0. writeNull ( ) ; } else { arg0. writeObject ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( JSONWriter arg0, Object arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( JSONWriter arg0, Object arg1 ) { arg0. write ( arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Writer arg0, Object arg1 ) { arg0. write ( arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Object arg0, Writer arg1 ) { arg1. write_long ( arg0. hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Object arg0, Writer arg1 ) { arg1. write ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Object arg0, Writer arg1 ) { arg1. writeObject ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Object arg0, Writer arg1 ) { arg1. write ( arg0. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void @SuppressWarnings ( Object arg0, Writer arg1 ) { arg1. writeVInt ( arg0. hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Gson_17_/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java_99-101": {
      "loc": "99-101",
      "input": "@Override\npublic Date read(JsonReader in) throws IOException {\n  if (in.peek() != JsonToken.STRING) {\n    throw new JsonParseException(\"The date should be a string value\");\n  }\n  Date date = deserializeToDate(in.nextString());\n  if (dateType == Date.class) {\n    return date;\n  } else if (dateType == Timestamp.class) {\n    return new Timestamp(date.getTime());\n  } else if (dateType == java.sql.Date.class) {\n    return new java.sql.Date(date.getTime());\n  } else {\n    throw new AssertionError();\n  }\n}",
      "target": "@Override\npublic Date read(JsonReader in) throws IOException {\n  if (in.peek() == JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  Date date = deserializeToDate(in.nextString());\n  if (dateType == Date.class) {\n    return date;\n  } else if (dateType == Timestamp.class) {\n    return new Timestamp(date.getTime());\n  } else if (dateType == java.sql.Date.class) {\n    return new java.sql.Date(date.getTime());\n  } else {\n    throw new AssertionError();\n  }\n}",
      "function range": "97,3-113,3",
      "raw_output": [
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } if ( loc0 == null ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } if ( loc0 == null ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } finally { if ( loc0 == null ) { loc0 = new Date ( ) ; } } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } finally { if ( loc0 == null ) { loc0 = new Date ( ) ; } } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new JsonException ( loc1 ) ; } if ( loc0 == null ) { throw new JsonParseException ( \"srini_string\" ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( IOException loc1 ) { throw new JsonException ( loc1 ) ; } if ( loc0 == null ) { throw new JsonParseException ( \"srini_string\" ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readNull ( ) ; } catch ( IOException loc1 ) { throw new JsonException ( loc1 ) ; } if ( loc0 == null ) { throw new JsonParseException ( \"srini_string\" ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { if ( arg0 == null ) { return null ; } Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( DateParseException loc1 ) { throw new JsonException ( loc1 ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } if ( loc0 == null ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readNumber ( ) ; } catch ( NumberFormatException loc1 ) { throw new IOException ( loc1. getMessage ( ) ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( IOException loc1 ) { throw new JsonException ( loc1 ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( DateParseException loc1 ) { throw new JsonException ( loc1 ) ; } return loc0 ; }",
        "Date function ( JsonReader arg0 ) { try { return arg0. readNumber ( ) ; } catch ( NumberFormatException loc0 ) { throw new IOException ( loc0. getMessage ( ) ) ; } }",
        "Date function ( JsonReader arg0 ) { if ( arg0 == null ) { return null ; } Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( DateParseException loc1 ) { throw new JsonException ( loc1 ) ; } return loc0 ; }",
        "Date function ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new RuntimeException ( \"srini_string\" + loc1. getMessage ( ) ) ; } return loc0 ; }",
        "Date function ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new RuntimeException ( loc1. getMessage ( ) ) ; } return loc0 ; }",
        "Date function ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new RuntimeException ( \"srini_string\", loc1 ) ; } return loc0 ; }",
        "Date function ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new IOException ( \"srini_string\" + loc1. getMessage ( ) ) ; } return loc0 ; }",
        "Date function ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new ParserException ( \"srini_string\" + loc1. getMessage ( ) ) ; } return loc0 ; }",
        "Date function ( java. io. InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. deserialize ( arg0 ) ; } catch ( java. io. IOException loc1 ) { throw new RuntimeException ( loc1. getMessage ( ) ) ; } return loc0 ; }",
        "Date function ( java. io. InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. deserialize ( arg0 ) ; } catch ( java. io. IOException loc1 ) { throw new RuntimeException ( \"srini_string\" + arg0, loc1 ) ; } return loc0 ; }",
        "Date function ( java. io. InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateHelper. deserialize ( arg0 ) ; } catch ( java. io. IOException loc1 ) { throw new RuntimeException ( loc1. getMessage ( ) ) ; } return loc0 ; }",
        "Date function ( StreamInput arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( NumberFormatException loc1 ) { throw new IOException ( \"srini_string\" = \"srini_string\" ) ; } return loc0 ; }",
        "Date function ( java. io. InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. parseDate ( arg0 ) ; } catch ( java. io. UnsupportedEncodingException loc1 ) { throw new RuntimeException ( loc1. toString ( ) ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Deserialize a Date from a JsonReader.",
        "Deserialize a Date from the given JsonReader.",
        "Reads a Date from the given JsonReader.",
        "Reads a date from the input stream.",
        "Deserialize a date from the input stream."
      ],
      "output": [
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } if ( loc0 == null ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } if ( loc0 == null ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } finally { if ( loc0 == null ) { loc0 = new Date ( ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } finally { if ( loc0 == null ) { loc0 = new Date ( ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new JsonException ( loc1 ) ; } if ( loc0 == null ) { throw new JsonParseException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( IOException loc1 ) { throw new JsonException ( loc1 ) ; } if ( loc0 == null ) { throw new JsonParseException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readNull ( ) ; } catch ( IOException loc1 ) { throw new JsonException ( loc1 ) ; } if ( loc0 == null ) { throw new JsonParseException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { if ( arg0 == null ) { return null ; } Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( DateParseException loc1 ) { throw new JsonException ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readBoolean ( ) ; } catch ( IOException loc1 ) { throw new SerializationException ( loc1 ) ; } if ( loc0 == null ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readNumber ( ) ; } catch ( NumberFormatException loc1 ) { throw new IOException ( loc1. getMessage ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( IOException loc1 ) { throw new JsonException ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( DateParseException loc1 ) { throw new JsonException ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { try { return arg0. readNumber ( ) ; } catch ( NumberFormatException loc0 ) { throw new IOException ( loc0. getMessage ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( JsonReader arg0 ) { if ( arg0 == null ) { return null ; } Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( DateParseException loc1 ) { throw new JsonException ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new RuntimeException ( \"srini_string\" + loc1. getMessage ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new RuntimeException ( loc1. getMessage ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new RuntimeException ( \"srini_string\", loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new IOException ( \"srini_string\" + loc1. getMessage ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. read ( arg0 ) ; } catch ( IOException loc1 ) { throw new ParserException ( \"srini_string\" + loc1. getMessage ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( java. io. InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. deserialize ( arg0 ) ; } catch ( java. io. IOException loc1 ) { throw new RuntimeException ( loc1. getMessage ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( java. io. InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. deserialize ( arg0 ) ; } catch ( java. io. IOException loc1 ) { throw new RuntimeException ( \"srini_string\" + arg0, loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( java. io. InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateHelper. deserialize ( arg0 ) ; } catch ( java. io. IOException loc1 ) { throw new RuntimeException ( loc1. getMessage ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( StreamInput arg0 ) { Date loc0 = null ; try { loc0 = arg0. readDate ( ) ; } catch ( NumberFormatException loc1 ) { throw new IOException ( \"srini_string\" = \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Date read ( java. io. InputStream arg0 ) { Date loc0 = null ; try { loc0 = DateUtils. parseDate ( arg0 ) ; } catch ( java. io. UnsupportedEncodingException loc1 ) { throw new RuntimeException ( loc1. toString ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_11_/src/com/google/javascript/jscomp/TypeCheck.java_1314-1316": {
      "loc": "1314-1316",
      "input": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (n.getJSType() != null && parent.isAssign()) {\n    return;\n  } else if (validator.expectNotNullOrUndefined(t, n, childType,\n      \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n    checkPropertyAccess(childType, property.getString(), t, n);\n  }\n  ensureTyped(t, n);\n}",
      "target": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (validator.expectNotNullOrUndefined(t, n, childType,\n      \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n    checkPropertyAccess(childType, property.getString(), t, n);\n  }\n  ensureTyped(t, n);\n}",
      "function range": "1303,3-1321,3",
      "raw_output": [
        "R function ( GetPropStmt arg0 ) { R loc0 = arg0. getLastChild ( ) ; R loc1 = loc0. getValue ( ) ; return loc1 ; }",
        "R function ( GetPROP arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
        "R function ( GetPropTree arg0 ) { R loc0 = arg0. getLastChild ( ) ; R loc1 = arg0. getLastChild ( ) ; return loc0 ; }",
        "R function ( GetPROP arg0 ) { R loc0 = arg0. getProperty ( ) ; return loc0 ; }",
        "R function ( GetPropContext arg0 ) { R loc0 = arg0. getProperty ( ) ; return loc0 ; }",
        "R function ( GetPropStmt arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
        "R function ( GetPropTree arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
        "void function ( GetPropStmt arg0 ) { }",
        "R function ( GetPROP arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
        "R function ( GetPropStmt arg0 ) { R loc0 = arg0. getRprop ( ) ; return loc0 ; }",
        "PROP function ( GetPropRequest arg0 ) { return arg0. getProperty ( ) ; }",
        "PROP function ( GetPropRequest arg0 ) { return arg0. getNode ( ) ; }",
        "PROP function ( GetPropContext arg0 ) { return arg0. getProperty ( ) ; }",
        "PROP function ( GetPROP arg0 ) { return arg0 ; }",
        "PROP function ( GetProp arg0 ) { return arg0 ; }",
        "T function ( Class < T > arg0 ) { return arg0. cast ( ) ; }",
        "T function ( Class < T > arg0 ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
        "T function ( Class < T > arg0 ) { try { return arg0. cast ( ) ; } catch ( ClassCastException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
        "T function ( Class < T > arg0, T arg1 ) { return arg0. cast ( arg1 ) ; }",
        "T function ( Class < T > arg0 ) { try { return arg0. cast ( ) ; } catch ( ClassCastException loc0 ) { throw new ClassCastException ( loc0 ) ; } }",
        "GetPROP function ( GetPROP arg0 ) { return arg0 ; }",
        "GETPROP function ( GetPROP arg0 ) { return arg0 ; }",
        "GetPROP function ( GetPROP arg0 ) { throw new UnsupportedOperationException ( ) ; }",
        "T function ( T arg0 ) { return arg0 ; }",
        "GetPROP function ( GetPROPRequest arg0 ) { return arg0 ; }"
      ],
      "mid_translation": [
        "Visits a GETPROP node.",
        "Visit a GETPROP node.",
        "Visits GETPROP node.",
        "Visits GETPROP.",
        "Visits GETPROP nodes."
      ],
      "output": [
        {
          "patch": "private R visitGetProp ( GetPropStmt arg0 ) { R loc0 = arg0. getLastChild ( ) ; R loc1 = loc0. getValue ( ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitGetProp ( GetPROP arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitGetProp ( GetPropTree arg0 ) { R loc0 = arg0. getLastChild ( ) ; R loc1 = arg0. getLastChild ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitGetProp ( GetPROP arg0 ) { R loc0 = arg0. getProperty ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitGetProp ( GetPropContext arg0 ) { R loc0 = arg0. getProperty ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitGetProp ( GetPropStmt arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitGetProp ( GetPropTree arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitGetProp ( GetPropStmt arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitGetProp ( GetPROP arg0 ) { R loc0 = arg0. getRPROP ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitGetProp ( GetPropStmt arg0 ) { R loc0 = arg0. getRprop ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PROP visitGetProp ( GetPropRequest arg0 ) { return arg0. getProperty ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PROP visitGetProp ( GetPropRequest arg0 ) { return arg0. getNode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PROP visitGetProp ( GetPropContext arg0 ) { return arg0. getProperty ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PROP visitGetProp ( GetPROP arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PROP visitGetProp ( GetProp arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T visitGetProp ( Class < T > arg0 ) { return arg0. cast ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T visitGetProp ( Class < T > arg0 ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T visitGetProp ( Class < T > arg0 ) { try { return arg0. cast ( ) ; } catch ( ClassCastException loc0 ) { throw new RuntimeException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T visitGetProp ( Class < T > arg0, T arg1 ) { return arg0. cast ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T visitGetProp ( Class < T > arg0 ) { try { return arg0. cast ( ) ; } catch ( ClassCastException loc0 ) { throw new ClassCastException ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private GetPROP visitGetProp ( GetPROP arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private GETPROP visitGetProp ( GetPROP arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private GetPROP visitGetProp ( GetPROP arg0 ) { throw new UnsupportedOperationException ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T visitGetProp ( T arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private GetPROP visitGetProp ( GetPROPRequest arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_15_/src/main/java/org/apache/commons/csv/CSVFormat.java_1189-1190": {
      "loc": "1189-1190",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n    if (!quote) {\n        out.append(value, start, end);\n        return;\n    }\n    out.append(quoteChar);\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            out.append(value, start, pos + 1);\n            start = pos;\n        }\n        pos++;\n    }\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
      "target": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            if (c <= COMMENT) {\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n    if (!quote) {\n        out.append(value, start, end);\n        return;\n    }\n    out.append(quoteChar);\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            out.append(value, start, pos + 1);\n            start = pos;\n        }\n        pos++;\n    }\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
      "function range": "1151,5-1256,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Codec_18_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_81-82": {
      "loc": "81-82",
      "input": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n}",
      "target": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n    return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n}",
      "function range": "71,5-82,5",
      "raw_output": [
        "boolean function ( CS1 arg0, CS2 arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CS1 arg0, CS2 arg1 ) { if ( arg0 == arg1 ) { return true ; } if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CS1 arg0, CS2 arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg2 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CS1 arg0, CS2 arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getClass ( )!= arg1. getClass ( ) ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CS1 arg0, CS2 arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 == null || arg1 == null ) { return false ; } else { return arg0. equals ( arg1 ) ; } }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null || arg1 == null || arg0. length ( ) == 0 || arg1. length ( ) == 0 ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null && arg1 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null || arg1 == null || arg0. length ( ) == 0 || arg1. length ( ) == 0 ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. equals ( arg1 ) ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. equals ( arg1 ) ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }"
      ],
      "mid_translation": [
        "Returns true if cs1 equals cs2.",
        "Checks if two CharSequences are equal.",
        "Checks if two CharSequences are equals.",
        "Check if two CharSequences are equal.",
        "Returns true if two CharSequences are equal."
      ],
      "output": [
        {
          "patch": "public static boolean equals ( CS1 arg0, CS2 arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( CS1 arg0, CS2 arg1 ) { if ( arg0 == arg1 ) { return true ; } if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( CS1 arg0, CS2 arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg2 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( CS1 arg0, CS2 arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getClass ( )!= arg1. getClass ( ) ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( CS1 arg0, CS2 arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 == null || arg1 == null ) { return false ; } else { return arg0. equals ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null || arg1 == null || arg0. length ( ) == 0 || arg1. length ( ) == 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null && arg1 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null || arg1 == null || arg0. length ( ) == 0 || arg1. length ( ) == 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. equals ( arg1 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. equals ( arg1 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( CharSequence arg0, CharSequence arg1 ) { if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Gson_13_/gson/src/main/java/com/google/gson/stream/JsonReader.java_731-732": {
      "loc": "731-732",
      "input": "private int peekNumber() throws IOException {\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n  long value = 0; \n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n  int i = 0;\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; \n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}",
      "target": "private int peekNumber() throws IOException {\n  char[] buffer = this.buffer;\n  int p = pos;\n  int l = limit;\n  long value = 0; \n  boolean negative = false;\n  boolean fitsInLong = true;\n  int last = NUMBER_CHAR_NONE;\n  int i = 0;\n  charactersOfNumber:\n  for (; true; i++) {\n    if (p + i == l) {\n      if (i == buffer.length) {\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p = pos;\n      l = limit;\n    }\n    char c = buffer[p + i];\n    switch (c) {\n    case '-':\n      if (last == NUMBER_CHAR_NONE) {\n        negative = true;\n        last = NUMBER_CHAR_SIGN;\n        continue;\n      } else if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n    case '+':\n      if (last == NUMBER_CHAR_EXP_E) {\n        last = NUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n      return PEEKED_NONE;\n    case 'e':\n    case 'E':\n      if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n        last = NUMBER_CHAR_EXP_E;\n        continue;\n      }\n      return PEEKED_NONE;\n    case '.':\n      if (last == NUMBER_CHAR_DIGIT) {\n        last = NUMBER_CHAR_DECIMAL;\n        continue;\n      }\n      return PEEKED_NONE;\n    default:\n      if (c < '0' || c > '9') {\n        if (!isLiteral(c)) {\n          break charactersOfNumber;\n        }\n        return PEEKED_NONE;\n      }\n      if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n        value = -(c - '0');\n        last = NUMBER_CHAR_DIGIT;\n      } else if (last == NUMBER_CHAR_DIGIT) {\n        if (value == 0) {\n          return PEEKED_NONE; \n        }\n        long newValue = value * 10 - (c - '0');\n        fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n            || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n        value = newValue;\n      } else if (last == NUMBER_CHAR_DECIMAL) {\n        last = NUMBER_CHAR_FRACTION_DIGIT;\n      } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n        last = NUMBER_CHAR_EXP_DIGIT;\n      }\n    }\n  }\n  if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n    peekedLong = negative ? value : -value;\n    pos += i;\n    return peeked = PEEKED_LONG;\n  } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n      || last == NUMBER_CHAR_EXP_DIGIT) {\n    peekedNumberLength = i;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}",
      "function range": "641,3-742,3",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_8_/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java_307-308": {
      "loc": "307-308",
      "input": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    if (!_hasSegments)  return _currentSegment;\n    return contentsAsArray();\n}",
      "target": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n    if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n    return contentsAsArray();\n}",
      "function range": "298,5-310,5",
      "raw_output": [
        "JTextBuffer function ( final JTextArea arg0 ) { if ( arg0 == null ) { return null ; } return arg0. getTextBuffer ( ) ; }",
        "JTextBuffer function ( final JEditorPane arg0 ) { return arg0. getTextBuffer ( ) ; }",
        "JTextBuffer function ( final JTextArea arg0 ) { return arg0. getTextBuffer ( ) ; }",
        "JTextBuffer function ( final JEditorPane arg0 ) { if ( arg0 == null ) { return null ; } return arg0. getTextBuffer ( ) ; }",
        "JTextBuffer function ( final JTextArea arg0 ) { if ( arg0 == null ) { return null ; } else { return arg0. getTextBuffer ( ) ; } }",
        "Buffer function ( final Graphics arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, false ) ; }",
        "JTextBuffer function ( final JEditorPane arg0 ) { return arg0. getTextBuffer ( ) ; }",
        "Buffer function ( final Graphics arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, 0 ) ; }",
        "Buffer function ( final JEditorPane arg0 ) { return arg0. getTextBuffer ( ) ; }",
        "Buffer function ( final Graphics arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, null ) ; }",
        "CharSequence function ( final int arg0, final int arg1, final int arg2 ) { return new TextBuffer ( arg0, arg1, arg2 ) ; }",
        "CharSequence function ( final int arg0, final int arg1 ) { return new TextBuffer ( arg0, arg1 ) ; }",
        "CharSequence function ( final int arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, false ) ; }",
        "CharSequence function ( final int arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, 0 ) ; }",
        "CharSequence function ( final int arg0, final int arg1 ) { return new TextView ( arg0, arg1 ) ; }",
        "char [ ] function ( ) { return toString ( 0, length ( ) ) ; }",
        "char [ ] function ( ) { return CharBuffer. allocate ( ). toString ( ) ; }",
        "char [ ] function ( ) { return this. buffer. toCharArray ( ) ; }",
        "char [ ] function ( ) { return new String ( ). toCharArray ( ) ; }",
        "char [ ] function ( ) { return ( char [ ] ) data. clone ( ) ; }",
        "char [ ] function ( ) { return new String ( ). toCharArray ( ) ; }",
        "char [ ] function ( ) { return CharBuffer. allocate ( 4096 ). toString ( ) ; }",
        "char [ ] function ( ) { return this. buffer. toCharArray ( ) ; }",
        "char [ ] function ( ) { return new String ( this. buffer ). toCharArray ( ) ; }",
        "char [ ] function ( ) { return toString ( 0 ). toCharArray ( ) ; }"
      ],
      "mid_translation": [
        "Gets the text buffer.",
        "Get the text buffer.",
        "Returns the text buffer.",
        "Returns a char array containing the contents of this buffer.",
        "Returns a char array containing the contents of the input buffer."
      ],
      "output": [
        {
          "patch": "public JTextBuffer getTextBuffer ( final JTextArea arg0 ) { if ( arg0 == null ) { return null ; } return arg0. getTextBuffer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JTextBuffer getTextBuffer ( final JEditorPane arg0 ) { return arg0. getTextBuffer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JTextBuffer getTextBuffer ( final JTextArea arg0 ) { return arg0. getTextBuffer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JTextBuffer getTextBuffer ( final JEditorPane arg0 ) { if ( arg0 == null ) { return null ; } return arg0. getTextBuffer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JTextBuffer getTextBuffer ( final JTextArea arg0 ) { if ( arg0 == null ) { return null ; } else { return arg0. getTextBuffer ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Buffer getTextBuffer ( final Graphics arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public JTextBuffer getTextBuffer ( final JEditorPane arg0 ) { return arg0. getTextBuffer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Buffer getTextBuffer ( final Graphics arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Buffer getTextBuffer ( final JEditorPane arg0 ) { return arg0. getTextBuffer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Buffer getTextBuffer ( final Graphics arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CharSequence getTextBuffer ( final int arg0, final int arg1, final int arg2 ) { return new TextBuffer ( arg0, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CharSequence getTextBuffer ( final int arg0, final int arg1 ) { return new TextBuffer ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CharSequence getTextBuffer ( final int arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CharSequence getTextBuffer ( final int arg0, final int arg1, final int arg2 ) { return getTextBuffer ( arg0, arg1, arg2, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CharSequence getTextBuffer ( final int arg0, final int arg1 ) { return new TextView ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return toString ( 0, length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return CharBuffer. allocate ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return this. buffer. toCharArray ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return new String ( ). toCharArray ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return ( char [ ] ) data. clone ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return new String ( ). toCharArray ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return CharBuffer. allocate ( 4096 ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return this. buffer. toCharArray ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return new String ( this. buffer ). toCharArray ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public char [ ] getTextBuffer ( ) { return toString ( 0 ). toCharArray ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_130_/src/com/google/javascript/jscomp/CollapseProperties.java_172-173": {
      "loc": "172-173",
      "input": "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (name.globalSets == 1 && name.localSets == 0 &&\n        name.aliasingGets > 0) {\n      List<Ref> refs = Lists.newArrayList(name.getRefs());\n      for (Ref ref : refs) {\n        if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n          if (inlineAliasIfPossible(ref, namespace)) {\n            name.removeRef(ref);\n          }\n        }\n      }\n    }\n    if ((name.type == Name.Type.OBJECTLIT ||\n         name.type == Name.Type.FUNCTION) &&\n        name.aliasingGets == 0 && name.props != null) {\n      workList.addAll(name.props);\n    }\n  }\n}",
      "target": "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n        name.aliasingGets > 0) {\n      List<Ref> refs = Lists.newArrayList(name.getRefs());\n      for (Ref ref : refs) {\n        if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n          if (inlineAliasIfPossible(ref, namespace)) {\n            name.removeRef(ref);\n          }\n        }\n      }\n    }\n    if ((name.type == Name.Type.OBJECTLIT ||\n         name.type == Name.Type.FUNCTION) &&\n        name.aliasingGets == 0 && name.props != null) {\n      workList.addAll(name.props);\n    }\n  }\n}",
      "function range": "161,3-197,3",
      "raw_output": [
        "void function ( String arg0, Map < String, String > arg1 ) { arg1. put ( \"srini_string\", arg0 ) ; arg1. put ( \"srini_string\", arg0 ) ; }",
        "String function ( String arg0, String arg1 ) { return \"srini_string\". concat ( arg0, arg1 ) ; }",
        "String function ( String arg0 ) { return \"srini_string\". concat ( arg0 ) ; }",
        "void function ( String arg0, Map < String, String > arg1 ) { arg1. put ( \"srini_string\", arg0 ) ; }",
        "void function ( Map < String, String > arg0, Map < String, String > arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
        "void function ( Map < String, String > arg0, String arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
        "void function ( Map < String, String > arg0, Map < String, String > arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { return arg0 ; }",
        "String function ( String arg0, String arg1 ) { return \"srini_string\". concat ( arg0, arg1 ) ; }",
        "void function ( Map < String, String > arg0 ) { arg0. put ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { return \"srini_string\". concat ( arg0 ) ; }",
        "String function ( String arg0, String arg1 ) { return \"srini_string\". concat ( arg0 ) ; }",
        "String function ( String arg0, String arg1 ) { return \"srini_string\". concat ( arg0, arg1 ) ; }",
        "String function ( String arg0, String arg1 ) { return arg0 + \"srini_string\" + arg1 ; }",
        "String function ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "List < T > function ( List < T > arg0 ) { return arg0 ; }",
        "List < String > function ( List < String > arg0 ) { return arg0 ; }",
        "void function ( @ NotNull VirtualFile arg0, @ NotNull VirtualFile arg1, @ NotNull VirtualFile arg2 ) { }",
        "Map < String, Object > function ( Map < String, Object > arg0 ) { return arg0 ; }",
        "void function ( @ NotNull VirtualFile arg0, @ NotNull VirtualFile arg1 ) { }",
        "void function ( Map < String, String > arg0 ) { arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }",
        "void function ( Map < String, String > arg0 ) { arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Inline aliases in a global namespace.",
        "Inline aliases in the global namespace.",
        "Inline aliases for a global namespace.",
        "Inline aliases.",
        "Inline aliases in a global namespace"
      ],
      "output": [
        {
          "patch": "private void inlineAliases ( String arg0, Map < String, String > arg1 ) { arg1. put ( \"srini_string\", arg0 ) ; arg1. put ( \"srini_string\", arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String inlineAliases ( String arg0, String arg1 ) { return \"srini_string\". concat ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String inlineAliases ( String arg0 ) { return \"srini_string\". concat ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inlineAliases ( String arg0, Map < String, String > arg1 ) { arg1. put ( \"srini_string\", arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inlineAliases ( Map < String, String > arg0, Map < String, String > arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inlineAliases ( Map < String, String > arg0, String arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inlineAliases ( Map < String, String > arg0, Map < String, String > arg1 ) { arg0. put ( \"srini_string\", arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, String > inlineAliases ( Map < String, String > arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String inlineAliases ( String arg0, String arg1 ) { return \"srini_string\". concat ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inlineAliases ( Map < String, String > arg0 ) { arg0. put ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String inlineAliases ( String arg0 ) { return \"srini_string\". concat ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String inlineAliases ( String arg0, String arg1 ) { return \"srini_string\". concat ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String inlineAliases ( String arg0, String arg1 ) { return \"srini_string\". concat ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String inlineAliases ( String arg0, String arg1 ) { return arg0 + \"srini_string\" + arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String inlineAliases ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < T > inlineAliases ( List < T > arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < String > inlineAliases ( List < String > arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inlineAliases ( @ NotNull VirtualFile arg0, @ NotNull VirtualFile arg1, @ NotNull VirtualFile arg2 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, Object > inlineAliases ( Map < String, Object > arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inlineAliases ( @ NotNull VirtualFile arg0, @ NotNull VirtualFile arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inlineAliases ( Map < String, String > arg0 ) { arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, String > inlineAliases ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, String > inlineAliases ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inlineAliases ( Map < String, String > arg0 ) { arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; arg0. put ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, String > inlineAliases ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; for ( Map. Entry < String, String > loc1 : arg0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; loc0. put ( loc2, loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_31_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_134-135": {
      "loc": "134-135",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte == 0) {\n            break;\n        }\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); \n    }\n    return result;\n}",
      "target": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); \n    }\n    return result;\n}",
      "function range": "101,5-148,5",
      "raw_output": [
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } arg0 [ arg1 + loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return arg2 + loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } else if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { break ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 ++ ; } } return loc0 ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = 'a' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '7' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { loc0 [ arg1 + loc1 ] -='' ; } } return new String ( loc0 ) ; }",
        "String function ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] ='' ; } } return new String ( loc0 ) ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Parse an octal value from the byte array.",
        "Parse an octal value from a byte array.",
        "Parse an octal from the byte array.",
        "Parse an octal string from the byte array.",
        "Parses an octal value from the byte array."
      ],
      "output": [
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 |= 0x80 ; } } if ( arg1 < arg2 + loc0 ) { loc0 |= 0x80 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + \"srini_string\" ) ; } arg0 [ arg1 + loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return arg2 + loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 [ arg1 + loc1 ] + \"srini_string\" ) ; } else if ( arg0 [ arg1 + loc1 ] < 0 || arg0 [ arg1 + loc1 ] > 0x7F ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7f ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = 'a' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '7' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { break ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] >='' ) { loc0 [ arg1 + loc1 ] -='' ; } } return new String ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { char [ ] loc0 = new char [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] = '0' ; } else if ( arg0 [ arg1 + loc1 ] <'' ) { loc0 [ arg1 + loc1 ] ='' ; } } return new String ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F ) { loc0 |= 0x80 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int parseOctal ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { loc0 ++ ; } else if ( arg0 [ arg1 + loc1 ] & 0x80 ) { loc0 |= 0x80 ; } else if ( arg0 [ arg1 + loc1 ] & 0x7F == 0 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_159_/src/com/google/javascript/jscomp/InlineFunctions.java_777-781": {
      "loc": "777-781",
      "input": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed != null);\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
      "target": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed != null);\n  if (node.getType() == Token.NAME) {\n    if (isCandidateUsage(node)) {\n      changed.add(node.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}",
      "function range": "773,3-787,3",
      "raw_output": [
        "Map < String, Function > function ( Map < String, Function > arg0 ) { Map < String, Function > loc0 = new HashMap < String, Function > ( ) ; for ( Map. Entry < String, Function > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; return loc0 ; }",
        "Map < String, Function > function ( Map < String, Function > arg0 ) { Map < String, Function > loc0 = new HashMap < String, Function > ( ) ; for ( Map. Entry < String, Function > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < String, Function > function ( Map < String, Function > arg0 ) { Map < String, Function > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, Function > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; return loc0 ; }",
        "Map < String, Function > function ( Map < String, Function > arg0 ) { Map < String, Function > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, Function > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toString ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "List < Function > function ( List < Function > arg0 ) { List < Function > loc0 = Lists. newArrayList ( ) ; for ( Function loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < FunctionCallExpression > function ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { FunctionCallExpression loc2 = ( FunctionCallExpression ) loc1 ; while ( loc2!= null ) { loc0. add ( loc2. getFunction ( ) ) ; } } return loc0 ; }",
        "List < FunctionCallExpression > function ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { FunctionCallExpression loc2 = ( FunctionCallExpression ) loc1 ; while ( loc2!= null ) { loc0. add ( loc2. getFunction ( ) ) ; } } return loc0 ; }",
        "List < FunctionCallExpression > function ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( isCall ( loc1 ) ) { loc0. add ( loc1. getFunction ( ) ) ; } } return loc0 ; }",
        "List < FunctionCallExpression > function ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( loc1 instanceof FunctionCallExpression ) { loc0. add ( ( FunctionCallExpression ) loc1 ) ; } } return loc0 ; }",
        "List < FunctionCallExpression > function ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( isCall ( loc1 ) ) { loc0. add ( loc1. getFunction ( ) ) ; } } return loc0 ; }",
        "List < Callable < T >> function ( Callable < T > arg0 ) { List < Callable < T >> loc0 = Iterables. transform ( arg0, new Function < T, R > ( ) { @ Override public T apply ( T arg1 ) throws Exception { return arg1 ; } } ) ; return loc0 ; }",
        "List < Callable < T >> function ( Callable < T > arg0 ) { List < Callable < T >> loc0 = Iterables. transform ( arg0, new Function < T, R > ( ) { @ Override public T apply ( T arg1 ) throws Exception { return arg1. call ( ) ; } } ) ; return loc0 ; }",
        "List < Callable < T >> function ( Callable < T > arg0, List < Callable < T >> arg1 ) { List < Callable < T >> loc0 = Iterables. transform ( arg0, new Function < T, R > ( ) { @ Override public T apply ( T arg2 ) throws Exception { return arg1. get ( 0 ) ; } } ) ; return loc0 ; }",
        "List < Callable < T >> function ( Callable < T > arg0, List < Callable < T >> arg1 ) { List < Callable < T >> loc0 = Iterables. transform ( arg0, new Function < T, R > ( ) { @ Override public R apply ( T arg2 ) throws Exception { return arg1 ; } } ) ; return loc0 ; }",
        "List < Callable < T >> function ( Callable < T > arg0 ) { List < Callable < T >> loc0 = Iterables. transform ( arg0, new Function < T, R > ( ) { @ Override public T apply ( T arg1, R arg2 ) throws Exception { return arg1 ; } } ) ; return loc0 ; }",
        "List < FunctionCallExpression > function ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getFunctionCount ( ) ; loc1 ++ ) { loc0. add ( arg0. getFunction ( loc1 ) ) ; } return loc0 ; }",
        "List < FunctionCallExpression > function ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getFunctionCount ( ) ; loc1 ++ ) { loc0. add ( arg0. getFunction ( loc1 ) ) ; } return loc0 ; }",
        "List < FunctionCallExpression > function ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { loc0. add ( loc1. getFunction ( ) ) ; } return loc0 ; }",
        "List < FunctionCallExpression > function ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { loc0. add ( loc1. getFunction ( ) ) ; } return loc0 ; }",
        "List < FunctionCallExpression > function ( FunctionCallExpression arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { loc0. add ( loc1. getFunction ( ) ) ; } return loc0 ; }",
        "List < FunctionCallExpression > function ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( loc1 instanceof FunctionCallExpression ) { loc0. add ( ( FunctionCallExpression ) loc1 ) ; } } return loc0 ; }",
        "List < FunctionCallExpression > function ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getFirstChild ( ) ) { if ( loc1 instanceof FunctionCallExpression ) { loc0. add ( ( FunctionCallExpression ) loc1 ) ; } } return loc0 ; }",
        "List < FunctionCallExpression > function ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getFirstChild ( ) ) { if ( loc1 instanceof FunctionCallExpression ) loc0. add ( ( FunctionCallExpression ) loc1 ) ; } return loc0 ; }",
        "List < FunctionCallExpression > function ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( loc1 instanceof FunctionCallExpression ) loc0. add ( ( FunctionCallExpression ) loc1 ) ; } return loc0 ; }",
        "List < FunctionCallExpression > function ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getFirstChild ( ) ) { if ( loc1 instanceof FunctionCallExpression ) loc0. add ( ( FunctionCallExpression ) loc1 ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Find called functions.",
        "Find called functions in a node.",
        "Recursively find called functions.",
        "Find called functions of a node.",
        "Find called functions from a node."
      ],
      "output": [
        {
          "patch": "private Map < String, Function > findCalledFunctions ( Map < String, Function > arg0 ) { Map < String, Function > loc0 = new HashMap < String, Function > ( ) ; for ( Map. Entry < String, Function > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, Function > findCalledFunctions ( Map < String, Function > arg0 ) { Map < String, Function > loc0 = new HashMap < String, Function > ( ) ; for ( Map. Entry < String, Function > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, Function > findCalledFunctions ( Map < String, Function > arg0 ) { Map < String, Function > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, Function > loc1 : arg0. entrySet ( ) ) loc0. put ( loc1. getKey ( ). toLowerCase ( ), loc1. getValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Map < String, Function > findCalledFunctions ( Map < String, Function > arg0 ) { Map < String, Function > loc0 = new HashMap < > ( ) ; for ( Map. Entry < String, Function > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ). toString ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < Function > findCalledFunctions ( List < Function > arg0 ) { List < Function > loc0 = Lists. newArrayList ( ) ; for ( Function loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { FunctionCallExpression loc2 = ( FunctionCallExpression ) loc1 ; while ( loc2!= null ) { loc0. add ( loc2. getFunction ( ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { FunctionCallExpression loc2 = ( FunctionCallExpression ) loc1 ; while ( loc2!= null ) { loc0. add ( loc2. getFunction ( ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( isCall ( loc1 ) ) { loc0. add ( loc1. getFunction ( ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( loc1 instanceof FunctionCallExpression ) { loc0. add ( ( FunctionCallExpression ) loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( isCall ( loc1 ) ) { loc0. add ( loc1. getFunction ( ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T findCalledFunctions ( T arg1 ) throws Exception { return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T findCalledFunctions ( T arg1 ) throws Exception { return arg1. call ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T findCalledFunctions ( T arg2 ) throws Exception { return arg1. get ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R findCalledFunctions ( T arg2 ) throws Exception { return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T findCalledFunctions ( T arg1, R arg2 ) throws Exception { return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getFunctionCount ( ) ; loc1 ++ ) { loc0. add ( arg0. getFunction ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getFunctionCount ( ) ; loc1 ++ ) { loc0. add ( arg0. getFunction ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { loc0. add ( loc1. getFunction ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { loc0. add ( loc1. getFunction ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( FunctionCallExpression arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { loc0. add ( loc1. getFunction ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( loc1 instanceof FunctionCallExpression ) { loc0. add ( ( FunctionCallExpression ) loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getFirstChild ( ) ) { if ( loc1 instanceof FunctionCallExpression ) { loc0. add ( ( FunctionCallExpression ) loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getFirstChild ( ) ) { if ( loc1 instanceof FunctionCallExpression ) loc0. add ( ( FunctionCallExpression ) loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( Node arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getNextSibling ( ) ) { if ( loc1 instanceof FunctionCallExpression ) loc0. add ( ( FunctionCallExpression ) loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private List < FunctionCallExpression > findCalledFunctions ( ASTNode arg0 ) { List < FunctionCallExpression > loc0 = new ArrayList < FunctionCallExpression > ( ) ; for ( Node loc1 = arg0 ; loc1!= null ; loc1 = loc1. getFirstChild ( ) ) { if ( loc1 instanceof FunctionCallExpression ) loc0. add ( ( FunctionCallExpression ) loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_5_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-194": {
      "loc": "193-194",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i++);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
      "target": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
      "function range": "185,5-205,5",
      "raw_output": [
        "Index function ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && ( loc1 < arg0. length ( ) - 1 ) ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && ( loc1 < arg0. length ( ) ) ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && loc1 < arg0. length ( ) - 1 ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( String arg0 ) { Index loc0 = null ; int loc1 = 0 ; while ( ( loc1 < arg0. length ( ) ) && ( arg0. charAt ( loc1 ) == '|' ) ) { loc0 = ( Index ) _parseIndex ( arg0. substring ( loc1 + 1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( String arg0 ) { Index loc0 = null ; int loc1 = 0 ; while ( ( loc1 < arg0. length ( ) ) && ( arg0. charAt ( loc1 ) == '.' ) ) { loc0 = ( Index ) _parseIndex ( arg0. substring ( loc1 + 1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parse ( loc0 ) ; return loc1 ; }",
        "Index function ( ) { String loc0 = \"srini_string\" ; Index loc1 = null ; try { loc0 = Integer. parseInt ( loc0 ) ; } catch ( NumberFormatException loc2 ) { } return loc1 ; }",
        "Index function ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parseIndex ( loc0 ) ; return loc1 ; }",
        "Index function ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parseFromString ( loc0 ) ; return loc1 ; }",
        "Index function ( String arg0 ) { Index loc0 = new Index ( ) ; loc0. parse ( arg0 ) ; return loc0 ; }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\", arg0 ) ; return - 1 ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { } return - 1 ; }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { Log. e ( \"srini_string\", \"srini_string\", loc0 ) ; return - 1 ; } }",
        "int function ( String arg0 ) { int loc0 = 0 ; try { loc0 = arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc1 ) { } if ( loc0 == - 1 ) { return - 1 ; } return loc0 ; }",
        "int function ( String arg0 ) { int loc0 = 0 ; try { loc0 = arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc1 ) { loc0 = - 1 ; } if ( loc0 == - 1 ) { return - 1 ; } return loc0 ; }",
        "int function ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\" ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { } return - 1 ; }",
        "int function ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\" ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
        "int function ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\", loc0 ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\", arg0 ) ; return - 1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\" ) ; return - 1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\" + arg0 ) ; return - 1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; throw loc1 ; } }"
      ],
      "mid_translation": [
        "Method _parseIndex.",
        "_parseIndex Method.",
        "_parseIndex returns - 1 if the string is not a valid index.",
        "_parseIndex returns - 1 if not found.",
        "_parseIndex returns - 1 if the string is invalid."
      ],
      "output": [
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && ( loc1 < arg0. length ( ) - 1 ) ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && ( loc1 < arg0. length ( ) ) ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && loc1 < arg0. length ( ) - 1 ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = null ; int loc1 = 0 ; while ( ( loc1 < arg0. length ( ) ) && ( arg0. charAt ( loc1 ) == '|' ) ) { loc0 = ( Index ) _parseIndex ( arg0. substring ( loc1 + 1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = null ; int loc1 = 0 ; while ( ( loc1 < arg0. length ( ) ) && ( arg0. charAt ( loc1 ) == '.' ) ) { loc0 = ( Index ) _parseIndex ( arg0. substring ( loc1 + 1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parse ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( ) { String loc0 = \"srini_string\" ; Index loc1 = null ; try { loc0 = Integer. parseInt ( loc0 ) ; } catch ( NumberFormatException loc2 ) { } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parseIndex ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parseFromString ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = new Index ( ) ; loc0. parse ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\", arg0 ) ; return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { } return - 1 ; }",
          "correctness": "plausible"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
          "correctness": "plausible"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
          "correctness": "plausible"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { Log. e ( \"srini_string\", \"srini_string\", loc0 ) ; return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { int loc0 = 0 ; try { loc0 = arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc1 ) { } if ( loc0 == - 1 ) { return - 1 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { int loc0 = 0 ; try { loc0 = arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc1 ) { loc0 = - 1 ; } if ( loc0 == - 1 ) { return - 1 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\" ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { } return - 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\" ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\", loc0 ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\", arg0 ) ; return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\" ) ; return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\" + arg0 ) ; return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; throw loc1 ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Gson_15_/gson/src/main/java/com/google/gson/stream/JsonWriter.java_495-496": {
      "loc": "495-496",
      "input": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(Double.toString(value));\n  return this;\n}",
      "target": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n  if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(Double.toString(value));\n  return this;\n}",
      "function range": "493,3-501,3",
      "raw_output": [
        "void function ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) arg1 ) ; }",
        "void function ( double arg0, DataOutput arg1 ) { arg1. writeDouble ( arg0 ) ; }",
        "void function ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) ( arg1 + 0.0 ) ) ; }",
        "void function ( Double arg0, StreamOutput arg1 ) { arg1. write_long ( ( int ) arg0 ) ; }",
        "void function ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) ( arg1 + 1 ) ) ; }",
        "void function ( double arg0, DataOutput arg1 ) { arg1. writeDouble ( arg0 ) ; }",
        "void function ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) arg1 ) ; }",
        "void function ( Double arg0, StreamOutput arg1 ) { arg1. writeDouble ( value ) ; }",
        "void function ( double arg0, StreamOutput arg1 ) { arg1. writeDouble ( arg0 ) ; }",
        "void function ( double arg0, DataOutput arg1 ) { arg1. writeDouble ( value ) ; }",
        "void function ( DataOutput arg0, int arg1 ) { arg0. write_ulong ( arg1 ) ; }",
        "void function ( DataOutput arg0, int arg1 ) { arg0. write_ulong ( ( int ) arg1 ) ; }",
        "void function ( DataOutput arg0, Integer arg1 ) { arg0. write_ulong ( arg1 ) ; }",
        "void function ( DataOutput arg0, int arg1, int arg2 ) { arg0. write_ulong ( arg1 ) ; }",
        "void function ( DataOutput arg0, int arg1 ) { arg0. writeByte ( ( byte ) ( arg1 & 0xff ) ) ; }",
        "void function ( DataOutput arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
        "void function ( OutputArchive arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
        "void function ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) arg1 ) ; }",
        "void function ( FSDataOutput arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
        "void function ( OutputByteBuffer arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
        "void function ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) arg1 ) ; }",
        "void function ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) ( arg1 + 1 ) ) ; }",
        "void function ( DataOutput arg0, double arg1 ) { arg0. write_double ( arg1 ) ; }",
        "void function ( Double arg0, Writer arg1 ) { arg1. write_long ( ( int ) arg0 ) ; }",
        "void function ( Double arg0, StreamOutput arg1 ) { arg1. write_long ( ( int ) arg0 ) ; }"
      ],
      "mid_translation": [
        "Write a double value.",
        "Write double value.",
        "Write a numeric value.",
        "Writes a double value.",
        "Write a double value"
      ],
      "output": [
        {
          "patch": "public void value ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( double arg0, DataOutput arg1 ) { arg1. writeDouble ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) ( arg1 + 0.0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( Double arg0, StreamOutput arg1 ) { arg1. write_long ( ( int ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) ( arg1 + 1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( double arg0, DataOutput arg1 ) { arg1. writeDouble ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( Double arg0, StreamOutput arg1 ) { arg1. writeDouble ( value ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( double arg0, StreamOutput arg1 ) { arg1. writeDouble ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( double arg0, DataOutput arg1 ) { arg1. writeDouble ( value ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, int arg1 ) { arg0. write_ulong ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, int arg1 ) { arg0. write_ulong ( ( int ) arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, Integer arg1 ) { arg0. write_ulong ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, int arg1, int arg2 ) { arg0. write_ulong ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, int arg1 ) { arg0. writeByte ( ( byte ) ( arg1 & 0xff ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( OutputArchive arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( FSDataOutput arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( OutputByteBuffer arg0, double arg1 ) { arg0. writeDouble ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, double arg1 ) { arg0. write_long ( ( int ) ( arg1 + 1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( DataOutput arg0, double arg1 ) { arg0. write_double ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( Double arg0, Writer arg1 ) { arg1. write_long ( ( int ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void value ( Double arg0, StreamOutput arg1 ) { arg1. write_long ( ( int ) arg0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_27_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java_794-795": {
      "loc": "794-795",
      "input": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                ;\n            } else {\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); \n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue; \n                    }\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); \n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return ext.complete(p, ctxt, bean);\n                }\n            }\n            continue;\n        }\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n            continue;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n    try {\n        return ext.complete(p, ctxt, buffer, creator);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        return null; \n    }\n}",
      "target": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                ;\n            } else {\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); \n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        continue; \n                    }\n                    while (t == JsonToken.FIELD_NAME) {\n                        p.nextToken(); \n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return ext.complete(p, ctxt, bean);\n                }\n            }\n            continue;\n        }\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n            continue;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n    try {\n        return ext.complete(p, ctxt, buffer, creator);\n    } catch (Exception e) {\n        wrapInstantiationProblem(e, ctxt);\n        return null; \n    }\n}",
      "function range": "773,5-857,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_20_/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java_1330-1331": {
      "loc": "1330-1331",
      "input": "public void writeEmbeddedObject(Object object) throws IOException {\n    throw new JsonGenerationException(\"No native support for writing embedded objects\",\n            this);\n}",
      "target": "public void writeEmbeddedObject(Object object) throws IOException {\n    if (object == null) {\n        writeNull();\n        return;\n    }\n    if (object instanceof byte[]) {\n        writeBinary((byte[]) object);\n        return;\n    }\n    throw new JsonGenerationException(\"No native support for writing embedded objects of type \"\n            +object.getClass().getName(),\n            this);\n}",
      "function range": "1328,5-1332,5",
      "raw_output": [
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( \"srini_string\" ) ; }",
        "void function ( EmbeddedObject arg0, Writer arg1 ) { arg1. write_string ( \"srini_string\" ) ; }",
        "void function ( EmbeddedObject arg0, ObjectOutputStream arg1 ) { arg1. writeObject ( arg0. getObject ( ) ) ; }",
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { }",
        "void function ( EmbeddedObject arg0, ObjectOutput arg1 ) { }",
        "void function ( EmbeddedObject arg0, JSONWriter arg1 ) { arg1. writeEmbeddedObject ( arg0 ) ; }",
        "void function ( EmbeddedObject arg0, JSON arg1 ) { arg1. put ( \"srini_string\", arg0. getClass ( ). getName ( ) ) ; }",
        "void function ( EmbeddedObject arg0, JSON arg1 ) { arg1. put ( \"srini_string\", arg0. getObjectId ( ) ) ; }",
        "void function ( embeddedObject arg0, JSONWriter arg1 ) { arg1. writeEmbeddedObject ( arg0 ) ; }",
        "void function ( EmbeddedObject arg0, JSON arg1 ) { arg1. put ( \"srini_string\", arg0. getId ( ) ) ; }",
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }",
        "void function ( EmbeddedObject arg0, StreamOutput arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }",
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { arg0. writeEmbeddedObject ( arg0 ) ; }",
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( arg0. getName ( ) ) ; }",
        "void function ( final EmbeddedObject arg0, final OutputStream arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }",
        "void function ( EmbeddedObject arg0, Writer arg1 ) { arg1. write ( arg0. toString ( ) ) ; }",
        "void function ( EmbeddedObject arg0, Writer arg1 ) { arg1. write_string ( \"srini_string\" ) ; }",
        "void function ( EmbeddedObject arg0, Writer arg1 ) { arg1. write_string ( arg0. toString ( ) ) ; }",
        "void function ( EmbeddedObject arg0, Writer arg1 ) { arg1. writeEmbeddedObject ( arg0 ) ; }",
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( \"srini_string\" ) ; }",
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }",
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { arg0. writeEmbeddedObject ( arg0 ) ; }",
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( arg0. getName ( ) ) ; }",
        "void function ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write ( arg0. getObjectId ( ). toString ( ) ) ; }",
        "void function ( final EmbeddedObject arg0, final OutputStream arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }"
      ],
      "mid_translation": [
        "Write an embedded object.",
        "Write an embedded object to the JSON stream.",
        "Write an embedded object to the output stream.",
        "Writes an embedded object.",
        "Writes an embedded object to the output stream."
      ],
      "output": [
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, Writer arg1 ) { arg1. write_string ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, ObjectOutputStream arg1 ) { arg1. writeObject ( arg0. getObject ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, ObjectOutput arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, JSONWriter arg1 ) { arg1. writeEmbeddedObject ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, JSON arg1 ) { arg1. put ( \"srini_string\", arg0. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, JSON arg1 ) { arg1. put ( \"srini_string\", arg0. getObjectId ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( embeddedObject arg0, JSONWriter arg1 ) { arg1. writeEmbeddedObject ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, JSON arg1 ) { arg1. put ( \"srini_string\", arg0. getId ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, StreamOutput arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { arg0. writeEmbeddedObject ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( arg0. getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( final EmbeddedObject arg0, final OutputStream arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, Writer arg1 ) { arg1. write ( arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, Writer arg1 ) { arg1. write_string ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, Writer arg1 ) { arg1. write_string ( arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, Writer arg1 ) { arg1. writeEmbeddedObject ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { arg0. writeEmbeddedObject ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write_string ( arg0. getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( EmbeddedObject arg0, OutputStream arg1 ) { arg1. write ( arg0. getObjectId ( ). toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void writeEmbeddedObject ( final EmbeddedObject arg0, final OutputStream arg1 ) { arg1. write_string ( arg0. getObjectName ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_46_/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java_529-531": {
      "loc": "529-531",
      "input": "private static ZipLong unixTimeToZipLong(long l) {\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n    }\n    return new ZipLong(l);\n}",
      "target": "private static ZipLong unixTimeToZipLong(long l) {\n    if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n        throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n    }\n    return new ZipLong(l);\n}",
      "function range": "528,5-534,5",
      "raw_output": [
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new ZipLong ( ( int ) ( arg0 & 0xffffffffL ) ) ; }",
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( arg0 ) ; }",
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new ZipLong ( ( int ) ( arg0 / 1000L ) ) ; }",
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xFFFFFFFFL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( arg0 ) ; }",
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } return new ZipLong ( arg0 ) ; }",
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( arg0 ) ; }",
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( ( int ) ( arg0 & 0xffffffffL ) ) ; }",
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } return new ZipLong ( arg0 ) ; }",
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xFFFFFFFFL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( arg0 ) ; }",
        "ZipLong function ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new ZipLong ( ( int ) ( arg0 & 0xffffffffL ) ) ; }",
        "ZipLong function ( long arg0 ) { return new ZipLong ( arg0 ) ; }",
        "ZipLong function ( long arg0 ) { return new ZipLong ( ( int ) ( arg0 & 0xffffffffL ) ) ; }",
        "ZipLong function ( long arg0 ) { if ( arg0 < 0 ) return null ; return new ZipLong ( ( int ) ( arg0 / 1000L ) ) ; }",
        "ZipLong function ( UnixTimestamp arg0 ) { return new ZipLong ( arg0. getMostSignificantBits ( ) ) ; }",
        "ZipLong function ( UnixTimestamp arg0 ) { return new ZipLong ( arg0. toMillis ( ) ) ; }",
        "ZipOutputStream function ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 56 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 56 ) } ) ; }",
        "ZipOutputStream function ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 >> 56 ) } ) ; }",
        "ZipOutputStream function ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 >> 56 ), ( int ) ( arg0 >> 56 ) } ) ; }",
        "ZipOutputStream function ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 56 ) } ) ; }",
        "ZipOutputStream function ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 56 ), ( int ) ( arg0 >> 56 ), ( int ) ( arg0 & 0xffffffffL ) } ) ; }",
        "ZipLong function ( long arg0 ) { return new ZipLong ( ( int ) ( arg0 / 1000L ) ) ; }",
        "ZipLong function ( long arg0 ) { if ( arg0 < 0 ) return null ; return new ZipLong ( ( int ) ( arg0 / 1000L ) ) ; }",
        "ZipLong function ( long arg0 ) { return new ZipLong ( ( int ) ( arg0 / 1000L ), ( int ) ( arg0 % 1000000L ) ) ; }",
        "ZipLong function ( java. util. Date arg0 ) { return new ZipLong ( arg0. toMilliseconds ( ) ) ; }",
        "ZipLong function ( java. util. Date arg0 ) { return new ZipLong ( arg0. toMillis ( ) ) ; }"
      ],
      "mid_translation": [
        "Converts a unix timestamp to a ZipLong.",
        "Convert a unix timestamp to a ZipLong.",
        "Converts a UNIX timestamp to a ZipLong.",
        "Converts a unix timestamp to a zip long.",
        "Converts a unix time to a ZipLong."
      ],
      "output": [
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new ZipLong ( ( int ) ( arg0 & 0xffffffffL ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new ZipLong ( ( int ) ( arg0 / 1000L ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xFFFFFFFFL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } return new ZipLong ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( ( int ) ( arg0 & 0xffffffffL ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } return new ZipLong ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xFFFFFFFFL ) ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return new ZipLong ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( ( arg0 < 0 ) || ( arg0 > 0xffffffffL ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new ZipLong ( ( int ) ( arg0 & 0xffffffffL ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { return new ZipLong ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { return new ZipLong ( ( int ) ( arg0 & 0xffffffffL ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( arg0 < 0 ) return null ; return new ZipLong ( ( int ) ( arg0 / 1000L ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( UnixTimestamp arg0 ) { return new ZipLong ( arg0. getMostSignificantBits ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( UnixTimestamp arg0 ) { return new ZipLong ( arg0. toMillis ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static ZipOutputStream unixTimeToZipLong ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 56 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 56 ) } ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static ZipOutputStream unixTimeToZipLong ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 >> 56 ) } ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static ZipOutputStream unixTimeToZipLong ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 >> 56 ), ( int ) ( arg0 >> 56 ) } ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static ZipOutputStream unixTimeToZipLong ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 56 ) } ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static ZipOutputStream unixTimeToZipLong ( long arg0 ) { return new ZipOutputStream ( new byte [ ] { ( int ) ( arg0 & 0xffffffffffL ), ( int ) ( arg0 >> 16 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 32 ), ( int ) ( arg0 >> 48 ), ( int ) ( arg0 & 0xffffffffL ), ( int ) ( arg0 >> 56 ), ( int ) ( arg0 >> 56 ), ( int ) ( arg0 & 0xffffffffL ) } ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { return new ZipLong ( ( int ) ( arg0 / 1000L ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { if ( arg0 < 0 ) return null ; return new ZipLong ( ( int ) ( arg0 / 1000L ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( long arg0 ) { return new ZipLong ( ( int ) ( arg0 / 1000L ), ( int ) ( arg0 % 1000000L ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( java. util. Date arg0 ) { return new ZipLong ( arg0. toMilliseconds ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static ZipLong unixTimeToZipLong ( java. util. Date arg0 ) { return new ZipLong ( arg0. toMillis ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_46_src/com/google/javascript/rhino/jstype/RecordType.java_142-145": {
      "loc": "142-145",
      "input": "@Override\npublic JSType getLeastSupertype(JSType that) {\n  if (!that.isRecordType()) {\n    return super.getLeastSupertype(that);\n  }\n  RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n  for (String property : properties.keySet()) {\n    if (that.toMaybeRecordType().hasProperty(property) &&\n        that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n            getPropertyType(property))) {\n      builder.addProperty(property, getPropertyType(property),\n          getPropertyNode(property));\n    }\n  }\n  return builder.build();\n}",
      "target": "JSType getGreatestSubtypeHelper(JSType that) {\n  if (that.isRecordType()) {\n    RecordType thatRecord = that.toMaybeRecordType();\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n      if (thatRecord.hasProperty(property) &&\n          !thatRecord.getPropertyType(property).isEquivalentTo(\n              getPropertyType(property))) {\n        return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n      }\n      builder.addProperty(property, getPropertyType(property),\n          getPropertyNode(property));\n    }\n    for (String property : thatRecord.properties.keySet()) {\n      if (!hasProperty(property)) {\n        builder.addProperty(property, thatRecord.getPropertyType(property),\n            thatRecord.getPropertyNode(property));\n      }\n    }\n    return builder.build();\n  }\n  JSType greatestSubtype = registry.getNativeType(\n      JSTypeNative.NO_OBJECT_TYPE);\n  JSType thatRestrictedToObj =\n      registry.getNativeType(JSTypeNative.OBJECT_TYPE)\n      .getGreatestSubtype(that);\n  if (!thatRestrictedToObj.isEmptyType()) {\n    for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n      String propName = entry.getKey();\n      JSType propType = entry.getValue();\n      UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n      for (ObjectType alt :\n               registry.getEachReferenceTypeWithProperty(propName)) {\n        JSType altPropType = alt.getPropertyType(propName);\n        if (altPropType != null && !alt.isEquivalentTo(this) &&\n            alt.isSubtype(that) &&\n            (propType.isUnknownType() || altPropType.isUnknownType() ||\n                altPropType.isEquivalentTo(propType))) {\n          builder.addAlternate(alt);\n        }\n      }\n      greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n    }\n  }\n  return greatestSubtype;\n}",
      "function range": "140,3-155,3",
      "raw_output": [
        "SuperType function ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
        "R function ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
        "R function ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) { return null ; } return loc0. getSupertype ( ) ; }",
        "SuperType function ( Type arg0 ) { SuperType loc0 = arg0. getSuperType ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
        "R function ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0 ; }",
        "SuperType function ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
        "SuperType function ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) { return null ; } return loc0. getSupertype ( ) ; }",
        "Type function ( Type arg0 ) { if ( arg0. getSupertype ( ) == null ) return null ; return arg0. getSupertype ( ). getSupertype ( ) ; }",
        "PsiType function ( PsiType arg0 ) { if ( arg0 == null ) return null ; return arg0. getSupertype ( ) ; }",
        "R function ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
        "SuperType function ( Type arg0 ) { SuperType loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
        "SuperType function ( Type arg0 ) { SuperType loc0 = arg0 ; while ( loc0. getSuperclass ( )!= null ) { loc0 = loc0. getSuperclass ( ) ; } return loc0 ; }",
        "SuperType function ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
        "SuperType function ( Type arg0 ) { SuperType loc0 = arg0 ; while ( loc0 == null ) { loc0 = arg0. getSupertype ( ) ; } return loc0 ; }",
        "Class <? > function ( Class <? > arg0 ) { Class <? > loc0 = arg0 ; while ( loc0. getSuperclass ( )!= null ) { loc0 = loc0. getSuperclass ( ) ; } return loc0 ; }",
        "Class <? > function ( Class <? > arg0 ) { Class <? > loc0 = arg0 ; while ( loc0. getSuperclass ( )!= Object. class ) { loc0 = loc0. getSuperclass ( ) ; } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
        "Class <? > function ( Class <? > arg0 ) { if ( arg0 == Object. class ) { return Object. class ; } if ( arg0. getSuperclass ( )!= null ) { return arg0. getSuperclass ( ) ; } return null ; }",
        "Class <? > function ( Class <? > arg0 ) { Class <? > loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSupertype ( )!= Object. class ) loc0 = loc0. getSupertype ( ) ; return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSuperclass ( )!= null ) { loc0 = loc0. getSuperclass ( ) ; } return loc0 ; }",
        "R function ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
        "SuperType function ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) { return null ; } return loc0. getSupertype ( ) ; }"
      ],
      "mid_translation": [
        "Returns the least supertype of the given type.",
        "Gets the least supertype of the given type.",
        "Get the least supertype of the given type.",
        "Gets the least supertype of another type.",
        "Returns the least supertype of the specified type."
      ],
      "output": [
        {
          "patch": "@Override\npublic SuperType getLeastSupertype ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) { return null ; } return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic SuperType getLeastSupertype ( Type arg0 ) { SuperType loc0 = arg0. getSuperType ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic SuperType getLeastSupertype ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic SuperType getLeastSupertype ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) { return null ; } return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Type getLeastSupertype ( Type arg0 ) { if ( arg0. getSupertype ( ) == null ) return null ; return arg0. getSupertype ( ). getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic PsiType getLeastSupertype ( PsiType arg0 ) { if ( arg0 == null ) return null ; return arg0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic SuperType getLeastSupertype ( Type arg0 ) { SuperType loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic SuperType getLeastSupertype ( Type arg0 ) { SuperType loc0 = arg0 ; while ( loc0. getSuperclass ( )!= null ) { loc0 = loc0. getSuperclass ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic SuperType getLeastSupertype ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic SuperType getLeastSupertype ( Type arg0 ) { SuperType loc0 = arg0 ; while ( loc0 == null ) { loc0 = arg0. getSupertype ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Class <? > getLeastSupertype ( Class <? > arg0 ) { Class <? > loc0 = arg0 ; while ( loc0. getSuperclass ( )!= null ) { loc0 = loc0. getSuperclass ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Class <? > getLeastSupertype ( Class <? > arg0 ) { Class <? > loc0 = arg0 ; while ( loc0. getSuperclass ( )!= Object. class ) { loc0 = loc0. getSuperclass ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Class <? > getLeastSupertype ( Class <? > arg0 ) { if ( arg0 == Object. class ) { return Object. class ; } if ( arg0. getSuperclass ( )!= null ) { return arg0. getSuperclass ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Class <? > getLeastSupertype ( Class <? > arg0 ) { Class <? > loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSupertype ( )!= null ) { loc0 = loc0. getSupertype ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSupertype ( )!= Object. class ) loc0 = loc0. getSupertype ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0 ; while ( loc0. getSuperclass ( )!= null ) { loc0 = loc0. getSuperclass ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic R getLeastSupertype ( R arg0 ) { R loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) return null ; return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic SuperType getLeastSupertype ( Type arg0 ) { SuperType loc0 = arg0. getSupertype ( ) ; if ( loc0 == null ) { return null ; } return loc0. getSupertype ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_76_/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java_583-585": {
      "loc": "583-585",
      "input": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                t = p.nextToken();\n                Object bean;\n                try {\n                    bean = creator.build(ctxt, buffer);\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                    continue;\n                }\n                while (t == JsonToken.FIELD_NAME) {\n                    p.nextToken();\n                    tokens.copyCurrentStructure(p);\n                    t = p.nextToken();\n                }\n                tokens.writeEndObject();\n                if (bean.getClass() != _beanType.getRawClass()) {\n                    ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n            }\n            continue;\n        }\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n    Object bean;\n    try {\n        bean = creator.build(ctxt, buffer);\n    } catch (Exception e) {\n        return wrapInstantiationProblem(e, ctxt);\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n}",
      "target": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n\t\tDeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));\n            continue;\n        }\n        if (buffer.readIdProperty(propName)) {\n            continue;\n        }\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n            continue;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n            continue;\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n        if (_anySetter != null) {\n            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n        }\n    }\n    Object bean;\n    try {\n        bean = creator.build(ctxt, buffer);\n    } catch (Exception e) {\n        return wrapInstantiationProblem(e, ctxt);\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n}",
      "function range": "565,5-637,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Compress_38_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java_859-860": {
      "loc": "859-860",
      "input": "@Override\npublic boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
      "target": "@Override\npublic boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n    if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n        return true;\n    }\n    return false;\n}",
      "function range": "849,5-864,5",
      "raw_output": [
        "boolean function ( ) { return false ; }",
        "boolean function ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
        "boolean function ( File arg0 ) { return arg0. isDirectory ( ) ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
        "boolean function ( Path arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
        "boolean function ( File arg0 ) { return arg0. isDirectory ( ) ; }",
        "boolean function ( File arg0 ) { if ( arg0. isDirectory ( ) ) { return true ; } else { return false ; } }",
        "boolean function ( File arg0 ) { if ( arg0. isDirectory ( ) ) { return true ; } else { return arg0. getName ( ). startsWith ( \"srini_string\" ) ; } }",
        "boolean function ( File arg0 ) { if ( arg0. isDirectory ( ) ) { return true ; } return arg0. getName ( ). startsWith ( \"srini_string\" ) ; }",
        "boolean function ( File arg0 ) { if ( arg0. isDirectory ( ) ) { return true ; } return false ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { File loc0 = new File ( this ) ; return loc0. isDirectory ( ) ; }",
        "boolean function ( ) { File loc0 = new File ( this ) ; boolean loc1 = loc0. isDirectory ( ) ; return loc1 ; }",
        "boolean function ( ) { String loc0 = FilePath. get ( this ). getAbsolutePath ( ) ; return loc0. endsWith ( File. separator ) ; }",
        "boolean function ( ) { File loc0 = new File ( this, \"srini_string\" ) ; return loc0. isDirectory ( ) ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { return this. getPath ( ). startsWith ( \"srini_string\" ) ; }",
        "boolean function ( ) { return this. getClass ( ). getName ( ). equals ( Constants. DIRECTORY ) ; }",
        "boolean function ( ) { return true ; }",
        "boolean function ( ) { return this. getClass ( ). getName ( ). endsWith ( File. separator ) ; }",
        "boolean function ( File arg0 ) { return arg0. isDirectory ( ) ; }",
        "boolean function ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
        "boolean function ( File arg0 ) { return arg0. getName ( ). endsWith ( File. separator ) ; }",
        "boolean function ( String arg0 ) { return arg0. startsWith ( File. separator ) ; }"
      ],
      "mid_translation": [
        "Returns true if this is a directory.",
        "Returns true if the file is a directory.",
        "Returns true if this file is a directory.",
        "Returns true if this entry is a directory.",
        "Is this a directory?"
      ],
      "output": [
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( File arg0 ) { return arg0. isDirectory ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( Path arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( File arg0 ) { return arg0. isDirectory ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( File arg0 ) { if ( arg0. isDirectory ( ) ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( File arg0 ) { if ( arg0. isDirectory ( ) ) { return true ; } else { return arg0. getName ( ). startsWith ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( File arg0 ) { if ( arg0. isDirectory ( ) ) { return true ; } return arg0. getName ( ). startsWith ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( File arg0 ) { if ( arg0. isDirectory ( ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { File loc0 = new File ( this ) ; return loc0. isDirectory ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { File loc0 = new File ( this ) ; boolean loc1 = loc0. isDirectory ( ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { String loc0 = FilePath. get ( this ). getAbsolutePath ( ) ; return loc0. endsWith ( File. separator ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { File loc0 = new File ( this, \"srini_string\" ) ; return loc0. isDirectory ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { return this. getPath ( ). startsWith ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { return this. getClass ( ). getName ( ). equals ( Constants. DIRECTORY ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( ) { return this. getClass ( ). getName ( ). endsWith ( File. separator ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( File arg0 ) { return arg0. isDirectory ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( File arg0 ) { return arg0. getName ( ). endsWith ( File. separator ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isDirectory ( String arg0 ) { return arg0. startsWith ( File. separator ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_1_/src/main/java/org/jsoup/nodes/Document.java_125-127": {
      "loc": "125-127",
      "input": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().appendChild(new TextNode(\" \", \"\"));\n        body().appendChild(node);\n    }\n}",
      "target": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n        body().prependChild(node);\n        body().prependChild(new TextNode(\" \", \"\"));\n    }\n}",
      "function range": "113,5-128,5",
      "raw_output": [
        "XMLElement function ( Element arg0 ) { return normalize ( arg0, null ) ; }",
        "XMLElement function ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; arg0. setTextContent ( Normalizer. normalize ( loc0 ) ) ; } return arg0 ; }",
        "XMLElement function ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normalize ( loc0 ) ; } else { return arg0 ; } }",
        "XMLElement function ( Element arg0, boolean arg1 ) { return normalize ( arg0, arg1, null ) ; }",
        "XMLElement function ( Element arg0 ) { return normalize ( arg0, true ) ; }",
        "XMLElement function ( Element arg0 ) { return normalize ( arg0, null ) ; }",
        "XMLElement function ( Element arg0 ) { return normalize ( arg0, true ) ; }",
        "XMLElement function ( Element arg0 ) { if ( arg0 == null ) { return null ; } Element loc0 = arg0. normalize ( ) ; return loc0 ; }",
        "XMLElement function ( Element arg0 ) { if ( arg0 == null ) return null ; Element loc0 = arg0. normalize ( ) ; return loc0 ; }",
        "XMLElement function ( Element arg0 ) { return NormalisationUtil. normalize ( arg0 ) ; }",
        "XMLElement function ( Element arg0 ) { return normalize ( arg0, null ) ; }",
        "XMLElement function ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; if ( loc0!= null ) { return NormalisationUtil. normalizeXMLElement ( loc0 ) ; } } return arg0 ; }",
        "XMLElement function ( Element arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normaliseXMLElement ( loc0 ) ; } else { return arg0 ; } }",
        "XMLElement function ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; if ( loc0!= null ) { return normaliseXMLElement ( arg0, loc0 ) ; } } return arg0 ; }",
        "XMLElement function ( Element arg0 ) { return normalise ( arg0, null ) ; }",
        "XMLElement function ( Element arg0 ) { return normalise ( arg0, null ) ; }",
        "String function ( Element arg0 ) { return normalise ( arg0, null ) ; }",
        "XMLElement function ( Element arg0 ) { return normalize ( arg0, null ) ; }",
        "XMLElement function ( Element arg0 ) { return normalizeElement ( arg0, null ) ; }",
        "XMLElement function ( Element arg0 ) { return normalize ( arg0, false ) ; }",
        "XMLElement function ( Element arg0 ) { return normalize ( arg0, null ) ; }",
        "XMLElement function ( Element arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normaliseXMLElement ( loc0 ) ; } else { return arg0 ; } }",
        "XMLElement function ( Element arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normaliseXMLElement ( arg0, loc0 ) ; } else { return arg0 ; } }",
        "XMLElement function ( Element arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normaliseXMLElement ( loc0, arg0 ) ; } else { return arg0 ; } }",
        "XMLElement function ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; if ( loc0!= null ) { return NormalisationUtil. normalizeXMLElement ( loc0 ) ; } } return arg0 ; }"
      ],
      "mid_translation": [
        "Normalise the XML element.",
        "Normalise the XML Element.",
        "Normalise XML element.",
        "This method normalises the XML element.",
        "Normalise XML Element."
      ],
      "output": [
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalize ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; arg0. setTextContent ( Normalizer. normalize ( loc0 ) ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normalize ( loc0 ) ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0, boolean arg1 ) { return normalize ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalize ( arg0, true ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalize ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalize ( arg0, true ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0 == null ) { return null ; } Element loc0 = arg0. normalize ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0 == null ) return null ; Element loc0 = arg0. normalize ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return NormalisationUtil. normalize ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalize ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; if ( loc0!= null ) { return NormalisationUtil. normalizeXMLElement ( loc0 ) ; } } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normaliseXMLElement ( loc0 ) ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; if ( loc0!= null ) { return normaliseXMLElement ( arg0, loc0 ) ; } } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalise ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalise ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String normalise ( Element arg0 ) { return normalise ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalize ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalizeElement ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalize ( arg0, false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { return normalize ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normaliseXMLElement ( loc0 ) ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normaliseXMLElement ( arg0, loc0 ) ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; return normaliseXMLElement ( loc0, arg0 ) ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private XMLElement normalise ( Element arg0 ) { if ( arg0. hasAttribute ( \"srini_string\" ) ) { String loc0 = arg0. getAttribute ( \"srini_string\" ) ; if ( loc0!= null ) { return NormalisationUtil. normalizeXMLElement ( loc0 ) ; } } return arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_6_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-195": {
      "loc": "193-195",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
      "target": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c <= '0') {\n        return (len == 1 && c == '0') ? 0 : -1;\n    }\n    if (c > '9') {\n        return -1;\n    }\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n    }\n    if (len == 10) {\n        long l = NumberInput.parseLong(str);\n        if (l > Integer.MAX_VALUE) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(str);\n}",
      "function range": "185,5-206,5",
      "raw_output": [
        "Index function ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && ( loc1 < arg0. length ( ) - 1 ) ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && ( loc1 < arg0. length ( ) ) ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && loc1 < arg0. length ( ) - 1 ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( String arg0 ) { Index loc0 = null ; int loc1 = 0 ; while ( ( loc1 < arg0. length ( ) ) && ( arg0. charAt ( loc1 ) == '|' ) ) { loc0 = ( Index ) _parseIndex ( arg0. substring ( loc1 + 1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( String arg0 ) { Index loc0 = null ; int loc1 = 0 ; while ( ( loc1 < arg0. length ( ) ) && ( arg0. charAt ( loc1 ) == '.' ) ) { loc0 = ( Index ) _parseIndex ( arg0. substring ( loc1 + 1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "Index function ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parse ( loc0 ) ; return loc1 ; }",
        "Index function ( ) { String loc0 = \"srini_string\" ; Index loc1 = null ; try { loc0 = Integer. parseInt ( loc0 ) ; } catch ( NumberFormatException loc2 ) { } return loc1 ; }",
        "Index function ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parseIndex ( loc0 ) ; return loc1 ; }",
        "Index function ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parseFromString ( loc0 ) ; return loc1 ; }",
        "Index function ( String arg0 ) { Index loc0 = new Index ( ) ; loc0. parse ( arg0 ) ; return loc0 ; }",
        "int function ( String arg0 ) { int loc0 = 0 ; try { loc0 = arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc1 ) { } if ( loc0 == - 1 ) { return - 1 ; } return loc0 ; }",
        "int function ( String arg0 ) { int loc0 = 0 ; try { loc0 = arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc1 ) { loc0 = - 1 ; } if ( loc0 == - 1 ) { return - 1 ; } return loc0 ; }",
        "int function ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\" ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { } return - 1 ; }",
        "int function ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\" ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
        "int function ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\", loc0 ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\", arg0 ) ; return - 1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\" ) ; return - 1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\" + arg0 ) ; return - 1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; throw loc1 ; } }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { } return - 1 ; }",
        "int function ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { Log. e ( \"srini_string\", \"srini_string\", loc0 ) ; return - 1 ; } }",
        "int function ( String arg0 ) { if ( arg0 == null ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }"
      ],
      "mid_translation": [
        "Method _parseIndex.",
        "_parseIndex Method.",
        "_parseIndex returns - 1 if not found.",
        "_parseIndex returns - 1 if the string is invalid.",
        "_parseIndex returns - 1 if the string is not a valid index"
      ],
      "output": [
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && ( loc1 < arg0. length ( ) - 1 ) ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && ( loc1 < arg0. length ( ) ) ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = new Index ( ) ; int loc1 = 0 ; while ( loc1 < arg0. length ( ) && loc1 < arg0. length ( ) - 1 ) { loc0. addElement ( arg0. charAt ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = null ; int loc1 = 0 ; while ( ( loc1 < arg0. length ( ) ) && ( arg0. charAt ( loc1 ) == '|' ) ) { loc0 = ( Index ) _parseIndex ( arg0. substring ( loc1 + 1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = null ; int loc1 = 0 ; while ( ( loc1 < arg0. length ( ) ) && ( arg0. charAt ( loc1 ) == '.' ) ) { loc0 = ( Index ) _parseIndex ( arg0. substring ( loc1 + 1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parse ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( ) { String loc0 = \"srini_string\" ; Index loc1 = null ; try { loc0 = Integer. parseInt ( loc0 ) ; } catch ( NumberFormatException loc2 ) { } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parseIndex ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( ) { String loc0 = \"srini_string\" ; Index loc1 = new Index ( ) ; loc1. parseFromString ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final Index _parseIndex ( String arg0 ) { Index loc0 = new Index ( ) ; loc0. parse ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { int loc0 = 0 ; try { loc0 = arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc1 ) { } if ( loc0 == - 1 ) { return - 1 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { int loc0 = 0 ; try { loc0 = arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc1 ) { loc0 = - 1 ; } if ( loc0 == - 1 ) { return - 1 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\" ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { } return - 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\" ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { int loc0 = arg0. indexOf ( \"srini_string\" ) ; if ( loc0!= - 1 ) { return arg0. indexOf ( \"srini_string\", loc0 ) ; } return arg0. indexOf ( \"srini_string\" ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\", arg0 ) ; return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\" ) ; return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { LoggerFactory. getLogger ( getClass ( ) ). debug ( \"srini_string\" + arg0 ) ; return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { MARSHAL loc1 = new MARSHAL ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; throw loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { } return - 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { Log. e ( \"srini_string\", \"srini_string\", loc0 ) ; return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private final int _parseIndex ( String arg0 ) { if ( arg0 == null ) { return - 1 ; } try { return Integer. parseInt ( arg0 ) ; } catch ( NumberFormatException loc0 ) { return - 1 ; } }",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_102_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_67-70": {
      "loc": "67-70",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale()\n                        ? format.getLocale()\n                        : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\ndf0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}",
      "target": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale()\n                        ? format.getLocale()\n                        : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\ndf0.getClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}",
      "function range": "61,5-136,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_109_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_1908-1909": {
      "loc": "1908-1909",
      "input": "private Node parseContextTypeExpression(JsDocToken token) {\n        return parseTypeName(token);\n}",
      "target": "private Node parseContextTypeExpression(JsDocToken token) {\n  if (token == JsDocToken.QMARK) {\n    return newNode(Token.QMARK);\n  } else {\n    return parseBasicTypeExpression(token);\n  }\n}",
      "function range": "1907,3-1909,3",
      "raw_output": [
        "PsiElement function ( String arg0 ) { PsiElement loc0 = null ; PsiElement loc1 = null ; while ( loc1!= null ) { loc1 = loc1. getParent ( ) ; } return loc0 ; }",
        "void function ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0!= null ) { throw new SAXException ( \"srini_string\" + loc0 ) ; } }",
        "void function ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0!= null ) { throw new SAXException ( \"srini_string\" ) ; } }",
        "PsiElement function ( String arg0 ) { PsiElement loc0 = new PsiElement ( ) ; loc0. setType ( arg0 ) ; return loc0 ; }",
        "void function ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0 == null ) { throw new SAXException ( \"srini_string\" ) ; } }",
        "PsiElement function ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. CONTEXT_TYPE ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
        "PsiElement function ( ParserRuleContext arg0 ) { PsiElement loc0 = arg0. loc0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. CONTEXT_TYPE ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
        "PsiElement function ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. CONTEXT ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
        "PsiElement function ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0 instanceof PsiElement ) { return ( PsiElement ) loc0 ; } loc0 = ( PsiElement ) loc0. getParent ( ) ; } return null ; }",
        "PsiElement function ( String arg0 ) { PsiElement loc0 = null ; PsiElement loc1 = null ; while ( loc1!= null ) { if ( arg0. equals ( loc1. getElementType ( ) ) ) { break ; } loc0 = loc1 ; } return loc0 ; }",
        "PsiElement function ( String arg0 ) { PsiElement loc0 = null ; Token loc1 = null ; while ( loc1!= null ) { if ( arg0. equals ( loc1. getType ( ) ) ) { break ; } loc0 = loc1 ; } return loc0 ; }",
        "PsiElement function ( String arg0 ) { PsiElement loc0 = null ; Token loc1 = null ; while ( loc1!= null ) { if ( arg0. equals ( loc1. getType ( ) ) ) { break ; } loc0 = loc0. getParent ( ) ; } return loc0 ; }",
        "PsiElement function ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. CONTEXT_TYPE ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
        "PsiElement function ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. NAME ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
        "PsiElement function ( String arg0 ) { PsiElement loc0 = null ; Token loc1 = null ; while ( loc1!= null ) { if ( arg0. equals ( loc1. getType ( ) ) ) { loc0 = loc1 ; break ; } } return loc0 ; }",
        "void function ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0!= null ) { throw new SAXException ( \"srini_string\" ) ; } }",
        "PsiElement function ( String arg0 ) { PsiElement loc0 = new PsiElement ( ) ; loc0. setType ( arg0 ) ; return loc0 ; }",
        "void function ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0 == null ) { throw new SAXException ( \"srini_string\" ) ; } }",
        "PsiElement function ( XMLStreamReader arg0 ) { PsiElement loc0 = arg0. parseTypeExpression ( ) ; return loc0 ; }",
        "PsiElement function ( String arg0 ) { PsiElement loc0 = new PsiElement ( arg0 ) ; return loc0 ; }",
        "PsiType function ( Expr arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; return loc0. getType ( ) ; }",
        "PsiElement function ( Expr arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; return loc0 ; }",
        "PsiElement function ( Expr arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; return loc0. getType ( ) ; }",
        "PsiElement function ( XMLStreamReader arg0 ) { return null ; }",
        "PsiElement function ( Expr arg0 ) { return null ; }"
      ],
      "mid_translation": [
        "Parse a context type expression.",
        "Parses a context type expression.",
        "Parse a context - type expression.",
        "Parse a context type expression",
        "Parse a type expression that represents a context type."
      ],
      "output": [
        {
          "patch": "private PsiElement parseContextTypeExpression ( String arg0 ) { PsiElement loc0 = null ; PsiElement loc1 = null ; while ( loc1!= null ) { loc1 = loc1. getParent ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void parseContextTypeExpression ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0!= null ) { throw new SAXException ( \"srini_string\" + loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void parseContextTypeExpression ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0!= null ) { throw new SAXException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( String arg0 ) { PsiElement loc0 = new PsiElement ( ) ; loc0. setType ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void parseContextTypeExpression ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0 == null ) { throw new SAXException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. CONTEXT_TYPE ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( ParserRuleContext arg0 ) { PsiElement loc0 = arg0. loc0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. CONTEXT_TYPE ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. CONTEXT ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0 instanceof PsiElement ) { return ( PsiElement ) loc0 ; } loc0 = ( PsiElement ) loc0. getParent ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( String arg0 ) { PsiElement loc0 = null ; PsiElement loc1 = null ; while ( loc1!= null ) { if ( arg0. equals ( loc1. getElementType ( ) ) ) { break ; } loc0 = loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( String arg0 ) { PsiElement loc0 = null ; Token loc1 = null ; while ( loc1!= null ) { if ( arg0. equals ( loc1. getType ( ) ) ) { break ; } loc0 = loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( String arg0 ) { PsiElement loc0 = null ; Token loc1 = null ; while ( loc1!= null ) { if ( arg0. equals ( loc1. getType ( ) ) ) { break ; } loc0 = loc0. getParent ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. CONTEXT_TYPE ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( PsiElement arg0 ) { PsiElement loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == PsiElement. NAME ) { return loc0 ; } loc0 = loc0. getParent ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( String arg0 ) { PsiElement loc0 = null ; Token loc1 = null ; while ( loc1!= null ) { if ( arg0. equals ( loc1. getType ( ) ) ) { loc0 = loc1 ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void parseContextTypeExpression ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0!= null ) { throw new SAXException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( String arg0 ) { PsiElement loc0 = new PsiElement ( ) ; loc0. setType ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void parseContextTypeExpression ( XMLStreamReader arg0 ) { String loc0 = arg0. getAttributeValue ( ) ; if ( loc0 == null ) { throw new SAXException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( XMLStreamReader arg0 ) { PsiElement loc0 = arg0. parseTypeExpression ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( String arg0 ) { PsiElement loc0 = new PsiElement ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiType parseContextTypeExpression ( Expr arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; return loc0. getType ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( Expr arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( Expr arg0 ) { PsiElement loc0 = arg0. getParent ( ) ; return loc0. getType ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( XMLStreamReader arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PsiElement parseContextTypeExpression ( Expr arg0 ) { return null ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_133_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_2401-2402": {
      "loc": "2401-2402",
      "input": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  return result;\n}",
      "target": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n  unreadToken = NO_UNREAD_TOKEN;\n  return result;\n}",
      "function range": "2399,3-2402,3",
      "raw_output": [
        "String function ( Element arg0 ) { return arg0. getAttribute ( \"srini_string\" ) ; }",
        "JSDocLine function ( Element arg0 ) { return arg0. getJSDoc ( ) ; }",
        "JSDocLine function ( ) { return SwingUtilities. findRemainingJSDoc ( this. getClass ( ) ) ; }",
        "JSDocLine function ( @ NotNull ParserRuleContext arg0 ) { return arg0. getPreviousJSDoc ( ) ; }",
        "JSDocLine function ( ) { return SwingUtilities. findRemainingJSDoc ( this ) ; }",
        "JSDocLine function ( Node arg0 ) { return arg0 == null? null : arg0. getJSDoc ( ) ; }",
        "JSDocLine function ( JSDocLine arg0 ) { return arg0 == null? null : arg0. getRemainingJSDoc ( ) ; }",
        "JSDocLine function ( Node arg0 ) { return arg0 == null? null : JSDocParser. getJSDoc ( arg0 ) ; }",
        "JSDocLine function ( Element arg0 ) { return arg0. getElementsByTagName ( \"srini_string\" ) ; }",
        "JSDocLine function ( Element arg0 ) { return arg0. getJSDoc ( ) ; }",
        "JSDocLine function ( StreamInput arg0 ) { int loc0 = arg0. remaining ( ) ; while ( loc0 > 0 ) { if ( arg0. readBoolean ( ) ) { return arg0. readJSDoc ( ) ; } loc0 -- ; } return null ; }",
        "JSDocLine function ( StreamInput arg0 ) { if ( arg0. remaining ( ) == 0 ) { return null ; } return arg0. readJSDoc ( ) ; }",
        "JSDocLine function ( StreamTokenizer arg0 ) { return arg0. skipPast ( \"srini_string\" ) ; }",
        "JSDocLine function ( StreamInput arg0 ) { return arg0. readJSDoc ( ) ; }",
        "JSDocLine function ( StreamInput arg0 ) { return arg0. skipJSDoc ( ) ; }",
        "JSDocLine function ( StreamTokenizer arg0 ) { return arg0. skipPast ( \"srini_string\" ) ; }",
        "JSDocLine function ( Stream arg0 ) { return arg0. skipJSDoc ( ) ; }",
        "JSDocLine function ( StreamInput arg0 ) { return arg0. skipJSDoc ( ) ; }",
        "JSDocLine function ( StreamInput arg0 ) { return arg0. readJSDoc ( ) ; }",
        "JSDocLine function ( StreamTokenizer arg0 ) { return arg0. nextToken ( ) ; }",
        "JSDocLine function ( ) { return null ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "JSDocLine function ( Element arg0 ) { return arg0. getJSDoc ( ) ; }",
        "JSDocLine function ( ) { return SwingUtilities. findRemainingJSDoc ( this ) ; }",
        "String function ( ) { return null ; }"
      ],
      "mid_translation": [
        "Gets the remaining JSDoc line.",
        "Get the remaining JSDoc line.",
        "Gets the remaining JSDoc line from the stream.",
        "Get the remaining JSDoc line from the stream.",
        "Returns the remaining JSDoc line."
      ],
      "output": [
        {
          "patch": "private String getRemainingJSDocLine ( Element arg0 ) { return arg0. getAttribute ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( Element arg0 ) { return arg0. getJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( ) { return SwingUtilities. findRemainingJSDoc ( this. getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( @ NotNull ParserRuleContext arg0 ) { return arg0. getPreviousJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( ) { return SwingUtilities. findRemainingJSDoc ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( Node arg0 ) { return arg0 == null? null : arg0. getJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( JSDocLine arg0 ) { return arg0 == null? null : arg0. getRemainingJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( Node arg0 ) { return arg0 == null? null : JSDocParser. getJSDoc ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( Element arg0 ) { return arg0. getElementsByTagName ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( Element arg0 ) { return arg0. getJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( StreamInput arg0 ) { int loc0 = arg0. remaining ( ) ; while ( loc0 > 0 ) { if ( arg0. readBoolean ( ) ) { return arg0. readJSDoc ( ) ; } loc0 -- ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( StreamInput arg0 ) { if ( arg0. remaining ( ) == 0 ) { return null ; } return arg0. readJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( StreamTokenizer arg0 ) { return arg0. skipPast ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( StreamInput arg0 ) { return arg0. readJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( StreamInput arg0 ) { return arg0. skipJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( StreamTokenizer arg0 ) { return arg0. skipPast ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( Stream arg0 ) { return arg0. skipJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( StreamInput arg0 ) { return arg0. skipJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( StreamInput arg0 ) { return arg0. readJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( StreamTokenizer arg0 ) { return arg0. nextToken ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String getRemainingJSDocLine ( ) { return \"srini_string\" ; }",
          "correctness": "timeout"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( Element arg0 ) { return arg0. getJSDoc ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private JSDocLine getRemainingJSDocLine ( ) { return SwingUtilities. findRemainingJSDoc ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String getRemainingJSDocLine ( ) { return null ; }",
          "correctness": "timeout"
        }
      ]
    },
    "Jsoup_15_/src/main/java/org/jsoup/parser/TreeBuilderState.java_283-284": {
      "loc": "283-284",
      "input": "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    return false; \n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    return false; \n                } else if (!tb.framesetOk()) {\n                    return false; \n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    while (stack.size() > 1)\n                        stack.removeLast();\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                    \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                    \"p\", \"section\", \"summary\", \"ul\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                Element form = tb.insert(startTag);\n                tb.setFormElement(form);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                        tb.process(new Token.EndTag(el.nodeName()));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"button\"));\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"a\"));\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.in(name,\n                    \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"nobr\"));\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                startTag.name(\"img\");\n                return tb.process(startTag);\n            } else if (name.equals(\"isindex\")) {\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n                tb.process(new Token.StartTag(\"form\"));\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.StartTag(\"label\"));\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n                tb.process(new Token.Character(prompt));\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.process(new Token.StartTag(\"input\", inputAttribs));\n                tb.process(new Token.EndTag(\"label\"));\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.EndTag(\"form\"));\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                TreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.process(new Token.EndTag(\"option\"));\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.in(\"rp\", \"rt\")) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); \n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (StringUtil.in(name,\n                    \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.name();\n            if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                    \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                    \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.process(new Token.StartTag(name)); \n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.in(name,\n                    \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                OUTER:\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    LinkedList<Element> stack = tb.getStack();\n                    for (int si = 0; si < stack.size(); si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    INNER:\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { \n                            tb.removeFromStack(node);\n                            continue INNER;\n                        } else if (node == formatEl)\n                            break INNER;\n                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n                        if (lastNode == furthestBlock) {\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n                        lastNode = node;\n                    }\n                    if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n                    Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); \n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n            break;\n        case EOF:\n            break;\n    }\n    return true;\n}",
      "target": "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                return tb.process(t, InHead);\n            } else if (name.equals(\"body\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    return false; \n                } else {\n                    tb.framesetOk(false);\n                    Element body = stack.get(1);\n                    for (Attribute attribute : startTag.getAttributes()) {\n                        if (!body.hasAttr(attribute.getKey()))\n                            body.attributes().put(attribute);\n                    }\n                }\n            } else if (name.equals(\"frameset\")) {\n                tb.error(this);\n                LinkedList<Element> stack = tb.getStack();\n                if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                    return false; \n                } else if (!tb.framesetOk()) {\n                    return false; \n                } else {\n                    Element second = stack.get(1);\n                    if (second.parent() != null)\n                        second.remove();\n                    while (stack.size() > 1)\n                        stack.removeLast();\n                    tb.insert(startTag);\n                    tb.transition(InFrameset);\n                }\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                    \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                    \"p\", \"section\", \"summary\", \"ul\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                    tb.error(this);\n                    tb.pop();\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"form\")) {\n                if (tb.getFormElement() != null) {\n                    tb.error(this);\n                    return false;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                Element form = tb.insert(startTag);\n                tb.setFormElement(form);\n            } else if (name.equals(\"li\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (el.nodeName().equals(\"li\")) {\n                        tb.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                tb.framesetOk(false);\n                LinkedList<Element> stack = tb.getStack();\n                for (int i = stack.size() - 1; i > 0; i--) {\n                    Element el = stack.get(i);\n                    if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                        tb.process(new Token.EndTag(el.nodeName()));\n                        break;\n                    }\n                    if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                        break;\n                }\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n            } else if (name.equals(\"plaintext\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.PLAINTEXT); \n            } else if (name.equals(\"button\")) {\n                if (tb.inButtonScope(\"button\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"button\"));\n                    tb.process(startTag);\n                } else {\n                    tb.reconstructFormattingElements();\n                    tb.insert(startTag);\n                    tb.framesetOk(false);\n                }\n            } else if (name.equals(\"a\")) {\n                if (tb.getActiveFormattingElement(\"a\") != null) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"a\"));\n                    Element remainingA = tb.getFromStack(\"a\");\n                    if (remainingA != null) {\n                        tb.removeFromActiveFormattingElements(remainingA);\n                        tb.removeFromStack(remainingA);\n                    }\n                }\n                tb.reconstructFormattingElements();\n                Element a = tb.insert(startTag);\n                tb.pushActiveFormattingElements(a);\n            } else if (StringUtil.in(name,\n                    \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (name.equals(\"nobr\")) {\n                tb.reconstructFormattingElements();\n                if (tb.inScope(\"nobr\")) {\n                    tb.error(this);\n                    tb.process(new Token.EndTag(\"nobr\"));\n                    tb.reconstructFormattingElements();\n                }\n                Element el = tb.insert(startTag);\n                tb.pushActiveFormattingElements(el);\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.insertMarkerToFormattingElements();\n                tb.framesetOk(false);\n            } else if (name.equals(\"table\")) {\n                if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                tb.transition(InTable);\n            } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                tb.reconstructFormattingElements();\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"input\")) {\n                tb.reconstructFormattingElements();\n                Element el = tb.insertEmpty(startTag);\n                if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                    tb.framesetOk(false);\n            } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                tb.insertEmpty(startTag);\n            } else if (name.equals(\"hr\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.insertEmpty(startTag);\n                tb.framesetOk(false);\n            } else if (name.equals(\"image\")) {\n                startTag.name(\"img\");\n                return tb.process(startTag);\n            } else if (name.equals(\"isindex\")) {\n                tb.error(this);\n                if (tb.getFormElement() != null)\n                    return false;\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n                tb.process(new Token.StartTag(\"form\"));\n                if (startTag.attributes.hasKey(\"action\")) {\n                    Element form = tb.getFormElement();\n                    form.attr(\"action\", startTag.attributes.get(\"action\"));\n                }\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.StartTag(\"label\"));\n                String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                        startTag.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n                tb.process(new Token.Character(prompt));\n                Attributes inputAttribs = new Attributes();\n                for (Attribute attr : startTag.attributes) {\n                    if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                        inputAttribs.put(attr);\n                }\n                inputAttribs.put(\"name\", \"isindex\");\n                tb.process(new Token.StartTag(\"input\", inputAttribs));\n                tb.process(new Token.EndTag(\"label\"));\n                tb.process(new Token.StartTag(\"hr\"));\n                tb.process(new Token.EndTag(\"form\"));\n            } else if (name.equals(\"textarea\")) {\n                tb.insert(startTag);\n                tb.tokeniser.transition(TokeniserState.Rcdata);\n                tb.markInsertionMode();\n                tb.framesetOk(false);\n                tb.transition(Text);\n            } else if (name.equals(\"xmp\")) {\n                if (tb.inButtonScope(\"p\")) {\n                    tb.process(new Token.EndTag(\"p\"));\n                }\n                tb.reconstructFormattingElements();\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"iframe\")) {\n                tb.framesetOk(false);\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"noembed\")) {\n                handleRawtext(startTag, tb);\n            } else if (name.equals(\"select\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.framesetOk(false);\n                TreeBuilderState state = tb.state();\n                if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                    tb.transition(InSelectInTable);\n                else\n                    tb.transition(InSelect);\n            } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                if (tb.currentElement().nodeName().equals(\"option\"))\n                    tb.process(new Token.EndTag(\"option\"));\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            } else if (StringUtil.in(\"rp\", \"rt\")) {\n                if (tb.inScope(\"ruby\")) {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                        tb.error(this);\n                        tb.popStackToBefore(\"ruby\"); \n                    }\n                    tb.insert(startTag);\n                }\n            } else if (name.equals(\"math\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (name.equals(\"svg\")) {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n                tb.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (StringUtil.in(name,\n                    \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                tb.error(this);\n                return false;\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(startTag);\n            }\n            break;\n        case EndTag:\n            Token.EndTag endTag = t.asEndTag();\n            name = endTag.name();\n            if (name.equals(\"body\")) {\n                if (!tb.inScope(\"body\")) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.transition(AfterBody);\n                }\n            } else if (name.equals(\"html\")) {\n                boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                if (notIgnored)\n                    return tb.process(endTag);\n            } else if (StringUtil.in(name,\n                    \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                    \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                    \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"form\")) {\n                Element currentForm = tb.getFormElement();\n                tb.setFormElement(null);\n                if (currentForm == null || !tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.removeFromStack(currentForm);\n                }\n            } else if (name.equals(\"p\")) {\n                if (!tb.inButtonScope(name)) {\n                    tb.error(this);\n                    tb.process(new Token.StartTag(name)); \n                    return tb.process(endTag);\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (name.equals(\"li\")) {\n                if (!tb.inListItemScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                if (!tb.inScope(name)) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                }\n            } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                    tb.error(this);\n                    return false;\n                } else {\n                    tb.generateImpliedEndTags(name);\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                }\n            } else if (name.equals(\"sarcasm\")) {\n                return anyOtherEndTag(t, tb);\n            } else if (StringUtil.in(name,\n                    \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                OUTER:\n                for (int i = 0; i < 8; i++) {\n                    Element formatEl = tb.getActiveFormattingElement(name);\n                    if (formatEl == null)\n                        return anyOtherEndTag(t, tb);\n                    else if (!tb.onStack(formatEl)) {\n                        tb.error(this);\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    } else if (!tb.inScope(formatEl.nodeName())) {\n                        tb.error(this);\n                        return false;\n                    } else if (tb.currentElement() != formatEl)\n                        tb.error(this);\n                    Element furthestBlock = null;\n                    Element commonAncestor = null;\n                    boolean seenFormattingElement = false;\n                    LinkedList<Element> stack = tb.getStack();\n                    for (int si = 0; si < stack.size(); si++) {\n                        Element el = stack.get(si);\n                        if (el == formatEl) {\n                            commonAncestor = stack.get(si - 1);\n                            seenFormattingElement = true;\n                        } else if (seenFormattingElement && tb.isSpecial(el)) {\n                            furthestBlock = el;\n                            break;\n                        }\n                    }\n                    if (furthestBlock == null) {\n                        tb.popStackToClose(formatEl.nodeName());\n                        tb.removeFromActiveFormattingElements(formatEl);\n                        return true;\n                    }\n                    Element node = furthestBlock;\n                    Element lastNode = furthestBlock;\n                    INNER:\n                    for (int j = 0; j < 3; j++) {\n                        if (tb.onStack(node))\n                            node = tb.aboveOnStack(node);\n                        if (!tb.isInActiveFormattingElements(node)) { \n                            tb.removeFromStack(node);\n                            continue INNER;\n                        } else if (node == formatEl)\n                            break INNER;\n                        Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                        tb.replaceActiveFormattingElement(node, replacement);\n                        tb.replaceOnStack(node, replacement);\n                        node = replacement;\n                        if (lastNode == furthestBlock) {\n                        }\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        node.appendChild(lastNode);\n                        lastNode = node;\n                    }\n                    if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        tb.insertInFosterParent(lastNode);\n                    } else {\n                        if (lastNode.parent() != null)\n                            lastNode.remove();\n                        commonAncestor.appendChild(lastNode);\n                    }\n                    Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n                    Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n                    for (Node childNode : childNodes) {\n                        adopter.appendChild(childNode); \n                    }\n                    furthestBlock.appendChild(adopter);\n                    tb.removeFromActiveFormattingElements(formatEl);\n                    tb.removeFromStack(formatEl);\n                    tb.insertOnStackAfter(furthestBlock, adopter);\n                }\n            } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                if (!tb.inScope(\"name\")) {\n                    if (!tb.inScope(name)) {\n                        tb.error(this);\n                        return false;\n                    }\n                    tb.generateImpliedEndTags();\n                    if (!tb.currentElement().nodeName().equals(name))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    tb.clearFormattingElementsToLastMarker();\n                }\n            } else if (name.equals(\"br\")) {\n                tb.error(this);\n                tb.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(t, tb);\n            }\n            break;\n        case EOF:\n            break;\n    }\n    return true;\n}",
      "function range": "246,9-761,9",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_1_/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java_58-59": {
      "loc": "58-59",
      "input": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\n') {\n        lineCounter++;\n    }\n    lastChar = current;\n    return lastChar;\n}",
      "target": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n    if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {\n        lineCounter++;\n    }\n    lastChar = current;\n    return lastChar;\n}",
      "function range": "55,5-63,5",
      "raw_output": [
        "char function ( ) { return ( char ) ( getLine ( ) + 1 ) ; }",
        "char function ( ) { return ( char ) ( 1024 * 1024 ) ; }",
        "char function ( ) { return ( char ) ( this. nextLine ( ) + 1 ) ; }",
        "char function ( ) { }",
        "char function ( ) { return ( char ) ( getLineCounter ( ) + 1 ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "Token function ( ) { return null ; }",
        "Token function ( ) { return new Token ( ) ; }",
        "Token function ( TokenStream arg0 ) { return arg0. nextToken ( ) ; }",
        "Token function ( LineReader arg0 ) { return arg0. nextToken ( ) ; }",
        "long function ( ) { return ++ counter ; }",
        "long function ( ) { return ++ line_counter ; }",
        "long function ( ) { return ++ line ; }",
        "long function ( ) { return ++ lastLine ; }",
        "long function ( ) { return 0 ; }",
        "char function ( ) { return ( char ) ( getLine ( ) + 1 ) ; }",
        "char function ( ) { return ( char ) ( 1024 * 1024 ) ; }",
        "char function ( ) { }",
        "int function ( ) { return ++ line ; }",
        "char function ( ) { return ( char ) ( this. nextLine ( ) + 1 ) ; }",
        "char function ( ) { return ( char ) ( lineCounter. getLine ( ) + 1 ) ; }",
        "char function ( ) { return ( char ) ( lineCounter. getLine ( ) - 1 ) ; }",
        "char function ( ) { return ( char ) ( getLineCounter ( ). peek ( ) ) ; }",
        "char function ( ) { return ( char ) ( lineCounter. peekLine ( ) ) ; }",
        "char function ( ) { return ( char ) ( lineCounter. get ( ) + 1 ) ; }"
      ],
      "mid_translation": [
        "Override the read method to increment the line counter and return the last character.",
        "Override the read method to increment the line counter and return the last token.",
        "Override the read method to increment the line counter and return the last value.",
        "Override the read method to increment the line counter and return the last char.",
        "Override the read method to increment the lineCounter and return the last character."
      ],
      "output": [
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( getLine ( ) + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( 1024 * 1024 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( this. nextLine ( ) + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( getLineCounter ( ) + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String read ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Token read ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Token read ( ) { return new Token ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Token read ( TokenStream arg0 ) { return arg0. nextToken ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Token read ( LineReader arg0 ) { return arg0. nextToken ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic long read ( ) { return ++ counter ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic long read ( ) { return ++ line_counter ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic long read ( ) { return ++ line ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic long read ( ) { return ++ lastLine ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic long read ( ) { return 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( getLine ( ) + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( 1024 * 1024 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int read ( ) { return ++ line ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( this. nextLine ( ) + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( lineCounter. getLine ( ) + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( lineCounter. getLine ( ) - 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( getLineCounter ( ). peek ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( lineCounter. peekLine ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic char read ( ) { return ( char ) ( lineCounter. get ( ) + 1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_46_/src/main/java/org/jsoup/nodes/Entities.java_118-119": {
      "loc": "118-119",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) \n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
      "target": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) \n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
      "function range": "79,5-154,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_37_/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java_135-136": {
      "loc": "135-136",
      "input": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n            _valueHandler, _typeHandler, _asStatic);\n}",
      "target": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    return new SimpleType(subclass, _bindings, this, _superInterfaces,\n            _valueHandler, _typeHandler, _asStatic);\n}",
      "function range": "119,5-137,5",
      "raw_output": [
        "JavaType function ( ) { return JavaTypeHelper. narrow ( this ) ; }",
        "JavaType function ( ) { return narrow ( ( JavaType ) this ) ; }",
        "JavaType function ( ) { return narrow ( ( JavaType ) this ) ; }",
        "JavaType function ( ) { return JavaTypeLattice. narrow ( this ) ; }",
        "JavaType function ( ) { return JavaTypeHelper. narrow ( this, JavaType. class ) ; }",
        "JavaType function ( ) { return JavaTypeLattice. narrower ( this ) ; }",
        "JavaType function ( ) { JavaType loc0 = JavaTypeRegistry. getType ( getClass ( ) ) ; loc0 = narrower ( loc0, this ) ; return loc0 ; }",
        "JavaType function ( ) { return JavaTypeLattice. narrower ( this ) ; }",
        "JavaType function ( ) { return JavaTypeLattice. narrower ( getType ( ) ) ; }",
        "JavaType function ( ) { return JavaTypeHelper. narrower ( this ) ; }",
        "JavaType function ( ) { return JavaTypeLattice. narrower ( this ) ; }",
        "JavaType function ( ) { return JavaTypeLattice. narrower ( this ) ; }",
        "JavaType function ( ) { JavaType loc0 = getType ( ) ; if ( loc0 instanceof JavaType ) { loc0 = ( JavaType ) loc0 ; } return narrower ( ( JavaType ) loc0 ) ; }",
        "JavaType function ( ) { JavaType loc0 = getType ( ) ; if ( loc0 instanceof JavaType ) { loc0 = ( JavaType ) loc0 ; } else if ( loc0 instanceof JavaType ) { loc0 = ( JavaType ) loc0 ; } return loc0 ; }",
        "JavaType function ( ) { return narrower ( JavaType. class ) ; }",
        "JavaType function ( ) { return JavaTypeLattice. narrower ( this ) ; }",
        "JavaType function ( ) { return getType ( ). narrower ( ) ; }",
        "JavaType function ( ) { return JavaTypeLattice. narrow ( this ) ; }",
        "JavaType function ( ) { return JavaTypeHelper. narrower ( this ) ; }",
        "JavaType function ( ) { return JavaTypeLattice. narrower ( this ) ; }",
        "org. omg. CORBA. Object function ( Class arg0 ) { try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { BAD_OPERATION loc1 = new BAD_OPERATION ( \"srini_string\" ) ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
        "org. omg. CORBA. Object function ( Class arg0 ) { try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { BAD_OPERATION loc1 = new BAD_OPERATION ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; throw loc1 ; } }",
        "org. omg. CORBA. Object function ( Class arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { throw new ClassCastException ( \"srini_string\" ) ; } }",
        "org. omg. CORBA. Object function ( Class arg0 ) { try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { BAD_OPERATION loc1 = new BAD_OPERATION ( \"srini_string\" ) ; loc1. minor = Minor. ClassCast ; throw loc1 ; } }",
        "org. omg. CORBA. TypeCode function ( java. lang. Class arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { throw new ClassCastException ( \"srini_string\" ) ; } }"
      ],
      "mid_translation": [
        "Returns a JavaType that is narrowed to this one.",
        "Returns a JavaType that is a narrower version of this one.",
        "Returns a JavaType that is a narrower of this one.",
        "Returns a JavaType that is a narrower version of this type.",
        "Returns a new instance of this type with the specified subclass."
      ],
      "output": [
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeHelper. narrow ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return narrow ( ( JavaType ) this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return narrow ( ( JavaType ) this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeLattice. narrow ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeHelper. narrow ( this, JavaType. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeLattice. narrower ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { JavaType loc0 = JavaTypeRegistry. getType ( getClass ( ) ) ; loc0 = narrower ( loc0, this ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeLattice. narrower ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeLattice. narrower ( getType ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeHelper. narrower ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeLattice. narrower ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeLattice. narrower ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { JavaType loc0 = getType ( ) ; if ( loc0 instanceof JavaType ) { loc0 = ( JavaType ) loc0 ; } return narrower ( ( JavaType ) loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { JavaType loc0 = getType ( ) ; if ( loc0 instanceof JavaType ) { loc0 = ( JavaType ) loc0 ; } else if ( loc0 instanceof JavaType ) { loc0 = ( JavaType ) loc0 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return narrower ( JavaType. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeLattice. narrower ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return getType ( ). narrower ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeLattice. narrow ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeHelper. narrower ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected JavaType _narrow ( ) { return JavaTypeLattice. narrower ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected org. omg. CORBA. Object _narrow ( Class arg0 ) { try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { BAD_OPERATION loc1 = new BAD_OPERATION ( \"srini_string\" ) ; loc1. initCause ( loc0 ) ; throw loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected org. omg. CORBA. Object _narrow ( Class arg0 ) { try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { BAD_OPERATION loc1 = new BAD_OPERATION ( \"srini_string\" ) ; loc1. minor = Minor. Inappropriate ; throw loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected org. omg. CORBA. Object _narrow ( Class arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { throw new ClassCastException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected org. omg. CORBA. Object _narrow ( Class arg0 ) { try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { BAD_OPERATION loc1 = new BAD_OPERATION ( \"srini_string\" ) ; loc1. minor = Minor. ClassCast ; throw loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected org. omg. CORBA. TypeCode _narrow ( java. lang. Class arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } try { return arg0. cast ( this ) ; } catch ( ClassCastException loc0 ) { throw new ClassCastException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_24_/src/main/java/org/jsoup/parser/TokeniserState.java_558-559": {
      "loc": "558-559",
      "input": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        r.advance();\n        return;\n    }\n    if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\f':\n            case ' ':\n                t.transition(BeforeAttributeName);\n                break;\n            case '/':\n                t.transition(SelfClosingStartTag);\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(Data);\n                break;\n            default:\n                t.dataBuffer.append(c);\n                anythingElse(t, r);\n                break;\n        }\n    } else {\n        anythingElse(t, r);\n    }\n}",
      "target": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n        return;\n    }\n    if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\f':\n            case ' ':\n                t.transition(BeforeAttributeName);\n                break;\n            case '/':\n                t.transition(SelfClosingStartTag);\n                break;\n            case '>':\n                t.emitTagPending();\n                t.transition(Data);\n                break;\n            default:\n                t.dataBuffer.append(c);\n                anythingElse(t, r);\n                break;\n        }\n    } else {\n        anythingElse(t, r);\n    }\n}",
      "function range": "553,9-586,9",
      "raw_output": [
        "List < Integer > function ( Integer arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( loc1 ) ; return loc0 ; }",
        "List < Integer > function ( Integer arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0. add ( new Integer ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( Integer arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( new Integer ( loc1 ) ) ; return loc0 ; }",
        "List < Integer > function ( ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) loc0. add ( new Integer ( loc1 ) ) ; return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; if ( loc1 < 0 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; if ( loc0 < 0 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; if ( loc1 < 0 ) { throw new IOException ( \"srini_string\" + arg0. read ( ) ) ; } return loc0 ; }",
        "int function ( CharacterReader arg0 ) { int loc0 = arg0. read ( ) ; if ( loc0 < 0 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; if ( loc1 < 0 ) { throw new IOException ( \"srini_string\" + arg0 ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; if ( loc0 < 0 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; if ( loc1 < 0 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; int loc2 = arg0. read ( ) ; if ( ( loc2 & 0xc0 )!= 0x80 ) { return loc0 ; } else if ( ( loc2 & 0x80 )!= 0 ) { return loc1 ; } else { throw new IOException ( \"srini_string\" + arg0. read ( ) ) ; } }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; int loc2 = arg0. read ( ) ; int loc3 = arg0. read ( ) ; if ( ( loc3 & 0xc0 )!= 0x80 ) { return loc2 ; } else if ( loc3 & 0x80 ) { return loc0 ; } else { throw new IOException ( \"srini_string\" ) ; } }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; int loc2 = arg0. read ( ) ; int loc3 = arg0. read ( ) ; if ( ( loc3 & 0xc0 )!= 0x80 ) { return loc0 ; } else if ( loc3 & 0x80 ) { return loc1 ; } else { throw new IOException ( \"srini_string\" ) ; } }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; if ( loc0 == - 1 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; if ( loc1 < 0 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; if ( loc0 < 0 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new IOException ( ) ; } if ( loc1 == - 1 ) { throw new IOException ( ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { throw new IOException ( \"srini_string\" ) ; } if ( loc1 == loc0 ) { return loc2 ; } return loc1 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; if ( loc0 == - 1 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. read ( ) ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { return loc0 ; } loc0 ++ ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = arg0. read ( ) ; int loc1 = arg0. read ( ) ; if ( loc1 < 0 ) { throw new IOException ( \"srini_string\" ) ; } return loc0 ; }",
        "int function ( Reader arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. read ( ) ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { return loc0 ; } loc0 ++ ; } if ( loc0 < arg0. read ( ) ) { return loc0 ; } return 0 ; }",
        "int function ( Reader arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. read ( ) ; loc1 ++ ) { int loc2 = arg0. read ( ) ; if ( loc2 == - 1 ) { return loc0 ; } loc0 ++ ; } if ( loc0 == 0 ) { return loc0 ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Method read.",
        "Read a CR tag from a CharacterReader.",
        "Reads a CR tag from a CharacterReader.",
        "Read a CR tag from a character reader.",
        "Reads a CR tag from a character reader."
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_57_/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java_1441-1442": {
      "loc": "1441-1442",
      "input": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n            true));\n}",
      "target": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n            true));\n}",
      "function range": "1435,5-1443,5",
      "raw_output": [
        "byte [ ] function ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return loc0 ; }",
        "List < byte [ ] > function ( byte [ ] arg0, int arg1, int arg2 ) { List < byte [ ] > loc0 = new ArrayList < > ( arg2 ) ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0. add ( arg0 [ arg1 + loc1 ] ) ; return loc0 ; }",
        "List < byte [ ] > function ( byte [ ] arg0, int arg1, int arg2 ) { List < byte [ ] > loc0 = new ArrayList < > ( arg2 ) ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0. add ( arg0 [ arg1 + loc1 ] ) ; } return loc0 ; }",
        "byte [ ] function ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) ( arg0 [ arg1 + loc1 ] & 0xff ) ; arg0 [ arg1 + loc1 ] = 0xff ; } return loc0 ; }",
        "byte [ ] function ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) ( arg0 [ arg1 + loc1 ] & 0xff ) ; } return loc0 ; }",
        "void function ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { Iterator loc0 = arg0. iterator ( ) ; while ( loc0. hasNext ( ) ) { int loc1 = loc0. next ( ) ; arg1 [ arg2 + loc1 ] = ( byte ) loc0. next ( ) ; } }",
        "void function ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { Iterator loc0 = arg0. iterator ( ) ; while ( loc0. hasNext ( ) ) { int loc1 = loc0. next ( ) ; arg1 [ arg2 + loc1 ] = ( byte ) loc1 ; loc0. next ( ) ; } }",
        "void function ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { Iterator loc0 = arg0. iterator ( ) ; while ( loc0. hasNext ( ) ) { int loc1 = loc0. next ( ) ; arg1 [ arg2 + loc1 ] = ( byte ) loc1 ; loc0. remove ( ) ; } }",
        "void function ( final InputStream arg0, final byte [ ] arg1, final int arg2, final Map < byte, Integer > arg3 ) { while ( arg0. available ( ) > 0 ) { final int loc0 = arg0. read ( arg1, arg2, arg3 ) ; arg3. put ( loc0, arg1. length - loc0 ) ; } }",
        "void function ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { Iterator loc0 = arg0. iterator ( ) ; while ( loc0. hasNext ( ) ) { int loc1 = loc0. next ( ) ; arg1 [ arg2 + loc1 ] = ( byte ) loc0. next ( ) ; } loc0. remove ( ) ; }",
        "List < byte [ ] > function ( byte [ ] arg0, int arg1, int arg2 ) { List < byte [ ] > loc0 = new ArrayList < > ( arg2 ) ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0. add ( arg0 [ arg1 + loc1 ] ) ; return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0 [ arg1 + loc1 ] & 0xff ; arg0 [ arg1 + loc1 ] = ( byte ) loc2 ; loc0 += loc2 ; } return loc0 ; }",
        "byte [ ] function ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0 [ arg1 + loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0 [ arg1 + loc1 ] & 0xff ; arg0 [ arg1 + loc1 ] = ( byte ) loc2 ; loc0 ++ ; } return loc0 ; }",
        "byte [ ] function ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0 [ arg1 + loc1 ] = ( byte ) arg0 [ loc1 ] ; return loc0 ; }",
        "byte [ ] function ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = arg1 ; loc1 < arg1 + arg2 ; loc1 ++ ) { if ( arg0 [ loc1 ] < 0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = arg1 ; loc1 < arg1 + arg2 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] & 0xFF ; loc0 += loc2 << 8 ; if ( loc0 < 0 ) { throw new EOFException ( ) ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0 [ arg1 + loc1 ] & 0xFF ; loc0 += loc2 << 8 ; if ( loc0 < 0 ) { break ; } } return loc0 ; }",
        "int function ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0 [ arg1 + loc1 ] ; if ( loc2 < 0 ) { loc0 ++ ; } while ( loc0 < arg0. arg2 ) { loc0 ++ ; } } return loc0 ; }",
        "void function ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = arg0. readByte ( ) ; } }",
        "void function ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { byte [ ] loc0 = new byte [ arg2 ] ; while ( arg0. hasNext ( loc0 ) ) { int loc1 = arg0. readByte ( ) ; arg1 [ arg2 + loc1 ] = loc0 [ loc1 ] ; arg0. next ( loc0, 0, loc1 ) ; } }",
        "void function ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { byte [ ] loc0 = new byte [ arg3 ] ; for ( int loc1 = 0 ; loc1 < arg3 ; loc1 ++ ) { loc0 [ loc1 ] = arg0. readByte ( ) ; } }",
        "MappingIterator function ( byte [ ] arg0, int arg1, int arg2 ) { return new BytesMappingIterator ( arg0, arg1, arg2 ) ; }",
        "void function ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { byte [ ] loc0 = new byte [ arg2 ] ; while ( arg0. hasNext ( loc0 ) ) { int loc1 = arg0. readByte ( ) ; arg1 [ arg2 + loc1 ] = loc0 [ loc1 ] ; arg0. read ( loc0, 0, loc1 ) ; } }"
      ],
      "mid_translation": [
        "Reads a sequence of bytes from a byte array.",
        "Reads a sequence of bytes into a mapping iterator.",
        "Read a sequence of bytes from a byte array.",
        "Reads a sequence of bytes from the given byte array.",
        "Read a sequence of bytes into a mapping iterator."
      ],
      "output": [
        {
          "patch": "public byte [ ] readValues ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > readValues ( byte [ ] arg0, int arg1, int arg2 ) { List < byte [ ] > loc0 = new ArrayList < > ( arg2 ) ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0. add ( arg0 [ arg1 + loc1 ] ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > readValues ( byte [ ] arg0, int arg1, int arg2 ) { List < byte [ ] > loc0 = new ArrayList < > ( arg2 ) ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0. add ( arg0 [ arg1 + loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] readValues ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) ( arg0 [ arg1 + loc1 ] & 0xff ) ; arg0 [ arg1 + loc1 ] = 0xff ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] readValues ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) ( arg0 [ arg1 + loc1 ] & 0xff ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void readValues ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { Iterator loc0 = arg0. iterator ( ) ; while ( loc0. hasNext ( ) ) { int loc1 = loc0. next ( ) ; arg1 [ arg2 + loc1 ] = ( byte ) loc0. next ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void readValues ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { Iterator loc0 = arg0. iterator ( ) ; while ( loc0. hasNext ( ) ) { int loc1 = loc0. next ( ) ; arg1 [ arg2 + loc1 ] = ( byte ) loc1 ; loc0. next ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void readValues ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { Iterator loc0 = arg0. iterator ( ) ; while ( loc0. hasNext ( ) ) { int loc1 = loc0. next ( ) ; arg1 [ arg2 + loc1 ] = ( byte ) loc1 ; loc0. remove ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void readValues ( final InputStream arg0, final byte [ ] arg1, final int arg2, final Map < byte, Integer > arg3 ) { while ( arg0. available ( ) > 0 ) { final int loc0 = arg0. read ( arg1, arg2, arg3 ) ; arg3. put ( loc0, arg1. length - loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void readValues ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { Iterator loc0 = arg0. iterator ( ) ; while ( loc0. hasNext ( ) ) { int loc1 = loc0. next ( ) ; arg1 [ arg2 + loc1 ] = ( byte ) loc0. next ( ) ; } loc0. remove ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > readValues ( byte [ ] arg0, int arg1, int arg2 ) { List < byte [ ] > loc0 = new ArrayList < > ( arg2 ) ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0. add ( arg0 [ arg1 + loc1 ] ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int readValues ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0 [ arg1 + loc1 ] & 0xff ; arg0 [ arg1 + loc1 ] = ( byte ) loc2 ; loc0 += loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] readValues ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0 [ arg1 + loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int readValues ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0 [ arg1 + loc1 ] & 0xff ; arg0 [ arg1 + loc1 ] = ( byte ) loc2 ; loc0 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] readValues ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) loc0 [ arg1 + loc1 ] = ( byte ) arg0 [ loc1 ] ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public byte [ ] readValues ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) arg0 [ arg1 + loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int readValues ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = arg1 ; loc1 < arg1 + arg2 ; loc1 ++ ) { if ( arg0 [ loc1 ] < 0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int readValues ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = arg1 ; loc1 < arg1 + arg2 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] & 0xFF ; loc0 += loc2 << 8 ; if ( loc0 < 0 ) { throw new EOFException ( ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int readValues ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0 [ arg1 + loc1 ] & 0xFF ; loc0 += loc2 << 8 ; if ( loc0 < 0 ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int readValues ( byte [ ] arg0, int arg1, int arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { int loc2 = arg0 [ arg1 + loc1 ] ; if ( loc2 < 0 ) { loc0 ++ ; } while ( loc0 < arg0. arg2 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void readValues ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { byte [ ] loc0 = new byte [ arg2 ] ; for ( int loc1 = 0 ; loc1 < arg2 ; loc1 ++ ) { loc0 [ loc1 ] = arg0. readByte ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void readValues ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { byte [ ] loc0 = new byte [ arg2 ] ; while ( arg0. hasNext ( loc0 ) ) { int loc1 = arg0. readByte ( ) ; arg1 [ arg2 + loc1 ] = loc0 [ loc1 ] ; arg0. next ( loc0, 0, loc1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void readValues ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { byte [ ] loc0 = new byte [ arg3 ] ; for ( int loc1 = 0 ; loc1 < arg3 ; loc1 ++ ) { loc0 [ loc1 ] = arg0. readByte ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MappingIterator readValues ( byte [ ] arg0, int arg1, int arg2 ) { return new BytesMappingIterator ( arg0, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void readValues ( ByteSource arg0, byte [ ] arg1, int arg2, int arg3 ) { byte [ ] loc0 = new byte [ arg2 ] ; while ( arg0. hasNext ( loc0 ) ) { int loc1 = arg0. readByte ( ) ; arg1 [ arg2 + loc1 ] = loc0 [ loc1 ] ; arg0. read ( loc0, 0, loc1 ) ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonCore_25_/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java_1963-1964": {
      "loc": "1963-1964",
      "input": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        outBuf[outPtr++] = c;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}",
      "target": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        outBuf[outPtr++] = c;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}",
      "function range": "1948,5-1990,5",
      "raw_output": [
        "void function ( ) { }",
        "void function ( ) { Name loc0 = \"srini_string\" ; Class <? > loc1 = Class. forName ( loc0 ) ; String loc2 = \"srini_string\" ; Method loc3 = ( Method ) loc1. getMethod ( \"srini_string\" ) ; loc3. setAccessible ( true ) ; loc3. invoke ( null, loc2 ) ; }",
        "void function ( ) { String loc0 = \"srini_string\" ; Class <? > loc1 = Class. forName ( loc0 ) ; String loc2 = \"srini_string\" ; Method loc3 = ( Method ) loc1. getMethod ( \"srini_string\" ) ; loc3. setAccessible ( true ) ; loc3. invoke ( null, loc2 ) ; }",
        "void function ( ) { Name loc0 = \"srini_string\" ; Class <? > loc1 = Class. forName ( loc0 ) ; String loc2 = \"srini_string\" ; Method loc3 = ( Method ) loc1. getMethod ( \"srini_string\" ) ; loc3. invoke ( null, loc2 ) ; }",
        "void function ( ) { String loc0 = \"srini_string\" ; Class <? > loc1 = Class. forName ( loc0 ) ; String loc2 = \"srini_string\" ; Method loc3 = ( Method ) loc1. getMethod ( \"srini_string\" ) ; loc3. invoke ( null, loc2 ) ; }",
        "void function ( OddName arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( OddName arg0, int arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( OddName arg0, Name arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( OddName arg0, String arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( OddName arg0, Integer arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( int arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0 ) ; }",
        "void function ( int arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
        "void function ( int arg0, char arg1 ) { if ( ( arg0 & 1 )!= 1 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
        "void function ( int arg0, String arg1 ) { if ( arg0 % 2!= 0 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
        "void function ( int arg0, char arg1 ) { if ( ( arg0 & 1 )!= 0 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
        "void function ( int arg0, String arg1 ) { throw new RuntimeException ( \"srini_string\" + arg0 + \"srini_string\" + arg1 ) ; }",
        "void function ( int arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }",
        "void function ( int arg0, String arg1 ) { if ( arg0 % 2!= 0 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
        "void function ( int arg0, int arg1 ) { throw new RuntimeException ( \"srini_string\" + arg0 + \"srini_string\" + arg1 ) ; }",
        "void function ( int arg0, int arg1 ) { if ( ( arg0 & 1 )!= 0 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
        "void function ( int arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }",
        "void function ( int arg0 ) { }",
        "void function ( int arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0 ) ; }",
        "void function ( int arg0 ) { throw new Error ( \"srini_string\" ) ; }",
        "void function ( int arg0, int arg1 ) { throw new RuntimeException ( \"srini_string\" ) ; }"
      ],
      "mid_translation": [
        "handleOddName2 Method.",
        "Handle Odd Name 2.",
        "Handle an odd name.",
        "Handle odd name 2.",
        "Handle an odd name 2."
      ],
      "output": [
        {
          "patch": "private void _handleOddName2 ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( ) { Name loc0 = \"srini_string\" ; Class <? > loc1 = Class. forName ( loc0 ) ; String loc2 = \"srini_string\" ; Method loc3 = ( Method ) loc1. getMethod ( \"srini_string\" ) ; loc3. setAccessible ( true ) ; loc3. invoke ( null, loc2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( ) { String loc0 = \"srini_string\" ; Class <? > loc1 = Class. forName ( loc0 ) ; String loc2 = \"srini_string\" ; Method loc3 = ( Method ) loc1. getMethod ( \"srini_string\" ) ; loc3. setAccessible ( true ) ; loc3. invoke ( null, loc2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( ) { Name loc0 = \"srini_string\" ; Class <? > loc1 = Class. forName ( loc0 ) ; String loc2 = \"srini_string\" ; Method loc3 = ( Method ) loc1. getMethod ( \"srini_string\" ) ; loc3. invoke ( null, loc2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( ) { String loc0 = \"srini_string\" ; Class <? > loc1 = Class. forName ( loc0 ) ; String loc2 = \"srini_string\" ; Method loc3 = ( Method ) loc1. getMethod ( \"srini_string\" ) ; loc3. invoke ( null, loc2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( OddName arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( OddName arg0, int arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( OddName arg0, Name arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( OddName arg0, String arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( OddName arg0, Integer arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0, char arg1 ) { if ( ( arg0 & 1 )!= 1 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0, String arg1 ) { if ( arg0 % 2!= 0 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0, char arg1 ) { if ( ( arg0 & 1 )!= 0 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0, String arg1 ) { throw new RuntimeException ( \"srini_string\" + arg0 + \"srini_string\" + arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0, String arg1 ) { if ( arg0 % 2!= 0 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0, int arg1 ) { throw new RuntimeException ( \"srini_string\" + arg0 + \"srini_string\" + arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0, int arg1 ) { if ( ( arg0 & 1 )!= 0 ) { throw new RuntimeException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0 ) { throw new RuntimeException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0 ) { throw new RuntimeException ( \"srini_string\" + arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0 ) { throw new Error ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void _handleOddName2 ( int arg0, int arg1 ) { throw new RuntimeException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_34_/src/main/java/org/jsoup/parser/CharacterReader.java_91-92": {
      "loc": "91-92",
      "input": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        if (offset < length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) \n                return offset - pos;\n        }\n    }\n    return -1;\n}",
      "target": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) \n                return offset - pos;\n        }\n    }\n    return -1;\n}",
      "function range": "82,5-98,5",
      "raw_output": [
        "Object function ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. get ( 0 ) ; } else if ( arg0 instanceof List ) { return nextIndexOf ( ( List ) arg0 ) ; } else { return null ; } }",
        "Object function ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. get ( 0 ) ; } else if ( arg0 instanceof Collection ) { return nextIndexOf ( ( List ) arg0 ) ; } else { return null ; } }",
        "Object function ( T arg0 ) { return nextIndexOf ( arg0. getClass ( ), arg0 ) ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return 0 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( this ) ; } else { return - 1 ; } }",
        "int function ( T arg0 ) { return ( arg0 == null )? 0 : arg0. hashCode ( ) ; }",
        "int function ( Sequence arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( Sequence arg0, char arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( Sequence arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg0. charAt ( loc0 + 1 ) ) { return loc0 ; } } return - 1 ; }",
        "int function ( Sequence arg0, Sequence arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg1. contains ( arg0. charAt ( loc0 ) ) ) { return loc0 ; } } return - 1 ; }",
        "int function ( Sequence arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } for ( int loc0 = 0 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { if ( arg0. charAt ( loc1 ) == arg2 ) { return loc1 ; } } return - 1 ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg0 ) { return loc0 ; } } return - 1 ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } for ( int loc0 = 0 ; loc0 < arg2 ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
        "int function ( CharSequence arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg2 ) { return loc0 ; } } return - 1 ; }",
        "int function ( Sequence arg0, int arg1 ) { for ( int loc0 = arg1 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( Sequence arg0, char arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( Sequence arg0, boolean arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg1 && ( arg0. charAt ( loc0 ) == arg0. charAt ( loc0 ) ) ) { return loc0 ; } } return - 1 ; }",
        "int function ( Sequence arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( Sequence arg0, int arg1, boolean arg2 ) { for ( int loc0 = arg1 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( Object arg0, Object arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg1. equals ( arg0. get ( loc0 ) ) ) return loc0 ; return - 1 ; }",
        "int function ( Object arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. get ( loc0 ) == null ) return loc0 + 1 ; return - 1 ; }",
        "int function ( Object arg0, Object arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg1. equals ( arg0. get ( loc0 ) ) ) { return loc0 + 1 ; } } return - 1 ; }",
        "int function ( Object arg0, Object arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. get ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
        "int function ( Object arg0, Object arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg1. equals ( arg0. get ( loc0 ) ) ) { return loc0 ; } } return - 1 ; }"
      ],
      "mid_translation": [
        "Method nextIndexOf.",
        "This method returns the index of the first occurrence of the specified sequence.",
        "Returns the index of the first occurrence of the specified sequence.",
        "This method returns the index of the next occurrence of the specified sequence.",
        "nextIndexOf Method."
      ],
      "output": [
        {
          "patch": "Object nextIndexOf ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. get ( 0 ) ; } else if ( arg0 instanceof List ) { return nextIndexOf ( ( List ) arg0 ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object nextIndexOf ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. get ( 0 ) ; } else if ( arg0 instanceof Collection ) { return nextIndexOf ( ( List ) arg0 ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "Object nextIndexOf ( T arg0 ) { return nextIndexOf ( arg0. getClass ( ), arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Object arg0 ) { if ( arg0 == null ) { return 0 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( this ) ; } else { return - 1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( T arg0 ) { return ( arg0 == null )? 0 : arg0. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0, char arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg0. charAt ( loc0 + 1 ) ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0, Sequence arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg1. contains ( arg0. charAt ( loc0 ) ) ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( CharSequence arg0, int arg1, int arg2 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } for ( int loc0 = 0 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( CharSequence arg0, int arg1, int arg2 ) { int loc0 = arg0. length ( ) ; for ( int loc1 = arg1 ; loc1 < loc0 ; loc1 ++ ) { if ( arg0. charAt ( loc1 ) == arg2 ) { return loc1 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( CharSequence arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg0 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( CharSequence arg0, int arg1, int arg2 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } for ( int loc0 = 0 ; loc0 < arg2 ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( CharSequence arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg2 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0, int arg1 ) { for ( int loc0 = arg1 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0, char arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0, boolean arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg1 && ( arg0. charAt ( loc0 ) == arg0. charAt ( loc0 ) ) ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Sequence arg0, int arg1, boolean arg2 ) { for ( int loc0 = arg1 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Object arg0, Object arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg1. equals ( arg0. get ( loc0 ) ) ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Object arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. get ( loc0 ) == null ) return loc0 + 1 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Object arg0, Object arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg1. equals ( arg0. get ( loc0 ) ) ) { return loc0 + 1 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Object arg0, Object arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. get ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int nextIndexOf ( Object arg0, Object arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg1. equals ( arg0. get ( loc0 ) ) ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_47_/src/main/java/org/jsoup/nodes/Entities.java_122-123": {
      "loc": "122-123",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (!inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) \n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
      "target": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n                    if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (canEncode(coreCharset, c, encoder))\n                        accum.append(c);\n                    else if (map.containsKey(c))\n                        accum.append('&').append(map.get(c)).append(';');\n                    else\n                        accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n            }\n        } else {\n            final String c = new String(Character.toChars(codePoint));\n            if (encoder.canEncode(c)) \n                accum.append(c);\n            else\n                accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n        }\n    }\n}",
      "function range": "79,5-155,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_82_/src/com/google/javascript/rhino/jstype/JSType.java_163-164": {
      "loc": "163-164",
      "input": "public final boolean isEmptyType() {\n  return isNoType() || isNoObjectType() || isNoResolvedType();\n}",
      "target": "public final boolean isEmptyType() {\n  return isNoType() || isNoObjectType() || isNoResolvedType() ||\n      (registry.getNativeFunctionType(\n           JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n}",
      "function range": "162,3-164,3",
      "raw_output": [
        "boolean function ( ) { return Type. EMPTY. equals ( this. getClass ( ) ) ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
        "boolean function ( ) { return Type. EMPTY. equals ( this ) ; }",
        "boolean function ( ) { return Type. values ( ). isEmpty ( ) ; }",
        "boolean function ( ) { return getType ( ). isEmpty ( ) ; }",
        "boolean function ( ) { return true ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { return Type. EMPTY. equals ( this ) ; }",
        "boolean function ( ) { return getType ( ). isEmpty ( ) ; }",
        "boolean function ( ) { return Constants. EMPTY_STRING ; }",
        "boolean function ( ) { return this == EMPTY_TYPE ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { return true ; }",
        "boolean function ( ) { return this == EmptyType. EMPTY ; }",
        "boolean function ( ) { return this == EmptyType ; }",
        "boolean function ( ) { return true ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { return Type. EMPTY. equals ( this ) ; }",
        "boolean function ( ) { return this == EmptyType. EMPTY ; }",
        "boolean function ( ) { return this == EMPTY_TYPE ; }",
        "boolean function ( ) { return Type. EMPTY. equals ( this. getClass ( ) ) ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
        "boolean function ( Type arg0 ) { if ( arg0 == null ) return true ; return false ; }",
        "boolean function ( Type arg0 ) { return arg0 == null || arg0. getType ( ) == Type. STRING ; }",
        "boolean function ( ) { return Type. EMPTY. equals ( this ) ; }"
      ],
      "mid_translation": [
        "Returns true if the type is empty.",
        "Returns true if this type is empty.",
        "Returns true if this type is an empty type.",
        "Returns true if this is an empty type.",
        "Return true if the type is empty."
      ],
      "output": [
        {
          "patch": "public final boolean isEmptyType ( ) { return Type. EMPTY. equals ( this. getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return Type. EMPTY. equals ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return Type. values ( ). isEmpty ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return getType ( ). isEmpty ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return true ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return false ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return Type. EMPTY. equals ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return getType ( ). isEmpty ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return Constants. EMPTY_STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return this == EMPTY_TYPE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return this == EmptyType. EMPTY ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return this == EmptyType ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return Type. EMPTY. equals ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return this == EmptyType. EMPTY ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return this == EMPTY_TYPE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return Type. EMPTY. equals ( this. getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( Type arg0 ) { if ( arg0 == null ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( Type arg0 ) { return arg0 == null || arg0. getType ( ) == Type. STRING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final boolean isEmptyType ( ) { return Type. EMPTY. equals ( this ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_118_/src/com/google/javascript/jscomp/DisambiguateProperties.java_495-496": {
      "loc": "495-496",
      "input": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child != null;\n      child = child.getNext()) {\n    String name = child.getString();\n    T type = typeSystem.getType(getScope(), n, name);\n    Property prop = getProperty(name);\n    if (!prop.scheduleRenaming(child,\n                               processProperty(t, prop, type, null))) {\n      if (propertiesToErrorFor.containsKey(name)) {\n        compiler.report(JSError.make(\n            t.getSourceName(), child, propertiesToErrorFor.get(name),\n            Warnings.INVALIDATION, name,\n            (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n      }\n    }\n  }\n}",
      "target": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child != null;\n      child = child.getNext()) {\n    if (child.isQuotedString()) {\n      continue;\n    }\n    String name = child.getString();\n    T type = typeSystem.getType(getScope(), n, name);\n    Property prop = getProperty(name);\n    if (!prop.scheduleRenaming(child,\n                               processProperty(t, prop, type, null))) {\n      if (propertiesToErrorFor.containsKey(name)) {\n        compiler.report(JSError.make(\n            t.getSourceName(), child, propertiesToErrorFor.get(name),\n            Warnings.INVALIDATION, name,\n            (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n      }\n    }\n  }\n}",
      "function range": "490,5-513,5",
      "raw_output": [
        "void function ( Literal arg0, Object arg1 ) { String loc0 = arg0. getStringValue ( ) ; System. out. println ( \"srini_string\" + loc0 ) ; }",
        "void function ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" + arg0. getValue ( ) + \"srini_string\" ) ; }",
        "void function ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" + arg0. toString ( ) + \"srini_string\" ) ; }",
        "void function ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
        "void function ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( PsiBuilder arg0, ObjectLiteral arg1 ) { arg0. error ( \"srini_string\", arg1 ) ; }",
        "void function ( LiteralContext arg0, Object arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( PsiBuilder arg0, Object arg1 ) { arg0. error ( \"srini_string\" ) ; }",
        "void function ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( PsiBuilder arg0, ObjectLiteral arg1 ) { arg0. error ( \"srini_string\" ) ; }",
        "void function ( LiteralContext arg0, ObjectLiteral arg1 ) { Object loc0 = arg1 ; for ( int loc1 = 0 ; loc1 < loc0. length ( ) ; loc1 ++ ) { Literal loc2 = ( Literal ) loc0 [ loc1 ] ; if ( loc2 instanceof Literal ) { Literal loc3 = ( Literal ) loc2 ; Literal loc4 = ( Literal ) loc3 ; handle ( arg0, loc1, loc4 ) ; } } }",
        "void function ( LiteralContext arg0, ObjectLiteral arg1 ) { Object loc0 = arg1 ; for ( int loc1 = 0 ; loc1 < loc0. length ( ) ; loc1 ++ ) { Object loc2 = loc0 [ loc1 ] ; Object loc3 = loc0 [ loc1 ] ; Object loc4 = loc0 [ loc1 ] ; loc0 [ loc1 ] = loc3 ; } }",
        "void function ( LiteralContext arg0, ObjectLiteral arg1 ) { Object loc0 = arg1 ; for ( int loc1 = 0 ; loc1 < loc0. length ( ) ; loc1 ++ ) { Literal loc2 = ( Literal ) loc0 [ loc1 ] ; if ( loc2 instanceof Literal ) { Literal loc3 = ( Literal ) loc2 ; Literal loc4 = ( Literal ) loc3 ; handle ( loc0, loc1, loc4 ) ; } } }",
        "void function ( LiteralContext arg0, ObjectLiteral arg1 ) { Object loc0 = arg1 ; for ( int loc1 = 0 ; loc1 < loc0. length ( ) ; loc1 ++ ) { Object loc2 = loc0 [ loc1 ] ; Object loc3 = loc0 [ loc1 ] ; loc0 [ loc1 ] = loc3 ; } }",
        "void function ( LiteralContext arg0, ObjectLiteral arg1 ) { String loc0 = arg1. getStringValue ( ) ; System. out. println ( \"srini_string\" + loc0 + \"srini_string\" ) ; }",
        "void function ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0 instanceof Literal ) { Literal loc1 = ( Literal ) loc0 ; arg0 = ( ( Literal ) loc1 ). getValue ( ) ; } }",
        "void function ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0!= null ) { Object loc1 = loc0. evaluate ( arg0 ) ; if ( loc1 instanceof Identifier ) { Identifier loc2 = ( Identifier ) loc1 ; Object loc3 = ( Identifier ) loc1 ; } } }",
        "void function ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0!= null ) { Object loc1 = loc0. getValue ( ) ; arg0. put ( loc1. toString ( ), loc1 ) ; } }",
        "void function ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0!= null ) { Object loc1 = loc0. evaluate ( arg0 ) ; if ( loc1 instanceof Literal ) { Literal loc2 = ( Literal ) loc1 ; } } }",
        "void function ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0!= null ) { Object loc1 = loc0. evaluate ( arg0 ) ; if ( loc1 instanceof Literal ) { Identifier loc2 = ( Identifier ) loc1 ; Object loc3 = ( Identifier ) loc1 ; } } }",
        "R function ( ObjectLiteral arg0 ) { R loc0 = arg0. getObjectLiteral ( ) ; return loc0 ; }",
        "R function ( ObjectLiteral arg0 ) { R loc0 = arg0. getObject ( ) ; return loc0 ; }",
        "R function ( Literal arg0 ) { R loc0 = arg0. getObjectLiteral ( ) ; return loc0 ; }",
        "R function ( Node arg0, Object arg1 ) { R loc0 = arg0. getObjectLiteral ( ) ; return loc0 ; }",
        "R function ( Literal arg0, A arg1 ) { R loc0 = arg0. getObjectLiteral ( ) ; return loc0 ; }"
      ],
      "mid_translation": [
        "Handle object literal.",
        "Handle an object literal.",
        "Handle object literals.",
        "Handle object literal nodes.",
        "Handle object literal node."
      ],
      "output": [
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { String loc0 = arg0. getStringValue ( ) ; System. out. println ( \"srini_string\" + loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" + arg0. getValue ( ) + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" + arg0. toString ( ) + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( PsiBuilder arg0, ObjectLiteral arg1 ) { arg0. error ( \"srini_string\", arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( LiteralContext arg0, Object arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( PsiBuilder arg0, Object arg1 ) { arg0. error ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( PsiBuilder arg0, ObjectLiteral arg1 ) { arg0. error ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( LiteralContext arg0, ObjectLiteral arg1 ) { Object loc0 = arg1 ; for ( int loc1 = 0 ; loc1 < loc0. length ( ) ; loc1 ++ ) { Literal loc2 = ( Literal ) loc0 [ loc1 ] ; if ( loc2 instanceof Literal ) { Literal loc3 = ( Literal ) loc2 ; Literal loc4 = ( Literal ) loc3 ; handle ( arg0, loc1, loc4 ) ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( LiteralContext arg0, ObjectLiteral arg1 ) { Object loc0 = arg1 ; for ( int loc1 = 0 ; loc1 < loc0. length ( ) ; loc1 ++ ) { Object loc2 = loc0 [ loc1 ] ; Object loc3 = loc0 [ loc1 ] ; Object loc4 = loc0 [ loc1 ] ; loc0 [ loc1 ] = loc3 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( LiteralContext arg0, ObjectLiteral arg1 ) { Object loc0 = arg1 ; for ( int loc1 = 0 ; loc1 < loc0. length ( ) ; loc1 ++ ) { Literal loc2 = ( Literal ) loc0 [ loc1 ] ; if ( loc2 instanceof Literal ) { Literal loc3 = ( Literal ) loc2 ; Literal loc4 = ( Literal ) loc3 ; handle ( loc0, loc1, loc4 ) ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( LiteralContext arg0, ObjectLiteral arg1 ) { Object loc0 = arg1 ; for ( int loc1 = 0 ; loc1 < loc0. length ( ) ; loc1 ++ ) { Object loc2 = loc0 [ loc1 ] ; Object loc3 = loc0 [ loc1 ] ; loc0 [ loc1 ] = loc3 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( LiteralContext arg0, ObjectLiteral arg1 ) { String loc0 = arg1. getStringValue ( ) ; System. out. println ( \"srini_string\" + loc0 + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0 instanceof Literal ) { Literal loc1 = ( Literal ) loc0 ; arg0 = ( ( Literal ) loc1 ). getValue ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0!= null ) { Object loc1 = loc0. evaluate ( arg0 ) ; if ( loc1 instanceof Identifier ) { Identifier loc2 = ( Identifier ) loc1 ; Object loc3 = ( Identifier ) loc1 ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0!= null ) { Object loc1 = loc0. getValue ( ) ; arg0. put ( loc1. toString ( ), loc1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0!= null ) { Object loc1 = loc0. evaluate ( arg0 ) ; if ( loc1 instanceof Literal ) { Literal loc2 = ( Literal ) loc1 ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleObjectLit ( Literal arg0, Object arg1 ) { Object loc0 = arg1 ; while ( loc0!= null ) { Object loc1 = loc0. evaluate ( arg0 ) ; if ( loc1 instanceof Literal ) { Identifier loc2 = ( Identifier ) loc1 ; Object loc3 = ( Identifier ) loc1 ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R handleObjectLit ( ObjectLiteral arg0 ) { R loc0 = arg0. getObjectLiteral ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R handleObjectLit ( ObjectLiteral arg0 ) { R loc0 = arg0. getObject ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R handleObjectLit ( Literal arg0 ) { R loc0 = arg0. getObjectLiteral ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R handleObjectLit ( Node arg0, Object arg1 ) { R loc0 = arg0. getObjectLiteral ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R handleObjectLit ( Literal arg0, A arg1 ) { R loc0 = arg0. getObjectLiteral ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_96_/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java_735-736": {
      "loc": "735-736",
      "input": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1 != candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {\n        paramName = candidate.findImplicitParamName(0);\n        useProps = (paramName != null) && paramDef.couldSerialize();\n    }\n    if (useProps) {\n        SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n        };\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n        return;\n    }\n    _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n    if (paramDef != null) {\n        ((POJOPropertyBuilder) paramDef).removeConstructors();\n    }\n}",
      "target": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1 != candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {\n        paramName = candidate.paramName(0);\n        useProps = (paramName != null) && paramDef.couldSerialize();\n    }\n    if (useProps) {\n        SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n        };\n        creators.addPropertyCreator(candidate.creator(), true, properties);\n        return;\n    }\n    _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n    if (paramDef != null) {\n        ((POJOPropertyBuilder) paramDef).removeConstructors();\n    }\n}",
      "function range": "701,5-752,5",
      "raw_output": [
        "void function ( Class <? extends Property > arg0, Constructor <? extends Property > arg1 ) { add ( arg0, null, arg1 ) ; }",
        "void function ( Class <? > arg0, PropertyCreator arg1 ) { add ( arg0, null, arg1 ) ; }",
        "void function ( Class <? > arg0, PropCreator arg1 ) { PropCreators. add ( arg0, arg1 ) ; }",
        "void function ( PropertyCreator arg0 ) { PropertyCreators. add ( arg0 ) ; }",
        "void function ( Class <? > arg0, Constructor <? > arg1 ) { PropertyCreators. add ( arg0, arg1 ) ; }",
        "void function ( Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreator )? ( PropertyCreator ) arg0 : new PropertyCreator ( arg0 ) ) ; }",
        "void function ( final PropertyCreators arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } if ( creators == null ) { creators = new ArrayList < PropertyCreator > ( ) ; } creators. add ( arg0 ) ; }",
        "void function ( final PropertyCreators arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } if ( creators == null ) { creators = new ArrayList < > ( ) ; } creators. add ( arg0 ) ; }",
        "void function ( PropertyCreators arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. add ( new PropertyCreator ( ) ) ; }",
        "void function ( final Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreator )? ( PropertyCreator ) arg0 : new PropertyCreator ( arg0 ) ) ; }",
        "void function ( Creator arg0 ) { creators. add ( arg0 ) ; }",
        "void function ( PropertyCreators arg0 ) { creators. add ( arg0 ) ; }",
        "void function ( PropertyCreators arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } creators. add ( arg0 ) ; }",
        "void function ( ClassCreator arg0 ) { creators. add ( arg0 ) ; }",
        "void function ( Creator arg0 ) { creators. add ( ( arg0 == null )? new NullCreators ( ) : arg0 ) ; }",
        "void function ( PropertyCreators arg0, Class <? > arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. add ( arg1 ) ; }",
        "void function ( IPropertyCreators arg0, IPropertyCreator arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. add ( arg1 ) ; }",
        "void function ( PropertyCreators arg0, Class <? > arg1, Class <? >... arg2 ) { for ( Class <? > loc0 : arg2 ) { arg0. add ( loc0 ) ; } }",
        "void function ( PropertyCreators arg0, Class <? > arg1, Class <? >... arg2 ) { for ( Class <? > loc0 : arg2 ) { add ( arg0, loc0, arg1 ) ; } }",
        "void function ( final PropertyCreators arg0, final Class <? > arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. add ( arg1 ) ; }",
        "void function ( Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreators )? ( PropertyCreators ) arg0 : new PropertyCreators ( arg0 ) ) ; }",
        "void function ( Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreator )? ( PropertyCreator ) arg0 : new PropertyCreator ( arg0 ) ) ; }",
        "void function ( Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreator )? ( PropertyCreator ) arg0 : new PropertyCreator ( ( PropertyCreator ) arg0 ) ) ; }",
        "void function ( Creator arg0 ) { creators. add ( arg0 ) ; }",
        "void function ( PropertyCreators arg0, PropertyCreator arg1 ) { creators. add ( arg0, arg1 ) ; }"
      ],
      "mid_translation": [
        "Add an explicit or explicit property creator.",
        "Add an explicit or property creator to the creators list.",
        "Add an explicit or property creator to the creators collection.",
        "Add an explicit or explicit property creator to the creators.",
        "Add an explicit or property creator to the creators."
      ],
      "output": [
        {
          "patch": "protected void _addExplicitAnyCreator ( Class <? extends Property > arg0, Constructor <? extends Property > arg1 ) { add ( arg0, null, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Class <? > arg0, PropertyCreator arg1 ) { add ( arg0, null, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Class <? > arg0, PropCreator arg1 ) { PropCreators. add ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( PropertyCreator arg0 ) { PropertyCreators. add ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Class <? > arg0, Constructor <? > arg1 ) { PropertyCreators. add ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreator )? ( PropertyCreator ) arg0 : new PropertyCreator ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( final PropertyCreators arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } if ( creators == null ) { creators = new ArrayList < PropertyCreator > ( ) ; } creators. add ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( final PropertyCreators arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } if ( creators == null ) { creators = new ArrayList < > ( ) ; } creators. add ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( PropertyCreators arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. add ( new PropertyCreator ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( final Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreator )? ( PropertyCreator ) arg0 : new PropertyCreator ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Creator arg0 ) { creators. add ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( PropertyCreators arg0 ) { creators. add ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( PropertyCreators arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } creators. add ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( ClassCreator arg0 ) { creators. add ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Creator arg0 ) { creators. add ( ( arg0 == null )? new NullCreators ( ) : arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( PropertyCreators arg0, Class <? > arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. add ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( IPropertyCreators arg0, IPropertyCreator arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. add ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( PropertyCreators arg0, Class <? > arg1, Class <? >... arg2 ) { for ( Class <? > loc0 : arg2 ) { arg0. add ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( PropertyCreators arg0, Class <? > arg1, Class <? >... arg2 ) { for ( Class <? > loc0 : arg2 ) { add ( arg0, loc0, arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( final PropertyCreators arg0, final Class <? > arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. add ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreators )? ( PropertyCreators ) arg0 : new PropertyCreators ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreator )? ( PropertyCreator ) arg0 : new PropertyCreator ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Creator arg0 ) { creators. add ( ( arg0 instanceof PropertyCreator )? ( PropertyCreator ) arg0 : new PropertyCreator ( ( PropertyCreator ) arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( Creator arg0 ) { creators. add ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void _addExplicitAnyCreator ( PropertyCreators arg0, PropertyCreator arg1 ) { creators. add ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_41_/src/main/java/org/jsoup/nodes/Element.java_1175-1176": {
      "loc": "1175-1176",
      "input": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return this == o;\n}",
      "target": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n    return tag.equals(element.tag);\n}",
      "function range": "1167,5-1176,5",
      "raw_output": [
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
        "boolean function ( Element arg0, Element arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. equals ( arg1 ) ) ; }",
        "boolean function ( Element arg0, Element arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Element arg0, Element arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. getClass ( ) == arg1. getClass ( ) ) ; }",
        "boolean function ( Element arg0, Element arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( Element arg0, Element arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. getClass ( ). equals ( arg1. getClass ( ) ) ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return! this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardPieURL ) ) { return false ; } return ( ( StandardPieURL ) arg0 ). equals ( this ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardPieURL ) ) { return false ; } return ( ( StandardPieURL ) arg0 ). equals ( this ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardPieURL ) ) { return false ; } return ( ( StandardPieURL ) arg0 ). equals ( this ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } Class loc0 = ( Class <? > ) arg0 ; if (! loc0. equals ( this. getClass ( ) ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } Class <? > loc0 = ( Class <? > ) arg0 ; if (! loc0. equals ( this. getClass ( ) ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } Class loc0 = ( Class <? > ) arg0 ; if (! arg0. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } Class loc0 = ( Class <? > ) arg0 ; if (! ObjectUtilities. equal ( this, loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } return true ; }"
      ],
      "mid_translation": [
        "Returns true if this object equals the specified object.",
        "Returns true if this object equals the given object.",
        "Compares two Element objects to see if they are equal.",
        "Returns true if this object equals o.",
        "Returns true if this is the same as o."
      ],
      "output": [
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Element arg0, Element arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. equals ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Element arg0, Element arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Element arg0, Element arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. getClass ( ) == arg1. getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Element arg0, Element arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Element arg0, Element arg1 ) { return arg0 == arg1 || ( arg0!= null && arg0. getClass ( ). equals ( arg1. getClass ( ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return! this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardPieURL ) ) { return false ; } return ( ( StandardPieURL ) arg0 ). equals ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardPieURL ) ) { return false ; } return ( ( StandardPieURL ) arg0 ). equals ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardPieURL ) ) { return false ; } return ( ( StandardPieURL ) arg0 ). equals ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } Class loc0 = ( Class <? > ) arg0 ; if (! loc0. equals ( this. getClass ( ) ) ) { return false ; } return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } Class <? > loc0 = ( Class <? > ) arg0 ; if (! loc0. equals ( this. getClass ( ) ) ) { return false ; } return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } Class loc0 = ( Class <? > ) arg0 ; if (! arg0. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } Class loc0 = ( Class <? > ) arg0 ; if (! ObjectUtilities. equal ( this, loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } if ( arg0 == null || getClass ( )!= arg0. getClass ( ) ) { return false ; } return true ; }",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_82_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java_495-496": {
      "loc": "495-496",
      "input": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = ignorals.getIgnored();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    }\n    else {\n    \tanySetterField = beanDesc.findAnySetterField();\n    \tif(anySetterField != null) {\n    \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n    \t}\n    }\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n            && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n            beanDesc, builder, beanDesc.findProperties(), ignored);\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType)\n                    || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                        \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                        name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}",
      "target": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n        ignored = ignorals.findIgnoredForDeserialization();\n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n    } else {\n        ignored = Collections.emptySet();\n    }\n    AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n    AnnotatedMember anySetterField = null;\n    if (anySetterMethod != null) {\n        builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n    }\n    else {\n    \tanySetterField = beanDesc.findAnySetterField();\n    \tif(anySetterField != null) {\n    \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n    \t}\n    }\n    if (anySetterMethod == null && anySetterField == null) {\n        Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n        if (ignored2 != null) {\n            for (String propName : ignored2) {\n                builder.addIgnorable(propName);\n            }\n        }\n    }\n    final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n            && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n    List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n            beanDesc, builder, beanDesc.findProperties(), ignored);\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n        }\n    }\n    for (BeanPropertyDefinition propDef : propDefs) {\n        SettableBeanProperty prop = null;\n        if (propDef.hasSetter()) {\n            JavaType propertyType = propDef.getSetter().getParameterType(0);\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (propDef.hasField()) {\n            JavaType propertyType = propDef.getField().getType();\n            prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n        } else if (useGettersAsSetters && propDef.hasGetter()) {\n            AnnotatedMethod getter = propDef.getGetter();\n            Class<?> rawPropertyType = getter.getRawType();\n            if (Collection.class.isAssignableFrom(rawPropertyType)\n                    || Map.class.isAssignableFrom(rawPropertyType)) {\n                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n            }\n        }\n        if (hasCreatorProps && propDef.hasConstructorParameter()) {\n            final String name = propDef.getName();\n            CreatorProperty cprop = null;\n            if (creatorProps != null) {\n                for (SettableBeanProperty cp : creatorProps) {\n                    if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                        cprop = (CreatorProperty) cp;\n                        break;\n                    }\n                }\n            }\n            if (cprop == null) {\n                List<String> n = new ArrayList<>();\n                for (SettableBeanProperty cp : creatorProps) {\n                    n.add(cp.getName());\n                }\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                        \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                        name, n);\n                continue;\n            }\n            if (prop != null) {\n                cprop.setFallbackSetter(prop);\n            }\n            prop = cprop;\n            builder.addCreatorProperty(cprop);\n            continue;\n        }\n        if (prop != null) {\n            Class<?>[] views = propDef.findViews();\n            if (views == null) {\n                if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                    views = NO_VIEWS;\n                }\n            }\n            prop.setViews(views);\n            builder.addProperty(prop);\n        }\n    }\n}",
      "function range": "472,5-615,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Csv_4_/src/main/java/org/apache/commons/csv/CSVParser.java_288-289": {
      "loc": "288-289",
      "input": "public Map<String, Integer> getHeaderMap() {\n    return new LinkedHashMap<String, Integer>(this.headerMap);\n}",
      "target": "public Map<String, Integer> getHeaderMap() {\n    return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n}",
      "function range": "287,5-289,5",
      "raw_output": [
        "HeaderMap function ( Map arg0 ) { return new HeaderMap ( arg0 ) ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { return new HashMap < String, String > ( arg0 ) ; }",
        "HeaderMap function ( HttpServletRequest arg0 ) { return new HeaderMap ( arg0. getHeader ( ) ) ; }",
        "Map < String, String > function ( Map < String,? > arg0 ) { return new HashMap < String, String > ( arg0 ) ; }",
        "Map < String,? extends Map < String,? extends Map < String,? extends Map < String,? extends Map < String,? >> function ( ) { return null ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { return new HashMap < String, String > ( arg0 ) ; }",
        "HeaderMap function ( Map arg0 ) { return new HeaderMap ( arg0 ) ; }",
        "Map < K, V > function ( Map < K, V > arg0 ) { return new HashMap < K, V > ( arg0 ) ; }",
        "Map < String, String > function ( Map < String,? > arg0 ) { return new HashMap < String, String > ( arg0 ) ; }",
        "HeaderMap function ( HttpServletRequest arg0 ) { return new HeaderMap ( arg0. getHeader ( ) ) ; }",
        "HeaderMap function ( ) { return new HeaderMap ( ) ; }",
        "HeaderMap function ( ) { return ( HeaderMap ) super. clone ( ) ; }",
        "HeaderMap function ( ) { HeaderMap loc0 = new HeaderMap ( ) ; loc0. headerMap = new HashMap ( ) ; return loc0 ; }",
        "HeaderMap function ( ) { HeaderMap loc0 = new HeaderMap ( ) ; loc0. header = new BasicMap ( ) ; return loc0 ; }",
        "HeaderMap function ( ) { HeaderMap loc0 = new HeaderMap ( ) ; loc0. headerMaps = new HashMap ( ) ; return loc0 ; }",
        "HeaderMap function ( Map arg0 ) { return new HeaderMap ( arg0 ) ; }",
        "HeaderMap function ( Map < K, V > arg0 ) { return new HeaderMap ( arg0 ) ; }",
        "HeaderMap function ( HttpServletRequest arg0 ) { return new HeaderMap ( arg0. getHeader ( ) ) ; }",
        "Map < K, V > function ( Map < K, V > arg0 ) { return Collections. unmodifiableMap ( arg0 ) ; }",
        "Map < String, String > function ( ) { return Collections. unmodifiableMap ( new HashMap < String, String > ( ) ) ; }",
        "HeaderMap function ( final HttpParams arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new HeaderMap ( arg0 ) ; }",
        "Map < String,? extends Map < String,? extends Object >> function ( ) { return Collections. unmodifiableMap ( new HashMap < String,? extends Map < String,? extends Object >> ( ) ) ; }",
        "HeaderMap function ( final HttpParams arg0 ) { if ( arg0 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; return new HeaderMap ( arg0 ) ; }",
        "HeaderMap function ( HttpServletRequest arg0 ) { return new HeaderMap ( arg0. getHeader ( ) ) ; }",
        "Map < String, String > function ( ) { return Collections. unmodifiableMap ( new HashMap < String, String > ( ) ) ; }"
      ],
      "mid_translation": [
        "Gets the header map.",
        "Get the header map.",
        "Returns a copy of the header map.",
        "Returns the header map.",
        "Gets header map."
      ],
      "output": [
        {
          "patch": "public HeaderMap getHeaderMap ( Map arg0 ) { return new HeaderMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < String, String > getHeaderMap ( Map < String, String > arg0 ) { return new HashMap < String, String > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( HttpServletRequest arg0 ) { return new HeaderMap ( arg0. getHeader ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < String, String > getHeaderMap ( Map < String,? > arg0 ) { return new HashMap < String, String > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < String,? extends Map < String,? extends Map < String,? extends Map < String,? extends Map < String,? >> getHeaderMap ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < String, String > getHeaderMap ( Map < String, String > arg0 ) { return new HashMap < String, String > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( Map arg0 ) { return new HeaderMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < K, V > getHeaderMap ( Map < K, V > arg0 ) { return new HashMap < K, V > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < String, String > getHeaderMap ( Map < String,? > arg0 ) { return new HashMap < String, String > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( HttpServletRequest arg0 ) { return new HeaderMap ( arg0. getHeader ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( ) { return new HeaderMap ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( ) { return ( HeaderMap ) super. clone ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( ) { HeaderMap loc0 = new HeaderMap ( ) ; loc0. headerMap = new HashMap ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( ) { HeaderMap loc0 = new HeaderMap ( ) ; loc0. header = new BasicMap ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( ) { HeaderMap loc0 = new HeaderMap ( ) ; loc0. headerMaps = new HashMap ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( Map arg0 ) { return new HeaderMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( Map < K, V > arg0 ) { return new HeaderMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( HttpServletRequest arg0 ) { return new HeaderMap ( arg0. getHeader ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < K, V > getHeaderMap ( Map < K, V > arg0 ) { return Collections. unmodifiableMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < String, String > getHeaderMap ( ) { return Collections. unmodifiableMap ( new HashMap < String, String > ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( final HttpParams arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return new HeaderMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < String,? extends Map < String,? extends Object >> getHeaderMap ( ) { return Collections. unmodifiableMap ( new HashMap < String,? extends Map < String,? extends Object >> ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( final HttpParams arg0 ) { if ( arg0 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; return new HeaderMap ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public HeaderMap getHeaderMap ( HttpServletRequest arg0 ) { return new HeaderMap ( arg0. getHeader ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < String, String > getHeaderMap ( ) { return Collections. unmodifiableMap ( new HashMap < String, String > ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_57_/src/main/java/org/jsoup/nodes/Attributes.java_125-126": {
      "loc": "125-126",
      "input": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            attributes.remove(attrKey);\n    }\n}",
      "target": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            it.remove();\n    }\n}",
      "function range": "118,5-127,5",
      "raw_output": [
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { Args. notNull ( arg0, \"srini_string\" ) ; arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" + arg1 ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) arg0. removeAttribute ( arg1 ) ; }",
        "void function ( Object arg0, String arg1 ) { if ( arg0 == null ) return ; arg0 = arg0. toString ( ) ; arg0. setAttribute ( arg1, null ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } else { throw new ClassCastException ( arg1 ) ; } }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" + arg1 + \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( Object arg0, String arg1 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; arg0 = arg0. toString ( ) ; arg0. setAttribute ( arg1, null ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" + arg1 ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } else { arg0. removeAttribute ( arg1 ) ; } }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
        "void function ( Object arg0, String arg1 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; arg0 = arg0. toString ( ) ; arg0. setAttribute ( arg1, null ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0. hasAttribute ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
        "void function ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } arg0. removeAttribute ( arg1 ) ; }",
        "void function ( String arg0, Object arg1 ) { Object loc0 = arg1 ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }"
      ],
      "mid_translation": [
        "Removes the attribute with the specified key ignoring case.",
        "Remove the attribute with the specified key ignoring case.",
        "Removes the attribute with the given key ignoring case.",
        "Remove the attribute with the given key ignoring case.",
        "Removes the attribute with the specified name ignoring case."
      ],
      "output": [
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { Args. notNull ( arg0, \"srini_string\" ) ; arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" + arg1 ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( Object arg0, String arg1 ) { if ( arg0 == null ) return ; arg0 = arg0. toString ( ) ; arg0. setAttribute ( arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } else { throw new ClassCastException ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" + arg1 + \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( Object arg0, String arg1 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; arg0 = arg0. toString ( ) ; arg0. setAttribute ( arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" + arg1 ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } else { arg0. removeAttribute ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( Object arg0, String arg1 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; arg0 = arg0. toString ( ) ; arg0. setAttribute ( arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0. hasAttribute ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0. contains ( arg1 ) ) { arg0. removeAttribute ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( final Attributes arg0, final String arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } arg0. removeAttribute ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void removeIgnoreCase ( String arg0, Object arg1 ) { Object loc0 = arg1 ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_75_/src/main/java/org/jsoup/nodes/Attributes.java_319-321": {
      "loc": "319-321",
      "input": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n            accum.append(\"=\\\"\");\n            Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n            accum.append('\"');\n        }\n    }\n}",
      "target": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n        if (!Attribute.shouldCollapseAttribute(key, val, out)) {\n            accum.append(\"=\\\"\");\n            Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n            accum.append('\"');\n        }\n    }\n}",
      "function range": "310,5-326,5",
      "raw_output": [
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( final T arg0 ) { return \"srini_string\" + arg0. toString ( ) + \"srini_string\" ; }",
        "void function ( HtmlOutput arg0 ) { arg0. write ( \"srini_string\" ) ; }",
        "String function ( final T arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( Map < String, Object > arg0 ) { return \"srini_string\" + arg0. get ( \"srini_string\" ) ; }",
        "void function ( Appendable arg0, String arg1 ) { arg0. append ( \"srini_string\" = \"srini_string\" ) ; arg0. append ( arg1 ) ; }",
        "Appendable function ( String arg0, String arg1 ) { return append ( arg0 ). append ( \"srini_string\" = \"srini_string\" ). append ( arg1 ) ; }",
        "Appendable function ( String arg0, String arg1 ) { return append ( arg0, arg1, \"srini_string\" ) ; }",
        "Appendable function ( Appendable arg0, String arg1 ) { return append ( arg0, arg1, \"srini_string\" ) ; }",
        "Appendable function ( String arg0, String arg1 ) { return append ( arg0 ). append ( \"srini_string\" + arg1 + \"srini_string\" ) ; }",
        "void function ( PrintWriter arg0 ) { arg0. println ( \"srini_string\" ) ; }",
        "void function ( PrintStream arg0 ) { arg0. println ( \"srini_string\" ) ; }",
        "void function ( TinyosError arg0 ) { System. err. println ( \"srini_string\" + arg0. getMessage ( ) ) ; }",
        "void function ( TinyosError arg0 ) { System. out. println ( \"srini_string\" + arg0. getMessage ( ) ) ; }",
        "void function ( PrintStream arg0, int arg1 ) { arg0. println ( \"srini_string\" + arg1 ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( ) { return \"srini_string\" + \"srini_string\" ; }",
        "void function ( ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( String arg0 ) { System. out. println ( \"srini_string\" + arg0 ) ; }",
        "String function ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( T arg0, String arg1 ) { return \"srini_string\" + arg0 + \"srini_string\" + arg1 ; }",
        "String function ( T arg0 ) { return \"srini_string\" + arg0. getClass ( ). getName ( ) + \"srini_string\" + arg0. toString ( ) ; }",
        "String function ( final T arg0, final String arg1 ) { return \"srini_string\" + arg0 + \"srini_string\" + arg1 ; }",
        "String function ( T arg0 ) { return \"srini_string\" + arg0. getClass ( ). getName ( ) + \"srini_string\" + arg0. getContent ( ) ; }"
      ],
      "mid_translation": [
        "Html output.",
        "Append the HTML code to the Appendable.",
        "HTML output.",
        "Html method.",
        "Html format."
      ],
      "output": [
        {
          "patch": "final String html ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( final T arg0 ) { return \"srini_string\" + arg0. toString ( ) + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final void html ( HtmlOutput arg0 ) { arg0. write ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( final T arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( Map < String, Object > arg0 ) { return \"srini_string\" + arg0. get ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final void html ( Appendable arg0, String arg1 ) { arg0. append ( \"srini_string\" = \"srini_string\" ) ; arg0. append ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Appendable html ( String arg0, String arg1 ) { return append ( arg0 ). append ( \"srini_string\" = \"srini_string\" ). append ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Appendable html ( String arg0, String arg1 ) { return append ( arg0, arg1, \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Appendable html ( Appendable arg0, String arg1 ) { return append ( arg0, arg1, \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final Appendable html ( String arg0, String arg1 ) { return append ( arg0 ). append ( \"srini_string\" + arg1 + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final void html ( PrintWriter arg0 ) { arg0. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final void html ( PrintStream arg0 ) { arg0. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final void html ( TinyosError arg0 ) { System. err. println ( \"srini_string\" + arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final void html ( TinyosError arg0 ) { System. out. println ( \"srini_string\" + arg0. getMessage ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final void html ( PrintStream arg0, int arg1 ) { arg0. println ( \"srini_string\" + arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( ) { return \"srini_string\" + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final void html ( ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final void html ( String arg0 ) { System. out. println ( \"srini_string\" + arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( T arg0, String arg1 ) { return \"srini_string\" + arg0 + \"srini_string\" + arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( T arg0 ) { return \"srini_string\" + arg0. getClass ( ). getName ( ) + \"srini_string\" + arg0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( final T arg0, final String arg1 ) { return \"srini_string\" + arg0 + \"srini_string\" + arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "final String html ( T arg0 ) { return \"srini_string\" + arg0. getClass ( ). getName ( ) + \"srini_string\" + arg0. getContent ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_33_/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java_748-749": {
      "loc": "748-749",
      "input": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg != null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)) {\n            name = \"\";\n        } else {\n            return null;\n        }\n    }\n    return PropertyName.construct(name);\n}",
      "target": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg != null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)\n                || _hasAnnotation(a, JsonUnwrapped.class)\n                || _hasAnnotation(a, JsonBackReference.class)\n                || _hasAnnotation(a, JsonManagedReference.class)) {\n            name = \"\";\n        } else {\n            return null;\n        }\n    }\n    return PropertyName.construct(name);\n}",
      "function range": "730,5-755,5",
      "raw_output": [
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( final Object arg0 ) { return arg0 == null? \"srini_string\" : arg0. getClass ( ). getName ( ) ; }",
        "String function ( PicoContainer arg0 ) { return arg0 == null? \"srini_string\" : arg0. getComponent ( ). getName ( ) ; }",
        "String function ( PicoContainer arg0 ) { return arg0 == null? \"srini_string\" : arg0. getClass ( ). getName ( ) ; }",
        "String function ( PicoContainer arg0 ) { return arg0. getComponent ( PicoContainer. class ). getName ( ) ; }",
        "String function ( Class <? > arg0 ) { for ( Class <? > loc0 : arg0. getDeclaredFields ( ) ) { String loc1 = loc0. getName ( ) ; if ( loc1. startsWith ( \"srini_string\" ) ) { return loc1 ; } } return null ; }",
        "String function ( Class <? > arg0 ) { for ( Class <? > loc0 : arg0. getInterfaces ( ) ) { String loc1 = loc0. getName ( ) ; if ( loc1. startsWith ( \"srini_string\" ) ) { return loc1 ; } } return null ; }",
        "String function ( Class <? > arg0 ) { for ( Class <? > loc0 : arg0. getDeclaredClasses ( ) ) { if ( loc0. isInstance ( arg0 ) ) { return loc0. getName ( ) ; } } return null ; }",
        "String function ( Class <? > arg0 ) { for ( Class <? > loc0 : arg0. getDeclaredConstructors ( ) ) { if ( loc0. isInstance ( this ) ) { return loc0. getName ( ) ; } } return null ; }",
        "String function ( Class <? > arg0 ) { String loc0 = arg0. getName ( ) ; String loc1 = loc0. substring ( 0, loc0. lastIndexOf ( '.' ) ) ; return ( loc1!= null? loc0 : \"srini_string\" ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( Serializable arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
        "String function ( Serializable arg0 ) { return arg0. getClass ( ). getName ( ) ; }",
        "String function ( PicoContainer arg0 ) { return arg0. getComponent ( PicoContainer. class ). getName ( ) ; }",
        "String function ( Serializable arg0 ) { return arg0!= null? arg0. getClass ( ). getName ( ) : null ; }",
        "String function ( AnnotatedObject arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
        "String function ( Annotation arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
        "String function ( Object arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
        "String function ( AnnotatedObject arg0 ) { return arg0!= null? arg0. getClass ( ). getName ( ) : null ; }",
        "String function ( AnnotatedObject arg0 ) { if ( arg0 == null ) return null ; return arg0. getClass ( ). getName ( ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( ) { return getClass ( ). getName ( ) ; }",
        "String function ( ) { return Dimension2D. class. getName ( ) ; }",
        "String function ( ) { return Person. class. getName ( ) ; }",
        "String function ( ) { return Dimension2D. class. getSimpleName ( ) ; }"
      ],
      "mid_translation": [
        "Find the name for serialization.",
        "Find a property name for serialization.",
        "Find name for serialization.",
        "Find the name for serialization for the given annotated object.",
        "Gets the name for serialization."
      ],
      "output": [
        {
          "patch": "@Override\npublic String findNameForSerialization ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( final Object arg0 ) { return arg0 == null? \"srini_string\" : arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( PicoContainer arg0 ) { return arg0 == null? \"srini_string\" : arg0. getComponent ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( PicoContainer arg0 ) { return arg0 == null? \"srini_string\" : arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( PicoContainer arg0 ) { return arg0. getComponent ( PicoContainer. class ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Class <? > arg0 ) { for ( Class <? > loc0 : arg0. getDeclaredFields ( ) ) { String loc1 = loc0. getName ( ) ; if ( loc1. startsWith ( \"srini_string\" ) ) { return loc1 ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Class <? > arg0 ) { for ( Class <? > loc0 : arg0. getInterfaces ( ) ) { String loc1 = loc0. getName ( ) ; if ( loc1. startsWith ( \"srini_string\" ) ) { return loc1 ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Class <? > arg0 ) { for ( Class <? > loc0 : arg0. getDeclaredClasses ( ) ) { if ( loc0. isInstance ( arg0 ) ) { return loc0. getName ( ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Class <? > arg0 ) { for ( Class <? > loc0 : arg0. getDeclaredConstructors ( ) ) { if ( loc0. isInstance ( this ) ) { return loc0. getName ( ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Class <? > arg0 ) { String loc0 = arg0. getName ( ) ; String loc1 = loc0. substring ( 0, loc0. lastIndexOf ( '.' ) ) ; return ( loc1!= null? loc0 : \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Serializable arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Serializable arg0 ) { return arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( PicoContainer arg0 ) { return arg0. getComponent ( PicoContainer. class ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Serializable arg0 ) { return arg0!= null? arg0. getClass ( ). getName ( ) : null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( AnnotatedObject arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Annotation arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( Object arg0 ) { return arg0 == null? null : arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( AnnotatedObject arg0 ) { return arg0!= null? arg0. getClass ( ). getName ( ) : null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( AnnotatedObject arg0 ) { if ( arg0 == null ) return null ; return arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( ) { return getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( ) { return Dimension2D. class. getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( ) { return Person. class. getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String findNameForSerialization ( ) { return Dimension2D. class. getSimpleName ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_83_/src/com/google/javascript/jscomp/CommandLineRunner.java_334-335": {
      "loc": "334-335",
      "input": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n  String param = params.getParameter(0);\n  if (param == null) {\n    setter.addValue(true);\n    return 0;\n  } else {\n    String lowerParam = param.toLowerCase();\n    if (TRUES.contains(lowerParam)) {\n      setter.addValue(true);\n    } else if (FALSES.contains(lowerParam)) {\n      setter.addValue(false);\n    } else {\n      setter.addValue(true);\n      return 0;\n    }\n    return 1;\n  }\n}",
      "target": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n  String param = null;\n  try {\n    param = params.getParameter(0);\n  } catch (CmdLineException e) {}\n  if (param == null) {\n    setter.addValue(true);\n    return 0;\n  } else {\n    String lowerParam = param.toLowerCase();\n    if (TRUES.contains(lowerParam)) {\n      setter.addValue(true);\n    } else if (FALSES.contains(lowerParam)) {\n      setter.addValue(false);\n    } else {\n      setter.addValue(true);\n      return 0;\n    }\n    return 1;\n  }\n}",
      "function range": "332,7-351,7",
      "raw_output": [
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ] ; if ( loc2. equals ( \"srini_string\" ) ) { loc0. addArgument ( loc2 ) ; } else if ( loc2. equals ( \"srini_string\" ) ) { loc0. addArgument ( loc2 ) ; } } return loc0 ; }",
        "int function ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1 [ loc2 ] = loc3 ; } else if ( loc3. equals ( \"srini_string\" ) ) { loc1 [ loc2 ] = loc3 ; } } return loc0 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; else if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ]. trim ( ) ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. startsWith ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < loc1. size ( ) ; loc2 ++ ) { String loc3 = loc1. get ( loc2 ) ; if ( loc3. equals ( \"srini_string\" ) ) { loc0. addArgument ( loc3 ) ; } } return loc0 ; }",
        "boolean function ( String [ ] arg0 ) { boolean loc0 = false ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ] ; if ( loc2. equals ( \"srini_string\" ) ) { loc0 = true ; break ; } } return loc0 ; }",
        "boolean function ( String [ ] arg0 ) { boolean loc0 = false ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ]. trim ( ) ; if ( loc2. equals ( \"srini_string\" ) ) { loc0 = true ; break ; } } return loc0 ; }",
        "boolean function ( String [ ] arg0 ) { boolean loc0 = true ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ] ; if ( loc2. equals ( \"srini_string\" ) ) { loc0 = true ; break ; } } return loc0 ; }",
        "int function ( String [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { String loc1 = arg0 [ loc0 ] ; if ( loc1. equals ( \"srini_string\" ) ) { return loc0 ; } } throw new Exception ( \"srini_string\" ) ; }",
        "boolean function ( String [ ] arg0 ) { boolean loc0 = true ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ]. trim ( ) ; if ( loc2. equals ( \"srini_string\" ) ) { loc0 = true ; break ; } } return loc0 ; }",
        "int function ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1 [ loc2 ] = loc3 ; } } return loc1. length ; }",
        "int function ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3!= null ) { loc1 [ loc2 ] = loc3. trim ( ). toUpperCase ( ) ; } } return loc1. length ; }",
        "int function ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1 [ loc2 ] = loc3 ; else loc1 [ loc2 ] = loc3 ; } return loc1. length ; }",
        "int function ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3!= null ) { loc1 [ loc2 ] = loc3. trim ( ) ; } } return loc1. length ; }",
        "int function ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. startsWith ( \"srini_string\" ) ) { loc1 [ loc2 ] = loc3. substring ( 1, 3 ) ; } } return loc1. length ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. parseArgs ( arg0 ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ]. trim ( ) ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( String loc2 : arg0 ) { if ( loc2. equals ( \"srini_string\" ) ) { loc1. add ( loc2 ) ; } else if ( loc2. equals ( \"srini_string\" ) ) { loc1. add ( loc2 ) ; } } return loc1 ; }",
        "CommandLine function ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; } return loc1 ; }"
      ],
      "mid_translation": [
        "Parse command line arguments.",
        "Parses the command line arguments.",
        "This method is called to parse the command line arguments.",
        "parseArguments Method.",
        "Parses the command - line arguments."
      ],
      "output": [
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ] ; if ( loc2. equals ( \"srini_string\" ) ) { loc0. addArgument ( loc2 ) ; } else if ( loc2. equals ( \"srini_string\" ) ) { loc0. addArgument ( loc2 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1 [ loc2 ] = loc3 ; } else if ( loc3. equals ( \"srini_string\" ) ) { loc1 [ loc2 ] = loc3 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; else if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ]. trim ( ) ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. startsWith ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < loc1. size ( ) ; loc2 ++ ) { String loc3 = loc1. get ( loc2 ) ; if ( loc3. equals ( \"srini_string\" ) ) { loc0. addArgument ( loc3 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean parseArguments ( String [ ] arg0 ) { boolean loc0 = false ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ] ; if ( loc2. equals ( \"srini_string\" ) ) { loc0 = true ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean parseArguments ( String [ ] arg0 ) { boolean loc0 = false ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ]. trim ( ) ; if ( loc2. equals ( \"srini_string\" ) ) { loc0 = true ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean parseArguments ( String [ ] arg0 ) { boolean loc0 = true ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ] ; if ( loc2. equals ( \"srini_string\" ) ) { loc0 = true ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments ( String [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { String loc1 = arg0 [ loc0 ] ; if ( loc1. equals ( \"srini_string\" ) ) { return loc0 ; } } throw new Exception ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean parseArguments ( String [ ] arg0 ) { boolean loc0 = true ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { String loc2 = arg0 [ loc1 ]. trim ( ) ; if ( loc2. equals ( \"srini_string\" ) ) { loc0 = true ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1 [ loc2 ] = loc3 ; } } return loc1. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3!= null ) { loc1 [ loc2 ] = loc3. trim ( ). toUpperCase ( ) ; } } return loc1. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1 [ loc2 ] = loc3 ; else loc1 [ loc2 ] = loc3 ; } return loc1. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3!= null ) { loc1 [ loc2 ] = loc3. trim ( ) ; } } return loc1. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic int parseArguments ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. startsWith ( \"srini_string\" ) ) { loc1 [ loc2 ] = loc3. substring ( 1, 3 ) ; } } return loc1. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. parseArgs ( arg0 ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ]. trim ( ) ; if ( loc3. equals ( \"srini_string\" ) ) { loc1. add ( loc3 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( String loc2 : arg0 ) { if ( loc2. equals ( \"srini_string\" ) ) { loc1. add ( loc2 ) ; } else if ( loc2. equals ( \"srini_string\" ) ) { loc1. add ( loc2 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic CommandLine parseArguments ( String [ ] arg0 ) { CommandLine loc0 = new CommandLine ( arg0 [ 0 ] ) ; List < String > loc1 = loc0. getArgs ( ) ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { String loc3 = arg0 [ loc2 ] ; if ( loc3. equals ( \"srini_string\" ) ) loc1. add ( loc3 ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_88_/src/main/java/org/jsoup/nodes/Attribute.java_80-81": {
      "loc": "80-81",
      "input": "public String getValue() {\n    return val;\n}",
      "target": "public String getValue() {\n    return Attributes.checkNotNull(val);\n}",
      "function range": "79,5-81,5",
      "raw_output": [
        "T function ( final T arg0 ) { return arg0 ; }",
        "java. lang. String function ( ) { return Locale. getDefault ( ) ; }",
        "long function ( ) { return Long. MAX_VALUE ; }",
        "double function ( ) { return Double. NaN ; }",
        "T function ( ) { return ( T ) this. getClass ( ). getName ( ) ; }",
        "CNA    function ( ) { return CNA    ; }",
        "String function ( ) { return CNA    ; }",
        "void function ( CNA    arg0 ) { this. cNA    = arg0 ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "CNA    function ( ) { return new CNA    ( ) ; }",
        "CNA    function ( ) { return CNA    ; }",
        "CNA    function ( ) { return new CNA    ( ) ; }",
        "AbstractCNA    function ( ) { return CNA    ; }",
        "String function ( ) { return CNA   . getValue ( ) ; }",
        "CPN    function ( ) { return CNA    ; }",
        "CNA    function ( ) { return CNA    ; }",
        "String function ( ) { return CNA    ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "java. lang. String function ( ) { return CNA    ; }",
        "Object function ( ) { return CNA    ; }",
        "CNA    function ( ) { return CNA    ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "CSNA    function ( ) { return CNA    ; }",
        "CONA    function ( ) { return CNA    ; }",
        "String function ( ) { return CNA    ; }"
      ],
      "mid_translation": [
        "Gets the value.",
        "Gets the value of the CNA    property.",
        "Gets the value of the CNA    field.",
        "Returns the value of the CNA    property.",
        "Get the value of the CNA    property."
      ],
      "output": [
        {
          "patch": "public T getValue ( final T arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public java. lang. String getValue ( ) { return Locale. getDefault ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getValue ( ) { return Long. MAX_VALUE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getValue ( ) { return Double. NaN ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T getValue ( ) { return ( T ) this. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CNA    getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void getValue ( CNA    arg0 ) { this. cNA    = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String getValue ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public CNA    getValue ( ) { return new CNA    ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CNA    getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CNA    getValue ( ) { return new CNA    ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public AbstractCNA    getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String getValue ( ) { return CNA   . getValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CPN    getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CNA    getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String getValue ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public java. lang. String getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CNA    getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String getValue ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public CSNA    getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CONA    getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String getValue ( ) { return CNA    ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_43_/src/main/java/org/jsoup/nodes/Element.java_574-575": {
      "loc": "574-575",
      "input": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element.equals(search))\n            return i;\n    }\n    return null;\n}",
      "target": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n        if (element == search)\n            return i;\n    }\n    return null;\n}",
      "function range": "568,5-578,5",
      "raw_output": [
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return ( ( List ) loc0 ). indexOf ( \"srini_string\" ) ; } return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } else { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc1. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) return - 1 ; if ( arg0 instanceof List ) return ( ( List ) arg0 ). size ( ) ; List loc0 = ( List ) arg0 ; int loc1 = 0 ; while ( loc1 < loc0. size ( ) ) { loc1 ++ ; loc0. get ( loc1 ) ; loc1 ++ ; } return loc1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc1. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return ( ( List ) loc0 ). indexOf ( \"srini_string\" ) ; } return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return 0 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return ( ( List ) loc0 ). indexOf ( \"srini_string\" ) ; } return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc1. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return ( ( List ) loc0 ). get ( 0 ) ; } return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } else { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } }",
        "int function ( Object arg0 ) { if ( arg0 == null ) return - 1 ; if ( arg0 instanceof List ) return ( ( List ) arg0 ). size ( ) ; List loc0 = ( List ) arg0 ; int loc1 = 0 ; while ( loc1 < loc0. size ( ) ) { loc1 ++ ; loc0. get ( loc1 ) ; loc1 ++ ; } return loc1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return 0 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } else if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc1. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
        "int function ( Object arg0 ) { if ( arg0 == null ) return - 1 ; if ( arg0 instanceof List ) return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; else return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
        "int function ( List arg0, List arg1 ) { int loc0 = 0 ; for ( Object loc1 : arg0 ) { if ( arg1. contains ( loc1 ) ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < T > arg0, List < T > arg1 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { if ( arg1. contains ( loc1 ) ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List arg0, List arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { if ( arg1. get ( loc0 ) == null ) { return loc0 ; } } return - 1 ; }",
        "int function ( List arg0 ) { int loc0 = 0 ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof Number ) { loc0 = ( ( Number ) loc1 ). intValue ( ) ; break ; } } return loc0 ; }",
        "int function ( List arg0 ) { int loc0 = 0 ; Iterator loc1 = arg0. iterator ( ) ; while ( loc1. hasNext ( ) ) { loc0 = loc1. next ( ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Get the index of the element in the list.",
        "Gets the index of the element in the list.",
        "Returns the index of the element in the list.",
        "Get the index of the element in the list",
        "Get the index in the list of elements."
      ],
      "output": [
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return ( ( List ) loc0 ). indexOf ( \"srini_string\" ) ; } return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } else { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc1. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) return - 1 ; if ( arg0 instanceof List ) return ( ( List ) arg0 ). size ( ) ; List loc0 = ( List ) arg0 ; int loc1 = 0 ; while ( loc1 < loc0. size ( ) ) { loc1 ++ ; loc0. get ( loc1 ) ; loc1 ++ ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc1. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return ( ( List ) loc0 ). indexOf ( \"srini_string\" ) ; } return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return ( ( List ) loc0 ). indexOf ( \"srini_string\" ) ; } return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc1. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return ( ( List ) loc0 ). get ( 0 ) ; } return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } else { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) return - 1 ; if ( arg0 instanceof List ) return ( ( List ) arg0 ). size ( ) ; List loc0 = ( List ) arg0 ; int loc1 = 0 ; while ( loc1 < loc0. size ( ) ) { loc1 ++ ; loc0. get ( loc1 ) ; loc1 ++ ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } return 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) { return - 1 ; } if ( arg0 instanceof List ) { List loc0 = ( List ) arg0 ; return loc0. indexOf ( \"srini_string\" ) ; } else if ( arg0 instanceof List ) { List loc1 = ( List ) arg0 ; return loc1. indexOf ( \"srini_string\" ) ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( Object arg0 ) { if ( arg0 == null ) return - 1 ; if ( arg0 instanceof List ) return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; else return ( ( List ) arg0 ). indexOf ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( List arg0, List arg1 ) { int loc0 = 0 ; for ( Object loc1 : arg0 ) { if ( arg1. contains ( loc1 ) ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( List < T > arg0, List < T > arg1 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { if ( arg1. contains ( loc1 ) ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( List arg0, List arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { if ( arg1. get ( loc0 ) == null ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( List arg0 ) { int loc0 = 0 ; for ( Object loc1 : arg0 ) { if ( loc1 instanceof Number ) { loc0 = ( ( Number ) loc1 ). intValue ( ) ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static int indexInList ( List arg0 ) { int loc0 = 0 ; Iterator loc1 = arg0. iterator ( ) ; while ( loc1. hasNext ( ) ) { loc0 = loc1. next ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_146_/src/com/google/javascript/rhino/jstype/JSType.java_706-707": {
      "loc": "706-707",
      "input": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(this, that);\n  }\n  throw new IllegalStateException();\n}",
      "target": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      JSType noType = getNativeType(JSTypeNative.NO_TYPE);\n      return new TypePair(noType, noType);\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(this, that);\n  }\n  throw new IllegalStateException();\n}",
      "function range": "696,3-715,3",
      "raw_output": [
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1!= null ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( ) { Set < Type > loc0 = new HashSet < Type > ( ) ; for ( Type loc1 : Types. values ( ) ) { if ( loc1. equals ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( ) { Set < Type > loc0 = new HashSet < Type > ( ) ; for ( Type loc1 : Types. values ( ) ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "Set < String > function ( ) { return new HashSet < > ( Arrays. asList ( \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\" ) ) ; }",
        "Set < String > function ( ) { return new HashSet < > ( Arrays. asList ( \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\" ) ) ; }",
        "Set < String > function ( Set < String > arg0 ) { Set < String > loc0 = new HashSet < > ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc0 ) ) loc0. add ( loc1 ) ; } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1!= null ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( Arrays. asList ( arg0 ) ) ; return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( arg0 ) ; for ( Type loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "Type [ ] function ( ) { return Type. values ( ) ; }",
        "Set < Type > function ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( arg0 ) ; return loc0 ; }",
        "Set < Type > function ( ) { return Sets. newHashSet ( ) ; }"
      ],
      "mid_translation": [
        "Get the types under equality.",
        "Gets the types under equality.",
        "Get types under equality.",
        "Returns the types under equality.",
        "Gets types under equality."
      ],
      "output": [
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1!= null ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( ) { Set < Type > loc0 = new HashSet < Type > ( ) ; for ( Type loc1 : Types. values ( ) ) { if ( loc1. equals ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( ) { Set < Type > loc0 = new HashSet < Type > ( ) ; for ( Type loc1 : Types. values ( ) ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < String > getTypesUnderInequality ( ) { return new HashSet < > ( Arrays. asList ( \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\" ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < String > getTypesUnderInequality ( ) { return new HashSet < > ( Arrays. asList ( \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\", \"srini_string\" ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < String > getTypesUnderInequality ( Set < String > arg0 ) { Set < String > loc0 = new HashSet < > ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc0 ) ) loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1!= null ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. isInstance ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { if ( loc1. equals ( loc0 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( Arrays. asList ( arg0 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( ) ; for ( Type loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( arg0 ) ; for ( Type loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type [ ] getTypesUnderInequality ( ) { return Type. values ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( Set < Type > arg0 ) { Set < Type > loc0 = new HashSet < > ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Set < Type > getTypesUnderInequality ( ) { return Sets. newHashSet ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_12_/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java_108-109": {
      "loc": "108-109",
      "input": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int nodeType = node.getNodeType();\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return nodeType == Node.ELEMENT_NODE\n                        || nodeType == Node.DOCUMENT_NODE;\n            case Compiler.NODE_TYPE_TEXT :\n                return nodeType == Node.CDATA_SECTION_NODE\n                    || nodeType == Node.TEXT_NODE;\n            case Compiler.NODE_TYPE_COMMENT :\n                return nodeType == Node.COMMENT_NODE;\n            case Compiler.NODE_TYPE_PI :\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n    }\n    return false;\n}",
      "target": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                    && equalStrings(testPrefix, getPrefix(node));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int nodeType = node.getNodeType();\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return nodeType == Node.ELEMENT_NODE\n                        || nodeType == Node.DOCUMENT_NODE;\n            case Compiler.NODE_TYPE_TEXT :\n                return nodeType == Node.CDATA_SECTION_NODE\n                    || nodeType == Node.TEXT_NODE;\n            case Compiler.NODE_TYPE_COMMENT :\n                return nodeType == Node.COMMENT_NODE;\n            case Compiler.NODE_TYPE_PI :\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n    }\n    return false;\n}",
      "function range": "87,5-136,5",
      "raw_output": [
        "void function ( TestNode arg0 ) { }",
        "void function ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; Method loc0 = arg0. getClass ( ) ; Method loc1 = loc0. getMethod ( \"srini_string\" ) ; assertEquals ( \"srini_string\", loc1. getName ( ) ) ; }",
        "void function ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; Method loc0 = arg0. getClass ( ) ; Method loc1 = loc0. getMethod ( \"srini_string\" ) ; loc1. setAccessible ( true ) ; loc0. setAccessible ( true ) ; assertEquals ( \"srini_string\", loc1. getName ( ) ) ; }",
        "void function ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; Method loc0 = arg0. getClass ( ) ; Method loc1 = loc0. getMethod ( \"srini_string\" ) ; loc1. setAccessible ( true ) ; loc0. setAccessible ( true ) ; }",
        "void function ( ) { TestNode loc0 = new TestNode ( ) ; Method loc1 = new Method ( \"srini_string\" ) ; Method ( loc0 ) ; Method ( loc1 ) ; }",
        "void function ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; TestNode loc2 = new TestNode ( arg0 ) ; loc2. print ( \"srini_string\" ) ; }",
        "void function ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; TestNode loc2 = new TestNode ( arg0 ) ; loc2. print ( \"srini_string\" ) ; }",
        "void function ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; System. out. println ( \"srini_string\" ) ; }",
        "void function ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; System. out. println ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; }",
        "void function ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; TestNode loc2 = new TestNode ( arg0 ) ; loc2. print ( \"srini_string\" ) ; loc2. println ( ) ; }",
        "void function ( String [ ] arg0 ) { Mammoth loc0 = new Mammoth ( ) ; loc0. observe ( ) ; loc0. timePasses ( ) ; loc0. observe ( ) ; }",
        "void function ( String [ ] arg0 ) { Mammoth loc0 = new Mammoth ( ) ; loc0. observe ( ) ; loc0. timePasses ( ) ; loc0. observe ( ) ; loc0. timePasses ( ) ; }",
        "void function ( String [ ] arg0 ) { Mammoth loc0 = new Mammoth ( ) ; loc0. observe ( ) ; loc0. timePasses ( ) ; TestCase loc1 = new TestCase ( ) ; loc1. observe ( ) ; }",
        "void function ( String [ ] arg0 ) { Mammoth loc0 = new Mammoth ( ) ; System. out. println ( \"srini_string\" ) ; loc0. observe ( ) ; }",
        "void function ( String [ ] arg0 ) { JOSMFixture. createUnitTestFixture ( ). init ( ) ; }",
        "void function ( ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( ) { }",
        "void function ( ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = new TestNode ( ) ; }",
        "void function ( ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; }",
        "void function ( ) { System. out. println ( \"srini_string\" ) ; TestClass loc0 = new TestClass ( ) ; }",
        "void function ( ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = new TestNode ( ) ; System. out. println ( loc0. toString ( ) ) ; }",
        "void function ( ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = new TestNode ( ) ; System. out. println ( \"srini_string\" ) ; }",
        "void function ( ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = new TestNode ( ) ; loc0. print ( ) ; }",
        "void function ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = arg0 ; }",
        "void function ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; }"
      ],
      "mid_translation": [
        "TestNode Method.",
        "Test Node.",
        "Test node.",
        "testNode Method.",
        "TestNode method."
      ],
      "output": [
        {
          "patch": "public static void testNode ( TestNode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; Method loc0 = arg0. getClass ( ) ; Method loc1 = loc0. getMethod ( \"srini_string\" ) ; assertEquals ( \"srini_string\", loc1. getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; Method loc0 = arg0. getClass ( ) ; Method loc1 = loc0. getMethod ( \"srini_string\" ) ; loc1. setAccessible ( true ) ; loc0. setAccessible ( true ) ; assertEquals ( \"srini_string\", loc1. getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; Method loc0 = arg0. getClass ( ) ; Method loc1 = loc0. getMethod ( \"srini_string\" ) ; loc1. setAccessible ( true ) ; loc0. setAccessible ( true ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( ) { TestNode loc0 = new TestNode ( ) ; Method loc1 = new Method ( \"srini_string\" ) ; Method ( loc0 ) ; Method ( loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; TestNode loc2 = new TestNode ( arg0 ) ; loc2. print ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; TestNode loc2 = new TestNode ( arg0 ) ; loc2. print ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; System. out. println ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( Node arg0 ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; System. out. println ( \"srini_string\" ) ; Test loc1 = new Test ( ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; loc0. print ( \"srini_string\" ) ; loc1. print ( \"srini_string\" ) ; TestNode loc2 = new TestNode ( arg0 ) ; loc2. print ( \"srini_string\" ) ; loc2. println ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( String [ ] arg0 ) { Mammoth loc0 = new Mammoth ( ) ; loc0. observe ( ) ; loc0. timePasses ( ) ; loc0. observe ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( String [ ] arg0 ) { Mammoth loc0 = new Mammoth ( ) ; loc0. observe ( ) ; loc0. timePasses ( ) ; loc0. observe ( ) ; loc0. timePasses ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( String [ ] arg0 ) { Mammoth loc0 = new Mammoth ( ) ; loc0. observe ( ) ; loc0. timePasses ( ) ; TestCase loc1 = new TestCase ( ) ; loc1. observe ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( String [ ] arg0 ) { Mammoth loc0 = new Mammoth ( ) ; System. out. println ( \"srini_string\" ) ; loc0. observe ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( String [ ] arg0 ) { JOSMFixture. createUnitTestFixture ( ). init ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = new TestNode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( ) { System. out. println ( \"srini_string\" ) ; Test loc0 = new Test ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( ) { System. out. println ( \"srini_string\" ) ; TestClass loc0 = new TestClass ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = new TestNode ( ) ; System. out. println ( loc0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = new TestNode ( ) ; System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = new TestNode ( ) ; loc0. print ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; TestNode loc0 = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void testNode ( TestNode arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_16_/src/main/java/org/apache/commons/lang3/math/NumberUtils.java_458-459": {
      "loc": "458-459",
      "input": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos || expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) { \n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { \n                }\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { \n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) { \n                }\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) { \n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) { \n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) { \n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) { \n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "target": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos || expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            if (expPos > str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) { \n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { \n                }\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { \n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) { \n                }\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) { \n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) { \n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) { \n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) { \n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "function range": "444,5-594,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_111_/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java_54-55": {
      "loc": "54-55",
      "input": "@Override\nprotected JSType caseTopType(JSType topType) {\n  return topType;\n}",
      "target": "@Override\nprotected JSType caseTopType(JSType topType) {\n  return topType.isAllType() ?\n      getNativeType(ARRAY_TYPE) : topType;\n}",
      "function range": "52,9-55,9",
      "raw_output": [
        "Type function ( ) { return TopType. OBJECT ; }",
        "Type function ( Type arg0 ) { return arg0 ; }",
        "Class <? > function ( ) { return Object. class ; }",
        "Type function ( ) { return TopType. TASK ; }",
        "Type function ( ) { return TopType. OBJECT_LIST ; }",
        "R function ( TopType arg0 ) { R loc0 = null ; switch ( arg0. getType ( ) ) { case TOP_TYPE : loc0 = ( R ) arg0 ; break ; case LEFT_TYPE : loc0 = ( R ) arg0 ; break ; default : return loc0 ; } }",
        "R function ( TopType arg0 ) { R loc0 = null ; switch ( arg0. getType ( ) ) { case LEFT_TYPE : loc0 = ( R ) arg0 ; break ; case RIGHT_TYPE : loc0 = ( R ) arg0 ; break ; default : return loc0 ; } }",
        "R function ( TopType arg0 ) { R loc0 = null ; switch ( arg0. getType ( ) ) { case TOP_TYPE : loc0 = ( R ) topType ( ) ; break ; default : return loc0 ; } }",
        "R function ( TopType arg0 ) { R loc0 = null ; switch ( arg0. getType ( ) ) { case TOP_TYPE : loc0 = ( R ) arg0 ; break ; default : return loc0 ; } }",
        "R function ( TopType arg0 ) { R loc0 = null ; switch ( arg0. getType ( ) ) { case TOP_TYPE : loc0 = ( R ) topType ( ) ; break ; default : break ; } return loc0 ; }",
        "Type function ( TopType arg0 ) { return arg0. getType ( ) ; }",
        "PsiElement function ( TopType arg0 ) { PsiElement loc0 = ( PsiElement ) arg0 ; PsiElement loc1 = ( PsiElement ) loc0. getParent ( ) ; return loc1 ; }",
        "Type function ( TopType arg0 ) { return arg0. getElementType ( ) ; }",
        "Type function ( TopType arg0 ) { return arg0. getMainType ( ) ; }",
        "PsiElement function ( TopType arg0 ) { return arg0 ; }",
        "void function ( TopType arg0 ) { }",
        "void function ( TopType arg0 ) { arg0. setCaseTop ( new DefaultCaseTopType ( ) ) ; }",
        "void function ( TopType arg0 ) { arg0. setDefault ( ) ; }",
        "void function ( CaseTopType arg0 ) { }",
        "void function ( TopType arg0 ) { arg0. setLeft ( ) ; }",
        "PsiElement function ( PsiElement arg0 ) { return arg0 ; }",
        "Class <? extends Object > function ( ) { return Object. class ; }",
        "Type function ( TypeList arg0 ) { return arg0. getType ( ) ; }",
        "Type function ( Type arg0 ) { return arg0 ; }",
        "Class <? > function ( ) { return Object. class ; }"
      ],
      "mid_translation": [
        "Override the default implementation to return the top type.",
        "Implement the default implementation of the caseTopType method.",
        "Override caseTopType to return the top type.",
        "Implement the default implementation of the caseTopType interface.",
        "Overridden to return the top type."
      ],
      "output": [
        {
          "patch": "@Override\nprotected Type caseTopType ( ) { return TopType. OBJECT ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Type caseTopType ( Type arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Class <? > caseTopType ( ) { return Object. class ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Type caseTopType ( ) { return TopType. TASK ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Type caseTopType ( ) { return TopType. OBJECT_LIST ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Type caseTopType ( TopType arg0 ) { return arg0. getType ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected PsiElement caseTopType ( TopType arg0 ) { PsiElement loc0 = ( PsiElement ) arg0 ; PsiElement loc1 = ( PsiElement ) loc0. getParent ( ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Type caseTopType ( TopType arg0 ) { return arg0. getElementType ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Type caseTopType ( TopType arg0 ) { return arg0. getMainType ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected PsiElement caseTopType ( TopType arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected void caseTopType ( TopType arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected void caseTopType ( TopType arg0 ) { arg0. setCaseTop ( new DefaultCaseTopType ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected void caseTopType ( TopType arg0 ) { arg0. setDefault ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected void caseTopType ( CaseTopType arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected void caseTopType ( TopType arg0 ) { arg0. setLeft ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected PsiElement caseTopType ( PsiElement arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Class <? extends Object > caseTopType ( ) { return Object. class ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Type caseTopType ( TypeList arg0 ) { return arg0. getType ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Type caseTopType ( Type arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Class <? > caseTopType ( ) { return Object. class ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_107_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java_165-166": {
      "loc": "165-166",
      "input": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return null;\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
      "target": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n                    return NullifyingDeserializer.instance;\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, _property);\n            }\n        } else {\n            if ((_baseType != null)\n                    && _baseType.getClass() == type.getClass()) {\n                if (!type.hasGenericTypes()) {\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
      "function range": "146,5-199,5",
      "raw_output": [
        "Deserializer function ( byte [ ] arg0, typeId arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return findDeserializer ( arg0, arg1. toString ( ) ) ; }",
        "Deserializer function ( byte [ ] arg0, typeId arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return findDeserializer ( arg0, arg1. toString ( ) ) ; }",
        "Deserializer function ( typeId arg0 ) { return findDeserializer ( TypeFactory. get ( arg0 ) ) ; }",
        "Deserializer function ( typeId arg0 ) { return findDeserializer ( TypeFactory. get ( arg0. toString ( ) ) ) ; }",
        "Deserializer function ( typeId arg0 ) { return findDeserializer ( arg0, TypeDescriptor. valueOf ( Object. class ) ) ; }",
        "Deserializer function ( Type arg0 ) { if ( arg0 instanceof ParameterizedType ) { ParameterizedType loc0 = ( ParameterizedType ) arg0 ; return ( Deserializer ) loc0. getTypeInstance ( ) ; } else if ( arg0 instanceof ParameterizedType ) { return ( Deserializer ) loc0 ; } else { return null ; } }",
        "Deserializer function ( Type arg0 ) { if ( arg0 instanceof ParameterizedType ) return ( Deserializer ) arg0 ; else if ( arg0 instanceof ParameterizedType ) return ( ( ParameterizedType ) arg0 ). getTypeDeserializer ( ) ; else return null ; }",
        "Deserializer function ( Type arg0 ) { if ( arg0 instanceof ParameterizedType ) return ( Deserializer ) arg0 ; else if ( arg0 instanceof ParameterizedType ) return ( Deserializer ) arg0 ; else return null ; }",
        "Deserializer < T > function ( Type arg0 ) { if ( arg0 instanceof ParameterizedType ) return ( Deserializer < T > ) ( ( ParameterizedType ) arg0 ) ; else return null ; }",
        "Deserializer < T > function ( Type arg0, Map < Type,? extends T > arg1 ) { return findDeserializer ( arg0, arg1, null ) ; }",
        "Deserializer function ( byte [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } String loc0 = arg0 [ 0 ] ; Deserializer loc1 = DeserializerRegistry. lookup ( loc0 ) ; if ( loc1!= null ) { return loc1 ; } return null ; }",
        "Deserializer function ( byte [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } String loc0 = arg0 [ 0 ] ; Deserializer loc1 = Deserializer. findDeserializer ( loc0 ) ; if ( loc1!= null ) { return loc1 ; } return null ; }",
        "Deserializer function ( byte [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } String loc0 = arg0 [ 0 ] ; Deserializer loc1 = Deserializer. find ( loc0 ) ; if ( loc1!= null ) { return loc1 ; } return null ; }",
        "Deserializer function ( typeId arg0 ) { return findDeserializer ( arg0. toString ( ) ) ; }",
        "Deserializer function ( byte [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return findDeserializer ( arg0, Deserializer. class ) ; }",
        "Deserializer function ( @ NotNull TypeId arg0 ) { return findDeserializer ( arg0, null ) ; }",
        "Deserializer function ( @ NotNull TypeId arg0 ) { return ( Deserializer ) TypeId. find ( arg0 ) ; }",
        "Deserializer < T > function ( @ NotNull TypeId < T > arg0 ) { return ( Deserializer < T > ) TypeId. find ( arg0 ) ; }",
        "Deserializer < T > function ( TypeToken < T > arg0 ) { return ( Deserializer < T > ) TypeRegistry. getType ( arg0 ) ; }",
        "Deserializer < T > function ( TypeToken < T > arg0 ) { return findDeserializer ( arg0, null ) ; }",
        "Deserializer function ( byte [ ] arg0, TypeID arg1 ) { TypeID loc0 = arg0 [ 0 ] ; Deserializer loc1 = null ; for ( int loc2 = 1 ; loc2 < arg0. length ; ++ loc2 ) { if ( loc0 == arg1. getTypeID ( ) ) { loc1 = ( TypeID ) loc0 ; break ; } } return loc1 ; }",
        "Deserializer function ( byte [ ] arg0, TypeID arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return find ( arg0, arg1. getTypeID ( ) ) ; }",
        "Deserializer function ( byte [ ] arg0, TypeID arg1 ) { TypeID loc0 = arg0 [ 0 ] ; Deserializer loc1 = null ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { if ( loc0 == arg1. getTypeID ( ) ) { loc1 = ( TypeID ) loc0 ; break ; } } return loc1 ; }",
        "Deserializer function ( byte [ ] arg0, TypeID arg1 ) { TypeID loc0 = arg0 [ 0 ] ; Deserializer loc1 = null ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { if ( arg1. equals ( loc0 ) ) { loc1 = ( TypeID ) arg1 ; break ; } } return loc1 ; }",
        "Deserializer function ( byte [ ] arg0, TypeID arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return findDeserializer ( arg0, arg1. getTypeID ( ) ) ; }"
      ],
      "mid_translation": [
        "Find a deserializer for the given typeId.",
        "Find a deserializer for a single type.",
        "Find the deserializer for the given typeId.",
        "Find a deserializer for a single type id.",
        "Find a deserializer for a single type ID."
      ],
      "output": [
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0, typeId arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return findDeserializer ( arg0, arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0, typeId arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return findDeserializer ( arg0, arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( typeId arg0 ) { return findDeserializer ( TypeFactory. get ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( typeId arg0 ) { return findDeserializer ( TypeFactory. get ( arg0. toString ( ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( typeId arg0 ) { return findDeserializer ( arg0, TypeDescriptor. valueOf ( Object. class ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( Type arg0 ) { if ( arg0 instanceof ParameterizedType ) { ParameterizedType loc0 = ( ParameterizedType ) arg0 ; return ( Deserializer ) loc0. getTypeInstance ( ) ; } else if ( arg0 instanceof ParameterizedType ) { return ( Deserializer ) loc0 ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( Type arg0 ) { if ( arg0 instanceof ParameterizedType ) return ( Deserializer ) arg0 ; else if ( arg0 instanceof ParameterizedType ) return ( ( ParameterizedType ) arg0 ). getTypeDeserializer ( ) ; else return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( Type arg0 ) { if ( arg0 instanceof ParameterizedType ) return ( Deserializer ) arg0 ; else if ( arg0 instanceof ParameterizedType ) return ( Deserializer ) arg0 ; else return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer < T > _findDeserializer ( Type arg0 ) { if ( arg0 instanceof ParameterizedType ) return ( Deserializer < T > ) ( ( ParameterizedType ) arg0 ) ; else return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer < T > _findDeserializer ( Type arg0, Map < Type,? extends T > arg1 ) { return findDeserializer ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } String loc0 = arg0 [ 0 ] ; Deserializer loc1 = DeserializerRegistry. lookup ( loc0 ) ; if ( loc1!= null ) { return loc1 ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } String loc0 = arg0 [ 0 ] ; Deserializer loc1 = Deserializer. findDeserializer ( loc0 ) ; if ( loc1!= null ) { return loc1 ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } String loc0 = arg0 [ 0 ] ; Deserializer loc1 = Deserializer. find ( loc0 ) ; if ( loc1!= null ) { return loc1 ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( typeId arg0 ) { return findDeserializer ( arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return findDeserializer ( arg0, Deserializer. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( @ NotNull TypeId arg0 ) { return findDeserializer ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( @ NotNull TypeId arg0 ) { return ( Deserializer ) TypeId. find ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer < T > _findDeserializer ( @ NotNull TypeId < T > arg0 ) { return ( Deserializer < T > ) TypeId. find ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer < T > _findDeserializer ( TypeToken < T > arg0 ) { return ( Deserializer < T > ) TypeRegistry. getType ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer < T > _findDeserializer ( TypeToken < T > arg0 ) { return findDeserializer ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0, TypeID arg1 ) { TypeID loc0 = arg0 [ 0 ] ; Deserializer loc1 = null ; for ( int loc2 = 1 ; loc2 < arg0. length ; ++ loc2 ) { if ( loc0 == arg1. getTypeID ( ) ) { loc1 = ( TypeID ) loc0 ; break ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0, TypeID arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return find ( arg0, arg1. getTypeID ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0, TypeID arg1 ) { TypeID loc0 = arg0 [ 0 ] ; Deserializer loc1 = null ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { if ( loc0 == arg1. getTypeID ( ) ) { loc1 = ( TypeID ) loc0 ; break ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0, TypeID arg1 ) { TypeID loc0 = arg0 [ 0 ] ; Deserializer loc1 = null ; for ( int loc2 = 1 ; loc2 < arg0. length ; loc2 ++ ) { if ( arg1. equals ( loc0 ) ) { loc1 = ( TypeID ) arg1 ; break ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final Deserializer _findDeserializer ( byte [ ] arg0, TypeID arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return findDeserializer ( arg0, arg1. getTypeID ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_37_/src/main/java/org/jsoup/nodes/Element.java_1101-1102": {
      "loc": "1101-1102",
      "input": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return accum.toString().trim();\n}",
      "target": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n    return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n}",
      "function range": "1098,5-1102,5",
      "raw_output": [
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( ) { return document. getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return Document. getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return DOMUtils. getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return ( \"srini_string\" ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( Document arg0 ) { DocumentBuilder loc0 = arg0. getDocumentBuilder ( ) ; Document loc1 = loc0. build ( ) ; return loc1. getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
        "String function ( Document arg0 ) { return arg0. getDocumentElement ( ). toString ( ) ; }",
        "String function ( Document arg0 ) { Document loc0 = arg0. getDocument ( ) ; return loc0. getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
        "String function ( ) { return document. getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { if ( document == null ) { return null ; } return document. getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( ) { return getClass ( ). getName ( ) ; }",
        "String function ( ) { return ( \"srini_string\" ) ; }",
        "String function ( ) { return document. getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return document. toString ( ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( ) { return getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return document. getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return DocumentUtil. getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
        "String function ( ) { return Document. getDocumentElement ( ). toString ( ) ; }"
      ],
      "mid_translation": [
        "Returns the HTML of the document.",
        "Get the HTML of the document.",
        "Returns the HTML content of the document.",
        "Returns the HTML code of the document.",
        "Gets the HTML of the document."
      ],
      "output": [
        {
          "patch": "public String html ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html ( ) { return document. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return Document. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return DOMUtils. getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html ( Document arg0 ) { DocumentBuilder loc0 = arg0. getDocumentBuilder ( ) ; Document loc1 = loc0. build ( ) ; return loc1. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( Document arg0 ) { return arg0. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( Document arg0 ) { Document loc0 = arg0. getDocument ( ) ; return loc0. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html ( ) { return document. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { if ( document == null ) { return null ; } return document. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html ( ) { return getClass ( ). getName ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html ( ) { return ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html ( ) { return document. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return document. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String html ( ) { return getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return document. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return DocumentUtil. getDocument ( ). getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String html ( ) { return Document. getDocumentElement ( ). toString ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_77_/src/main/java/org/jsoup/parser/XmlTreeBuilder.java_117-118": {
      "loc": "117-118",
      "input": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; \n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}",
      "target": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.normalName();\n    Element firstFound = null;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; \n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}",
      "function range": "116,5-136,5",
      "raw_output": [
        "Tag function ( ) { Tag loc0 = new Tag ( ) ; loc0. close ( ) ; return loc0 ; }",
        "Tag function ( TagStack arg0 ) { if ( arg0!= null ) { arg0. pop ( ) ; } return arg0 ; }",
        "void function ( PrintWriter arg0 ) { arg0. write ( \"srini_string\" ) ; arg0. flush ( ) ; }",
        "Tag function ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }",
        "Tag function ( ) { Tag loc0 = new Tag ( ) ; loc0. open ( ) ; return loc0 ; }",
        "Tag function ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. empty ( ) ) throw new RuntimeException ( \"srini_string\" ) ; return arg0. pop ( ) ; }",
        "Tag function ( ) { Tag loc0 = ( Tag ) stack. pop ( ) ; if ( loc0 == null ) throw new RuntimeException ( \"srini_string\" ) ; return loc0 ; }",
        "Tag function ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. empty ( ) ) throw new RuntimeException ( \"srini_string\" ) ; return arg0. peek ( ) ; }",
        "Tag function ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. pop ( ) ; } return arg0 ; }",
        "TagData function ( TagData arg0 ) { TagData loc0 = ( TagData ) arg0. pop ( ) ; if ( loc0!= null ) { arg0. delete ( ) ; } return loc0 ; }",
        "TagStack function ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. pop ( ) ; } return arg0 ; }",
        "Tag function ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. pop ( ) ; } return arg0. pop ( ) ; }",
        "TagStack function ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 1 ) { arg0. pop ( ) ; } return arg0 ; }",
        "TagData function ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. pop ( ) ; } return arg0 ; }",
        "TagStack function ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. push ( ) ; arg0. pop ( ) ; } return arg0 ; }",
        "TagStack function ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }",
        "String function ( Stack < String > arg0 ) { arg0. pop ( ) ; return arg0. pop ( ) ; }",
        "TagStack function ( ) { return ( TagStack ) stack. pop ( ) ; }",
        "String function ( Stack < String > arg0 ) { arg0. pop ( ) ; return arg0. peek ( ) ; }",
        "String function ( Stack < String > arg0 ) { arg0. pop ( ) ; return ( arg0. pop ( ) ) ; }",
        "TagData function ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }",
        "TagContext function ( ) { TagContext loc0 = pop ( ) ; if ( loc0 == null ) throw new EmptyStackException ( ) ; return loc0 ; }",
        "TagContext function ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }",
        "TagContext function ( ) { TagContext loc0 = ( TagContext ) Stack. pop ( ) ; if ( loc0 == null ) throw new EmptyStackException ( ) ; return loc0 ; }",
        "TagStack function ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }"
      ],
      "mid_translation": [
        "Pop the stack to close a tag.",
        "Pop the stack to close the tag.",
        "Pop the stack to close an end tag.",
        "Pop the stack to close an XML tag.",
        "Pop the stack from the end tag."
      ],
      "output": [
        {
          "patch": "private Tag popStackToClose ( ) { Tag loc0 = new Tag ( ) ; loc0. close ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Tag popStackToClose ( TagStack arg0 ) { if ( arg0!= null ) { arg0. pop ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void popStackToClose ( PrintWriter arg0 ) { arg0. write ( \"srini_string\" ) ; arg0. flush ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Tag popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Tag popStackToClose ( ) { Tag loc0 = new Tag ( ) ; loc0. open ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Tag popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. empty ( ) ) throw new RuntimeException ( \"srini_string\" ) ; return arg0. pop ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Tag popStackToClose ( ) { Tag loc0 = ( Tag ) stack. pop ( ) ; if ( loc0 == null ) throw new RuntimeException ( \"srini_string\" ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Tag popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. empty ( ) ) throw new RuntimeException ( \"srini_string\" ) ; return arg0. peek ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Tag popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. pop ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagData popStackToClose ( TagData arg0 ) { TagData loc0 = ( TagData ) arg0. pop ( ) ; if ( loc0!= null ) { arg0. delete ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagStack popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. pop ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Tag popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. pop ( ) ; } return arg0. pop ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagStack popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 1 ) { arg0. pop ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagData popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. pop ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagStack popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; if ( arg0. size ( ) > 0 ) { arg0. push ( ) ; arg0. pop ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagStack popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String popStackToClose ( Stack < String > arg0 ) { arg0. pop ( ) ; return arg0. pop ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagStack popStackToClose ( ) { return ( TagStack ) stack. pop ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String popStackToClose ( Stack < String > arg0 ) { arg0. pop ( ) ; return arg0. peek ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String popStackToClose ( Stack < String > arg0 ) { arg0. pop ( ) ; return ( arg0. pop ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagData popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagContext popStackToClose ( ) { TagContext loc0 = pop ( ) ; if ( loc0 == null ) throw new EmptyStackException ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagContext popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagContext popStackToClose ( ) { TagContext loc0 = ( TagContext ) Stack. pop ( ) ; if ( loc0 == null ) throw new EmptyStackException ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TagStack popStackToClose ( TagStack arg0 ) { arg0. pop ( ) ; return arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_45_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_63-64": {
      "loc": "63-64",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format != null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if (format.getShape() == JsonFormat.Shape.STRING) {\n                TimeZone tz = format.getTimeZone();\n                final String pattern = format.hasPattern()\n                                ? format.getPattern()\n                                : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                final Locale loc = format.hasLocale()\n                                ? format.getLocale()\n                                : serializers.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = serializers.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withFormat(Boolean.FALSE, df);\n            }\n        }\n    }\n    return this;\n}",
      "target": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format != null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n            if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                            || format.hasLocale() || format.hasTimeZone()) {\n                TimeZone tz = format.getTimeZone();\n                final String pattern = format.hasPattern()\n                                ? format.getPattern()\n                                : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                final Locale loc = format.hasLocale()\n                                ? format.getLocale()\n                                : serializers.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) {\n                    tz = serializers.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withFormat(Boolean.FALSE, df);\n            }\n        }\n    }\n    return this;\n}",
      "function range": "49,5-81,5",
      "raw_output": [
        "Context function ( ) { return new Context ( ) ; }",
        "JsonSerializer < T > function ( ) { return new JsonSerializer < T > ( ) ; }",
        "JsonSerializer function ( ) { return new ContextualSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new JsonSerializer ( ) ; }",
        "ContextJsonSerializer function ( ) { return new ContextJsonSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new ContextualSerializer ( ) ; }",
        "Context function ( ) { return new Context ( ) ; }",
        "JsonSerializer < T > function ( ) { return new JsonSerializer < T > ( ) ; }",
        "JsonSerializer function ( ) { return new ContextualJsonSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new JsonSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new JsonSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new XmlSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new ContextualSerializer ( ) ; }",
        "Context function ( ) { return new Context ( ) ; }",
        "JsonSerializer function ( ) { return new ContextJsonSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new JsonSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new XmlSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new ContextualSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new JsonContext ( ) ; }",
        "JsonSerializer function ( ) { return new ContextJsonSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new ContextualSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new JsonSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new ContextualJsonSerializer ( ) ; }",
        "JsonSerializer function ( ) { return new ContextJsonSerializer ( ) ; }",
        "ContextJsonSerializer function ( ) { return new ContextJsonSerializer ( ) ; }"
      ],
      "mid_translation": [
        "Create a contextual JsonSerializer.",
        "Creates a contextual JsonSerializer.",
        "Override to create a contextual JsonSerializer.",
        "Override this method to create a contextual JsonSerializer.",
        "Create a contextual JsonSerializer instance."
      ],
      "output": [
        {
          "patch": "@Override\npublic Context createContextual ( ) { return new Context ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer < T > createContextual ( ) { return new JsonSerializer < T > ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextualSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new JsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic ContextJsonSerializer createContextual ( ) { return new ContextJsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextualSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Context createContextual ( ) { return new Context ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer < T > createContextual ( ) { return new JsonSerializer < T > ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextualJsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new JsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new JsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new XmlSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextualSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Context createContextual ( ) { return new Context ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextJsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new JsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new XmlSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextualSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new JsonContext ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextJsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextualSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new JsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextualJsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonSerializer createContextual ( ) { return new ContextJsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic ContextJsonSerializer createContextual ( ) { return new ContextJsonSerializer ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_5_/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java_665-668": {
      "loc": "665-668",
      "input": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0 ? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0 ? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1 != null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        throw new JXPathException(\n                \"Cannot compare pointers that do not belong to the same tree: '\"\n                        + p1 + \"' and '\" + p2 + \"'\");\n    }\n    int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n    if (r != 0) {\n        return r;\n    }\n    return p1.parent.compareChildNodePointers(p1, p2);\n}",
      "target": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0 ? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0 ? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1 != null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n        return 0;\n    }\n    int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n    if (r != 0) {\n        return r;\n    }\n    return p1.parent.compareChildNodePointers(p1, p2);\n}",
      "function range": "642,5-675,5",
      "raw_output": [
        "boolean function ( Object arg0, Object arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Node arg0, Node arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) return ( arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == arg1 ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == arg1 ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "int function ( NodePointers arg0, NodePointers arg1 ) { return arg0. compareTo ( arg1 ) ; }",
        "int function ( NodePointers arg0, NodePointers arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( NodePointers arg0, NodePointers arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg0 == null ) { return - 1 ; } else if ( arg1 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( NodePointers arg0, NodePointers arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( NodePointers arg0, NodePointers arg1 ) { return arg0. compareTo ( arg1. arg0 ) ; }",
        "int function ( Node arg0, Node arg1 ) { return arg0. compareTo ( arg1 ) ; }",
        "int function ( Node arg0, Node arg1 ) { if ( arg0 == null ) return - 1 ; if ( arg1 == null ) return 0 ; if ( arg0 == null ) return - 1 ; if ( arg1 == null ) return 1 ; return arg0. compareTo ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "int function ( Node arg0, Node arg1 ) { if ( arg0 == null ) return - 1 ; if ( arg1 == null ) return 0 ; if ( arg0 == null ) return 1 ; if ( arg1 == null ) return 1 ; return arg0. compareTo ( arg1 ) ; }",
        "int function ( Object arg0, Object arg1 ) { if ( arg0 == null ) return - 1 ; if ( arg1 == null ) return 1 ; if ( arg0 == null ) return 0 ; if ( arg1 == null ) return - 1 ; return arg0. compareTo ( arg1 ) ; }",
        "int function ( NavNode arg0, NavNode arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( NavNode arg0, NavNode arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 1 ; } else if ( arg1 == null ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( NavNode arg0, NavNode arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( NavNode arg0, NavNode arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( Node arg0, Node arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg0 == null ) { return - 1 ; } else if ( arg1 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "boolean function ( Node arg0, Node arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return arg0 == arg1 ; } else if ( arg1 == null ) { return arg0 == arg1 ; } else { return arg0. equals ( arg1 ) ; } } else { return arg0. equals ( arg1 ) ; } }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) return ( arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) return ( arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }"
      ],
      "mid_translation": [
        "Compare two node pointers.",
        "Compare two NodePointers.",
        "Compare node pointers.",
        "Compare two nodes.",
        "Compare two node pointers"
      ],
      "output": [
        {
          "patch": "private boolean compareNodePointers ( Object arg0, Object arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Node arg0, Node arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Object arg0, Object arg1 ) { if ( arg0 == null ) return ( arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == arg1 ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == arg1 ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( NodePointers arg0, NodePointers arg1 ) { return arg0. compareTo ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( NodePointers arg0, NodePointers arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( NodePointers arg0, NodePointers arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg0 == null ) { return - 1 ; } else if ( arg1 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( NodePointers arg0, NodePointers arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( NodePointers arg0, NodePointers arg1 ) { return arg0. compareTo ( arg1. arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( Node arg0, Node arg1 ) { return arg0. compareTo ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( Node arg0, Node arg1 ) { if ( arg0 == null ) return - 1 ; if ( arg1 == null ) return 0 ; if ( arg0 == null ) return - 1 ; if ( arg1 == null ) return 1 ; return arg0. compareTo ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Object arg0, Object arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( Node arg0, Node arg1 ) { if ( arg0 == null ) return - 1 ; if ( arg1 == null ) return 0 ; if ( arg0 == null ) return 1 ; if ( arg1 == null ) return 1 ; return arg0. compareTo ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( Object arg0, Object arg1 ) { if ( arg0 == null ) return - 1 ; if ( arg1 == null ) return 1 ; if ( arg0 == null ) return 0 ; if ( arg1 == null ) return - 1 ; return arg0. compareTo ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( NavNode arg0, NavNode arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( NavNode arg0, NavNode arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 1 ; } else if ( arg1 == null ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( NavNode arg0, NavNode arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( NavNode arg0, NavNode arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == arg1 ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int compareNodePointers ( Node arg0, Node arg1 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg0 == null ) { return - 1 ; } else if ( arg1 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Node arg0, Node arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Object arg0, Object arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Object arg0, Object arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return arg0 == arg1 ; } else if ( arg1 == null ) { return arg0 == arg1 ; } else { return arg0. equals ( arg1 ) ; } } else { return arg0. equals ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Object arg0, Object arg1 ) { if ( arg0 == null ) return ( arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean compareNodePointers ( Object arg0, Object arg1 ) { if ( arg0 == null ) return ( arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_97_/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java_114-115": {
      "loc": "114-115",
      "input": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        gen.writeObject(_value);\n    }\n}",
      "target": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n        ctxt.defaultSerializeValue(_value, gen);\n    }\n}",
      "function range": "104,5-116,5",
      "raw_output": [
        "void function ( JsonGenerator arg0 ) { arg0. writeEndObject ( ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). toString ( ) ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this ) ; }",
        "void function ( JSONGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
        "void function ( JSONGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( JSONGenerator arg0 ) { arg0. writeObject ( this ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
        "void function ( JSONGenerator arg0 ) { arg0. writeStartObject ( ) ; serialize ( arg0 ) ; arg0. writeEndObject ( ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( StreamOutput arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( CodedOutputByteBufferNano arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( DataOutput arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( Writer arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeEndObject ( ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObjectField ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObjectFieldStart ( \"srini_string\" ) ; }",
        "void function ( JSONGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( JSONGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
        "void function ( JSONGenerator arg0 ) { arg0. writeObject ( this ) ; }",
        "void function ( JsonGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }"
      ],
      "mid_translation": [
        "Serialize this object to a JsonGenerator.",
        "Serialize this object to a JSON generator.",
        "Serialize this object to the given generator.",
        "Serialize this object to the specified JsonGenerator.",
        "Serialize this object to the JSON generator."
      ],
      "output": [
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeEndObject ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JSONGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JSONGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JSONGenerator arg0 ) { arg0. writeObject ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JSONGenerator arg0 ) { arg0. writeStartObject ( ) ; serialize ( arg0 ) ; arg0. writeEndObject ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( StreamOutput arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( CodedOutputByteBufferNano arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( DataOutput arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( Writer arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeEndObject ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObjectField ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObjectFieldStart ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JSONGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JSONGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this. getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JSONGenerator arg0 ) { arg0. writeObject ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic final void serialize ( JsonGenerator arg0 ) { arg0. writeObject ( this. toString ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_93_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java_83-85": {
      "loc": "83-85",
      "input": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n                String name = cls.getSimpleName();\n                if (\"AbstractPointcutAdvisor\".equals(name)\n                        || \"AbstractApplicationContext\".equals(name)) {\n                    break main_check;\n                }\n            }\n        }\n        return;\n    } while (false);\n    throw JsonMappingException.from(ctxt,\n            String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n}",
      "target": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n        if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n                String name = cls.getSimpleName();\n                if (\"AbstractPointcutAdvisor\".equals(name)\n                        || \"AbstractApplicationContext\".equals(name)) {\n                    break main_check;\n                }\n            }\n        }\n        return;\n    } while (false);\n    throw JsonMappingException.from(ctxt,\n            String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n}",
      "function range": "67,5-99,5",
      "raw_output": [
        "Type function ( Subtype arg0 ) { if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return null ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
        "boolean function ( Class <? > arg0, subtype arg1 ) { return arg0. equals ( arg1. getSubtype ( ) ) ; }",
        "boolean function ( Class <? > arg0, subtype arg1 ) { return arg0. equals ( arg1. subtype ( ) ) ; }",
        "boolean function ( Type arg0, Subtype arg1 ) { return arg0. equals ( arg1. getSubtype ( ) ) ; }",
        "boolean function ( Class <? > arg0, subtype arg1 ) { return arg0. equals ( arg1. getClass ( ) ) ; }",
        "boolean function ( Subtype arg0, Class <? > arg1 ) { return arg0. equals ( arg1 ) ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return null ; }",
        "Type function ( Subtype arg0, JavaType arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg1. asSubtype ( arg0 ) ; }",
        "Type function ( Subtype arg0, JavaType arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg1 ; }",
        "Type function ( Subtype arg0, JavaType arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0. asSubtype ( arg1 ) ; }",
        "Type function ( Subtype arg0, JavaType arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if (! arg0. isSubtype ( ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if (! arg0. isSubtype ( ) ) { throw new ValidationException ( \"srini_string\" ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return null ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { return null ; } else if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 == null ) { return null ; } else { return arg0 ; } }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
        "Type function ( Subtype arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 == null ) { return null ; } else { return arg0 ; } }"
      ],
      "mid_translation": [
        "Validate the subtype of a JavaType.",
        "Validate the subtype of the given type.",
        "Validate a subtype of a JavaType.",
        "Validate the subtype of the JavaType.",
        "Validate the subtype of a JavaType"
      ],
      "output": [
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean validateSubType ( Class <? > arg0, subtype arg1 ) { return arg0. equals ( arg1. getSubtype ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean validateSubType ( Class <? > arg0, subtype arg1 ) { return arg0. equals ( arg1. subtype ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean validateSubType ( Type arg0, Subtype arg1 ) { return arg0. equals ( arg1. getSubtype ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean validateSubType ( Class <? > arg0, subtype arg1 ) { return arg0. equals ( arg1. getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean validateSubType ( Subtype arg0, Class <? > arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0, JavaType arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg1. asSubtype ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0, JavaType arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0, JavaType arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0. asSubtype ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0, JavaType arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if (! arg0. isSubtype ( ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if (! arg0. isSubtype ( ) ) { throw new ValidationException ( \"srini_string\" ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { return null ; } else if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 == null ) { return null ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Type validateSubType ( Subtype arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof JavaType ) { return ( ( JavaType ) arg0 ). asSubtype ( ) ; } else if ( arg0 == null ) { return null ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_45_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_394-395": {
      "loc": "394-395",
      "input": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; \n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; \n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        }\n    }\n}",
      "target": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n        } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break; \n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break; \n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break; \n        } else if (last) {\n            transition(HtmlTreeBuilderState.InBody);\n            break; \n        }\n    }\n}",
      "function range": "382,5-429,5",
      "raw_output": [
        "void function ( ) { }",
        "void function ( ) { Trace. log ( Trace. ERROR ) ; }",
        "void function ( String arg0 ) { }",
        "void function ( PsiFile arg0 ) { }",
        "void function ( Table arg0 ) { }",
        "void function ( ) { }",
        "void function ( ) { InsertionMode. reset ( ) ; }",
        "void function ( PsiFile arg0 ) { }",
        "void function ( String arg0 ) { }",
        "void function ( boolean arg0 ) { }",
        "void function ( ) { }",
        "void function ( InsertionMode arg0 ) { }",
        "void function ( ) { Advapi32Util. resetInsertionMode ( ) ; }",
        "void function ( ) { InsertionMode. resetInsertionMode ( ) ; }",
        "void function ( ) { InsertionMode. reset ( ) ; }",
        "void function ( ) { }",
        "void function ( ) { Trace. log ( Trace. ERROR, \"srini_string\" ) ; }",
        "void function ( ) { Trace. log ( Trace. ERROR ) ; }",
        "void function ( String arg0 ) { }",
        "void function ( ) { MiddlePin. reset ( ) ; }",
        "void function ( ) { }",
        "void function ( ) { throw new MethodNotImplementedException ( \"srini_string\" ) ; }",
        "void function ( ) { throw new MethodError ( \"srini_string\" ) ; }",
        "void function ( ) { StackTraceElement [ ] loc0 = new Throwable ( ) ; Parser loc1 = new Parser ( ) ; loc1. resetInsertionMode ( ) ; }",
        "void function ( ) { throw new RuntimeException ( \"srini_string\" ) ; }"
      ],
      "mid_translation": [
        "Reset insertion mode.",
        "Resets the insertion mode.",
        "Method resetInsertionMode.",
        "Resets insertion mode.",
        "resetInsertionMode Method."
      ],
      "output": [
        {
          "patch": "void resetInsertionMode ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "void resetInsertionMode ( ) { Trace. log ( Trace. ERROR ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( String arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( PsiFile arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( Table arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "void resetInsertionMode ( ) { InsertionMode. reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( PsiFile arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( String arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( boolean arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "void resetInsertionMode ( InsertionMode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { Advapi32Util. resetInsertionMode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { InsertionMode. resetInsertionMode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { InsertionMode. reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "void resetInsertionMode ( ) { Trace. log ( Trace. ERROR, \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { Trace. log ( Trace. ERROR ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( String arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { MiddlePin. reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "void resetInsertionMode ( ) { throw new MethodNotImplementedException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { throw new MethodError ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { StackTraceElement [ ] loc0 = new Throwable ( ) ; Parser loc1 = new Parser ( ) ; loc1. resetInsertionMode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void resetInsertionMode ( ) { throw new RuntimeException ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_40_/src/main/java/org/jsoup/nodes/DocumentType.java_22-23": {
      "loc": "22-23",
      "input": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    Validate.notEmpty(name);\n    attr(\"name\", name);\n    attr(\"publicId\", publicId);\n    attr(\"systemId\", systemId);\n}",
      "target": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n    attr(\"name\", name);\n    attr(\"publicId\", publicId);\n    attr(\"systemId\", systemId);\n}",
      "function range": "19,5-26,5",
      "raw_output": [
        "boolean function ( DocumentType arg0 ) { return ( arg0 instanceof DocumentElement ) ; }",
        "boolean function ( DocumentType arg0 ) { return ( arg0 instanceof DocumentType ) ; }",
        "boolean function ( ) { return false ; }",
        "DocumentType function ( ) { return DocumentType. DOCUMENT_TYPE ; }",
        "boolean function ( DocumentType arg0 ) { return true ; }",
        "DocumentType function ( ) { return new DocumentType ( ) ; }",
        "DocumentType function ( ) { return DocumentType. USER_ID ; }",
        "DocumentType function ( ) { return DocumentType. DOCUMENT_TYPE ; }",
        "DocumentType function ( ) { return DocumentType. USER_NAME ; }",
        "DocumentType function ( ) { return null ; }",
        "DocumentType function ( ) { return DocumentType. USER_ID ; }",
        "DocumentType function ( ) { return DocumentType. USER_NAME ; }",
        "DocumentType function ( ) { return DocumentType. DOCUMENT_TYPE ; }",
        "DocumentType function ( ) { return DocumentType. USER_DEFAULT ; }",
        "DocumentType function ( ) { return DocumentType. DO_NOTHING ; }",
        "Document function ( String arg0, Attributes arg1 ) { return create ( arg0, arg1, null ) ; }",
        "Document function ( String arg0, Attributes arg1 ) { if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return create ( arg0, arg1, null ) ; }",
        "DocumentType function ( String arg0, Attributes arg1 ) { return create ( arg0, arg1, null ) ; }",
        "DocumentType function ( String arg0, Attributes arg1 ) { if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return create ( arg0, arg1, null ) ; }",
        "Document function ( Attributes arg0 ) { return create ( arg0, null ) ; }",
        "DocumentType function ( ) { return DOCUMENT_TYPE ; }",
        "DocumentType function ( ) { return DocumentType. DOCUMENT_TYPE ; }",
        "DocumentType function ( ) { return DocumentType. DOCUMENT ; }",
        "DocumentType function ( ) { return DocumentType. USER_NAME ; }",
        "DocumentType function ( ) { return DocumentType. HTML ; }"
      ],
      "mid_translation": [
        "Implementation of the DocumentType interface.",
        "DocumentType constructor.",
        "DocumentType Constructor.",
        "Create a new document type with the specified attributes",
        "Implementation of DocumentType."
      ],
      "output": [
        {
          "patch": "public boolean DocumentType ( DocumentType arg0 ) { return ( arg0 instanceof DocumentElement ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean DocumentType ( DocumentType arg0 ) { return ( arg0 instanceof DocumentType ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean DocumentType ( ) { return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. DOCUMENT_TYPE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean DocumentType ( DocumentType arg0 ) { return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return new DocumentType ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. USER_ID ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. DOCUMENT_TYPE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. USER_NAME ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. USER_ID ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. USER_NAME ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. DOCUMENT_TYPE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. USER_DEFAULT ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. DO_NOTHING ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Document DocumentType ( String arg0, Attributes arg1 ) { return create ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Document DocumentType ( String arg0, Attributes arg1 ) { if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return create ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( String arg0, Attributes arg1 ) { return create ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( String arg0, Attributes arg1 ) { if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return create ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Document DocumentType ( Attributes arg0 ) { return create ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DOCUMENT_TYPE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. DOCUMENT_TYPE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. DOCUMENT ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. USER_NAME ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public DocumentType DocumentType ( ) { return DocumentType. HTML ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_21_/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java_152-153": {
      "loc": "152-153",
      "input": "public int getLength() {\n    return ValueUtils.getLength(getBaseValue());\n}",
      "target": "public int getLength() {\n    Object baseValue = getBaseValue();\n    return baseValue == null ? 1 : ValueUtils.getLength(baseValue);\n}",
      "function range": "151,5-153,5",
      "raw_output": [
        "long function ( ) { return Long. parseLong ( value ) ; }",
        "long function ( ) { return ( long ) this. getValue ( ). longValue ( ) ; }",
        "long function ( ) { return Long. MAX_VALUE ; }",
        "long function ( ) { return Long. valueOf ( getValue ( ) ). longValue ( ) ; }",
        "long function ( ) { return value. length ( ) ; }",
        "long function ( ) { return Long. MAX_VALUE ; }",
        "long function ( ) { return Long. parseLong ( value ) ; }",
        "long function ( ) { return 0 ; }",
        "long function ( ) { return Long. parseLong ( this. toString ( ) ) ; }",
        "long function ( ) { return ( long ) this. getValue ( ). longValue ( ) ; }",
        "long function ( ) { return Long. parseLong ( \"srini_string\" ) ; }",
        "long function ( ) { return 0 ; }",
        "long function ( ) { return 1 ; }",
        "long function ( ) { return Long. MAX_VALUE ; }",
        "long function ( ) { return ( long ) this. getValue ( ). longValue ( ) ; }",
        "long function ( ) { return 0 ; }",
        "long function ( ) { return Long. MAX_VALUE ; }",
        "long function ( ) { return 1 ; }",
        "int function ( ) { return 0 ; }",
        "long function ( ) { return 0L ; }",
        "long function ( ) { return 0 ; }",
        "long function ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
        "int function ( ) { return 0 ; }",
        "int function ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
        "long function ( ) { return SequenceUtils. getLength ( this ) ; }"
      ],
      "mid_translation": [
        "Returns the length of this value.",
        "Gets the length of this value.",
        "Returns the length of the value.",
        "Gets the length of the value.",
        "Returns the length of the sequence."
      ],
      "output": [
        {
          "patch": "public long getLength ( ) { return Long. parseLong ( value ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return ( long ) this. getValue ( ). longValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return Long. MAX_VALUE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return Long. valueOf ( getValue ( ) ). longValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return value. length ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return Long. MAX_VALUE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return Long. parseLong ( value ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return Long. parseLong ( this. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return ( long ) this. getValue ( ). longValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return Long. parseLong ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return Long. MAX_VALUE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return ( long ) this. getValue ( ). longValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return Long. MAX_VALUE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getLength ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public long getLength ( ) { return 0L ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { return 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getLength ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int getLength ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public int getLength ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public long getLength ( ) { return SequenceUtils. getLength ( this ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_21_/src/main/java/org/apache/commons/lang3/time/DateUtils.java_265-266": {
      "loc": "265-266",
      "input": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n            cal1.getClass() == cal2.getClass());\n}",
      "target": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n            cal1.getClass() == cal2.getClass());\n}",
      "function range": "258,5-270,5",
      "raw_output": [
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0. getTime ( ) == arg1. getTime ( ) ) { return true ; } else if ( arg0. getTime ( ) == arg1. getTime ( ) ) { return false ; } else { return true ; } }",
        "boolean function ( DateTime arg0, DateTime arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return false ; } return isSameLocalTime ( arg0. getTime ( ), arg1. getTime ( ) ) ; }",
        "boolean function ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! arg1. equals ( arg0 ) ) { return false ; } return true ; }",
        "boolean function ( DateTime arg0, DateTime arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! arg1. isSameLocalTime ( arg0 ) ) { return false ; } return true ; }",
        "boolean function ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! arg1. isSameLocalTime ( ) ) { return false ; } return true ; }",
        "boolean function ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0!= null && arg1!= null ) { return arg0. equals ( arg1 ) ; } else { return true ; } }",
        "boolean function ( DateTime arg0, DateTime arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getTime ( )!= arg1. getTime ( ) ) { return false ; } else { return true ; } }",
        "boolean function ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0!= null && arg1!= null ) { return arg0. equals ( arg1 ) ; } return true ; }",
        "boolean function ( DateTime arg0, DateTime arg1 ) { if ( arg0. getTime ( )!= arg1. getTime ( ) ) { return false ; } else { return true ; } }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { Calendar loc0 = ( Calendar ) arg0 ; Calendar loc1 = ( Calendar ) arg1 ; return ( loc0. getTimeInMillis ( ) == loc1. getTimeInMillis ( ) ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTime ( ) == arg1. getTime ( ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return ( arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { Calendar loc0 = ( Calendar ) arg0 ; Calendar loc1 = ( Calendar ) arg1 ; return ( loc0. getTimeInMillis ( ) == loc1. getTimeInMillis ( ) ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ) ; }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } else { Calendar loc0 = ( Calendar ) arg0 ; Calendar loc1 = ( Calendar ) arg1 ; return ( loc0. getTimeInMillis ( ) == loc1. getTimeInMillis ( ) ) ; } }",
        "boolean function ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTime ( ) == arg1. getTime ( ) ; }"
      ],
      "mid_translation": [
        "Method isSameLocalTime.",
        "IsSameLocalTime Method.",
        "Check if two calendars are the same local time.",
        "This method returns true if the two calendars are the same local time.",
        "This method returns true if two calendars are the same local time."
      ],
      "output": [
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0. getTime ( ) == arg1. getTime ( ) ) { return true ; } else if ( arg0. getTime ( ) == arg1. getTime ( ) ) { return false ; } else { return true ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( DateTime arg0, DateTime arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return false ; } return isSameLocalTime ( arg0. getTime ( ), arg1. getTime ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! arg1. equals ( arg0 ) ) { return false ; } return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( DateTime arg0, DateTime arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! arg1. isSameLocalTime ( arg0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! arg1. isSameLocalTime ( ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0!= null && arg1!= null ) { return arg0. equals ( arg1 ) ; } else { return true ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( DateTime arg0, DateTime arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getTime ( )!= arg1. getTime ( ) ) { return false ; } else { return true ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Date arg0, Date arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0!= null && arg1!= null ) { return arg0. equals ( arg1 ) ; } return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( DateTime arg0, DateTime arg1 ) { if ( arg0. getTime ( )!= arg1. getTime ( ) ) { return false ; } else { return true ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { Calendar loc0 = ( Calendar ) arg0 ; Calendar loc1 = ( Calendar ) arg1 ; return ( loc0. getTimeInMillis ( ) == loc1. getTimeInMillis ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTime ( ) == arg1. getTime ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return ( arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { Calendar loc0 = ( Calendar ) arg0 ; Calendar loc1 = ( Calendar ) arg1 ; return ( loc0. getTimeInMillis ( ) == loc1. getTimeInMillis ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. getTimeInMillis ( ) == arg1. getTimeInMillis ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } else { Calendar loc0 = ( Calendar ) arg0 ; Calendar loc1 = ( Calendar ) arg1 ; return ( loc0. getTimeInMillis ( ) == loc1. getTimeInMillis ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isSameLocalTime ( Calendar arg0, Calendar arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getTime ( ) == arg1. getTime ( ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_34_/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java_81-82": {
      "loc": "81-82",
      "input": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n             visitor.expectNumberFormat(typeHint);\n        }\n    }\n}",
      "target": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else {\n             visitor.expectNumberFormat(typeHint);\n        }\n    }\n}",
      "function range": "73,5-87,5",
      "raw_output": [
        "void function ( JsonFormat arg0 ) { }",
        "void function ( JsonValue arg0 ) { }",
        "void function ( VisitorContext arg0 ) { }",
        "void function ( T arg0 ) { }",
        "void function ( JsonFormat arg0, JsonValue arg1 ) { }",
        "void function ( JsonFormat arg0 ) { }",
        "void function ( JsonValue arg0 ) { }",
        "void function ( FormattingContext arg0 ) { }",
        "void function ( JsonFormat arg0, T arg1 ) { }",
        "void function ( JsonFormat arg0, Object arg1 ) { }",
        "void function ( JsonFormat arg0 ) { }",
        "void function ( FormattingContext arg0 ) { }",
        "void function ( JsonValue arg0 ) { }",
        "void function ( JsonFormat arg0, boolean arg1 ) { }",
        "void function ( Format arg0 ) { }",
        "void function ( TypeHint arg0 ) { }",
        "void function ( JsonFormatVisitor arg0 ) { }",
        "Type function ( ) { return null ; }",
        "JsonFormatVisitor function ( TypeHint arg0 ) { return this ; }",
        "void function ( JsonFormat arg0, TypeHint arg1 ) { }",
        "void function ( Number arg0 ) { }",
        "void function ( JsonNumber arg0 ) { }",
        "void function ( NumberFormat arg0 ) { }",
        "void function ( JsonValue arg0 ) { }",
        "void function ( Number arg0, JsonValue arg1 ) { }"
      ],
      "mid_translation": [
        "Implements the acceptJsonFormatVisitor interface.",
        "Override the acceptJsonFormatVisitor method.",
        "Implements the acceptJsonFormatVisitor method.",
        "Override acceptJsonFormatVisitor to accept a type hint.",
        "Override the acceptJsonFormatVisitor to accept a number format."
      ],
      "output": [
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonFormat arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonValue arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( VisitorContext arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( T arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonFormat arg0, JsonValue arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonFormat arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonValue arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( FormattingContext arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonFormat arg0, T arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonFormat arg0, Object arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonFormat arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( FormattingContext arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonValue arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonFormat arg0, boolean arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( Format arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( TypeHint arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonFormatVisitor arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Type acceptJsonFormatVisitor ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic JsonFormatVisitor acceptJsonFormatVisitor ( TypeHint arg0 ) { return this ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonFormat arg0, TypeHint arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( Number arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonNumber arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( NumberFormat arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( JsonValue arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic void acceptJsonFormatVisitor ( Number arg0, JsonValue arg1 ) { }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_86_/src/main/java/org/jsoup/nodes/Comment.java_78-79": {
      "loc": "78-79",
      "input": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    if (doc.childNodeSize() > 0) {\n        Element el = doc.child(0);\n        decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n        decl.attributes().addAll(el.attributes());\n    }\n    return decl;\n}",
      "target": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n    if (doc.children().size() > 0) {\n        Element el = doc.child(0);\n        decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n        decl.attributes().addAll(el.attributes());\n    }\n    return decl;\n}",
      "function range": "74,5-84,5",
      "raw_output": [
        "String function ( ) { return \"srini_string\" ; }",
        "org. w3c. dom. Document function ( ) { return getDocument ( ) ; }",
        "org. w3c. dom. Document function ( ) { throw new UnsupportedOperationException ( ) ; }",
        "String function ( ) { return getDocument ( ). getDocumentElement ( ) ; }",
        "XMLElement function ( ) { return getDocument ( ) ; }",
        "org. w3c. dom. Node function ( ) { org. w3c. dom. Node loc0 = this. node ; return loc0 ; }",
        "org. w3c. dom. Node function ( org. w3c. dom. Node arg0 ) { org. loc0. dom. Node loc1 = arg0 ; return loc1 ; }",
        "org. w3c. dom. Node function ( ) { org. w3c. dom. Node loc0 = node ( ) ; return loc0 ; }",
        "org. w3c. dom. Node function ( org. w3c. dom. Node arg0 ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
        "org. w3c. dom. Node function ( ) { return ( org. w3c. dom. Node ) this. node ; }",
        "XMLDeclaration function ( ) { return new XMLDeclaration ( this ) ; }",
        "XMLDeclaration function ( ) { return ( XMLDeclaration ) DocumentUtils. getDocument ( this ) ; }",
        "XMLDeclaration function ( ) { return new XMLDeclaration ( document ( ) ) ; }",
        "XMLDeclaration function ( ) { return ( XMLDeclaration ) document ; }",
        "XMLDeclaration function ( ) { return new DOMDeclaration ( this ) ; }",
        "XMLDeclaration function ( Document arg0 ) { return new XMLDeclaration ( arg0 ) ; }",
        "XMLDeclaration function ( ) { return new XMLDeclaration ( this ) ; }",
        "org. w3c. dom. Document function ( ) { return DocumentUtils. getDocument ( this ) ; }",
        "XMLDeclaration function ( ) { return new XMLDeclaration ( document ( ) ) ; }",
        "XMLDeclaration function ( ) { return ( XMLDeclaration ) DocumentUtils. getDocument ( this ) ; }",
        "XMLDeclaration function ( Node arg0 ) { return new XMLDeclaration ( arg0 ) ; }",
        "XMLDeclaration function ( Node arg0 ) { return ( XMLDeclaration ) arg0. getOwnerDocument ( ) ; }",
        "XMLDeclaration function ( Node arg0 ) { return ( XMLDeclaration ) arg0 ; }",
        "org. w3c. dom. Node function ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
        "XMLDeclaration function ( Node arg0 ) { XMLDeclaration loc0 = ( XMLDeclaration ) arg0 ; return loc0 ; }"
      ],
      "mid_translation": [
        "Returns the document as an XML declaration.",
        "Returns the node as an XML declaration.",
        "Returns the document as an XMLDeclaration object.",
        "Returns the document as an XMLDeclaration.",
        "Returns the node as an XMLDeclaration."
      ],
      "output": [
        {
          "patch": "public String asXmlDeclaration ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public org. w3c. dom. Document asXmlDeclaration ( ) { return getDocument ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public org. w3c. dom. Document asXmlDeclaration ( ) { throw new UnsupportedOperationException ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String asXmlDeclaration ( ) { return getDocument ( ). getDocumentElement ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLElement asXmlDeclaration ( ) { return getDocument ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public org. w3c. dom. Node asXmlDeclaration ( ) { org. w3c. dom. Node loc0 = this. node ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public org. w3c. dom. Node asXmlDeclaration ( org. w3c. dom. Node arg0 ) { org. loc0. dom. Node loc1 = arg0 ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public org. w3c. dom. Node asXmlDeclaration ( ) { org. w3c. dom. Node loc0 = node ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public org. w3c. dom. Node asXmlDeclaration ( org. w3c. dom. Node arg0 ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public org. w3c. dom. Node asXmlDeclaration ( ) { return ( org. w3c. dom. Node ) this. node ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( ) { return new XMLDeclaration ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( ) { return ( XMLDeclaration ) DocumentUtils. getDocument ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( ) { return new XMLDeclaration ( document ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( ) { return ( XMLDeclaration ) document ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( ) { return new DOMDeclaration ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( Document arg0 ) { return new XMLDeclaration ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( ) { return new XMLDeclaration ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public org. w3c. dom. Document asXmlDeclaration ( ) { return DocumentUtils. getDocument ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( ) { return new XMLDeclaration ( document ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( ) { return ( XMLDeclaration ) DocumentUtils. getDocument ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( Node arg0 ) { return new XMLDeclaration ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( Node arg0 ) { return ( XMLDeclaration ) arg0. getOwnerDocument ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( Node arg0 ) { return ( XMLDeclaration ) arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public org. w3c. dom. Node asXmlDeclaration ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public XMLDeclaration asXmlDeclaration ( Node arg0 ) { XMLDeclaration loc0 = ( XMLDeclaration ) arg0 ; return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_61_/src/main/java/org/jsoup/nodes/Element.java_1092-1093": {
      "loc": "1092-1093",
      "input": "public boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n    return false;\n}",
      "target": "public boolean hasClass(String className) {\n    final String classAttr = attributes.getIgnoreCase(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n    return false;\n}",
      "function range": "1091,5-1132,5",
      "raw_output": [
        "boolean function ( final String arg0, final String arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( final Class arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( final Attributes arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( Constants. CLASS_ATTRIBUTE ) ; }",
        "boolean function ( final String arg0, final String arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( final Class arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( Constants. CLASS_ATTRIBUTE ) ; }",
        "boolean function ( final Attributes arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
        "boolean function ( final Class arg0, final String arg1 ) { return ( arg0 == null )? false : arg0. getName ( ). equals ( arg1 ) ; }",
        "boolean function ( final Class arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
        "boolean function ( final Attributes arg0, final String arg1 ) { return ( arg0!= null && arg0. toString ( ). contains ( arg1 ) ) ; }",
        "boolean function ( final Attributes arg0, final String arg1 ) { return arg0. contains ( arg1 ) ; }",
        "boolean function ( final Object arg0, final String arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( final Class arg0, final String arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( final Class arg0, final Attributes arg1 ) { return arg0. equals ( arg1. getAttribute ( \"srini_string\" ) ) ; }",
        "boolean function ( final Class arg0, final String arg1 ) { return arg0. isAssignableFrom ( arg1 ) ; }",
        "boolean function ( final Class arg0, final Attributes arg1 ) { return arg0. equals ( arg1. getAttribute ( ) ) ; }",
        "boolean function ( final Class arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
        "boolean function ( Class <? > arg0 ) { return arg0. getName ( ). equals ( \"srini_string\" ) ; }",
        "boolean function ( Class arg0 ) { return arg0. getName ( ). startsWith ( \"srini_string\" ) ; }",
        "boolean function ( Class <? > arg0 ) { return arg0. getName ( ). startsWith ( \"srini_string\" ) ; }",
        "boolean function ( Class <? > arg0 ) { return arg0. getName ( ). equals ( getClass ( ). getName ( ) ) ; }",
        "boolean function ( Class arg0 ) { return arg0. getName ( ). endsWith ( \"srini_string\" ) || arg0. getName ( ). endsWith ( \"srini_string\" ) ; }"
      ],
      "mid_translation": [
        "Check if the class attribute matches the specified class name.",
        "Check if the class attribute matches the given class name.",
        "Check if the class attribute contains the specified class name.",
        "Check if the class attribute matches the specified class.",
        "Check if a class is present in this class."
      ],
      "output": [
        {
          "patch": "public boolean hasClass ( final String arg0, final String arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( final Class arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( String arg0, String arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( final Attributes arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass ( String arg0 ) { return arg0. equals ( Constants. CLASS_ATTRIBUTE ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass ( final String arg0, final String arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( String arg0, String arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( final Class arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( String arg0 ) { return arg0. equals ( Constants. CLASS_ATTRIBUTE ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass ( final Attributes arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass ( final Class arg0, final String arg1 ) { return ( arg0 == null )? false : arg0. getName ( ). equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( final Class arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( final Attributes arg0, final String arg1 ) { return ( arg0!= null && arg0. toString ( ). contains ( arg1 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( final Attributes arg0, final String arg1 ) { return arg0. contains ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass ( final Object arg0, final String arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( final Class arg0, final String arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( final Class arg0, final Attributes arg1 ) { return arg0. equals ( arg1. getAttribute ( \"srini_string\" ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass ( final Class arg0, final String arg1 ) { return arg0. isAssignableFrom ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass ( final Class arg0, final Attributes arg1 ) { return arg0. equals ( arg1. getAttribute ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean hasClass ( final Class arg0, final String arg1 ) { return arg0. getName ( ). equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( Class <? > arg0 ) { return arg0. getName ( ). equals ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( Class arg0 ) { return arg0. getName ( ). startsWith ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( Class <? > arg0 ) { return arg0. getName ( ). startsWith ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( Class <? > arg0 ) { return arg0. getName ( ). equals ( getClass ( ). getName ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean hasClass ( Class arg0 ) { return arg0. getName ( ). endsWith ( \"srini_string\" ) || arg0. getName ( ). endsWith ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonXml_5_/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java_59-60": {
      "loc": "59-60",
      "input": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    _rootNameLookup = src._rootNameLookup;\n}",
      "target": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n    _rootNameLookup = new XmlRootNameLookup();\n}",
      "function range": "55,5-60,5",
      "raw_output": [
        "void function ( Map arg0 ) { }",
        "void function ( SerializerProvider arg0 ) { }",
        "void function ( SerializerProviderRegistry arg0 ) { _rootNameLookup = arg0 ; }",
        "void function ( Map < String, String > arg0 ) { }",
        "void function ( SerializerProviderRegistry arg0 ) { }",
        "String function ( ) { return \"srini_string\" ; }",
        "boolean function ( Map arg0 ) { return true ; }",
        "boolean function ( Context arg0 ) { return true ; }",
        "String function ( String arg0 ) { return arg0 ; }",
        "boolean function ( Map arg0 ) { return false ; }",
        "void function ( SerializerProvider arg0 ) { }",
        "void function ( SerializerProviderConfig arg0 ) { }",
        "void function ( SerializerProvider arg0, String arg1 ) { }",
        "String function ( ) { return \"srini_string\" ; }",
        "void function ( String arg0 ) { }",
        "void function ( RootNameLookup arg0 ) { }",
        "void function ( Map arg0 ) { }",
        "void function ( NameLookup arg0 ) { }",
        "void function ( NameLookup arg0 ) { _rootNameLookup = arg0 ; }",
        "void function ( Map arg0 ) { _rootNameLookup = arg0 ; }",
        "void function ( RootNameLookup arg0 ) { }",
        "void function ( Map arg0 ) { }",
        "void function ( CompositeDataContext arg0 ) { }",
        "void function ( CompositeData arg0 ) { }",
        "void function ( NameLookup arg0 ) { }"
      ],
      "mid_translation": [
        "Override this method to set the serializer provider s _rootNameLookup.",
        "Override this method to allow subclasses to override.",
        "Override this method to set the serializer provider s root name lookup.",
        "Override this method to set the _rootNameLookup property.",
        "Override this method to set the _rootNameLookup attribute."
      ],
      "output": [
        {
          "patch": "protected void XmlSerializerProvider ( Map arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( SerializerProvider arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( SerializerProviderRegistry arg0 ) { _rootNameLookup = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( Map < String, String > arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( SerializerProviderRegistry arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String XmlSerializerProvider ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected boolean XmlSerializerProvider ( Map arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected boolean XmlSerializerProvider ( Context arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String XmlSerializerProvider ( String arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected boolean XmlSerializerProvider ( Map arg0 ) { return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( SerializerProvider arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( SerializerProviderConfig arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( SerializerProvider arg0, String arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected String XmlSerializerProvider ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( String arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( RootNameLookup arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( Map arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( NameLookup arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( NameLookup arg0 ) { _rootNameLookup = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( Map arg0 ) { _rootNameLookup = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( RootNameLookup arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( Map arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( CompositeDataContext arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( CompositeData arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void XmlSerializerProvider ( NameLookup arg0 ) { }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_29_/src/main/java/org/apache/commons/lang3/SystemUtils.java_1672-1673": {
      "loc": "1672-1673",
      "input": "\nstatic float toJavaVersionInt(String version) {\n    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n}",
      "target": "\nstatic int toJavaVersionInt(String version) {\n    return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n}",
      "function range": "1672,5-1674,5",
      "raw_output": [
        "List < Integer > function ( String arg0 ) { int loc0 = arg0. loc0 ( ) ; List < Integer > loc1 = new ArrayList < Integer > ( loc0 ) ; int loc2 = 0 ; while ( loc2 < loc0 ) { loc1. add ( loc2 ) ; loc2 ++ ; } return loc1 ; }",
        "List < Integer > function ( String arg0 ) { int loc0 = arg0. loc0 ( ) ; List < Integer > loc1 = new ArrayList < Integer > ( loc0 ) ; int loc2 = 0 ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) { loc1. add ( loc3 ) ; loc2 ++ ; } return loc1 ; }",
        "List < Integer > function ( String arg0 ) { int loc0 = Integer. parseInt ( arg0 ) ; List < Integer > loc1 = new ArrayList < Integer > ( ) ; int loc2 = 0 ; while ( loc2 < loc0 ) { loc1. add ( loc2 ) ; loc2 ++ ; } return loc1 ; }",
        "List < Integer > function ( String arg0 ) { int loc0 = Integer. parseInt ( arg0 ) ; List < Integer > loc1 = new ArrayList < Integer > ( loc0 ) ; int loc2 = 0 ; while ( loc2 < loc0 ) { loc1. add ( loc2 ) ; loc2 ++ ; } return loc1 ; }",
        "List < Integer > function ( String arg0 ) { int loc0 = Integer. parseInt ( arg0 ) ; List < Integer > loc1 = new ArrayList < Integer > ( loc0 ) ; int loc2 = 0 ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) { loc1. add ( loc3 ) ; loc2 ++ ; } return loc1 ; }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else if ( \"srini_string\". equals ( arg0 ) ) ; else return 0 ; }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else if ( \"srini_string\". equals ( arg0 ) ; else return - 1 ; }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) return 1 ; else if ( \"srini_string\". equals ( arg0 ) ) return 2 ; else if ( \"srini_string\". equals ( arg0 ) ) return 3 ; else if ( \"srini_string\". equals ( arg0 ) ) return 4 ; else if ( \"srini_string\". equals ( arg0 ) ) return 5 ; else return 0 ; }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else if ( \"srini_string\". equals ( arg0 ) ) ; else return 0 ; }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else if ( \"srini_string\". equals ( arg0 ) ) ; else return 255 ; }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) return 0 ; else if ( \"srini_string\". equals ( arg0 ) ) return 1 ; else if ( \"srini_string\". equals ( arg0 ) ) return 2 ; else if ( \"srini_string\". equals ( arg0 ) ) return 3 ; else if ( \"srini_string\". equals ( arg0 ) ) return 4 ; else return 0 ; }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "int function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }"
      ],
      "mid_translation": [
        "Convert a Java version string to a sequence of integers.",
        "Convert a Java version string to an int.",
        "Convert a Java version string to an integer version.",
        "Convert a Java version string to an integer.",
        "Convert a Java version string to an int version."
      ],
      "output": [
        {
          "patch": "static List < Integer > toJavaVersionInt ( String arg0 ) { int loc0 = arg0. loc0 ( ) ; List < Integer > loc1 = new ArrayList < Integer > ( loc0 ) ; int loc2 = 0 ; while ( loc2 < loc0 ) { loc1. add ( loc2 ) ; loc2 ++ ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static List < Integer > toJavaVersionInt ( String arg0 ) { int loc0 = arg0. loc0 ( ) ; List < Integer > loc1 = new ArrayList < Integer > ( loc0 ) ; int loc2 = 0 ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) { loc1. add ( loc3 ) ; loc2 ++ ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static List < Integer > toJavaVersionInt ( String arg0 ) { int loc0 = Integer. parseInt ( arg0 ) ; List < Integer > loc1 = new ArrayList < Integer > ( ) ; int loc2 = 0 ; while ( loc2 < loc0 ) { loc1. add ( loc2 ) ; loc2 ++ ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static List < Integer > toJavaVersionInt ( String arg0 ) { int loc0 = Integer. parseInt ( arg0 ) ; List < Integer > loc1 = new ArrayList < Integer > ( loc0 ) ; int loc2 = 0 ; while ( loc2 < loc0 ) { loc1. add ( loc2 ) ; loc2 ++ ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static List < Integer > toJavaVersionInt ( String arg0 ) { int loc0 = Integer. parseInt ( arg0 ) ; List < Integer > loc1 = new ArrayList < Integer > ( loc0 ) ; int loc2 = 0 ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) { loc1. add ( loc3 ) ; loc2 ++ ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else if ( \"srini_string\". equals ( arg0 ) ) ; else return 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else if ( \"srini_string\". equals ( arg0 ) ; else return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) return 1 ; else if ( \"srini_string\". equals ( arg0 ) ) return 2 ; else if ( \"srini_string\". equals ( arg0 ) ) return 3 ; else if ( \"srini_string\". equals ( arg0 ) ) return 4 ; else if ( \"srini_string\". equals ( arg0 ) ) return 5 ; else return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else if ( \"srini_string\". equals ( arg0 ) ) ; else return 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else if ( \"srini_string\". equals ( arg0 ) ) ; else return 255 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 4 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) return 0 ; else if ( \"srini_string\". equals ( arg0 ) ) return 1 ; else if ( \"srini_string\". equals ( arg0 ) ) return 2 ; else if ( \"srini_string\". equals ( arg0 ) ) return 3 ; else if ( \"srini_string\". equals ( arg0 ) ) return 4 ; else return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 3 ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "static int toJavaVersionInt ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return 0 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 1 ; } else if ( \"srini_string\". equals ( arg0 ) ) { return 2 ; } else { throw new RuntimeException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_59_/src/java/org/apache/commons/lang/text/StrBuilder.java_884-885": {
      "loc": "884-885",
      "input": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, strLen, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "target": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "function range": "878,5-895,5",
      "raw_output": [
        "String function ( String arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; loc0. append ('' ) ; loc0. append ( arg1 ) ; loc0. append ('' ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; loc0. append ('' ) ; loc0. append ( arg1 ) ; return loc0. toString ( ) ; }",
        "String function ( int arg0, String arg1 ) { StringBuilder loc0 = new StringBuilder ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0. toString ( ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, - 1 ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, 0 ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, 32 ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, false ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, 0, null ) ; }",
        "String function ( String arg0, Object arg1 ) { int loc0 = ( arg1 == null )? 0 : arg1. length ( ) ; StringBuilder loc1 = new StringBuilder ( loc0 * 5 ) ; loc1. append ( \"srini_string\" ) ; loc1. append ( arg0 ) ; loc1. append ( \"srini_string\" ) ; return loc1. toString ( ) ; }",
        "String function ( String arg0, Object arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1. toString ( ) ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0, Object arg1 ) { int loc0 = ( arg1 == null )? 0 : arg1. length ( ) ; StringBuilder loc1 = new StringBuilder ( loc0 * 10 ) ; loc1. append ( \"srini_string\" ) ; loc1. append ( arg0 ) ; loc1. append ( \"srini_string\" ) ; return loc1. toString ( ) ; }",
        "String function ( String arg0, Object arg1 ) { int loc0 = ( arg1 == null )? 0 : arg1. length ( ) ; StringBuilder loc1 = new StringBuilder ( loc0 * 2 ) ; loc1. append ( \"srini_string\" ) ; loc1. append ( arg0 ) ; loc1. append ( \"srini_string\" ) ; return loc1. toString ( ) ; }",
        "String function ( String arg0, Object arg1 ) { return appendFixedWidthPadRight ( arg0, arg1. length ( ) ) ; }",
        "String function ( String arg0, int arg1 ) { return append ( arg0, arg1, 0, arg0. length ( ) ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return append ( arg0, arg1, arg2, 0, arg0. length ( ) ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, 0, arg0. length ( ) ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return append ( arg0, arg1, arg2,'' ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return append ( arg0, arg1, arg2, false ) ; }",
        "StringBuilder function ( int arg0, String arg1 ) { return append ( arg0, arg1, 0, arg1. length ( ) ) ; }",
        "Builder function ( int arg0, String arg1 ) { return append ( arg0, arg1, 0, arg1. length ( ) ) ; }",
        "StringBuilder function ( int arg0, String arg1 ) { return appendFixedWidthString ( arg0, arg1, 0, arg1. length ( ) ) ; }",
        "Builder function ( String arg0, int arg1, int arg2 ) { return append ( arg0, arg1, arg2, \"srini_string\" ) ; }",
        "StringBuilder function ( int arg0, String arg1 ) { return appendFixedWidthString ( arg0, arg1, 0 ) ; }"
      ],
      "mid_translation": [
        "appendFixedWidthPadRight Method.",
        "Append a fixed - width string to the end of the string.",
        "appendFixedWidthPadRight This method will append the specified object to the end of the string.",
        "Append a fixed width string to the end of the string.",
        "Append a fixed - width string to the builder."
      ],
      "output": [
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; loc0. append ('' ) ; loc0. append ( arg1 ) ; loc0. append ('' ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; loc0. append ('' ) ; loc0. append ( arg1 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( int arg0, String arg1 ) { StringBuilder loc0 = new StringBuilder ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, - 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, 32 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, 0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, Object arg1 ) { int loc0 = ( arg1 == null )? 0 : arg1. length ( ) ; StringBuilder loc1 = new StringBuilder ( loc0 * 5 ) ; loc1. append ( \"srini_string\" ) ; loc1. append ( arg0 ) ; loc1. append ( \"srini_string\" ) ; return loc1. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, Object arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg0 ) ; loc0. append ( \"srini_string\" ) ; loc0. append ( arg1. toString ( ) ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, Object arg1 ) { int loc0 = ( arg1 == null )? 0 : arg1. length ( ) ; StringBuilder loc1 = new StringBuilder ( loc0 * 10 ) ; loc1. append ( \"srini_string\" ) ; loc1. append ( arg0 ) ; loc1. append ( \"srini_string\" ) ; return loc1. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, Object arg1 ) { int loc0 = ( arg1 == null )? 0 : arg1. length ( ) ; StringBuilder loc1 = new StringBuilder ( loc0 * 2 ) ; loc1. append ( \"srini_string\" ) ; loc1. append ( arg0 ) ; loc1. append ( \"srini_string\" ) ; return loc1. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, Object arg1 ) { return appendFixedWidthPadRight ( arg0, arg1. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1 ) { return append ( arg0, arg1, 0, arg0. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return append ( arg0, arg1, arg2, 0, arg0. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return appendFixedWidthString ( arg0, arg1, arg2, 0, arg0. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return append ( arg0, arg1, arg2,'' ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return append ( arg0, arg1, arg2, false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuilder appendFixedWidthPadRight ( int arg0, String arg1 ) { return append ( arg0, arg1, 0, arg1. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Builder appendFixedWidthPadRight ( int arg0, String arg1 ) { return append ( arg0, arg1, 0, arg1. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuilder appendFixedWidthPadRight ( int arg0, String arg1 ) { return appendFixedWidthString ( arg0, arg1, 0, arg1. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Builder appendFixedWidthPadRight ( String arg0, int arg1, int arg2 ) { return append ( arg0, arg1, arg2, \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public StringBuilder appendFixedWidthPadRight ( int arg0, String arg1 ) { return appendFixedWidthString ( arg0, arg1, 0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_51_/src/java/org/apache/commons/lang/BooleanUtils.java_682-683": {
      "loc": "682-683",
      "input": "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) == 's');\n            }\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n            }\n        }\n    }\n    return false;\n}",
      "target": "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) == 's');\n            }\n            return false;\n        }\n        case 4: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n            }\n            if (ch == 'T') {\n                return \n                    (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                    (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                    (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n            }\n        }\n    }\n    return false;\n}",
      "function range": "649,5-700,5",
      "raw_output": [
        "Boolean function ( Object arg0 ) { if ( arg0 == null ) return null ; if ( arg0 instanceof Boolean ) return ( ( Boolean ) arg0 ). booleanValue ( ) ; return ( ( Boolean ) arg0 ). booleanValue ( ) ; }",
        "Boolean function ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( ( Boolean ) arg0 ). booleanValue ( ) ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return null ; } }",
        "Boolean function ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return null ; } }",
        "Boolean function ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( ( Boolean ) arg0 ). booleanValue ( ) ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return false ; } }",
        "Boolean function ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return false ; } }",
        "T function ( T arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0 ; }",
        "T function ( T arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return arg0 ; }",
        "T function ( T arg0 ) { return arg0 ; }",
        "R function ( T arg0 ) { R loc0 = null ; if ( arg0!= null ) { loc0 = arg0. toString ( ) ; } return loc0 ; }",
        "T function ( T arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } return arg0 ; }",
        "Boolean function ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return null ; } }",
        "Boolean function ( Object arg0 ) { if ( arg0 == null ) return null ; if ( arg0 instanceof Boolean ) return ( Boolean ) arg0 ; if ( arg0 instanceof String ) return Boolean. valueOf ( ( String ) arg0 ) ; else return null ; }",
        "Boolean function ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return null ; } }",
        "Boolean function ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else if ( arg0 instanceof Number ) { Number loc0 = ( Number ) arg0 ; return loc0. booleanValue ( ) ; } else { return null ; } }",
        "Boolean function ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } return null ; }",
        "T function ( T arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0 ; }",
        "T function ( T arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return arg0 ; }",
        "T function ( T arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } return arg0 ; }",
        "Boolean function ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else { return Boolean. valueOf ( arg0. toString ( ) ) ; } }",
        "Boolean function ( T arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else { return Boolean. valueOf ( arg0. toString ( ) ) ; } }",
        "Boolean function ( String arg0 ) { if ( arg0 == null ) return null ; return new Boolean ( arg0 ) ; }",
        "Boolean function ( String arg0 ) { if ( arg0 == null ) return null ; return Boolean. valueOf ( arg0 ) ; }",
        "Object function ( String arg0 ) { if ( arg0 == null ) return null ; return Boolean. valueOf ( arg0 ) ; }",
        "Boolean function ( String arg0 ) { if ( arg0 == null ) return null ; if ( \"srini_string\". equals ( arg0 ) ) return true ; return false ; }",
        "Boolean function ( String arg0 ) { if ( arg0 == null ) return null ; return Boolean. parseBoolean ( arg0 ) ; }"
      ],
      "mid_translation": [
        "toBoolean Method.",
        "To boolean.",
        "ToBoolean Method.",
        "To Boolean.",
        "toBoolean This method converts a String to a Boolean."
      ],
      "output": [
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 == null ) return null ; if ( arg0 instanceof Boolean ) return ( ( Boolean ) arg0 ). booleanValue ( ) ; return ( ( Boolean ) arg0 ). booleanValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( ( Boolean ) arg0 ). booleanValue ( ) ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return null ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( ( Boolean ) arg0 ). booleanValue ( ) ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T toBoolean ( T arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T toBoolean ( T arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T toBoolean ( T arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static R toBoolean ( T arg0 ) { R loc0 = null ; if ( arg0!= null ) { loc0 = arg0. toString ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T toBoolean ( T arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return null ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 == null ) return null ; if ( arg0 instanceof Boolean ) return ( Boolean ) arg0 ; if ( arg0 instanceof String ) return Boolean. valueOf ( ( String ) arg0 ) ; else return null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } else { return null ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else if ( arg0 instanceof Number ) { Number loc0 = ( Number ) arg0 ; return loc0. booleanValue ( ) ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } if ( arg0 instanceof String ) { return Boolean. valueOf ( ( String ) arg0 ) ; } return null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static T toBoolean ( T arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T toBoolean ( T arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T toBoolean ( T arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Boolean toBoolean ( Object arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else { return Boolean. valueOf ( arg0. toString ( ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Boolean toBoolean ( T arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0 instanceof Boolean ) { return ( Boolean ) arg0 ; } else { return Boolean. valueOf ( arg0. toString ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Boolean toBoolean ( String arg0 ) { if ( arg0 == null ) return null ; return new Boolean ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Boolean toBoolean ( String arg0 ) { if ( arg0 == null ) return null ; return Boolean. valueOf ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Object toBoolean ( String arg0 ) { if ( arg0 == null ) return null ; return Boolean. valueOf ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Boolean toBoolean ( String arg0 ) { if ( arg0 == null ) return null ; if ( \"srini_string\". equals ( arg0 ) ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Boolean toBoolean ( String arg0 ) { if ( arg0 == null ) return null ; return Boolean. parseBoolean ( arg0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Jsoup_51_/src/main/java/org/jsoup/parser/CharacterReader.java_300-301": {
      "loc": "300-301",
      "input": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
      "target": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n}",
      "function range": "296,5-301,5",
      "raw_output": [
        "boolean function ( String arg0 ) { return arg0!= null && arg0. charAt ( 0 ) == '_' ; }",
        "boolean function ( String arg0 ) { return arg0. toLowerCase ( ). indexOf ( \"srini_string\" ) >= 0 ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '_' ; }",
        "boolean function ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. toLowerCase ( ). startsWith ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '_' ; }",
        "boolean function ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0!= null && arg0. charAt ( 0 ) == '_' ; }",
        "boolean function ( String arg0 ) { return arg0. toLowerCase ( ). startsWith ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. indexOf ( \"srini_string\" ) >= 0 ; }",
        "boolean function ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'f' ) ; }",
        "boolean function ( String arg0 ) { int loc0 ; for ( loc0 = 1 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( Character. isLetter ( arg0. charAt ( loc0 ) ) ) { return true ; } } return false ; }",
        "boolean function ( String arg0 ) { int loc0 ; for ( loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( Character. isLetter ( arg0. charAt ( loc0 ) ) ) { return true ; } } return false ; }",
        "boolean function ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) ; }",
        "boolean function ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) ; }",
        "boolean function ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'f' ) ; }",
        "boolean function ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) ; }",
        "boolean function ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) ; }",
        "boolean function ( int arg0 ) { char loc0 = ( char ) ( arg0 + 1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'f' ) ; }",
        "boolean function ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) ; }",
        "boolean function ( String arg0 ) { return arg0!= null && arg0. charAt ( 0 ) == '_' ; }",
        "boolean function ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '_' ; }",
        "boolean function ( String arg0 ) { return arg0. toLowerCase ( ). startsWith ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. toLowerCase ( ). indexOf ( \"srini_string\" ) >= 0 ; }"
      ],
      "mid_translation": [
        "Checks if input starts with a letter.",
        "Returns true if input starts with a letter.",
        "Checks if the current position is in the sequence of letters.",
        "Returns true if the current position is in the sequence of letters.",
        "Returns true if input starts with a letter"
      ],
      "output": [
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0!= null && arg0. charAt ( 0 ) == '_' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. toLowerCase ( ). indexOf ( \"srini_string\" ) >= 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. charAt ( 0 ) == '_' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. toLowerCase ( ). startsWith ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. charAt ( 0 ) == '_' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0!= null && arg0. charAt ( 0 ) == '_' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. toLowerCase ( ). startsWith ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. indexOf ( \"srini_string\" ) >= 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'f' ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { int loc0 ; for ( loc0 = 1 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( Character. isLetter ( arg0. charAt ( loc0 ) ) ) { return true ; } } return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { int loc0 ; for ( loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( Character. isLetter ( arg0. charAt ( loc0 ) ) ) { return true ; } } return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'f' ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( int arg0 ) { char loc0 = ( char ) ( arg0 + 1 ) ; return ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'f' ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0, int arg1 ) { char loc0 = arg0. charAt ( arg1 ) ; return ( loc0 >= 'A' && loc0 <= 'Z' ) || ( loc0 >= 'a' && loc0 <= 'z' ) || ( loc0 >= 'A' && loc0 <= 'Z' ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0!= null && arg0. charAt ( 0 ) == '_' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. startsWith ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. charAt ( 0 ) == '_' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. toLowerCase ( ). startsWith ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean matchesLetter ( String arg0 ) { return arg0. toLowerCase ( ). indexOf ( \"srini_string\" ) >= 0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Lang_6_/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java_95-96": {
      "loc": "95-96",
      "input": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos += Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}",
      "target": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos += Character.charCount(Character.codePointAt(input, pt));\n        }\n    }\n}",
      "function range": "75,5-98,5",
      "raw_output": [
        "Writer function ( CharSequence arg0 ) { StringWriter loc0 = new StringWriter ( ) ; char [ ] loc1 = new char [ arg0. length ( ) ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) loc0. append ( loc1 [ loc2 ] ) ; return loc0 ; }",
        "Writer function ( CharSequence arg0 ) { StringWriter loc0 = new StringWriter ( ) ; char [ ] loc1 = arg0. toCharArray ( ) ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc0. append ( loc1 [ loc2 ] ) ; } return loc0 ; }",
        "Writer function ( CharSequence arg0 ) { StringWriter loc0 = new StringWriter ( ) ; char [ ] loc1 = arg0. toCharArray ( ) ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) loc0. append ( loc1 [ loc2 ] ) ; return loc0 ; }",
        "Writer function ( CharSequence arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
        "Writer function ( CharSequence arg0 ) { Writer loc0 = new StringWriter ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
        "String function ( String arg0, String arg1 ) { char [ ] loc0 = new char [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 [ loc1 ] = arg0. charAt ( loc1 ) ; } return new String ( loc0 ) ; }",
        "char [ ] function ( char [ ] arg0, char [ ] arg1 ) { char [ ] loc0 = new char [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "String function ( String arg0, String arg1 ) { char [ ] loc0 = new char [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 [ loc1 ] = arg0. charAt ( loc1 ) ; } return translator ( loc0 ) ; }",
        "String function ( char arg0 [ ], char arg1 [ ] ) { StringBuffer loc0 = new StringBuffer ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. append ( arg0 [ loc1 ] ) ; } return loc0. toString ( ) ; }",
        "char [ ] function ( char [ ] arg0, char [ ] arg1 ) { int loc0 = arg0. length ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0 [ loc2 ] ; } return loc1 ; }",
        "CharSequence function ( final CharSequence arg0 ) { try { return translate ( arg0, UTF_8. name ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\" ) ; } }",
        "CharSequence function ( final CharSequence arg0 ) { try { return translate ( arg0, UTF_8. name ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
        "CharSequence function ( final CharSequence arg0 ) { if ( arg0 == null ) { return null ; } try { return translate ( arg0. toString ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
        "CharSequence function ( final CharSequence arg0 ) { try { return translate ( arg0, UTF_8. toString ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\" ) ; } }",
        "CharSequence function ( final CharSequence arg0 ) { if ( arg0 == null ) { return null ; } try { return translate ( arg0, UTF_8. name ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
        "CharSequence function ( final CharSequence arg0 ) { return translate ( arg0, 0, arg0. length ( ) ) ; }",
        "CharSequence function ( final CharSequence arg0 ) { return translates ( arg0, 0, arg0. length ( ) ) ; }",
        "CharSequence function ( final CharSequence arg0, final int arg1, final int arg2 ) { return translates ( arg0, ( char [ ] ) null, arg1, arg2 ) ; }",
        "CharSequence function ( final CharSequence arg0, final int arg1, final int arg2 ) { return translate ( arg0, ( char [ ] ) null, arg1, arg2 ) ; }",
        "CharSequence function ( final CharSequence arg0, final int arg1, final int arg2 ) { return translate ( arg0. toString ( ), arg1, arg2 ) ; }",
        "byte [ ] function ( char arg0 ) { byte [ ] loc0 = new byte [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) ( arg0. charAt ( loc1 ) ) ; } return loc0 ; }",
        "byte [ ] function ( char arg0 ) { byte [ ] loc0 = new byte [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) arg0. charAt ( loc1 ) ; } return loc0 ; }",
        "byte [ ] function ( char arg0 ) { byte [ ] loc0 = new byte [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { int loc2 = ( arg0. charAt ( loc1 ) & 0xFF ) ; loc0 [ loc1 ] = ( byte ) ( ( loc2 >> 8 ) & 0xFF ) ; loc0 [ loc1 ] = ( byte ) loc2 ; } return loc0 ; }",
        "byte [ ] function ( char [ ] arg0, int arg1 ) { int loc0 = arg0. length ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = ( arg0 [ loc2 ] & 0xFF ) ; loc1 [ loc2 ++ ] = ( byte ) ( ( loc3 >> 8 ) & 0xFF ) ; loc1 [ loc2 ++ ] = ( byte ) loc3 ; } return loc1 ; }",
        "byte [ ] function ( char arg0 ) { byte [ ] loc0 = new byte [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { int loc2 = ( arg0. charAt ( loc1 ) & 0xFF ) ; loc0 [ loc1 ] = ( byte ) ( ( loc2 >> 8 ) & 0xFF ) ; loc0 [ loc1 ] = ( byte ) ( loc2 & 0xFF ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Translate a CharSequence to a Writer.",
        "This method translates the input char sequence into the output char sequence.",
        "This method translates a CharSequence into a Sequence of UTF - 8 characters.",
        "This method translates a CharSequence into a Sequence of Unicode code points.",
        "This method translates the input char sequence into an array of bytes."
      ],
      "output": [
        {
          "patch": "public final Writer translate ( CharSequence arg0 ) { StringWriter loc0 = new StringWriter ( ) ; char [ ] loc1 = new char [ arg0. length ( ) ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) loc0. append ( loc1 [ loc2 ] ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final Writer translate ( CharSequence arg0 ) { StringWriter loc0 = new StringWriter ( ) ; char [ ] loc1 = arg0. toCharArray ( ) ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc0. append ( loc1 [ loc2 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final Writer translate ( CharSequence arg0 ) { StringWriter loc0 = new StringWriter ( ) ; char [ ] loc1 = arg0. toCharArray ( ) ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) loc0. append ( loc1 [ loc2 ] ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final Writer translate ( CharSequence arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final Writer translate ( CharSequence arg0 ) { Writer loc0 = new StringWriter ( ) ; loc0. append ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final String translate ( String arg0, String arg1 ) { char [ ] loc0 = new char [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 [ loc1 ] = arg0. charAt ( loc1 ) ; } return new String ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final char [ ] translate ( char [ ] arg0, char [ ] arg1 ) { char [ ] loc0 = new char [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final String translate ( String arg0, String arg1 ) { char [ ] loc0 = new char [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 [ loc1 ] = arg0. charAt ( loc1 ) ; } return translator ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final String translate ( char arg0 [ ], char arg1 [ ] ) { StringBuffer loc0 = new StringBuffer ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. append ( arg0 [ loc1 ] ) ; } return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final char [ ] translate ( char [ ] arg0, char [ ] arg1 ) { int loc0 = arg0. length ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0 [ loc2 ] ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0 ) { try { return translate ( arg0, UTF_8. name ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0 ) { try { return translate ( arg0, UTF_8. name ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0 ) { if ( arg0 == null ) { return null ; } try { return translate ( arg0. toString ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0 ) { try { return translate ( arg0, UTF_8. toString ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0 ) { if ( arg0 == null ) { return null ; } try { return translate ( arg0, UTF_8. name ( ) ) ; } catch ( UnsupportedEncodingException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0 ) { return translate ( arg0, 0, arg0. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0 ) { return translates ( arg0, 0, arg0. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0, final int arg1, final int arg2 ) { return translates ( arg0, ( char [ ] ) null, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0, final int arg1, final int arg2 ) { return translate ( arg0, ( char [ ] ) null, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final CharSequence translate ( final CharSequence arg0, final int arg1, final int arg2 ) { return translate ( arg0. toString ( ), arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final byte [ ] translate ( char arg0 ) { byte [ ] loc0 = new byte [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) ( arg0. charAt ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final byte [ ] translate ( char arg0 ) { byte [ ] loc0 = new byte [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 [ loc1 ] = ( byte ) arg0. charAt ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final byte [ ] translate ( char arg0 ) { byte [ ] loc0 = new byte [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { int loc2 = ( arg0. charAt ( loc1 ) & 0xFF ) ; loc0 [ loc1 ] = ( byte ) ( ( loc2 >> 8 ) & 0xFF ) ; loc0 [ loc1 ] = ( byte ) loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final byte [ ] translate ( char [ ] arg0, int arg1 ) { int loc0 = arg0. length ; byte [ ] loc1 = new byte [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = ( arg0 [ loc2 ] & 0xFF ) ; loc1 [ loc2 ++ ] = ( byte ) ( ( loc3 >> 8 ) & 0xFF ) ; loc1 [ loc2 ++ ] = ( byte ) loc3 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final byte [ ] translate ( char arg0 ) { byte [ ] loc0 = new byte [ arg0. length ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { int loc2 = ( arg0. charAt ( loc1 ) & 0xFF ) ; loc0 [ loc1 ] = ( byte ) ( ( loc2 >> 8 ) & 0xFF ) ; loc0 [ loc1 ] = ( byte ) ( loc2 & 0xFF ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_40_/src/java/org/apache/commons/lang/StringUtils.java_1048-1049": {
      "loc": "1048-1049",
      "input": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return contains(str.toUpperCase(), searchStr.toUpperCase());\n}",
      "target": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    int len = searchStr.length();\n    int max = str.length() - len;\n    for (int i = 0; i <= max; i++) {\n        if (str.regionMatches(true, i, searchStr, 0, len)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "function range": "1044,5-1049,5",
      "raw_output": [
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
        "boolean function ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) return true ; return false ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } else { return false ; } }",
        "boolean function ( String arg0, String arg1 ) { int loc0 = arg0. indexOf ( arg1 ) ; return ( loc0 == - 1 )? false : true ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
        "boolean function ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { int loc0 = arg0. indexOf ( arg1 ) ; return ( loc0 == - 1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } int loc0 = arg0. indexOf ( arg1 ) ; if ( loc0 == - 1 ) { return false ; } return true ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. equalsIgnoreCase ( arg1 ) ) { return true ; } return false ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
        "boolean function ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) return true ; return false ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } else { return false ; } }",
        "boolean function ( String arg0, String arg1 ) { return arg1. contains ( arg0. toLowerCase ( Locale. ENGLISH ) ) ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) return true ; return false ; }",
        "boolean function ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { int loc0 = arg0. indexOf ( arg1 ) ; return ( loc0 == - 1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { int loc0 = 0 ; int loc1 = arg0. indexOf ( arg1 ) ; return ( loc0!= - 1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) return true ; return false ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
        "boolean function ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { if ( arg0. contains ( searchStr ( arg1 ) ) ) return true ; return false ; }",
        "boolean function ( String arg0, String arg1 ) { int loc0 = arg0. indexOf ( arg1 ) ; return ( loc0 == - 1 ) ; }"
      ],
      "mid_translation": [
        "Checks if str contains searchStr ignoring case.",
        "Returns true if str contains searchStr ignoring case.",
        "Check if str contains searchStr ignoring case.",
        "Checks if str contains searchStr ignoring case",
        "Check if str contains searchStr ignoring case"
      ],
      "output": [
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) return true ; return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } else { return false ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { int loc0 = arg0. indexOf ( arg1 ) ; return ( loc0 == - 1 )? false : true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { int loc0 = arg0. indexOf ( arg1 ) ; return ( loc0 == - 1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } int loc0 = arg0. indexOf ( arg1 ) ; if ( loc0 == - 1 ) { return false ; } return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. equalsIgnoreCase ( arg1 ) ) { return true ; } return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) return true ; return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } else { return false ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { return arg1. contains ( arg0. toLowerCase ( Locale. ENGLISH ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) return true ; return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { int loc0 = arg0. indexOf ( arg1 ) ; return ( loc0 == - 1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { int loc0 = 0 ; int loc1 = arg0. indexOf ( arg1 ) ; return ( loc0!= - 1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) return true ; return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( arg1 ) ) { return true ; } return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { return arg0. contains ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { if ( arg0. contains ( searchStr ( arg1 ) ) ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean containsIgnoreCase ( String arg0, String arg1 ) { int loc0 = arg0. indexOf ( arg1 ) ; return ( loc0 == - 1 ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Jsoup_68_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_468-469": {
      "loc": "468-469",
      "input": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n    int bottom = stack.size() -1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n    for (int pos = bottom; pos >= top; pos--) {\n        final String elName = stack.get(pos).nodeName();\n        if (inSorted(elName, targetNames))\n            return true;\n        if (inSorted(elName, baseTypes))\n            return false;\n        if (extraTypes != null && inSorted(elName, extraTypes))\n            return false;\n    }\n    return false;\n}",
      "target": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n    final int bottom = stack.size() -1;\n    final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n    for (int pos = bottom; pos >= top; pos--) {\n        final String elName = stack.get(pos).nodeName();\n        if (inSorted(elName, targetNames))\n            return true;\n        if (inSorted(elName, baseTypes))\n            return false;\n        if (extraTypes != null && inSorted(elName, extraTypes))\n            return false;\n    }\n    return false;\n}",
      "function range": "466,5-486,5",
      "raw_output": [
        "boolean function ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } } return false ; }",
        "boolean function ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) return true ; loc0 = arg0. getParent ( ) ; } return false ; }",
        "boolean function ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) return true ; loc0 = arg0. getSuperclass ( ) ; } return false ; }",
        "boolean function ( Class arg0, Scope arg1 ) { return arg0. getName ( ). equals ( arg1. getName ( ) ) ; }",
        "boolean function ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) return true ; loc0 = loc0. getParent ( ) ; } return false ; }",
        "boolean function ( Class arg0, Scope arg1 ) { return arg0. getName ( ). equals ( arg1. getClassName ( ) ) ; }",
        "boolean function ( Class arg0, Scope arg1 ) { return arg0. getName ( ). equals ( arg1. getName ( ) ) ; }",
        "boolean function ( Class arg0, Scope arg1 ) { if ( arg0 == null ) { return false ; } Scope loc0 = arg0. getScope ( ) ; return ( loc0 == null || loc0. equals ( arg1 ) ) ; }",
        "boolean function ( Class arg0, Scope arg1 ) { if ( arg0 == null ) { return false ; } Scope loc0 = arg0. getScope ( ) ; while ( loc0!= null ) { if ( arg1. equals ( loc0 ) ) { return true ; } } return false ; }",
        "boolean function ( Class arg0, Scope arg1 ) { if ( arg0 == null ) { return false ; } Scope loc0 = arg1. getScopeForType ( arg0 ) ; return loc0!= null && arg1. equals ( loc0 ) ; }",
        "boolean function ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } loc0 = loc0. getParent ( ) ; } return false ; }",
        "boolean function ( Class arg0, int arg1 ) { Scope loc0 = Scope. getScopeInstance ( ) ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } } return false ; }",
        "boolean function ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } loc0 = arg0. getSuperclass ( ) ; } return false ; }",
        "boolean function ( Class arg0, int arg1 ) { Scope loc0 = Scope. getScopeInstance ( ) ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) return true ; loc0 = loc0. getParent ( ) ; } return false ; }",
        "boolean function ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } } return false ; }",
        "boolean function ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) ) { return true ; } return false ; }",
        "boolean function ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) || arg1. getName ( ). equals ( \"srini_string\" ) ) { return true ; } return false ; }",
        "boolean function ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) ) { return true ; } return false ; }",
        "boolean function ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) ) { return true ; } if ( arg1 == null ) { return false ; } return false ; }",
        "boolean function ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) || arg1. equals ( \"srini_string\" ) ) { return true ; } return false ; }",
        "void function ( Class <? > arg0, String arg1 ) { }",
        "void function ( String arg0, Map < String, Object > arg1 ) { }",
        "void function ( Class <? > arg0, String arg1, Map arg2 ) { }",
        "String function ( ) { return \"srini_string\" ; }",
        "void function ( Context arg0, Class <? > arg1, String arg2 ) { }"
      ],
      "mid_translation": [
        "Check if a class is in a specific scope.",
        "Checks if a class is in a specific scope.",
        "Checks to see if a class is in a specific scope.",
        "Checks if a class or method is in a specific scope.",
        "In specific scope."
      ],
      "output": [
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) return true ; loc0 = arg0. getParent ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) return true ; loc0 = arg0. getSuperclass ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { return arg0. getName ( ). equals ( arg1. getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) return true ; loc0 = loc0. getParent ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { return arg0. getName ( ). equals ( arg1. getClassName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { return arg0. getName ( ). equals ( arg1. getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { if ( arg0 == null ) { return false ; } Scope loc0 = arg0. getScope ( ) ; return ( loc0 == null || loc0. equals ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { if ( arg0 == null ) { return false ; } Scope loc0 = arg0. getScope ( ) ; while ( loc0!= null ) { if ( arg1. equals ( loc0 ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { if ( arg0 == null ) { return false ; } Scope loc0 = arg1. getScopeForType ( arg0 ) ; return loc0!= null && arg1. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } loc0 = loc0. getParent ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, int arg1 ) { Scope loc0 = Scope. getScopeInstance ( ) ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } loc0 = arg0. getSuperclass ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, int arg1 ) { Scope loc0 = Scope. getScopeInstance ( ) ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) return true ; loc0 = loc0. getParent ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class arg0, Scope arg1 ) { Scope loc0 = arg1 ; while ( loc0!= null ) { if ( arg0. getName ( ). equals ( loc0. getName ( ) ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) || arg1. getName ( ). equals ( \"srini_string\" ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) ) { return true ; } if ( arg1 == null ) { return false ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean inSpecificScope ( Class <? > arg0, Class <? > arg1, Scope arg2 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0. getName ( ). equals ( \"srini_string\" ) || arg0. getName ( ). equals ( \"srini_string\" ) || arg1. equals ( \"srini_string\" ) ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inSpecificScope ( Class <? > arg0, String arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inSpecificScope ( String arg0, Map < String, Object > arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inSpecificScope ( Class <? > arg0, String arg1, Map arg2 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String inSpecificScope ( ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void inSpecificScope ( Context arg0, Class <? > arg1, String arg2 ) { }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JxPath_10_/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java_42-43": {
      "loc": "42-43",
      "input": "public final Object computeValue(EvalContext context) {\n    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n            ? Boolean.TRUE : Boolean.FALSE;\n}",
      "target": "public final Object computeValue(EvalContext context) {\n    return compute(args[0].compute(context), args[1].compute(context))\n            ? Boolean.TRUE : Boolean.FALSE;\n}",
      "function range": "41,5-44,5",
      "raw_output": [
        "double function ( final double arg0, final double arg1 ) { return arg0 + ( arg1 - arg0 ) ; }",
        "double function ( final double arg0 ) { return arg0 / ( 1 + Math. exp ( - arg0 ) ) ; }",
        "double function ( final double arg0 ) { return arg0 * Math. sin ( 1 ) ; }",
        "double function ( final double arg0, final double arg1 ) { return arg0 + arg1 ; }",
        "double function ( double arg0, double arg1 ) { return arg0 + ( arg1 - arg0 ) ; }",
        "double function ( double arg0 ) { return arg0 ; }",
        "double function ( double arg0 ) { if ( arg0 == 0.0 ) { return 1.0 ; } else { return arg0 ; } }",
        "double function ( double arg0 ) { double loc0 = arg0 ; return loc0 == 0.0? 0.0 : loc0 ; }",
        "double function ( double arg0 ) { double loc0 = arg0 ; return loc0 == 0.0? 1.0 : loc0 ; }",
        "long function ( FunctionCallExpression arg0 ) { return arg0. getValue ( ) ; }",
        "double function ( final double arg0, final double arg1 ) { return arg0 + arg1 ; }",
        "double function ( final double arg0, final double arg1 ) { return arg0 + ( arg1 - arg0 ) ; }",
        "double function ( final double arg0, final double arg1 ) { return arg0 * arg1 ; }",
        "double function ( final double arg0 ) { return arg0 ; }",
        "double function ( final double arg0 ) { return arg0 * Math. sin ( 1 ) ; }",
        "double function ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { loc0 = 1.0 ; } else { loc0 *= arg0 ; } return loc0 ; }",
        "double function ( final double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { loc0 = 1.0 ; } else { loc0 *= arg0 ; } return loc0 ; }",
        "double function ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { loc0 = 1.0 ; } else { loc0 = 2.0 ; } return loc0 ; }",
        "double function ( final double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg0 ; } }",
        "double function ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { loc0 = 1.0 ; } else if ( loc0 > 1.0 ) { loc0 = 2.0 ; } return loc0 ; }",
        "double function ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 < 1.0 ) { return 1.0 ; } else if ( arg0 == 2.0 ) { return 2.0 ; } else { return arg0 ; } }",
        "double function ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { return 0.0 ; } else if ( loc0 < 1.0 ) { return 1.0 ; } else { return loc0 ; } }",
        "double function ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 < 1.0 ) { return 1.0 ; } else { return arg0 ; } }",
        "double function ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 == 1.0 ) { return 1.0 ; } else if ( arg0 == 2.0 ) { return 2.0 ; } else { return arg0 ; } }",
        "double function ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { return 0.0 ; } else if ( loc0 == 1.0 ) { return 1.0 ; } else { return loc0 ; } }"
      ],
      "mid_translation": [
        "Compute the value.",
        "Compute the value of the expression.",
        "Compute value.",
        "Compute the value of the formula.",
        "Computes the value of the expression."
      ],
      "output": [
        {
          "patch": "public final double computeValue ( final double arg0, final double arg1 ) { return arg0 + ( arg1 - arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( final double arg0 ) { return arg0 / ( 1 + Math. exp ( - arg0 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( final double arg0 ) { return arg0 * Math. sin ( 1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( final double arg0, final double arg1 ) { return arg0 + arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0, double arg1 ) { return arg0 + ( arg1 - arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { return arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { if ( arg0 == 0.0 ) { return 1.0 ; } else { return arg0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { double loc0 = arg0 ; return loc0 == 0.0? 0.0 : loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { double loc0 = arg0 ; return loc0 == 0.0? 1.0 : loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final long computeValue ( FunctionCallExpression arg0 ) { return arg0. getValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public final double computeValue ( final double arg0, final double arg1 ) { return arg0 + arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( final double arg0, final double arg1 ) { return arg0 + ( arg1 - arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( final double arg0, final double arg1 ) { return arg0 * arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( final double arg0 ) { return arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( final double arg0 ) { return arg0 * Math. sin ( 1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { loc0 = 1.0 ; } else { loc0 *= arg0 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( final double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { loc0 = 1.0 ; } else { loc0 *= arg0 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { loc0 = 1.0 ; } else { loc0 = 2.0 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( final double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { loc0 = 1.0 ; } else if ( loc0 > 1.0 ) { loc0 = 2.0 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 < 1.0 ) { return 1.0 ; } else if ( arg0 == 2.0 ) { return 2.0 ; } else { return arg0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { return 0.0 ; } else if ( loc0 < 1.0 ) { return 1.0 ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 < 1.0 ) { return 1.0 ; } else { return arg0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 == 1.0 ) { return 1.0 ; } else if ( arg0 == 2.0 ) { return 2.0 ; } else { return arg0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public final double computeValue ( double arg0 ) { double loc0 = arg0 ; if ( loc0 == 0.0 ) { return 0.0 ; } else if ( loc0 == 1.0 ) { return 1.0 ; } else { return loc0 ; } }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_32_/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java_136-137": {
      "loc": "136-137",
      "input": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if ((Boolean) tree.getAttribute()) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(0);\n            setBarycenter(new Vector2D(0, 0));\n        }\n    } else if (v[0][0] == null) {\n        setSize(Double.POSITIVE_INFINITY);\n        setBarycenter(Vector2D.NaN);\n    } else {\n        double sum  = 0;\n        double sumX = 0;\n        double sumY = 0;\n        for (Vector2D[] loop : v) {\n            double x1 = loop[loop.length - 1].getX();\n            double y1 = loop[loop.length - 1].getY();\n            for (final Vector2D point : loop) {\n                final double x0 = x1;\n                final double y0 = y1;\n                x1 = point.getX();\n                y1 = point.getY();\n                final double factor = x0 * y1 - y0 * x1;\n                sum  += factor;\n                sumX += factor * (x0 + x1);\n                sumY += factor * (y0 + y1);\n            }\n        }\n        if (sum < 0) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(sum / 2);\n            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n        }\n    }\n}",
      "target": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n        if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(0);\n            setBarycenter(new Vector2D(0, 0));\n        }\n    } else if (v[0][0] == null) {\n        setSize(Double.POSITIVE_INFINITY);\n        setBarycenter(Vector2D.NaN);\n    } else {\n        double sum  = 0;\n        double sumX = 0;\n        double sumY = 0;\n        for (Vector2D[] loop : v) {\n            double x1 = loop[loop.length - 1].getX();\n            double y1 = loop[loop.length - 1].getY();\n            for (final Vector2D point : loop) {\n                final double x0 = x1;\n                final double y0 = y1;\n                x1 = point.getX();\n                y1 = point.getY();\n                final double factor = x0 * y1 - y0 * x1;\n                sum  += factor;\n                sumX += factor * (x0 + x1);\n                sumY += factor * (y0 + y1);\n            }\n        }\n        if (sum < 0) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(sum / 2);\n            setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n        }\n    }\n}",
      "function range": "129,5-181,5",
      "raw_output": [
        "GeometricalProperties function ( Geometry arg0 ) { geometricalPropertiesCalculator loc0 = new geometricalPropertiesCalculator ( ) ; return loc0. compute ( arg0 ) ; }",
        "GeometricalProperties function ( Geometry arg0 ) { geometricalPropertiesCalculator loc0 = new geometricalPropertiesCalculator ( arg0 ) ; return loc0. compute ( ) ; }",
        "Geometry function ( Geometry arg0 ) { GeometryBuilder loc0 = GeometryBuilder. newInstance ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
        "GeometricalProperties function ( Geometry arg0 ) { geometricalPropertiesCalculator loc0 = new geometricalPropertiesCalculator ( arg0 ) ; return loc0. getGeoProperties ( ) ; }",
        "Geometry function ( Geometry arg0 ) { GeometryFactory loc0 = GeometryFactory. newInstance ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
        "Geometry function ( Geometry arg0 ) { GeometryBuilder loc0 = GeometryBuilder. newInstance ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
        "Geometry function ( Geometry arg0 ) { GeometryBuilder loc0 = new GeometryBuilder ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. toGeometricalProperties ( ) ; }",
        "Geometry function ( Geometry arg0 ) { GeometryBuilder loc0 = new GeometryBuilder ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
        "Geometry function ( Geometry arg0 ) { GeometryUtils. computeGeometricalProperties ( arg0 ) ; return arg0 ; }",
        "Geometry function ( Geometry arg0 ) { GeometryFactory loc0 = GeometryFactory. newInstance ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
        "GeometricalProperties function ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4, final double arg5, final double arg6 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3, arg4, arg5, arg6 ) ; }",
        "GeometricalProperties function ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3, arg4 ) ; }",
        "GeometricalProperties function ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4, final double arg5 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3, arg4, arg5 ) ; }",
        "GeometricalProperties function ( final double arg0, final double arg1, final double arg2, final double arg3 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3 ) ; }",
        "Geometrical function ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4 ) { return new Geometrical ( arg0, arg1, arg2, arg3, arg4 ) ; }",
        "GeometryetricalProperties function ( Geometry arg0 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( arg0 ) ; return loc0 ; }",
        "GeometryetricalProperties function ( Geometry arg0 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getCoordinateSequence ( ). size ( ) ; loc1 ++ ) { loc0. set ( loc1, arg0. getCoordinateSequence ( loc1 ). get ( loc1 ) ) ; } return loc0 ; }",
        "GeometryetricalProperties function ( Geometry arg0, double arg1 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getCoordinateSequence ( ). size ( ) ; loc1 ++ ) { loc0. set ( loc1, arg0. getCoordinateSequence ( loc1 ). get ( loc1 ) ) ; } return loc0 ; }",
        "GeometryetricalProperties function ( Geometry arg0 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( ) ; compute ( arg0, loc0 ) ; return loc0 ; }",
        "GeometryetricalProperties function ( Geometry arg0 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getCoordinateSequence ( ). size ( ) ; loc1 ++ ) { loc0. setProperty ( loc1, arg0. getCoordinateSequence ( loc1 ). get ( loc1 ) ) ; } return loc0 ; }",
        "GeometricalProperties function ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3, arg4 ) ; }",
        "GeometricalProperties function ( ) { return new GeometricalProperties ( ) ; }",
        "Geometrical function ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4 ) { return new Geometrical ( arg0, arg1, arg2, arg3, arg4 ) ; }",
        "GeometricalProperties function ( final double arg0, final double arg1 ) { final double loc0 = arg0 / arg1 ; return new GeometricalProperties ( loc0, arg1 ) ; }",
        "GeometricalProperties function ( double arg0, double arg1 ) { return new GeometricalProperties ( arg0, arg1 ) ; }"
      ],
      "mid_translation": [
        "Compute the geometrical properties.",
        "Compute geometrical properties.",
        "Compute Geometrical properties.",
        "Compute the geometryetrical properties.",
        "Compute the Geometrical properties."
      ],
      "output": [
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( Geometry arg0 ) { geometricalPropertiesCalculator loc0 = new geometricalPropertiesCalculator ( ) ; return loc0. compute ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( Geometry arg0 ) { geometricalPropertiesCalculator loc0 = new geometricalPropertiesCalculator ( arg0 ) ; return loc0. compute ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Geometry computeGeometricalProperties ( Geometry arg0 ) { GeometryBuilder loc0 = GeometryBuilder. newInstance ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( Geometry arg0 ) { geometricalPropertiesCalculator loc0 = new geometricalPropertiesCalculator ( arg0 ) ; return loc0. getGeoProperties ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Geometry computeGeometricalProperties ( Geometry arg0 ) { GeometryFactory loc0 = GeometryFactory. newInstance ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Geometry computeGeometricalProperties ( Geometry arg0 ) { GeometryBuilder loc0 = GeometryBuilder. newInstance ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Geometry computeGeometricalProperties ( Geometry arg0 ) { GeometryBuilder loc0 = new GeometryBuilder ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. toGeometricalProperties ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Geometry computeGeometricalProperties ( Geometry arg0 ) { GeometryBuilder loc0 = new GeometryBuilder ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Geometry computeGeometricalProperties ( Geometry arg0 ) { GeometryUtils. computeGeometricalProperties ( arg0 ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Geometry computeGeometricalProperties ( Geometry arg0 ) { GeometryFactory loc0 = GeometryFactory. newInstance ( ) ; geometricalProperties ( arg0, loc0 ) ; return loc0. create ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4, final double arg5, final double arg6 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3, arg4, arg5, arg6 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3, arg4 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4, final double arg5 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3, arg4, arg5 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( final double arg0, final double arg1, final double arg2, final double arg3 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Geometrical computeGeometricalProperties ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4 ) { return new Geometrical ( arg0, arg1, arg2, arg3, arg4 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometryetricalProperties computeGeometricalProperties ( Geometry arg0 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometryetricalProperties computeGeometricalProperties ( Geometry arg0 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getCoordinateSequence ( ). size ( ) ; loc1 ++ ) { loc0. set ( loc1, arg0. getCoordinateSequence ( loc1 ). get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometryetricalProperties computeGeometricalProperties ( Geometry arg0, double arg1 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getCoordinateSequence ( ). size ( ) ; loc1 ++ ) { loc0. set ( loc1, arg0. getCoordinateSequence ( loc1 ). get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometryetricalProperties computeGeometricalProperties ( Geometry arg0 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( ) ; compute ( arg0, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometryetricalProperties computeGeometricalProperties ( Geometry arg0 ) { GeometryetricalProperties loc0 = new GeometryetricalProperties ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getCoordinateSequence ( ). size ( ) ; loc1 ++ ) { loc0. setProperty ( loc1, arg0. getCoordinateSequence ( loc1 ). get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4 ) { return new GeometricalProperties ( arg0, arg1, arg2, arg3, arg4 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( ) { return new GeometricalProperties ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected Geometrical computeGeometricalProperties ( final double arg0, final double arg1, final double arg2, final double arg3, final double arg4 ) { return new Geometrical ( arg0, arg1, arg2, arg3, arg4 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( final double arg0, final double arg1 ) { final double loc0 = arg0 / arg1 ; return new GeometricalProperties ( loc0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\nprotected GeometricalProperties computeGeometricalProperties ( double arg0, double arg1 ) { return new GeometricalProperties ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_20_/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java_921-922": {
      "loc": "921-922",
      "input": "public double[] repairAndDecode(final double[] x) {\n    return\n        decode(x);\n}",
      "target": "public double[] repairAndDecode(final double[] x) {\n    return boundaries != null && isRepairMode ?\n        decode(repair(x)) :\n        decode(x);\n}",
      "function range": "920,9-923,9",
      "raw_output": [
        "List < byte [ ] > function ( byte [ ] arg0, boolean arg1 ) { List < byte [ ] > loc0 = RepairAndDecode ( arg0, arg1 ) ; List < byte [ ] > loc1 = RepairAndDecode ( loc0 ) ; return loc1 ; }",
        "List < byte [ ] > function ( byte [ ] arg0, boolean arg1 ) { List < byte [ ] > loc0 = RepairAndDecode ( arg0, arg1 ) ; List < byte [ ] > loc1 = RepairAndDecode ( arg0, arg1 ) ; return loc0 ; }",
        "List < byte [ ] > function ( byte [ ] arg0 ) { List < byte [ ] > loc0 = RepairAndDecode ( arg0 ) ; List < byte [ ] > loc1 = RepairAndDecode ( arg0 ) ; return loc0 ; }",
        "List < byte [ ] > function ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = RepairAndDecode ( arg0, arg1, arg2 ) ; List < byte [ ] > loc1 = Decode. decode ( loc0 ) ; return loc1 ; }",
        "List < byte [ ] > function ( byte [ ] arg0, boolean arg1 ) { List < byte [ ] > loc0 = RepairAndDecode ( arg0 ) ; List < byte [ ] > loc1 = RepairAndDecode ( loc0, arg1 ) ; return loc1 ; }",
        "INDArray function ( INDArray arg0 ) { int loc0 = arg0. length ( ) ; INDArray loc1 = Nd4j. createDoubleMatrix ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. getDouble ( loc2 ) ; if ( loc3 < loc0 ) { loc1. set ( loc2, loc3 ) ; } else if ( loc3 > loc0 ) { loc1. set ( loc2, loc3 ) ; } } return loc1 ; }",
        "INDArray function ( INDArray arg0 ) { int loc0 = arg0. length ( ) ; INDArray loc1 = Nd4j. createDoubleMatrix ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. getDouble ( loc2 ) ; if ( loc3 < loc0 ) { loc1. set ( loc2, loc3 ) ; } else { loc1. set ( loc2, loc3 ) ; } } return loc1 ; }",
        "INDArray function ( INDArray arg0 ) { int loc0 = arg0. length ( ) ; INDArray loc1 = Nd4j. createDoubleMatrix ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. getDouble ( loc2 ) ; if ( loc3 < loc0 ) { loc1. set ( loc3, loc2 ) ; } else { loc1. set ( loc3, loc2 ) ; } } return loc1 ; }",
        "INDArray function ( INDArray arg0, int arg1, int arg2 ) { INDArray loc0 = Nd4j. createDoubleMatrix ( arg0. size ( ), arg1, arg2 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. elementAt ( loc1 ) ; int loc3 = arg0. elementAt ( loc1 ) ; loc0. set ( loc2, loc3 ) ; } return loc0 ; }",
        "INDArray function ( INDArray arg0, int arg1, int arg2 ) { INDArray loc0 = Nd4j. createDoubleMatrix ( arg0. size ( ), arg1, arg2 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. elementAt ( loc1 ) ; int loc3 = arg0. elementAt ( loc1 ) ; loc0. set ( loc2, loc3 ) ; decode ( loc0, loc3 ) ; } return loc0 ; }",
        "List < byte [ ] > function ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0 [ loc2 ] ; if ( ( loc3 & 0x80 )!= 0 ) { loc1. add ( ( byte ) ( loc3 & 0x7f ) ) ; } } return loc1 ; }",
        "List < byte [ ] > function ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { byte loc3 = arg0 [ loc2 ] ; if ( ( loc3 & 0x80 )!= 0 ) { loc1. add ( ( byte ) ( loc3 & 0x7f ) ) ; } } return loc1 ; }",
        "List < byte [ ] > function ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = ( ( arg0 [ loc2 ] & 0xff ) << 24 ) | ( ( arg0 [ loc2 + 1 ] & 0xff ) << 8 ) ; loc1. add ( arg0 [ loc2 ] & 0xff ) ; } return loc1 ; }",
        "List < byte [ ] > function ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { byte loc3 = arg0 [ loc2 ] ; if ( ( loc3 & 0x80 )!= 0 ) { loc1. add ( ( byte ) ( loc3 & 0x80 ) ) ; } } return loc1 ; }",
        "List < byte [ ] > function ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0 [ loc2 ] ; if ( ( loc3 & 0x80 )!= 0 ) { loc1. add ( ( byte ) ( loc3 & 0x80 ) ) ; } } return loc1 ; }",
        "Vector function ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
        "Vector function ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
        "Vector function ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; int loc3 = arg0. get ( loc1 ) ; loc0. set ( loc2, loc3 ) ; decode ( arg0. get ( loc2 ), loc3 ) ; } return loc0 ; }",
        "Vector function ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; for ( int loc3 = 0 ; loc3 < loc0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, loc0. get ( loc3 ) ) ; } } return loc0 ; }",
        "Vector function ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = loc1 ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
        "Vector function ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0. set ( loc2, arg0. get ( loc1 ) ) ; } } return loc0 ; }",
        "Vector function ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0. set ( loc1, arg0. get ( loc2 ) ) ; } } return loc0 ; }",
        "Vector function ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = loc1 ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
        "Vector function ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = loc1 ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc2, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
        "Vector function ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = loc1 ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Repair and decode.",
        "Repair and decode vectors.",
        "repair and decode.",
        "Repair and decode a sequence of vectors.",
        "Repair and decode an array of vectors."
      ],
      "output": [
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0, boolean arg1 ) { List < byte [ ] > loc0 = RepairAndDecode ( arg0, arg1 ) ; List < byte [ ] > loc1 = RepairAndDecode ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0, boolean arg1 ) { List < byte [ ] > loc0 = RepairAndDecode ( arg0, arg1 ) ; List < byte [ ] > loc1 = RepairAndDecode ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0 ) { List < byte [ ] > loc0 = RepairAndDecode ( arg0 ) ; List < byte [ ] > loc1 = RepairAndDecode ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0, int arg1, int arg2 ) { byte [ ] loc0 = RepairAndDecode ( arg0, arg1, arg2 ) ; List < byte [ ] > loc1 = Decode. decode ( loc0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0, boolean arg1 ) { List < byte [ ] > loc0 = RepairAndDecode ( arg0 ) ; List < byte [ ] > loc1 = RepairAndDecode ( loc0, arg1 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public INDArray repairAndDecode ( INDArray arg0 ) { int loc0 = arg0. length ( ) ; INDArray loc1 = Nd4j. createDoubleMatrix ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. getDouble ( loc2 ) ; if ( loc3 < loc0 ) { loc1. set ( loc2, loc3 ) ; } else if ( loc3 > loc0 ) { loc1. set ( loc2, loc3 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public INDArray repairAndDecode ( INDArray arg0 ) { int loc0 = arg0. length ( ) ; INDArray loc1 = Nd4j. createDoubleMatrix ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. getDouble ( loc2 ) ; if ( loc3 < loc0 ) { loc1. set ( loc2, loc3 ) ; } else { loc1. set ( loc2, loc3 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public INDArray repairAndDecode ( INDArray arg0 ) { int loc0 = arg0. length ( ) ; INDArray loc1 = Nd4j. createDoubleMatrix ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0. getDouble ( loc2 ) ; if ( loc3 < loc0 ) { loc1. set ( loc3, loc2 ) ; } else { loc1. set ( loc3, loc2 ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public INDArray repairAndDecode ( INDArray arg0, int arg1, int arg2 ) { INDArray loc0 = Nd4j. createDoubleMatrix ( arg0. size ( ), arg1, arg2 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. elementAt ( loc1 ) ; int loc3 = arg0. elementAt ( loc1 ) ; loc0. set ( loc2, loc3 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public INDArray repairAndDecode ( INDArray arg0, int arg1, int arg2 ) { INDArray loc0 = Nd4j. createDoubleMatrix ( arg0. size ( ), arg1, arg2 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. elementAt ( loc1 ) ; int loc3 = arg0. elementAt ( loc1 ) ; loc0. set ( loc2, loc3 ) ; decode ( loc0, loc3 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0 [ loc2 ] ; if ( ( loc3 & 0x80 )!= 0 ) { loc1. add ( ( byte ) ( loc3 & 0x7f ) ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { byte loc3 = arg0 [ loc2 ] ; if ( ( loc3 & 0x80 )!= 0 ) { loc1. add ( ( byte ) ( loc3 & 0x7f ) ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = ( ( arg0 [ loc2 ] & 0xff ) << 24 ) | ( ( arg0 [ loc2 + 1 ] & 0xff ) << 8 ) ; loc1. add ( arg0 [ loc2 ] & 0xff ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { byte loc3 = arg0 [ loc2 ] ; if ( ( loc3 & 0x80 )!= 0 ) { loc1. add ( ( byte ) ( loc3 & 0x80 ) ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public List < byte [ ] > repairAndDecode ( byte [ ] arg0 ) { int loc0 = arg0. length ; List < byte [ ] > loc1 = new ArrayList < byte [ ] > ( loc0 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { int loc3 = arg0 [ loc2 ] ; if ( ( loc3 & 0x80 )!= 0 ) { loc1. add ( ( byte ) ( loc3 & 0x80 ) ) ; } } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; int loc3 = arg0. get ( loc1 ) ; loc0. set ( loc2, loc3 ) ; decode ( arg0. get ( loc2 ), loc3 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; for ( int loc3 = 0 ; loc3 < loc0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, loc0. get ( loc3 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = loc1 ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0. set ( loc2, arg0. get ( loc1 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0. set ( loc1, arg0. get ( loc2 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = loc1 ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0, boolean arg1 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = loc1 ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc2, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Vector repairAndDecode ( Vector arg0 ) { Vector loc0 = new Vector ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = loc1 ; for ( int loc3 = 0 ; loc3 < arg0. size ( ) ; loc3 ++ ) { loc0. set ( loc3, arg0. get ( loc3 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_41_/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java_520-521": {
      "loc": "520-521",
      "input": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = 0; i < weights.length; i++) {\n                sumWts += weights[i];\n            }\n            if (isBiasCorrected) {\n                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n            } else {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n}",
      "target": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = begin; i < begin + length; i++) {\n                sumWts += weights[i];\n            }\n            if (isBiasCorrected) {\n                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n            } else {\n                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n            }\n        }\n    }\n    return var;\n}",
      "function range": "501,5-532,5",
      "raw_output": [
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ], arg0 [ loc1 ] ) ; } return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += apply ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 - 1 ) ; } return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 += evaluate ( arg0 [ loc1 ] ) ; return loc0 ; }",
        "T function ( T [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]!= null ) { return evaluate ( arg0 [ loc0 ] ) ; } } return null ; }",
        "T function ( T [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == null ) { return null ; } } return evaluate ( arg0 [ loc0 ] ) ; }",
        "T function ( T [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if (! ( arg0 [ loc0 ] instanceof Condition ) ) { loc0 = loc0 + 1 ; } } return ( T ) arg0 [ loc0 ] ; }",
        "T function ( T [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]!= null ) { return ( T ) arg0 [ loc0 ] ; } } return null ; }",
        "boolean function ( Condition [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. evaluate ( ) ) { return true ; } } return false ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ], arg0 [ loc1 ] ) ; } return loc0 ; }",
        "Double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ], arg0 [ loc1 ] ) ; } return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "double function ( double arg0 [ ], Context arg1 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ], arg1 ) ; } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( double [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( double [ ] arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( ) ; } double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Evaluate an array of double values.",
        "Evaluate a variety of terms.",
        "Evaluate a variety of conditions.",
        "Evaluate an array of doubles.",
        "Evaluates an array of double values."
      ],
      "output": [
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ], arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += apply ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 - 1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 += evaluate ( arg0 [ loc1 ] ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T evaluate ( T [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]!= null ) { return evaluate ( arg0 [ loc0 ] ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T evaluate ( T [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == null ) { return null ; } } return evaluate ( arg0 [ loc0 ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T evaluate ( T [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if (! ( arg0 [ loc0 ] instanceof Condition ) ) { loc0 = loc0 + 1 ; } } return ( T ) arg0 [ loc0 ] ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T evaluate ( T [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]!= null ) { return ( T ) arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean evaluate ( Condition [ ] arg0 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. evaluate ( ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ], arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Double evaluate ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ], arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double arg0 [ ], Context arg1 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += evaluate ( arg0 [ loc1 ], arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] evaluate ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( ) ; } double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( ) ; } double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double evaluate ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_26_/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java_820-821": {
      "loc": "820-821",
      "input": "public String format(Date date) {\n    Calendar c = new GregorianCalendar(mTimeZone);\n    c.setTime(date);\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}",
      "target": "public String format(Date date) {\n    Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n    c.setTime(date);\n    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n}",
      "function range": "819,5-823,5",
      "raw_output": [
        "String function ( long arg0 ) { return arg0 == 0? \"srini_string\" : String. format ( \"srini_string\", arg0 ) ; }",
        "String function ( T arg0 ) { return arg0 == null? \"srini_string\" : arg0. toString ( ) ; }",
        "String function ( long arg0 ) { return String. format ( Locale. ROOT, \"srini_string\", arg0 ) ; }",
        "String function ( T arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0 ) ; }",
        "String function ( long arg0 ) { return arg0 + \"srini_string\" ; }",
        "String function ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { return arg0 == null? null : SimpleDateFormat. format ( \"srini_string\", arg0. getTime ( ) ) ; }",
        "String function ( Date arg0 ) { return arg0 == null? \"srini_string\" : arg0. toString ( ) ; }",
        "String function ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { return arg0 == null? \"srini_string\" : DateUtil. formatDate ( arg0 ) ; }",
        "String function ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. US ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. US ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
        "String function ( Date arg0 ) { Calendar loc0 = Calendar. getInstance ( ) ; loc0. setTime ( arg0 ) ; return DateUtil. formatDate ( loc0 ) ; }",
        "String function ( Date arg0 ) { Calendar loc0 = Calendar. getInstance ( ) ; loc0. setTime ( arg0 ) ; return DateUtils. formatDate ( loc0 ) ; }"
      ],
      "mid_translation": [
        "Format a date.",
        "Format the given date.",
        "Format a date as a string.",
        "Format a date into a string.",
        "Format a date to a string."
      ],
      "output": [
        {
          "patch": "public String format ( long arg0 ) { return arg0 == 0? \"srini_string\" : String. format ( \"srini_string\", arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( T arg0 ) { return arg0 == null? \"srini_string\" : arg0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( long arg0 ) { return String. format ( Locale. ROOT, \"srini_string\", arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( T arg0 ) { return arg0 == null? \"srini_string\" : String. format ( \"srini_string\", arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( long arg0 ) { return arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { return arg0 == null? null : SimpleDateFormat. format ( \"srini_string\", arg0. getTime ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( Date arg0 ) { return arg0 == null? \"srini_string\" : arg0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { return arg0 == null? \"srini_string\" : DateUtil. formatDate ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. US ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. US ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { SimpleDateFormat loc0 = new SimpleDateFormat ( \"srini_string\", Locale. getDefault ( ) ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { DateFormat loc0 = new SimpleDateFormat ( \"srini_string\" ) ; return loc0. format ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String format ( Date arg0 ) { Calendar loc0 = Calendar. getInstance ( ) ; loc0. setTime ( arg0 ) ; return DateUtil. formatDate ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String format ( Date arg0 ) { Calendar loc0 = Calendar. getInstance ( ) ; loc0. setTime ( arg0 ) ; return DateUtils. formatDate ( loc0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_61_/src/java/org/apache/commons/lang/text/StrBuilder.java_1776-1777": {
      "loc": "1776-1777",
      "input": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = thisBuf.length - strLen;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j) != thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
      "target": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    int len = size - strLen + 1;\n    outer:\n    for (int i = startIndex; i < len; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j) != thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}",
      "function range": "1760,5-1787,5",
      "raw_output": [
        "int function ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
        "int function ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
        "int function ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg3. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg3 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
        "int function ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
        "int function ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 ) ; }",
        "int function ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
        "int function ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg3. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg3 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
        "int function ( String arg0, String arg1, int arg2 ) { int loc0 = 0 ; for ( ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } loc0 ++ ; } return - 1 ; }",
        "int function ( String [ ] arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. equals ( arg1 ) ) { return loc0 ; } } return - 1 ; }",
        "int function ( String [ ] arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg0 [ loc0 ]. equals ( arg1 ) ) return loc0 ; return - 1 ; }",
        "int function ( String arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1. charAt ( loc0 ) ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
        "int function ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
        "int function ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg3. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg3 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg3 ) { return loc0 ; } } return - 1 ; }",
        "int function ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg3. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }"
      ],
      "mid_translation": [
        "Gets the index of the first occurrence of the specified string starting at the specified index.",
        "Returns the index of the first occurrence of the specified string starting at the specified index.",
        "Returns the index of the first occurrence of the specified string starting at the specified startIndex.",
        "Gets the index of the first occurrence of the specified string.",
        "Gets the index of the first occurrence of the specified string starting at the specified startIndex."
      ],
      "output": [
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg3. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg3 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, char arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg3. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg3 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return arg0. charAt ( loc0 + 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { int loc0 = 0 ; for ( ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } loc0 ++ ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String [ ] arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ]. equals ( arg1 ) ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String [ ] arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg0 [ loc0 ]. equals ( arg1 ) ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg1. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1. charAt ( loc0 ) ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) if ( arg0. charAt ( loc0 ) == arg1 ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg3. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg3 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg3 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int indexOf ( String arg0, String arg1, int arg2, String arg3 ) { for ( int loc0 = arg2 ; loc0 < arg3. length ( ) ; loc0 ++ ) { if ( arg0. charAt ( loc0 ) == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_5_/src/main/java/org/apache/commons/math3/complex/Complex.java_305-306": {
      "loc": "305-306",
      "input": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return NaN;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}",
      "target": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return INF;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}",
      "function range": "299,5-321,5",
      "raw_output": [
        "Complex function ( ) { return new Complex ( 1, 0 ) ; }",
        "Complex function ( ) { return new Complex ( 0, 0 ) ; }",
        "Number function ( ) { NumberFactory loc0 = NumberFactory. getInstance ( ) ; return loc0. reciprocal ( ) ; }",
        "Complex function ( ) { Complex loc0 = new Complex ( 0, 0 ) ; return loc0. reciprocal ( ) ; }",
        "ComplexNumber function ( ) { return new ComplexNumber ( 1, 0 ) ; }",
        "Number function ( ) { NumberFactory loc0 = NumberFactory. getInstance ( ) ; return loc0. reciprocal ( this ) ; }",
        "Complex function ( ) { return new Complex ( 1, 0 ) ; }",
        "Complex function ( ) { return new Complex ( 0, 0 ) ; }",
        "Number function ( ) { NumberFactory loc0 = NumberFactory. getInstance ( ) ; return loc0. reciprocal ( ) ; }",
        "ComplexNumber function ( ) { return new ComplexNumber ( 1, 0 ) ; }",
        "Complex function ( ) { return new Complex ( 1, 0 ) ; }",
        "Complex function ( ) { return new Complex ( 0, 0 ) ; }",
        "Complex function ( ) { double loc0 = 0.0 ; return new Complex ( loc0, 0.0 ) ; }",
        "Complex function ( ) { double loc0 = 0.0 ; return new Complex ( loc0, 0 ) ; }",
        "Complex function ( ) { Complex loc0 = new Complex ( ) ; loc0. reciprocal ( ) ; return loc0 ; }",
        "Complex function ( ) { return new Complex ( 1, 0 ) ; }",
        "Complex function ( ) { double loc0 = ( double ) this. numerator. reciprocal ( ) ; return new Complex ( loc0 ) ; }",
        "Complex function ( ) { return new Complex ( 0, 0 ) ; }",
        "Complex function ( ) { Complex loc0 = new Complex ( ) ; loc0. reciprocal ( this ) ; return loc0 ; }",
        "Complex function ( ) { double loc0 = 0.0 ; return new Complex ( loc0, 0.0 ) ; }",
        "Complex function ( ) { return new Complex ( 1, 0 ) ; }",
        "Complex function ( ) { return new Complex ( 0, 0 ) ; }",
        "Complex function ( ) { Complex loc0 = new Complex ( 0, 0 ) ; return loc0. reciprocal ( ) ; }",
        "ComplexNumber function ( ) { return new ComplexNumber ( 1, 0 ) ; }",
        "Number function ( ) { NumberFactory loc0 = NumberFactory. getInstance ( ) ; return loc0. reciprocal ( ) ; }"
      ],
      "mid_translation": [
        "Gets the reciprocal of this complex number.",
        "Returns the reciprocal of this complex number.",
        "Gets the reciprocal of this Complex number.",
        "Returns the reciprocal of this Complex number.",
        "Get the reciprocal of this complex number."
      ],
      "output": [
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 1, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 0, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Number reciprocal ( ) { NumberFactory loc0 = NumberFactory. getInstance ( ) ; return loc0. reciprocal ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex reciprocal ( ) { Complex loc0 = new Complex ( 0, 0 ) ; return loc0. reciprocal ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public ComplexNumber reciprocal ( ) { return new ComplexNumber ( 1, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Number reciprocal ( ) { NumberFactory loc0 = NumberFactory. getInstance ( ) ; return loc0. reciprocal ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 1, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 0, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Number reciprocal ( ) { NumberFactory loc0 = NumberFactory. getInstance ( ) ; return loc0. reciprocal ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber reciprocal ( ) { return new ComplexNumber ( 1, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 1, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 0, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { double loc0 = 0.0 ; return new Complex ( loc0, 0.0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { double loc0 = 0.0 ; return new Complex ( loc0, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { Complex loc0 = new Complex ( ) ; loc0. reciprocal ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 1, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { double loc0 = ( double ) this. numerator. reciprocal ( ) ; return new Complex ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 0, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { Complex loc0 = new Complex ( ) ; loc0. reciprocal ( this ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex reciprocal ( ) { double loc0 = 0.0 ; return new Complex ( loc0, 0.0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 1, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { return new Complex ( 0, 0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Complex reciprocal ( ) { Complex loc0 = new Complex ( 0, 0 ) ; return loc0. reciprocal ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public ComplexNumber reciprocal ( ) { return new ComplexNumber ( 1, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Number reciprocal ( ) { NumberFactory loc0 = NumberFactory. getInstance ( ) ; return loc0. reciprocal ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_33_/src/main/java/org/apache/commons/lang3/ClassUtils.java_910-911": {
      "loc": "910-911",
      "input": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}",
      "target": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n        classes[i] = array[i] == null ? null : array[i].getClass();\n    }\n    return classes;\n}",
      "function range": "902,5-913,5",
      "raw_output": [
        "Class [ ] function ( Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
        "Class [ ] function ( final Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
        "Class [ ] function ( Object... arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) { return null ; } Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
        "List < Class > function ( Object [ ] arg0 ) { List < Class > loc0 = new ArrayList < Class > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ]. getClass ( ) ) ; } return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
        "Class [ ] function ( final Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "Class [ ] function ( final Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "List < Class > function ( Object [ ] arg0 ) { List < Class > loc0 = new ArrayList < Class > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ]. getClass ( ) ) ; } return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
        "ArrayList < Class > function ( Object [ ] arg0 ) { ArrayList < Class > loc0 = new ArrayList < Class > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ]. getClass ( ) ) ; } return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. clone ( ) ; return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "Object [ ] function ( final Object [ ] arg0 ) { if ( arg0 == null ) { return null ; } final Object [ ] loc0 = new Object [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ] ; } return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
        "Class [ ] function ( Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. toString ( ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Converts an array of objects to a Class array.",
        "Converts an array of objects to an array of classes.",
        "Convert an array of objects to a Class array.",
        "Convert an array of objects to an array of classes.",
        "Converts an object array to an array of Class objects."
      ],
      "output": [
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( final Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object... arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) { return null ; } Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Class > toClass ( Object [ ] arg0 ) { List < Class > loc0 = new ArrayList < Class > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ]. getClass ( ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( final Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( final Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Class > toClass ( Object [ ] arg0 ) { List < Class > loc0 = new ArrayList < Class > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ]. getClass ( ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Class > toClass ( Object [ ] arg0 ) { ArrayList < Class > loc0 = new ArrayList < Class > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ]. getClass ( ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. clone ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Object [ ] toClass ( final Object [ ] arg0 ) { if ( arg0 == null ) { return null ; } final Object [ ] loc0 = new Object [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { if ( arg0 == null ) return null ; Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ]. getClass ( ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Class [ ] toClass ( Object [ ] arg0 ) { Class [ ] loc0 = new Class [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( Class ) arg0 [ loc1 ]. toString ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_48_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_189-190": {
      "loc": "189-190",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        x1 = x;\n        f1 = fx;\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
      "target": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                if (x == x1) {\n                    throw new ConvergenceException();\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        x1 = x;\n        f1 = fx;\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
      "function range": "129,5-251,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_57_/src/java/org/apache/commons/lang/LocaleUtils.java_223-224": {
      "loc": "223-224",
      "input": "public static boolean isAvailableLocale(Locale locale) {\n    return cAvailableLocaleSet.contains(locale);\n}",
      "target": "public static boolean isAvailableLocale(Locale locale) {\n    return availableLocaleList().contains(locale);\n}",
      "function range": "222,5-224,5",
      "raw_output": [
        "boolean function ( Locale arg0 ) { try { return arg0. getISO3Language ( )!= null && arg0. getISO3Country ( )!= null ; } catch ( IllegalArgumentException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { return isValidLocale ( arg0 ) ; }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. getISO3Language ( )!= null ; } catch ( IllegalArgumentException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) { return false ; } try { return arg0. getISO3Language ( )!= null ; } catch ( IllegalArgumentException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) { return false ; } try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. equals ( Locale. getDefault ( ) ) ; } catch ( MissingResourceException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. equals ( Locale. getDefault ( ) ) ; } catch ( IllegalArgumentException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) { return false ; } try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) { return false ; } return arg0. equals ( Locale. getDefault ( ) ) ; }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocale ( ) ; return loc0!= null && loc0. isAvailable ( ) ; }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocaleManager ( ) ; return loc0!= null && loc0. isAvailable ( ) ; }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocaleManager ( ) ; if ( loc0 == null ) return false ; return loc0. isAvailable ( ) ; }",
        "boolean function ( ) { return LocaleService. getLocale ( )!= null ; }",
        "boolean function ( ) { return LocaleManager. getLocale ( )!= null ; }",
        "boolean function ( ) { return LocaleService. locale!= null ; }",
        "boolean function ( ) { return LocaleHelper. isInitialized ( ) ; }",
        "boolean function ( ) { return LocaleManager. hasLocale ( ) ; }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocaleManager ( ) ; if ( loc0 == null ) return false ; return loc0. isAvailable ( ) ; }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocaleManager ( ) ; return loc0!= null && loc0. isAvailable ( ) ; }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) { return false ; } return arg0. equals ( Locale. getDefault ( ) ) ; }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocale ( ) ; return loc0!= null && loc0. isAvailable ( ) ; }",
        "boolean function ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocale ( ) ; if ( loc0 == null ) return false ; return loc0. isAvailable ( ) ; }"
      ],
      "mid_translation": [
        "Returns true if the given locale is a valid locale.",
        "Returns true if the given locale is a available locale.",
        "Returns true if the given locale is available.",
        "Returns true if the locale is available.",
        "Returns true if the specified locale is available."
      ],
      "output": [
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { try { return arg0. getISO3Language ( )!= null && arg0. getISO3Country ( )!= null ; } catch ( IllegalArgumentException loc0 ) { return false ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { return isValidLocale ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. getISO3Language ( )!= null ; } catch ( IllegalArgumentException loc0 ) { return false ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) { return false ; } try { return arg0. getISO3Language ( )!= null ; } catch ( IllegalArgumentException loc0 ) { return false ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) { return false ; } try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. equals ( Locale. getDefault ( ) ) ; } catch ( MissingResourceException loc0 ) { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; try { return arg0. equals ( Locale. getDefault ( ) ) ; } catch ( IllegalArgumentException loc0 ) { return false ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) { return false ; } try { return arg0. getISO3Language ( )!= null ; } catch ( MissingResourceException loc0 ) { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) { return false ; } return arg0. equals ( Locale. getDefault ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocale ( ) ; return loc0!= null && loc0. isAvailable ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocaleManager ( ) ; return loc0!= null && loc0. isAvailable ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocaleManager ( ) ; if ( loc0 == null ) return false ; return loc0. isAvailable ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( ) { return LocaleService. getLocale ( )!= null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( ) { return LocaleManager. getLocale ( )!= null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( ) { return LocaleService. locale!= null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( ) { return LocaleHelper. isInitialized ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( ) { return LocaleManager. hasLocale ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocaleManager ( ) ; if ( loc0 == null ) return false ; return loc0. isAvailable ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocaleManager ( ) ; return loc0!= null && loc0. isAvailable ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) { return false ; } return arg0. equals ( Locale. getDefault ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocale ( ) ; return loc0!= null && loc0. isAvailable ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean isAvailableLocale ( Locale arg0 ) { if ( arg0 == null ) return false ; LocaleManager loc0 = LocaleManager. getLocale ( ) ; if ( loc0 == null ) return false ; return loc0. isAvailable ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_53_/src/main/java/org/apache/commons/math/complex/Complex.java_153-154": {
      "loc": "153-154",
      "input": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    return createComplex(real + rhs.getReal(),\n        imaginary + rhs.getImaginary());\n}",
      "target": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n    if (isNaN || rhs.isNaN) {\n        return NaN;\n    }\n    return createComplex(real + rhs.getReal(),\n        imaginary + rhs.getImaginary());\n}",
      "function range": "150,5-155,5",
      "raw_output": [
        "Complex function ( Complex arg0 ) { return new Complex ( this. get ( ), arg0. get ( ) ) ; }",
        "ComplexNumber function ( ComplexNumber arg0 ) { return new ComplexNumber ( this. get ( ), arg0. get ( ) ) ; }",
        "Complex function ( Complex arg0 ) { return new Complex ( arg0. x, arg0. y ) ; }",
        "Complex function ( Complex arg0 ) { if ( arg0 == null ) { return null ; } return new ComplexSum ( this, arg0 ) ; }",
        "Complex function ( Complex arg0 ) { return new Complex ( this. count ( ), arg0. count ( ) ) ; }",
        "ComplexNumber function ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
        "Complex function ( Complex arg0, Complex arg1 ) { return new Complex ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
        "ComplexNumber function ( complexNumber arg0, complexNumber arg1 ) { return new ComplexNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
        "ComplexNumber function ( ComplexNumber arg0, ComplexNumber arg1 ) { return new SimpleComplexNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
        "ComplexNumber function ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumberImpl ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
        "Complex function ( Complex arg0 ) { return new Complex ( this. get ( ), arg0. get ( ) ) ; }",
        "Complex function ( Complex arg0 ) { return new Complex ( arg0. x, arg0. y ) ; }",
        "Complex function ( Complex arg0 ) { return new Complex ( this. get ( ) + arg0. get ( ) ) ; }",
        "ComplexNumber function ( ComplexNumber arg0 ) { return new ComplexNumber ( this. get ( ), arg0. get ( ) ) ; }",
        "Complex function ( Complex arg0 ) { return new SimpleComplex ( this. get ( ), arg0. get ( ) ) ; }",
        "Complex function ( Complex arg0, Complex arg1 ) { return new Complex ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
        "Complex function ( Complex arg0, Complex arg1 ) { return new Complex ( arg0. toString ( ) + \"srini_string\" + arg1. toString ( ) ) ; }",
        "Complex function ( Complex arg0, Complex arg1 ) { return new Complex ( arg0. toString ( ) + arg1. toString ( ) ) ; }",
        "Complex function ( Complex arg0, Complex arg1 ) { return new Complex ( ). add ( arg0 ). add ( arg1 ) ; }",
        "Complex function ( Complex arg0 ) { return new Complex ( arg0. x + arg0. x, arg0. y + arg0. y ) ; }",
        "ComplexNumber function ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
        "ComplexNumber function ( ComplexNumber arg0, ComplexNumber arg1 ) { if ( arg0. signum ( ) == arg1. signum ( ) ) { return new ComplexNumber ( arg0. floatValue ( ) + arg1. floatValue ( ) ) ; } else { return new ComplexNumber ( arg0. floatValue ( ) + arg1. floatValue ( ) ) ; } }",
        "ComplexNumber function ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumber ( this. getClass ( ). getName ( ) + \"srini_string\" + arg0. getClass ( ). getName ( ) + \"srini_string\" + arg1. getClass ( ). getName ( ), arg0. doubleValue ( ) ) ; }",
        "ComplexNumber function ( ComplexNumber arg0, ComplexNumber arg1 ) { return new SimpleNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
        "ComplexNumber function ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumber ( this. getClass ( ). getName ( ) + \"srini_string\" + arg0. getClass ( ). getName ( ) + \"srini_string\" + arg1. getClass ( ). getName ( ), arg0. doubleValue ( ) + arg1. doubleValue ( ) ) ; }"
      ],
      "mid_translation": [
        "Returns the sum of this complex number with the given complex number.",
        "This method is used to add two complex numbers to this complex number.",
        "Returns the sum of this complex number with the specified complex number.",
        "This method is used to add two Complex objects to this Complex object.",
        "This method is used to add two complex numbers to this one."
      ],
      "output": [
        {
          "patch": "public Complex add ( Complex arg0 ) { return new Complex ( this. get ( ), arg0. get ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0 ) { return new ComplexNumber ( this. get ( ), arg0. get ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0 ) { return new Complex ( arg0. x, arg0. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0 ) { if ( arg0 == null ) { return null ; } return new ComplexSum ( this, arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0 ) { return new Complex ( this. count ( ), arg0. count ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0, Complex arg1 ) { return new Complex ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( complexNumber arg0, complexNumber arg1 ) { return new ComplexNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0, ComplexNumber arg1 ) { return new SimpleComplexNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumberImpl ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0 ) { return new Complex ( this. get ( ), arg0. get ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0 ) { return new Complex ( arg0. x, arg0. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0 ) { return new Complex ( this. get ( ) + arg0. get ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0 ) { return new ComplexNumber ( this. get ( ), arg0. get ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0 ) { return new SimpleComplex ( this. get ( ), arg0. get ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0, Complex arg1 ) { return new Complex ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0, Complex arg1 ) { return new Complex ( arg0. toString ( ) + \"srini_string\" + arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0, Complex arg1 ) { return new Complex ( arg0. toString ( ) + arg1. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0, Complex arg1 ) { return new Complex ( ). add ( arg0 ). add ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex add ( Complex arg0 ) { return new Complex ( arg0. x + arg0. x, arg0. y + arg0. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0, ComplexNumber arg1 ) { if ( arg0. signum ( ) == arg1. signum ( ) ) { return new ComplexNumber ( arg0. floatValue ( ) + arg1. floatValue ( ) ) ; } else { return new ComplexNumber ( arg0. floatValue ( ) + arg1. floatValue ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumber ( this. getClass ( ). getName ( ) + \"srini_string\" + arg0. getClass ( ). getName ( ) + \"srini_string\" + arg1. getClass ( ). getName ( ), arg0. doubleValue ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0, ComplexNumber arg1 ) { return new SimpleNumber ( arg0. x + arg1. x, arg0. y + arg1. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber add ( ComplexNumber arg0, ComplexNumber arg1 ) { return new ComplexNumber ( this. getClass ( ). getName ( ) + \"srini_string\" + arg0. getClass ( ). getName ( ) + \"srini_string\" + arg1. getClass ( ). getName ( ), arg0. doubleValue ( ) + arg1. doubleValue ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_39_/src/java/org/apache/commons/lang3/StringUtils.java_3676-3677": {
      "loc": "3676-3677",
      "input": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; \n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
      "target": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || replacementList[i] == null) {\n            continue;\n        }\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; \n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n    while (textIndex != -1) {\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        buf.append(replacementList[replaceIndex]);\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                searchList[i].length() == 0 || replacementList[i] == null) \n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
      "function range": "3605,5-3731,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_50_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_187-188": {
      "loc": "187-188",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        x1 = x;\n        f1 = fx;\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
      "target": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        x1 = x;\n        f1 = fx;\n        if (FastMath.abs(f1) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return x1;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return x1;\n                }\n                break;\n            case BELOW_SIDE:\n                if (f1 <= 0) {\n                    return x1;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (f1 >= 0) {\n                    return x1;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                 atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return x1;\n            case LEFT_SIDE:\n                return inverted ? x1 : x0;\n            case RIGHT_SIDE:\n                return inverted ? x0 : x1;\n            case BELOW_SIDE:\n                return (f1 <= 0) ? x1 : x0;\n            case ABOVE_SIDE:\n                return (f1 >= 0) ? x1 : x0;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
      "function range": "128,5-253,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_58_/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java_121-122": {
      "loc": "121-122",
      "input": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(), guess);\n}",
      "target": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    return fit(guess);\n}",
      "function range": "119,5-122,5",
      "raw_output": [
        "GaussianClassifier function ( GaussianClassifier arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return GaussianClassifier. fit ( arg0 ) ; }",
        "GaussianClassifier function ( ) { GaussianClassifier loc0 = new GaussianClassifier ( ) ; loc0. rand ( ) ; return loc0 ; }",
        "LinearClassifier function ( Gaussian arg0 ) { return fit ( arg0, Gaussian. uniform ( 0.0, 1.0 ), Gaussian. uniform ( 1.0, 2.0 ) ) ; }",
        "GaussianClassifier function ( GaussianClassifier arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return GaussianClassifier. fit ( arg0 ) ; }",
        "GaussianClassifier function ( ) { GaussianClassifier loc0 = new GaussianClassifier ( ) ; loc0. init ( ) ; return loc0 ; }",
        "Gaussian function ( ) { Gaussian loc0 = new Gaussian ( 0.0, 1.0 ) ; return fit ( loc0 ) ; }",
        "Gaussian function ( ) { Gaussian loc0 = new Gaussian ( 1.0, 2.0 ) ; return fit ( loc0 ) ; }",
        "Gaussian function ( ) { Gaussian loc0 = Gaussian. create ( 0.0, 1.0 ) ; return fit ( loc0 ) ; }",
        "Gaussian function ( ) { Gaussian loc0 = Gaussian. create ( 0.0, 2.0 ) ; return fit ( loc0 ) ; }",
        "GaussianModel function ( ) { GaussianModel loc0 = Gaussian. createGaussianModel ( this. getClass ( ). getSimpleName ( ), 2.0 ) ; return loc0 ; }",
        "Gaussian function ( Gaussian arg0, double [ ] arg1 ) { return fit ( arg0, GaussianUtils. createGaussian ( arg1 ) ) ; }",
        "Gaussian function ( Gaussian arg0, double arg1 ) { return fit ( arg0, GaussianUtils. createGaussian ( arg1 ) ) ; }",
        "Gaussian function ( Gaussian arg0, double [ ] arg1 ) { return fit ( arg0, arg1, null ) ; }",
        "Gaussian function ( Gaussian arg0, double [ ] arg1 ) { return fit ( arg0, arg1, new double [ ] { 1 } ) ; }",
        "Gaussian function ( Gaussian arg0, double [ ] arg1 ) { return fit ( arg0, arg1, 1 ) ; }",
        "LinearClassifier function ( double arg0, double arg1 ) { return fit ( arg0, arg1, Gaussian. uniform ( 1.0, 2.0 ) ) ; }",
        "LinearClassifier function ( double arg0, double [ ] arg1 ) { return fit ( arg0, Gaussian. Phi ( arg1 ) ) ; }",
        "LinearClassifier function ( double arg0, double [ ] arg1 ) { return fit ( arg0, Gaussian. Phi ( arg1 ), arg1 ) ; }",
        "LinearClassifier function ( double arg0, double arg1 ) { return fit ( arg0, arg1, Gaussian. uniform ( 1 - arg0, 2 ) ) ; }",
        "LinearClassifier function ( double arg0, double [ ] arg1 ) { return fit ( arg0, arg1, new Gaussian < Double > ( ) ) ; }",
        "Gaussian function ( Gaussian arg0 ) { return Gauss. Phi ( this. model, arg0 ) ; }",
        "Gaussian function ( ) { Gaussian loc0 = Gaussian. create ( 0.0, 1.0 ) ; return loc0 ; }",
        "void function ( Gaussian arg0 ) { Parameters loc0 = Parameters. getInstance ( ) ; fit ( loc0, arg0 ) ; }",
        "void function ( Gaussian arg0 ) { fit ( arg0, new Gaussian ( 1.0, 0.0 ) ) ; }",
        "Gaussian function ( Gaussian arg0 ) { return Gauss. Phi ( this, arg0 ) ; }"
      ],
      "mid_translation": [
        "Fits the classifier using Gaussian.",
        "Fits the model using Gaussian.",
        "Fit the model using Gaussian.",
        "Fit the classifier using Gaussian.",
        "Fits the model to a Gaussian."
      ],
      "output": [
        {
          "patch": "public GaussianClassifier fit ( GaussianClassifier arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return GaussianClassifier. fit ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public GaussianClassifier fit ( ) { GaussianClassifier loc0 = new GaussianClassifier ( ) ; loc0. rand ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LinearClassifier fit ( Gaussian arg0 ) { return fit ( arg0, Gaussian. uniform ( 0.0, 1.0 ), Gaussian. uniform ( 1.0, 2.0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public GaussianClassifier fit ( GaussianClassifier arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return GaussianClassifier. fit ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public GaussianClassifier fit ( ) { GaussianClassifier loc0 = new GaussianClassifier ( ) ; loc0. init ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( ) { Gaussian loc0 = new Gaussian ( 0.0, 1.0 ) ; return fit ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( ) { Gaussian loc0 = new Gaussian ( 1.0, 2.0 ) ; return fit ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( ) { Gaussian loc0 = Gaussian. create ( 0.0, 1.0 ) ; return fit ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( ) { Gaussian loc0 = Gaussian. create ( 0.0, 2.0 ) ; return fit ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public GaussianModel fit ( ) { GaussianModel loc0 = Gaussian. createGaussianModel ( this. getClass ( ). getSimpleName ( ), 2.0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( Gaussian arg0, double [ ] arg1 ) { return fit ( arg0, GaussianUtils. createGaussian ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( Gaussian arg0, double arg1 ) { return fit ( arg0, GaussianUtils. createGaussian ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( Gaussian arg0, double [ ] arg1 ) { return fit ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( Gaussian arg0, double [ ] arg1 ) { return fit ( arg0, arg1, new double [ ] { 1 } ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( Gaussian arg0, double [ ] arg1 ) { return fit ( arg0, arg1, 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LinearClassifier fit ( double arg0, double arg1 ) { return fit ( arg0, arg1, Gaussian. uniform ( 1.0, 2.0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LinearClassifier fit ( double arg0, double [ ] arg1 ) { return fit ( arg0, Gaussian. Phi ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LinearClassifier fit ( double arg0, double [ ] arg1 ) { return fit ( arg0, Gaussian. Phi ( arg1 ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LinearClassifier fit ( double arg0, double arg1 ) { return fit ( arg0, arg1, Gaussian. uniform ( 1 - arg0, 2 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LinearClassifier fit ( double arg0, double [ ] arg1 ) { return fit ( arg0, arg1, new Gaussian < Double > ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( Gaussian arg0 ) { return Gauss. Phi ( this. model, arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( ) { Gaussian loc0 = Gaussian. create ( 0.0, 1.0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void fit ( Gaussian arg0 ) { Parameters loc0 = Parameters. getInstance ( ) ; fit ( loc0, arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void fit ( Gaussian arg0 ) { fit ( arg0, new Gaussian ( 1.0, 0.0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Gaussian fit ( Gaussian arg0 ) { return Gauss. Phi ( this, arg0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_58_/src/java/org/apache/commons/lang/math/NumberUtils.java_454-456": {
      "loc": "454-456",
      "input": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && isDigits(numeric.substring(1))\n                    && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "target": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n    if (decPos > -1) {\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos > -1) {\n            mant = str.substring(0, expPos);\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar)) {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length() - 1);\n        } else {\n            exp = null;\n        }\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                    }\n                    return createBigInteger(numeric);\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                }\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1, str.length());\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigInteger(str);\n        } else {\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n            }\n            return createBigDecimal(str);\n        }\n    }\n}",
      "function range": "397,5-545,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_75_/src/main/java/org/apache/commons/math/stat/Frequency.java_303-304": {
      "loc": "303-304",
      "input": "@Deprecated\npublic double getPct(Object v) {\n    return getCumPct((Comparable<?>) v);\n}",
      "target": "@Deprecated\npublic double getPct(Object v) {\n    return getPct((Comparable<?>) v);\n}",
      "function range": "301,5-304,5",
      "raw_output": [
        "long function ( ) { return 0 ; }",
        "int function ( ) { return 0 ; }",
        "int function ( ) { return v. getPct ( ) ; }",
        "BigDecimal function ( ) { return new BigDecimal ( \"srini_string\" ) ; }",
        "long function ( ) { return v. getPct ( ) ; }",
        "long function ( ) { return 0 ; }",
        "int function ( ) { return ( ( Number ) v ( 0 ) ). intValue ( ) ; }",
        "int function ( ) { return 0 ; }",
        "long function ( ) { return v. getPct ( ) ; }",
        "int function ( ) { return v. getPct ( ) ; }",
        "long function ( ) { return 0 ; }",
        "double function ( ) { return 0.0 ; }",
        "BigDecimal function ( ) { return Pct ; }",
        "Number function ( ) { return Pct ; }",
        "BigDecimal function ( ) { return null ; }",
        "Percent function ( ) { return new Percent ( 1 ) ; }",
        "Percent function ( ) { return new Percent ( 0, 0 ) ; }",
        "Percent function ( ) { return new Percent ( 0 ) ; }",
        "Percent function ( ) { return new Percent ( 100 ) ; }",
        "double function ( ) { return 0.0 ; }",
        "double function ( Object arg0 ) { if ( arg0 == null ) return 0.0 ; if ( arg0 instanceof Number ) return ( ( Number ) arg0 ). doubleValue ( ) ; if ( arg0 instanceof String ) return ( ( String ) arg0 ). intValue ( ) ; return 0.0 ; }",
        "double function ( Object arg0 ) { ParamChecks. nullNotPermitted ( arg0, \"srini_string\" ) ; double loc0 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc1 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc2 = ( ( Double ) arg0 ). doubleValue ( ) ; return ( loc0 / loc1 ) ; }",
        "double function ( Object arg0 ) { ParamChecks. nullNotPermitted ( arg0, \"srini_string\" ) ; double loc0 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc1 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc2 = ( ( Double ) arg0 ). doubleValue ( ) ; return ( loc0 / loc1 ) * 100 ; }",
        "double function ( Object arg0 ) { ParamChecks. nullNotPermitted ( arg0, \"srini_string\" ) ; double loc0 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc1 = ( ( Double ) arg0 ). doubleValue ( ) ; return ( ( double ) loc0 / loc1 ) ; }",
        "double function ( Object arg0 ) { ParamChecks. nullNotPermitted ( arg0, \"srini_string\" ) ; double loc0 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc1 = ( ( Double ) arg0 ). doubleValue ( ) ; return ( loc0 / loc1 ) ; }"
      ],
      "mid_translation": [
        "Get the Pct of the object v.",
        "Returns the Pct of the object v.",
        "Get the Pct of the object.",
        "Get the pct of the object.",
        "Gets the pct of the object v."
      ],
      "output": [
        {
          "patch": "@Deprecated\npublic long getPct ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic int getPct ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic int getPct ( ) { return v. getPct ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic BigDecimal getPct ( ) { return new BigDecimal ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic long getPct ( ) { return v. getPct ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic long getPct ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic int getPct ( ) { return ( ( Number ) v ( 0 ) ). intValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic int getPct ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic long getPct ( ) { return v. getPct ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic int getPct ( ) { return v. getPct ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic long getPct ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct ( ) { return 0.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic BigDecimal getPct ( ) { return Pct ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic Number getPct ( ) { return Pct ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic BigDecimal getPct ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic Percent getPct ( ) { return new Percent ( 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic Percent getPct ( ) { return new Percent ( 0, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic Percent getPct ( ) { return new Percent ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic Percent getPct ( ) { return new Percent ( 100 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic double getPct ( ) { return 0.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Deprecated\npublic double getPct ( Object arg0 ) { if ( arg0 == null ) return 0.0 ; if ( arg0 instanceof Number ) return ( ( Number ) arg0 ). doubleValue ( ) ; if ( arg0 instanceof String ) return ( ( String ) arg0 ). intValue ( ) ; return 0.0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic double getPct ( Object arg0 ) { ParamChecks. nullNotPermitted ( arg0, \"srini_string\" ) ; double loc0 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc1 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc2 = ( ( Double ) arg0 ). doubleValue ( ) ; return ( loc0 / loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic double getPct ( Object arg0 ) { ParamChecks. nullNotPermitted ( arg0, \"srini_string\" ) ; double loc0 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc1 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc2 = ( ( Double ) arg0 ). doubleValue ( ) ; return ( loc0 / loc1 ) * 100 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic double getPct ( Object arg0 ) { ParamChecks. nullNotPermitted ( arg0, \"srini_string\" ) ; double loc0 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc1 = ( ( Double ) arg0 ). doubleValue ( ) ; return ( ( double ) loc0 / loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Deprecated\npublic double getPct ( Object arg0 ) { ParamChecks. nullNotPermitted ( arg0, \"srini_string\" ) ; double loc0 = ( ( Double ) arg0 ). doubleValue ( ) ; double loc1 = ( ( Double ) arg0 ). doubleValue ( ) ; return ( loc0 / loc1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_69_/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java_171-172": {
      "loc": "171-172",
      "input": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}",
      "target": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n}",
      "function range": "160,5-176,5",
      "raw_output": [
        "double function ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 < 1.0 ) { return 0.0 ; } else { return 1.0 ; } }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 < 1.0 ) { return 0.0 ; } else { return 1.0 ; } }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else { return 0.0 ; } }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else { return 0.0 ; } }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 < 1.0 ) { return 1.0 ; } else { return 0.0 ; } }",
        "CorrelationP function ( ) { return correlationP ; }",
        "CorrelationPoint function ( ) { return correlationP ; }",
        "CorrelationP function ( ) { return correlationP ( null ) ; }",
        "CorrelationP function ( ) { if ( correlationP == null ) { return new correlationP ( ) ; } return correlationP ; }",
        "CorrelationP function ( ) { return new CorrelationP ( ) ; }",
        "CorrelationP function ( ) { return correlationP ; }",
        "double [ ] function ( ) { double [ ] loc0 = correlationP ( ) ; double loc1 = loc0 [ 0 ] ; double loc2 = loc0 [ 1 ] ; return loc2 ; }",
        "double function ( double arg0 ) { if ( arg0 < 0.0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return correlationP ( ( double ) arg0 ) ; }",
        "double function ( double arg0 ) { if ( arg0 < 0.0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return correlationP ( arg0 ) ; }",
        "double [ ] function ( ) { double [ ] loc0 = correlationP ( ) ; return loc0 ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; double loc1 = ( loc0 + loc0 ) / 2.0 ; double loc2 = ( loc0 + loc1 ) / 2.0 ; double loc3 = ( loc0 + loc1 ) / 2.0 ; return loc2 ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; double loc1 = ( loc0 + loc0 ) / 2.0 ; double loc2 = ( loc0 + loc1 ) / 2.0 ; double loc3 = ( loc0 + loc1 ) / 2.0 ; return loc2 * loc3 ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; double loc1 = ( loc0 + loc0 ) / 2.0 ; double loc2 = ( loc1 - loc0 ) / 2.0 ; double loc3 = ( loc1 - loc0 ) / 2.0 ; return loc2 * loc3 ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; double loc1 = ( loc0 + loc0 ) / 2.0 ; double loc2 = ( loc1 - loc0 ) / 2.0 ; double loc3 = ( loc1 - loc0 ) / 2.0 ; return loc3 ; }",
        "double function ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; if ( loc0 < 0.0 || loc0 > 0.0 ) { throw new ArithmeticException ( \"srini_string\" ) ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ 0 ]. length ; loc2 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ 0 ]. length ; loc2 ++ ) { for ( int loc3 = 0 ; loc3 < arg0 [ 0 ]. length ; loc3 ++ ) { loc0 [ loc1 ] [ loc2 ] = loc0 [ loc3 ] [ loc1 ] ; } } } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ 0 ]. length ; loc2 ++ ) { for ( int loc3 = 0 ; loc3 < arg0 [ 0 ]. length ; loc3 ++ ) { loc0 [ loc1 - loc2 ] = loc0 [ loc3 ] [ loc2 ] ; } } } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ 0 ]. length ; loc2 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] [ loc2 ] - arg0 [ loc2 ] [ loc2 ] ; } } return loc0 ; }",
        "double [ ] function ( Matrix arg0 ) { double [ ] loc0 = new double [ arg0. dim1 + arg0. dim2 ] ; for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) { loc0 [ loc1 - loc2 ] [ loc3 ] ; } } } return loc0 ; }"
      ],
      "mid_translation": [
        "Gets the correlation p - values.",
        "Gets the correlation P values.",
        "Gets the correlation p values.",
        "Get the correlation p - values.",
        "Returns the correlation p - values of the matrix."
      ],
      "output": [
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 < 1.0 ) { return 0.0 ; } else { return 1.0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 < 1.0 ) { return 0.0 ; } else { return 1.0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else { return 0.0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else { return 0.0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; if ( loc0 < 0.0 ) { return 0.0 ; } else if ( loc0 > 0.0 ) { return 1.0 ; } else if ( loc0 < 1.0 ) { return 1.0 ; } else { return 0.0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public CorrelationP getCorrelationPValues ( ) { return correlationP ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CorrelationPoint getCorrelationPValues ( ) { return correlationP ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CorrelationP getCorrelationPValues ( ) { return correlationP ( null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CorrelationP getCorrelationPValues ( ) { if ( correlationP == null ) { return new correlationP ( ) ; } return correlationP ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CorrelationP getCorrelationPValues ( ) { return new CorrelationP ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public CorrelationP getCorrelationPValues ( ) { return correlationP ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] getCorrelationPValues ( ) { double [ ] loc0 = correlationP ( ) ; double loc1 = loc0 [ 0 ] ; double loc2 = loc0 [ 1 ] ; return loc2 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0 ) { if ( arg0 < 0.0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return correlationP ( ( double ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0 ) { if ( arg0 < 0.0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return correlationP ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] getCorrelationPValues ( ) { double [ ] loc0 = correlationP ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; double loc1 = ( loc0 + loc0 ) / 2.0 ; double loc2 = ( loc0 + loc1 ) / 2.0 ; double loc3 = ( loc0 + loc1 ) / 2.0 ; return loc2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; double loc1 = ( loc0 + loc0 ) / 2.0 ; double loc2 = ( loc0 + loc1 ) / 2.0 ; double loc3 = ( loc0 + loc1 ) / 2.0 ; return loc2 * loc3 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; double loc1 = ( loc0 + loc0 ) / 2.0 ; double loc2 = ( loc1 - loc0 ) / 2.0 ; double loc3 = ( loc1 - loc0 ) / 2.0 ; return loc2 * loc3 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg1 - arg0 ; double loc1 = ( loc0 + loc0 ) / 2.0 ; double loc2 = ( loc1 - loc0 ) / 2.0 ; double loc3 = ( loc1 - loc0 ) / 2.0 ; return loc3 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getCorrelationPValues ( double arg0, double arg1 ) { double loc0 = arg0 - arg1 ; if ( loc0 < 0.0 || loc0 > 0.0 ) { throw new ArithmeticException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double [ ] getCorrelationPValues ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ 0 ]. length ; loc2 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] getCorrelationPValues ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ 0 ]. length ; loc2 ++ ) { for ( int loc3 = 0 ; loc3 < arg0 [ 0 ]. length ; loc3 ++ ) { loc0 [ loc1 ] [ loc2 ] = loc0 [ loc3 ] [ loc1 ] ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] getCorrelationPValues ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ 0 ]. length ; loc2 ++ ) { for ( int loc3 = 0 ; loc3 < arg0 [ 0 ]. length ; loc3 ++ ) { loc0 [ loc1 - loc2 ] = loc0 [ loc3 ] [ loc2 ] ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] getCorrelationPValues ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ 0 ]. length ; loc2 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] [ loc2 ] - arg0 [ loc2 ] [ loc2 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] getCorrelationPValues ( Matrix arg0 ) { double [ ] loc0 = new double [ arg0. dim1 + arg0. dim2 ] ; for ( int loc1 = 0 ; loc1 < arg0. dim2 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { for ( int loc3 = 0 ; loc3 < arg0. dim2 ; loc3 ++ ) { loc0 [ loc1 - loc2 ] [ loc3 ] ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_85_/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java_198-199": {
      "loc": "198-199",
      "input": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb >= 0.0 ) {\n        throw new ConvergenceException(\n                  \"number of iterations={0}, maximum iterations={1}, \" +\n                  \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                  \"final b value={6}, f(a)={7}, f(b)={8}\",\n                  numIterations, maximumIterations, initial,\n                  lowerBound, upperBound, a, b, fa, fb);\n    }\n    return new double[]{a, b};\n}",
      "target": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n    if (fa * fb > 0.0 ) {\n        throw new ConvergenceException(\n                  \"number of iterations={0}, maximum iterations={1}, \" +\n                  \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                  \"final b value={6}, f(a)={7}, f(b)={8}\",\n                  numIterations, maximumIterations, initial,\n                  lowerBound, upperBound, a, b, fa, fb);\n    }\n    return new double[]{a, b};\n}",
      "function range": "165,5-208,5",
      "raw_output": [
        "double [ ] function ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 += arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
        "double [ ] function ( double arg0 ) { double loc0 = arg0 ; double loc1 = 1.0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 *= loc2 ; } return new double [ loc1 ] ; }",
        "double [ ] function ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 += arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc1 ; }",
        "double [ ] function ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 *= arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
        "double [ ] function ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc2 ; } return loc1 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 = loc1 + loc2 ; } return loc1 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc1 = loc0 + loc2 ; } return loc1 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc1 ; } return loc0 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 += loc2 ; } return loc1 ; }",
        "double [ ] function ( double arg0 ) { double loc0 = arg0 ; double loc1 = 1.0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 *= loc2 ; } return new double [ loc1 ] ; }",
        "double [ ] function ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
        "double [ ] function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } double loc0 = arg0 - arg1 ; double loc1 = loc0 / 2.0 ; return new double [ ] { loc1, loc0 } ; }",
        "double [ ] function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return new double [ 0 ] ; } else { return new double [ arg1 ] ; } }",
        "double [ ] function ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 *= arg1 [ loc2 ] ; } return loc1 ; }",
        "double [ ] function ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 += arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
        "double [ ] function ( double arg0 ) { double loc0 = arg0 ; double loc1 = 1.0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 *= loc2 ; } return new double [ loc1 ] ; }",
        "double [ ] function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return new double [ 0 ] ; } else { return new double [ arg1 ] ; } }",
        "double [ ] function ( double arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) { loc0 += arg0 ( loc2 ) ; loc1 *= 2.0 ; } return loc1 ; }",
        "double [ ] function ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 += arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc1 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc2 ; } return loc1 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 = loc1 + loc2 ; } return loc1 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc1 ; } return loc0 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc1 = loc0 + loc2 ; } return loc1 ; }",
        "double [ ] function ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc2 ; loc1 = loc1 - 1 ; } return loc1 ; }"
      ],
      "mid_translation": [
        "Returns an array of double values for the given univariate real function.",
        "Returns an array of double values that are bracketed by the specified function.",
        "Returns an array of double values for the specified univariate real function.",
        "Returns an array of double values for a given univariate real function.",
        "Returns an array of double values that are bracketed by the given function."
      ],
      "output": [
        {
          "patch": "public static double [ ] bracket ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 += arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0 ) { double loc0 = arg0 ; double loc1 = 1.0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 *= loc2 ; } return new double [ loc1 ] ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 += arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 *= arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc2 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 = loc1 + loc2 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc1 = loc0 + loc2 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 += loc2 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0 ) { double loc0 = arg0 ; double loc1 = 1.0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 *= loc2 ; } return new double [ loc1 ] ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } double loc0 = arg0 - arg1 ; double loc1 = loc0 / 2.0 ; return new double [ ] { loc1, loc0 } ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return new double [ 0 ] ; } else { return new double [ arg1 ] ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 *= arg1 [ loc2 ] ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 += arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0 ) { double loc0 = arg0 ; double loc1 = 1.0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 *= loc2 ; } return new double [ loc1 ] ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return new double [ 0 ] ; } else { return new double [ arg1 ] ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) { loc0 += arg0 ( loc2 ) ; loc1 *= 2.0 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( double arg0, double... arg1 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg1. length ; loc2 ++ ) { loc1 += arg1 [ loc2 ] ; loc0 *= arg1 [ loc2 ] ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc2 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 = loc1 + loc2 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc1 = loc0 + loc2 ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double [ ] bracket ( DoubleUnaryOperator arg0 ) { double loc0 = arg0. applyAsDouble ( ) ; double loc1 = loc0 ; for ( int loc2 = 0 ; loc2 < loc1 ; loc2 ++ ) { loc0 = loc0 + loc2 ; loc1 = loc1 - 1 ; } return loc1 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_43_/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java_422-423": {
      "loc": "422-423",
      "input": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        return appendTo == null ? null : appendTo.append(QUOTE);\n    }\n    int lastHold = start;\n    for (int i = pos.getIndex(); i < pattern.length(); i++) {\n        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                    QUOTE);\n            pos.setIndex(i + ESCAPED_QUOTE.length());\n            lastHold = pos.getIndex();\n            continue;\n        }\n        switch (c[pos.getIndex()]) {\n        case QUOTE:\n            next(pos);\n            return appendTo == null ? null : appendTo.append(c, lastHold,\n                    pos.getIndex() - lastHold);\n        default:\n            next(pos);\n        }\n    }\n    throw new IllegalArgumentException(\n            \"Unterminated quoted string at position \" + start);\n}",
      "target": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n        next(pos);\n        return appendTo == null ? null : appendTo.append(QUOTE);\n    }\n    int lastHold = start;\n    for (int i = pos.getIndex(); i < pattern.length(); i++) {\n        if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n            appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                    QUOTE);\n            pos.setIndex(i + ESCAPED_QUOTE.length());\n            lastHold = pos.getIndex();\n            continue;\n        }\n        switch (c[pos.getIndex()]) {\n        case QUOTE:\n            next(pos);\n            return appendTo == null ? null : appendTo.append(c, lastHold,\n                    pos.getIndex() - lastHold);\n        default:\n            next(pos);\n        }\n    }\n    throw new IllegalArgumentException(\n            \"Unterminated quoted string at position \" + start);\n}",
      "function range": "417,5-444,5",
      "raw_output": [
        "String function ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "String function ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
        "void function ( StringBuilder arg0, String arg1 ) { arg0. append ( '\"' ). append ( arg1 ). append ( '\"' ) ; }",
        "StringBuilder function ( StringBuilder arg0, String arg1 ) { return arg0. append ( '\"' ). append ( arg1 ). append ( '\"' ) ; }",
        "StringBuilder function ( StringBuilder arg0, char arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; arg0. append ( '\"' ) ; return arg0 ; }",
        "StringBuilder function ( StringBuilder arg0, String arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; arg0. append ( '\"' ) ; return arg0 ; }",
        "void function ( StringBuilder arg0, String arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; arg0. append ( '\"' ) ; }",
        "StringBuilder function ( String arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( '\"' ). append ( arg0 ). append ( '\"' ) ; return loc0 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; loc0. append ( arg0 ) ; loc0. append ( '\"' ) ; return loc0 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ). append ( arg0 ) ; loc0. append ( '\"' ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, StringBuffer arg1 ) { if ( arg0 == null || arg0. length ( ) == 0 ) { arg1. append ( \"srini_string\" ) ; } arg1. append ( '\"' ). append ( arg0 ). append ( '\"' ) ; return arg1 ; }",
        "StringBuffer function ( String arg0 ) { return new StringBuffer ( '\"' ). append ( arg0 ). append ( '\"' ) ; }",
        "StringBuffer function ( String arg0, StringBuffer arg1 ) { if ( arg0!= null && arg0. length ( ) > 0 ) { arg1. append ( '\"' ) ; arg1. append ( arg0 ) ; arg1. append ( '\"' ) ; } return arg1 ; }",
        "String function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; loc0. append ( arg0 ) ; loc0. append ( '\"' ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; if ( loc1 < arg0. length ( ) - 1 ) { loc0. append ( '\"' ) ; } } loc0. append ( '\"' ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; if ( loc1!= arg0. length ( ) - 1 ) { loc0. append ( '\"' ) ; } } loc0. append ( '\"' ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( '\"' ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; if ( loc1 < arg0. length ( ) - 1 ) { loc0. append ( '\"' ) ; } } loc0. append ( '\"' ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; if ( loc1 < arg0. length ( ) - 1 ) loc0. append ( '\"' ) ; } loc0. append ( arg0 ) ; return loc0. toString ( ) ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; loc0. append ( arg0 ) ; loc0. append ( '\"' ) ; return loc0 ; }",
        "StringBuffer function ( String arg0, StringBuffer arg1 ) { arg1. append ( '\"' ) ; arg1. append ( arg0 ) ; arg1. append ( '\"' ) ; return arg1 ; }",
        "StringBuffer function ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; if ( arg0!= null ) { loc0. append ( arg0 ) ; } loc0. append ( '\"' ) ; return loc0 ; }",
        "void function ( StringBuffer arg0, String arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; }",
        "void function ( StringBuffer arg0, String arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; arg0. append ( '\"' ) ; }"
      ],
      "mid_translation": [
        "Append quoted string.",
        "Append a quoted string.",
        "Append quoted string to StringBuffer.",
        "appendQuotedString Method.",
        "Append a quoted string to the StringBuffer"
      ],
      "output": [
        {
          "patch": "private String appendQuotedString ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String appendQuotedString ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( arg0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String appendQuotedString ( String arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String appendQuotedString ( String arg0 ) { return \"srini_string\" + arg0 + \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void appendQuotedString ( StringBuilder arg0, String arg1 ) { arg0. append ( '\"' ). append ( arg1 ). append ( '\"' ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuilder appendQuotedString ( StringBuilder arg0, String arg1 ) { return arg0. append ( '\"' ). append ( arg1 ). append ( '\"' ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuilder appendQuotedString ( StringBuilder arg0, char arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; arg0. append ( '\"' ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuilder appendQuotedString ( StringBuilder arg0, String arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; arg0. append ( '\"' ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void appendQuotedString ( StringBuilder arg0, String arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; arg0. append ( '\"' ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuilder appendQuotedString ( String arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( '\"' ). append ( arg0 ). append ( '\"' ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuffer appendQuotedString ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; loc0. append ( arg0 ) ; loc0. append ( '\"' ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuffer appendQuotedString ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ). append ( arg0 ) ; loc0. append ( '\"' ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuffer appendQuotedString ( String arg0, StringBuffer arg1 ) { if ( arg0 == null || arg0. length ( ) == 0 ) { arg1. append ( \"srini_string\" ) ; } arg1. append ( '\"' ). append ( arg0 ). append ( '\"' ) ; return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuffer appendQuotedString ( String arg0 ) { return new StringBuffer ( '\"' ). append ( arg0 ). append ( '\"' ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuffer appendQuotedString ( String arg0, StringBuffer arg1 ) { if ( arg0!= null && arg0. length ( ) > 0 ) { arg1. append ( '\"' ) ; arg1. append ( arg0 ) ; arg1. append ( '\"' ) ; } return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String appendQuotedString ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; loc0. append ( arg0 ) ; loc0. append ( '\"' ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String appendQuotedString ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; if ( loc1 < arg0. length ( ) - 1 ) { loc0. append ( '\"' ) ; } } loc0. append ( '\"' ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String appendQuotedString ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; if ( loc1!= arg0. length ( ) - 1 ) { loc0. append ( '\"' ) ; } } loc0. append ( '\"' ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String appendQuotedString ( String arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; loc0. append ( '\"' ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; if ( loc1 < arg0. length ( ) - 1 ) { loc0. append ( '\"' ) ; } } loc0. append ( '\"' ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private String appendQuotedString ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; if ( loc1 < arg0. length ( ) - 1 ) loc0. append ( '\"' ) ; } loc0. append ( arg0 ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuffer appendQuotedString ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; loc0. append ( arg0 ) ; loc0. append ( '\"' ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuffer appendQuotedString ( String arg0, StringBuffer arg1 ) { arg1. append ( '\"' ) ; arg1. append ( arg0 ) ; arg1. append ( '\"' ) ; return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private StringBuffer appendQuotedString ( String arg0 ) { StringBuffer loc0 = new StringBuffer ( ) ; loc0. append ( '\"' ) ; if ( arg0!= null ) { loc0. append ( arg0 ) ; } loc0. append ( '\"' ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void appendQuotedString ( StringBuffer arg0, String arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void appendQuotedString ( StringBuffer arg0, String arg1 ) { arg0. append ( '\"' ) ; arg0. append ( arg1 ) ; arg0. append ( '\"' ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_2_/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java_268-269": {
      "loc": "268-269",
      "input": "public double getNumericalMean() {\n    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n}",
      "target": "public double getNumericalMean() {\n    return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n}",
      "function range": "267,5-269,5",
      "raw_output": [
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) loc0 = loc2 ; } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 / 2.0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 += arg0 [ loc1 ] ; } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 += arg0 [ loc1 ] ; } return loc0 / arg0. length ; }"
      ],
      "mid_translation": [
        "Gets the numerical mean.",
        "Get the numerical mean.",
        "Gets the numerical mean of the data.",
        "Gets the numerical mean value.",
        "Get the numerical mean of the data."
      ],
      "output": [
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) loc0 = loc2 ; } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 / 2.0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 += arg0 [ loc1 ] ; } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getNumericalMean ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 += arg0 [ loc1 ] ; } return loc0 / arg0. length ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_27_/src/main/java/org/apache/commons/math3/fraction/Fraction.java_597-598": {
      "loc": "597-598",
      "input": "public double percentageValue() {\n    return multiply(100).doubleValue();\n}",
      "target": "public double percentageValue() {\n    return 100 * doubleValue();\n}",
      "function range": "596,5-598,5",
      "raw_output": [
        "PercentType function ( ) { return PercentType. PERCENT ; }",
        "PercentType function ( ) { return PercentType. INSTANCE ; }",
        "PercentFormat function ( ) { return new PercentFormat ( ) ; }",
        "PercentType function ( ) { return PercentType. CONTINUOUS ; }",
        "PercentType function ( ) { return PercentType. PERCENTAGE ; }",
        "PercentType function ( ) { return PercentType. PERCENT ; }",
        "PercentType function ( ) { return PercentType. INSTANCE ; }",
        "Percent function ( ) { return new Percent ( 100 ) ; }",
        "PercentType function ( ) { return PercentType. PERCENTAGE ; }",
        "PercentType function ( ) { return PercentType. CONTINUOUS ; }",
        "PercentType function ( ) { return PercentType. PERCENT ; }",
        "BigDecimal function ( ) { return BigDecimal. valueOf ( \"srini_string\" ) ; }",
        "Percent function ( ) { return new Percent ( value ( ) ) ; }",
        "float function ( ) { return ( float ) ( 1.0f / ( 1.0f + this. percentage ) ) ; }",
        "double function ( ) { return ( ( double ) this. getValue ( ) ) / 100.0 ; }",
        "double function ( double arg0 ) { double loc0 = ( double ) arg0 / 100 ; return ( ( loc0 * 100.0 ) / 100.0 ) ; }",
        "double function ( double arg0 ) { double loc0 = ( double ) arg0 / 100 ; return ( loc0 * 100.0 ) / 100.0 ; }",
        "double function ( double arg0 ) { double loc0 = ( double ) arg0 / 100.0 ; return ( ( loc0 * 100.0 ) / 100.0 ) ; }",
        "double function ( double arg0 ) { double loc0 = ( double ) arg0 ; return ( ( loc0 * 100.0 ) / 100.0 ) ; }",
        "double function ( double arg0 ) { double loc0 = 0.0 ; return ( ( double ) arg0 ) / 100.0 ; }",
        "BigDecimal function ( ) { return new BigDecimal ( \"srini_string\" ) ; }",
        "PercentType function ( ) { return PercentType. PERCENT ; }",
        "BigDecimal function ( ) { return new DecimalFormat ( \"srini_string\" ) ; }",
        "double function ( ) { return 0.0 ; }",
        "BigDecimal function ( Product arg0 ) { return new BigDecimal ( \"srini_string\" ) ; }"
      ],
      "mid_translation": [
        "Gets the percentage value.",
        "Get the percentage value.",
        "Returns the percentage value of this formula.",
        "Returns the percentage value of the formula.",
        "Returns the percentage value of the product."
      ],
      "output": [
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. PERCENT ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. INSTANCE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentFormat percentageValue ( ) { return new PercentFormat ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. CONTINUOUS ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. PERCENTAGE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. PERCENT ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. INSTANCE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Percent percentageValue ( ) { return new Percent ( 100 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. PERCENTAGE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. CONTINUOUS ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. PERCENT ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal percentageValue ( ) { return BigDecimal. valueOf ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Percent percentageValue ( ) { return new Percent ( value ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public float percentageValue ( ) { return ( float ) ( 1.0f / ( 1.0f + this. percentage ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue ( ) { return ( ( double ) this. getValue ( ) ) / 100.0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue ( double arg0 ) { double loc0 = ( double ) arg0 / 100 ; return ( ( loc0 * 100.0 ) / 100.0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double percentageValue ( double arg0 ) { double loc0 = ( double ) arg0 / 100 ; return ( loc0 * 100.0 ) / 100.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double percentageValue ( double arg0 ) { double loc0 = ( double ) arg0 / 100.0 ; return ( ( loc0 * 100.0 ) / 100.0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double percentageValue ( double arg0 ) { double loc0 = ( double ) arg0 ; return ( ( loc0 * 100.0 ) / 100.0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double percentageValue ( double arg0 ) { double loc0 = 0.0 ; return ( ( double ) arg0 ) / 100.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal percentageValue ( ) { return new BigDecimal ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PercentType percentageValue ( ) { return PercentType. PERCENT ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public BigDecimal percentageValue ( ) { return new DecimalFormat ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double percentageValue ( ) { return 0.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public BigDecimal percentageValue ( Product arg0 ) { return new BigDecimal ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_33_/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java_338-339": {
      "loc": "338-339",
      "input": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\n      int col = i + getArtificialVariableOffset();\n      if (getBasicRow(col) == null) {\n        columnsToDrop.add(col);\n      }\n    }\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n      int col = 0;\n      for (int j = 0; j < getWidth(); j++) {\n        if (!columnsToDrop.contains(j)) {\n          matrix[i - 1][col++] = tableau.getEntry(i, j);\n        }\n      }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n      columnLabels.remove((int) columnsToDrop.get(i));\n    }\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}",
      "target": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumArtificialVariables(); i++) {\n      int col = i + getArtificialVariableOffset();\n      if (getBasicRow(col) == null) {\n        columnsToDrop.add(col);\n      }\n    }\n    double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n    for (int i = 1; i < getHeight(); i++) {\n      int col = 0;\n      for (int j = 0; j < getWidth(); j++) {\n        if (!columnsToDrop.contains(j)) {\n          matrix[i - 1][col++] = tableau.getEntry(i, j);\n        }\n      }\n    }\n    for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n      columnLabels.remove((int) columnsToDrop.get(i));\n    }\n    this.tableau = new Array2DRowRealMatrix(matrix);\n    this.numArtificialVariables = 0;\n}",
      "function range": "327,5-367,5",
      "raw_output": [
        "Objective [ ] function ( Objective [ ] arg0 ) { Objective [ ] loc0 = new Objective [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "Object [ ] function ( Object [ ] arg0 ) { Object [ ] loc0 = new Object [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "Objective [ ] function ( Objective [ ] arg0 ) { Objective [ ] loc0 = new Objective [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "Object [ ] function ( Object [ ] arg0 ) { Object [ ] loc0 = new Object [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "Objective [ ] function ( Objective [ ] arg0, int arg1 ) { Objective [ ] loc0 = new Objective [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "void function ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
        "void function ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 % 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
        "void function ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 % 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
        "void function ( Double arg0 ) { double loc0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
        "void function ( Double arg0 ) { double loc0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
        "void function ( Point2D arg0, int arg1 ) { arg0 = arg0. copy ( ) ; arg0 = arg0. copy ( ) ; arg0 = arg0. copy ( ) ; }",
        "void function ( Point2D arg0 ) { arg0. setLocation ( arg0. x, arg0. y ) ; arg0. setLocation ( arg0. x, arg0. y ) ; }",
        "void function ( Double arg0 ) { arg0 = arg0. minus ( 1 ) ; arg0 = arg0. plus ( arg0 ) ; arg0 = arg0. plus ( arg0 ) ; }",
        "void function ( Double arg0 ) { arg0 = arg0. minus ( 1 ) ; arg0 = arg0. plus ( arg0 ) ; arg0 = arg0. plus ( 1 ) ; }",
        "void function ( Point2D arg0, int arg1 ) { arg0. setLocation ( arg1, arg0. x ) ; arg0. setLocation ( arg1, arg0. y ) ; }",
        "void function ( IObjective arg0, int arg1 ) { arg0. drop ( arg1 ) ; }",
        "void function ( Double arg0, int arg1 ) { DropPhase1 loc0 = new DropPhase1 ( arg0, arg1 ) ; arg0. set ( arg1, loc0 ) ; }",
        "void function ( IObjective arg0, int arg1 ) { arg0. drop ( arg1 ) ; arg0. drop ( arg1 ) ; }",
        "void function ( Double arg0, int arg1 ) { arg0 = arg0 - 1 ; arg0 = arg0 * arg0 ; arg0 = arg0 * arg0 ; arg0 = arg0 * arg0 ; }",
        "void function ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; }",
        "void function ( IObjective arg0, int arg1 ) { arg0. drop ( arg1 ) ; }",
        "void function ( Double arg0, int arg1 ) { DropPhase1 loc0 = new DropPhase1 ( arg0, arg1 ) ; arg0. set ( arg1, loc0 ) ; }",
        "void function ( IObjective arg0, int arg1 ) { arg0. drop ( arg1 ) ; arg0. drop ( arg1 ) ; }",
        "void function ( Double arg0, int arg1 ) { arg0 = arg0 - 1 ; arg0 = arg0 * arg0 ; arg0 = arg0 * arg0 ; arg0 = arg0 * arg0 ; }",
        "void function ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; }"
      ],
      "mid_translation": [
        "Method dropPhase1Objective.",
        "Drop the phase 1 objective.",
        "Drops the phase 1 objective.",
        "Drop phase 1 objective.",
        "Drop phase 1 objective."
      ],
      "output": [
        {
          "patch": "protected Objective [ ] dropPhase1Objective ( Objective [ ] arg0 ) { Objective [ ] loc0 = new Objective [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Object [ ] dropPhase1Objective ( Object [ ] arg0 ) { Object [ ] loc0 = new Object [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected Objective [ ] dropPhase1Objective ( Objective [ ] arg0 ) { Objective [ ] loc0 = new Objective [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected Object [ ] dropPhase1Objective ( Object [ ] arg0 ) { Object [ ] loc0 = new Object [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected Objective [ ] dropPhase1Objective ( Objective [ ] arg0, int arg1 ) { Objective [ ] loc0 = new Objective [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 % 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 % 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0 ) { double loc0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0 ) { double loc0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; arg0 = arg0 / 2.0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected void dropPhase1Objective ( Point2D arg0, int arg1 ) { arg0 = arg0. copy ( ) ; arg0 = arg0. copy ( ) ; arg0 = arg0. copy ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( Point2D arg0 ) { arg0. setLocation ( arg0. x, arg0. y ) ; arg0. setLocation ( arg0. x, arg0. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0 ) { arg0 = arg0. minus ( 1 ) ; arg0 = arg0. plus ( arg0 ) ; arg0 = arg0. plus ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0 ) { arg0 = arg0. minus ( 1 ) ; arg0 = arg0. plus ( arg0 ) ; arg0 = arg0. plus ( 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( Point2D arg0, int arg1 ) { arg0. setLocation ( arg1, arg0. x ) ; arg0. setLocation ( arg1, arg0. y ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( IObjective arg0, int arg1 ) { arg0. drop ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0, int arg1 ) { DropPhase1 loc0 = new DropPhase1 ( arg0, arg1 ) ; arg0. set ( arg1, loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( IObjective arg0, int arg1 ) { arg0. drop ( arg1 ) ; arg0. drop ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0, int arg1 ) { arg0 = arg0 - 1 ; arg0 = arg0 * arg0 ; arg0 = arg0 * arg0 ; arg0 = arg0 * arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected void dropPhase1Objective ( IObjective arg0, int arg1 ) { arg0. drop ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0, int arg1 ) { DropPhase1 loc0 = new DropPhase1 ( arg0, arg1 ) ; arg0. set ( arg1, loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( IObjective arg0, int arg1 ) { arg0. drop ( arg1 ) ; arg0. drop ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0, int arg1 ) { arg0 = arg0 - 1 ; arg0 = arg0 * arg0 ; arg0 = arg0 * arg0 ; arg0 = arg0 * arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "protected void dropPhase1Objective ( Double arg0, int arg1 ) { arg0 = arg0 - arg1 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_9_/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java_87-88": {
      "loc": "87-88",
      "input": "public Line revert() {\n    final Line reverted = new Line(zero, zero.subtract(direction));\n    return reverted;\n}",
      "target": "public Line revert() {\n    final Line reverted = new Line(this);\n    reverted.direction = reverted.direction.negate();\n    return reverted;\n}",
      "function range": "86,5-89,5",
      "raw_output": [
        "Line2D function ( Line2D arg0 ) { Point2D loc0 = arg0. getPoint2D ( ) ; Point2D loc1 = arg0. getPoint ( ) ; arg0. setPoint ( loc0. x, loc0. y ) ; arg0. setPoint ( loc1. x, loc1. y ) ; return arg0 ; }",
        "Line2D function ( Line2D arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; Line2D loc0 = ( Line2D ) arg0 ; return new Line2D ( loc0. getX ( ), loc0. getY ( ) ) ; }",
        "Line2D function ( Line2D arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; Line2D loc0 = ( Line2D ) arg0 ; return new Line2D ( loc0, loc0. getX ( ), loc0. getY ( ) ) ; }",
        "Line2D function ( Line2D arg0 ) { Point2D loc0 = arg0. getPoint2D ( ) ; Point2D loc1 = arg0. getPoint ( ) ; arg0. setPoint ( loc0. x, loc0. y ) ; arg0. setPoint ( loc1. x, loc1. y ) ; return loc0 ; }",
        "Line2D function ( Line2D arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; Line2D loc0 = ( Line2D ) arg0 ; return new Line2D ( loc0. getX ( ), loc0. getY ( ), loc0. getZ ( ) ) ; }",
        "String function ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } else if ( arg0. equals ( \"srini_string\" ) ) { return arg0 ; } else { return arg0 ; } }",
        "String function ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } else if ( arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } else { return arg0 ; } }",
        "String function ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } else if ( arg0. equals ( \"srini_string\" ) ) { return arg0 ; } else { return \"srini_string\" ; } }",
        "Line function ( Line arg0 ) { if ( arg0. isZero ( ) ) { return arg0 ; } else { return arg0 ; } }",
        "Lemma function ( Lemma arg0 ) { if ( arg0. isZero ( ) ) { return arg0 ; } else { return arg0 ; } }",
        "Lemma function ( Lemma arg0 ) { Lemma loc0 = Lemma. create ( arg0. getLemma ( ) ) ; arg0. setLemma ( loc0 ) ; return loc0 ; }",
        "Lemma function ( Lemma arg0 ) { if ( arg0. getLemma ( )!= null ) { arg0. setLemma ( arg0. getLemma ( ) ) ; } return arg0 ; }",
        "Lemma function ( Lemma arg0 ) { if ( arg0. getLemma ( )!= null ) { arg0. setLocation ( arg0. getLemma ( ) ) ; } return arg0 ; }",
        "Line function ( int arg0, int arg1 ) { return new Line ( arg0, arg1 ) ; }",
        "Lemma function ( Lemma arg0 ) { if ( arg0. getLemma ( )!= null ) { arg0. setLemma ( arg0. getLemma ( ). toUpperCase ( ) ) ; } return arg0 ; }",
        "LemmaLine function ( LemmaLine arg0 ) { arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; return arg0 ; }",
        "LemmaPosition function ( LemmaPosition arg0 ) { arg0. setOriginal ( arg0. getOriginal ( ) ) ; arg0. setOriginal ( arg0. getOriginal ( ) ) ; }",
        "Line function ( ) { return this ; }",
        "Line function ( ) { Line loc0 = this. getPreviousLine ( ) ; this. setPreviousLine ( loc0 ) ; return loc0 ; }",
        "Line function ( ) { Line loc0 = this. getLastLine ( ) ; this. setLastLine ( loc0 ) ; return loc0 ; }",
        "LemmaLine function ( LemmaLine arg0 ) { arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; return arg0 ; }",
        "Line function ( Line arg0 ) { arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; return arg0 ; }",
        "Line function ( Line arg0 ) { arg0. setOriginal ( arg0. getOriginal ( ) ) ; arg0. setOriginal ( arg0. getOriginal ( ) ) ; return arg0 ; }",
        "Line2D function ( Line2D arg0 ) { arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; return arg0 ; }",
        "Line function ( Line arg0 ) { Point loc0 = arg0. getPoint ( ) ; arg0. setPoint ( loc0. x, loc0. y ) ; return arg0 ; }"
      ],
      "mid_translation": [
        "Revert the line.",
        "Revert the line to a zero line.",
        "Revert to a zero line.",
        "Revert the line to its original value.",
        "Revert the line to the original value."
      ],
      "output": [
        {
          "patch": "public Line2D revert ( Line2D arg0 ) { Point2D loc0 = arg0. getPoint2D ( ) ; Point2D loc1 = arg0. getPoint ( ) ; arg0. setPoint ( loc0. x, loc0. y ) ; arg0. setPoint ( loc1. x, loc1. y ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line2D revert ( Line2D arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; Line2D loc0 = ( Line2D ) arg0 ; return new Line2D ( loc0. getX ( ), loc0. getY ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line2D revert ( Line2D arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; Line2D loc0 = ( Line2D ) arg0 ; return new Line2D ( loc0, loc0. getX ( ), loc0. getY ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line2D revert ( Line2D arg0 ) { Point2D loc0 = arg0. getPoint2D ( ) ; Point2D loc1 = arg0. getPoint ( ) ; arg0. setPoint ( loc0. x, loc0. y ) ; arg0. setPoint ( loc1. x, loc1. y ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line2D revert ( Line2D arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; Line2D loc0 = ( Line2D ) arg0 ; return new Line2D ( loc0. getX ( ), loc0. getY ( ), loc0. getZ ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String revert ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } else if ( arg0. equals ( \"srini_string\" ) ) { return arg0 ; } else { return arg0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public String revert ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } else if ( arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } else { return arg0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public String revert ( String arg0 ) { if ( arg0. equals ( \"srini_string\" ) ) { return \"srini_string\" ; } else if ( arg0. equals ( \"srini_string\" ) ) { return arg0 ; } else { return \"srini_string\" ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public Line revert ( Line arg0 ) { if ( arg0. isZero ( ) ) { return arg0 ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Lemma revert ( Lemma arg0 ) { if ( arg0. isZero ( ) ) { return arg0 ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Lemma revert ( Lemma arg0 ) { Lemma loc0 = Lemma. create ( arg0. getLemma ( ) ) ; arg0. setLemma ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Lemma revert ( Lemma arg0 ) { if ( arg0. getLemma ( )!= null ) { arg0. setLemma ( arg0. getLemma ( ) ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Lemma revert ( Lemma arg0 ) { if ( arg0. getLemma ( )!= null ) { arg0. setLocation ( arg0. getLemma ( ) ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line revert ( int arg0, int arg1 ) { return new Line ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Lemma revert ( Lemma arg0 ) { if ( arg0. getLemma ( )!= null ) { arg0. setLemma ( arg0. getLemma ( ). toUpperCase ( ) ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LemmaLine revert ( LemmaLine arg0 ) { arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LemmaPosition revert ( LemmaPosition arg0 ) { arg0. setOriginal ( arg0. getOriginal ( ) ) ; arg0. setOriginal ( arg0. getOriginal ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line revert ( ) { return this ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Line revert ( ) { Line loc0 = this. getPreviousLine ( ) ; this. setPreviousLine ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line revert ( ) { Line loc0 = this. getLastLine ( ) ; this. setLastLine ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public LemmaLine revert ( LemmaLine arg0 ) { arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line revert ( Line arg0 ) { arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line revert ( Line arg0 ) { arg0. setOriginal ( arg0. getOriginal ( ) ) ; arg0. setOriginal ( arg0. getOriginal ( ) ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line2D revert ( Line2D arg0 ) { arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; arg0. setOriginalValue ( arg0. getOriginalValue ( ) ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Line revert ( Line arg0 ) { Point loc0 = arg0. getPoint ( ) ; arg0. setPoint ( loc0. x, loc0. y ) ; return arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_56_/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java_237-239": {
      "loc": "237-239",
      "input": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    int idx = 1;\n    while (count < index) {\n        count += idx;\n        ++idx;\n    }\n    --idx;\n    indices[last] = idx;\n    return indices;\n}",
      "target": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n    indices[last] = index - count;\n    return indices;\n}",
      "function range": "216,5-246,5",
      "raw_output": [
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < Integer, Integer > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( long arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; ++ loc1 ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; ++ loc1 ) { loc0. put ( loc1, new HashMap < Integer, Integer > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( Index arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Integer > loc1 : arg0. entrySet ( ) ) { Map < Integer, Map < Integer, Integer >> loc2 = loc1. getValue ( ) ; loc0. put ( loc2. getKey ( ), loc2. getCount ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < Integer, Integer > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( long arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( Index arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : arg0. entrySet ( ) ) { Map < Integer, Integer > loc2 = loc1. getValue ( ) ; loc0. put ( loc2. getKey ( ), loc2. getCount ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( long arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts ( arg0 ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { Map < Integer, Map < Integer, Integer >> loc2 = ( Map < Integer, Integer > ) counts. get ( loc1 ) ; if ( loc2!= null ) { loc0. put ( loc1, loc2 ) ; } } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { Map < Integer, Map < Integer, Integer >> loc2 = ( Map < Integer, Map < Integer, Integer >> loc3 = loc1. get ( arg0 ) ; loc0. put ( loc2, loc3 ) ; } return loc0 ; }",
        "Map < Integer, Long > function ( Map < Integer, Long > arg0 ) { Map < Integer, Long > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0. keySet ( ) ) { loc0. put ( loc1, loc0. get ( loc1 ) ) ; } return loc0 ; }",
        "Map < Integer, Long > function ( Map < Integer, Long > arg0 ) { Map < Integer, Long > loc0 = new HashMap < > ( ) ; for ( Integer loc1 : arg0. keySet ( ) ) { loc0. put ( loc1, arg0. get ( loc1 ). get ( loc1 ) ) ; } return loc0 ; }",
        "Map < Integer, Long > function ( Map < Integer, Long > arg0 ) { Map < Integer, Long > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, Long > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < Integer, Long > function ( Map < Integer, Long > arg0 ) { Map < Integer, Long > loc0 = new HashMap < > ( ) ; for ( Integer loc1 : arg0. keySet ( ) ) { loc0. put ( loc1, arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts. entrySet ( ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } Map < Integer, Map < Integer, Integer >> loc1 = ( Map < Integer, Map < Integer, Integer >> ) loc0. get ( arg0 ) ; return loc1 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts. entrySet ( ) ) { if ( arg0 == loc1. getKey ( ) ) { loc0. put ( loc1. getValue ( ), loc1. getCount ( arg0 ) ) ; } } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : getCounts ( arg0 ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts. entrySet ( ) ) { if ( arg0 == loc1. getKey ( ) ) { loc0. put ( loc1. getValue ( ), loc1. getCount ( ) ) ; } } return loc0 ; }",
        "Map < Integer, Map < Integer, Integer >> function ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts. entrySet ( ) ) { Map < Integer, Integer > loc2 = loc1. getValue ( arg0 ) ; loc0. put ( loc2. getKey ( ), loc2. getCount ( arg0 ) ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Gets the counts for the specified index.",
        "Gets the counts for the given index.",
        "Gets the counts for a given index.",
        "Gets the counts.",
        "Gets the counts for a specific index."
      ],
      "output": [
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < Integer, Integer > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( long arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; ++ loc1 ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; ++ loc1 ) { loc0. put ( loc1, new HashMap < Integer, Integer > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( Index arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Integer > loc1 : arg0. entrySet ( ) ) { Map < Integer, Map < Integer, Integer >> loc2 = loc1. getValue ( ) ; loc0. put ( loc2. getKey ( ), loc2. getCount ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < Integer, Integer > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( long arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( Index arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : arg0. entrySet ( ) ) { Map < Integer, Integer > loc2 = loc1. getValue ( ) ; loc0. put ( loc2. getKey ( ), loc2. getCount ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( long arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. put ( loc1, new HashMap < > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts ( arg0 ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { Map < Integer, Map < Integer, Integer >> loc2 = ( Map < Integer, Integer > ) counts. get ( loc1 ) ; if ( loc2!= null ) { loc0. put ( loc1, loc2 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { Map < Integer, Map < Integer, Integer >> loc2 = ( Map < Integer, Map < Integer, Integer >> loc3 = loc1. get ( arg0 ) ; loc0. put ( loc2, loc3 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Long > getCounts ( Map < Integer, Long > arg0 ) { Map < Integer, Long > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0. keySet ( ) ) { loc0. put ( loc1, loc0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Long > getCounts ( Map < Integer, Long > arg0 ) { Map < Integer, Long > loc0 = new HashMap < > ( ) ; for ( Integer loc1 : arg0. keySet ( ) ) { loc0. put ( loc1, arg0. get ( loc1 ). get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Long > getCounts ( Map < Integer, Long > arg0 ) { Map < Integer, Long > loc0 = new HashMap < > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, Long > loc1 : arg0. entrySet ( ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Long > getCounts ( Map < Integer, Long > arg0 ) { Map < Integer, Long > loc0 = new HashMap < > ( ) ; for ( Integer loc1 : arg0. keySet ( ) ) { loc0. put ( loc1, arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts. entrySet ( ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } Map < Integer, Map < Integer, Integer >> loc1 = ( Map < Integer, Map < Integer, Integer >> ) loc0. get ( arg0 ) ; return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts. entrySet ( ) ) { if ( arg0 == loc1. getKey ( ) ) { loc0. put ( loc1. getValue ( ), loc1. getCount ( arg0 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : getCounts ( arg0 ) ) { loc0. put ( loc1. getKey ( ), loc1. getValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts. entrySet ( ) ) { if ( arg0 == loc1. getKey ( ) ) { loc0. put ( loc1. getValue ( ), loc1. getCount ( ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Map < Integer, Map < Integer, Integer >> getCounts ( int arg0 ) { Map < Integer, Map < Integer, Integer >> loc0 = new HashMap < > ( ) ; for ( Map. Entry < Integer, Map < Integer, Integer >> loc1 : counts. entrySet ( ) ) { Map < Integer, Integer > loc2 = loc1. getValue ( arg0 ) ; loc0. put ( loc2. getKey ( ), loc2. getCount ( arg0 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_96_/src/java/org/apache/commons/math/complex/Complex.java_258-259": {
      "loc": "258-259",
      "input": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
      "target": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n                ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n            }\n        } catch (ClassCastException ex) {\n            ret = false;\n        }\n    }\n    return ret;\n}",
      "function range": "245,5-267,5",
      "raw_output": [
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. getClass ( ). equals ( loc0. getClass ( ) ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return this. getClass ( ). equals ( ( ( StandardXYSeriesLabelGenerator ) arg0 ). getClass ( ) ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
        "boolean function ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. getClass ( ). equals ( loc0. getClass ( ) ) ; }",
        "boolean function ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. getClass ( ). equals ( loc0. getClass ( ) ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return! this. equals ( loc0 ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return ( this. getClass ( ) == loc0. getClass ( ) ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return true ; }"
      ],
      "mid_translation": [
        "Returns true if this object equals the specified object.",
        "Equals returns true if this object equals the specified object.",
        "Equals returns true if this object equals the given object.",
        "Returns true if this object equals the given object.",
        "Returns true if this object equals another object."
      ],
      "output": [
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; if (! this. equals ( loc0 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. getClass ( ). equals ( loc0. getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return this. getClass ( ). equals ( ( ( StandardXYSeriesLabelGenerator ) arg0 ). getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } final StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( final Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return super. equals ( ( StandardXYSeriesLabelGenerator ) arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. getClass ( ). equals ( loc0. getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( this == arg0 ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return this. getClass ( ). equals ( loc0. getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return! this. equals ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } StandardXYSeriesLabelGenerator loc0 = ( StandardXYSeriesLabelGenerator ) arg0 ; return ( this. getClass ( ) == loc0. getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean equals ( Object arg0 ) { if ( arg0 == null ) { return false ; } if ( arg0 == this ) { return true ; } if (! ( arg0 instanceof StandardXYSeriesLabelGenerator ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_91_/src/java/org/apache/commons/math/fraction/Fraction.java_259-261": {
      "loc": "259-261",
      "input": "public int compareTo(Fraction object) {\n    double nOd = doubleValue();\n    double dOn = object.doubleValue();\n    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n}",
      "target": "public int compareTo(Fraction object) {\n    long nOd = ((long) numerator) * object.denominator;\n    long dOn = ((long) denominator) * object.numerator;\n    return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n}",
      "function range": "258,5-262,5",
      "raw_output": [
        "boolean function ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == null ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. compareTo ( arg1 ) <= 0 ; }",
        "boolean function ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { return ( arg0 == null )? ( arg1 == null ) : arg0. compareTo ( arg1 ) <= 0 ; } return arg0. compareTo ( arg1 ) <= 0 ; }",
        "boolean function ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == null ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. compareTo ( arg1 ) <= 0 ; }",
        "boolean function ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == null ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. compareTo ( arg1 ) >= 0 ; }",
        "boolean function ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 == null || arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. compareTo ( arg1 ) <= 0 ; }",
        "int function ( Fraction arg0, Fraction arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else { return arg0. compareTo ( arg1 ) ; } } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( Fraction arg0, Fraction arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. compareTo ( arg1 ) ; }",
        "int function ( Fraction arg0, Fraction arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg1 == null ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( Fraction arg0, Fraction arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( Fraction arg0, Fraction arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg1 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 instanceof Number ) { Number loc0 = ( Number ) arg0 ; Number loc1 = ( Number ) arg1 ; return ( loc0. compareTo ( loc1 ) == 0 ) ; } return ( loc0. compareTo ( loc1 ) == 0 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; Fraction loc1 = ( Fraction ) arg1 ; if ( loc0. compareTo ( loc1 ) == 0 ) { return true ; } else if ( loc0. compareTo ( loc1 ) == 0 ) { return false ; } return true ; } else { return false ; } }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; Fraction loc1 = ( Fraction ) arg1 ; return ( loc0. compareTo ( loc1 ) == 0 ) ; } else { return false ; } }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; Fraction loc1 = ( Fraction ) arg1 ; if ( loc0. compareTo ( loc1 ) == 0 ) { return true ; } else if ( loc0. compareTo ( loc1 ) == 0 ) { return false ; } else return true ; } else { return false ; } }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; Fraction loc1 = ( Fraction ) arg1 ; if ( loc0. compareTo ( loc1 ) == 0 ) { return true ; } else if ( loc0. compareTo ( loc1 ) == 0 ) { return false ; } } else { return true ; } }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; if ( this. compareTo ( loc0 ) == 0 ) { return true ; } else if ( this. compareTo ( loc0 ) == 1 ) { return true ; } else { return false ; } } else { return false ; } }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; return this. fraction. compareTo ( loc0. fraction ) == 0 ; } else if ( this. fraction == arg0 ) { return true ; } else { return false ; } }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; return this. fraction. compareTo ( loc0. fraction ) == 0 ; } else if ( this. fraction!= null ) { return super. equals ( loc0. fraction ) ; } else { return false ; } }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; if ( this. signum ( )!= loc0. signum ( ) ) { return false ; } else if ( this. signum ( )!= loc0. signum ( ) ) { return false ; } else { return true ; } } else { return false ; } }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; if ( this. signum ( )!= loc0. signum ( ) ) { return false ; } else if ( this. signum ( )!= loc0. signum ( ) ) { return false ; } else { return true ; } } else { return true ; } }",
        "int function ( Number arg0, Number arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == null ) { return 1 ; } else if ( arg1 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( Number arg0, Number arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == null ) { return 1 ; } else if ( arg1 == null ) { return 0 ; } else { return arg1. compareTo ( arg0 ) ; } }",
        "int function ( Number arg0, Number arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == null ) { return 1 ; } else if ( arg1 == null ) { return 1 ; } return arg0. compareTo ( arg1 ) ; }",
        "int function ( Number arg0, Number arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == null ) { return 1 ; } else if ( arg1 == null ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( Number arg0, Number arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else if ( arg0 == null ) { return 0 ; } else if ( arg1 == null ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }"
      ],
      "mid_translation": [
        "Compares two fractions.",
        "Compares two Fraction objects.",
        "Compares two fraction objects.",
        "Compares this fraction with another fraction.",
        "Compare two fractions."
      ],
      "output": [
        {
          "patch": "public boolean compareTo ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == null ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. compareTo ( arg1 ) <= 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { return ( arg0 == null )? ( arg1 == null ) : arg0. compareTo ( arg1 ) <= 0 ; } return arg0. compareTo ( arg1 ) <= 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == null ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. compareTo ( arg1 ) <= 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == null ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. compareTo ( arg1 ) >= 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Number arg0, Number arg1 ) { if ( arg0 == null || arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg0 == null || arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. compareTo ( arg1 ) <= 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int compareTo ( Fraction arg0, Fraction arg1 ) { if ( arg0 == null ) { if ( arg1 == null ) { return 0 ; } else if ( arg1 == null ) { return - 1 ; } else { return arg0. compareTo ( arg1 ) ; } } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public int compareTo ( Fraction arg0, Fraction arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. compareTo ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0, Object arg1 ) { if ( arg0 instanceof Number ) { Number loc0 = ( Number ) arg0 ; Number loc1 = ( Number ) arg1 ; return ( loc0. compareTo ( loc1 ) == 0 ) ; } return ( loc0. compareTo ( loc1 ) == 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0, Object arg1 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; Fraction loc1 = ( Fraction ) arg1 ; if ( loc0. compareTo ( loc1 ) == 0 ) { return true ; } else if ( loc0. compareTo ( loc1 ) == 0 ) { return false ; } return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0, Object arg1 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; Fraction loc1 = ( Fraction ) arg1 ; return ( loc0. compareTo ( loc1 ) == 0 ) ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0, Object arg1 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; Fraction loc1 = ( Fraction ) arg1 ; if ( loc0. compareTo ( loc1 ) == 0 ) { return true ; } else if ( loc0. compareTo ( loc1 ) == 0 ) { return false ; } else return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0, Object arg1 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; Fraction loc1 = ( Fraction ) arg1 ; if ( loc0. compareTo ( loc1 ) == 0 ) { return true ; } else if ( loc0. compareTo ( loc1 ) == 0 ) { return false ; } } else { return true ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; if ( this. compareTo ( loc0 ) == 0 ) { return true ; } else if ( this. compareTo ( loc0 ) == 1 ) { return true ; } else { return false ; } } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; return this. fraction. compareTo ( loc0. fraction ) == 0 ; } else if ( this. fraction == arg0 ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; return this. fraction. compareTo ( loc0. fraction ) == 0 ; } else if ( this. fraction!= null ) { return super. equals ( loc0. fraction ) ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; if ( this. signum ( )!= loc0. signum ( ) ) { return false ; } else if ( this. signum ( )!= loc0. signum ( ) ) { return false ; } else { return true ; } } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean compareTo ( Object arg0 ) { if ( arg0 instanceof Fraction ) { Fraction loc0 = ( Fraction ) arg0 ; if ( this. signum ( )!= loc0. signum ( ) ) { return false ; } else if ( this. signum ( )!= loc0. signum ( ) ) { return false ; } else { return true ; } } else { return true ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_80_/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java_1135-1136": {
      "loc": "1135-1136",
      "input": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        int j = 4 * n - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
      "target": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n        int j = 4 * (n - 1);\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
      "function range": "1132,5-1147,5",
      "raw_output": [
        "int function ( int arg0 ) { arg0 = arg0 < 0? - arg0 : arg0 ; return arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { return arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; return arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) throw new IllegalArgumentException ( \"srini_string\" ) ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; arg0 ^= arg0 >> 32 ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; arg0 ^= arg0 >> 16 ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; arg0 = arg0 >> 16 ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 = arg0 < 0? - arg0 : arg0 ; return arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { return arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) throw new IllegalArgumentException ( \"srini_string\" ) ; return arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) arg0 *= - 1 ; if ( arg0 > 0 ) arg0 *= - 1 ; if ( arg0 < 0 ) arg0 *= 1 ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 = arg0 < 0? - arg0 : arg0 ; return arg0 < 0? - arg0 : arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { return arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) throw new IllegalArgumentException ( \"srini_string\" ) ; return arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) arg0 = - arg0 ; if ( arg0 > 1 ) arg0 = 1 ; if ( arg0 < 0 ) arg0 = 0 ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; return arg0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) arg0 = - arg0 ; return arg0 ; }",
        "int function ( int arg0 ) { return arg0 < 0? - arg0 : arg0 ; }",
        "int function ( int arg0 ) { if ( arg0 < - arg0 ) { arg0 = - arg0 ; } if ( arg0 > arg0 ) { arg0 = arg0 ; } if ( arg0 < arg0 ) { arg0 = arg0 ; } return arg0 ; }",
        "int function ( int arg0 ) { if ( arg0 < - arg0 ) { arg0 = - arg0 ; } if ( arg0 > arg0 ) { arg0 = arg0 ; } return arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; return arg0 ; }",
        "int function ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; return arg0 ; }"
      ],
      "mid_translation": [
        "flip if warranted.",
        "flip if warranted",
        "flip if widanted.",
        "flip if it is warranted.",
        "flip if it is warranted"
      ],
      "output": [
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 = arg0 < 0? - arg0 : arg0 ; return arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { return arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; return arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { if ( arg0 < 0 ) throw new IllegalArgumentException ( \"srini_string\" ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; arg0 ^= arg0 >> 32 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; arg0 ^= arg0 >> 16 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; arg0 = arg0 >> 16 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 = arg0 < 0? - arg0 : arg0 ; return arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { return arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { if ( arg0 < 0 ) throw new IllegalArgumentException ( \"srini_string\" ) ; return arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { if ( arg0 < 0 ) arg0 *= - 1 ; if ( arg0 > 0 ) arg0 *= - 1 ; if ( arg0 < 0 ) arg0 *= 1 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 = arg0 < 0? - arg0 : arg0 ; return arg0 < 0? - arg0 : arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { return arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { if ( arg0 < 0 ) throw new IllegalArgumentException ( \"srini_string\" ) ; return arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { if ( arg0 < 0 ) arg0 = - arg0 ; if ( arg0 > 1 ) arg0 = 1 ; if ( arg0 < 0 ) arg0 = 0 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { if ( arg0 < 0 ) arg0 = - arg0 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { return arg0 < 0? - arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { if ( arg0 < - arg0 ) { arg0 = - arg0 ; } if ( arg0 > arg0 ) { arg0 = arg0 ; } if ( arg0 < arg0 ) { arg0 = arg0 ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { if ( arg0 < - arg0 ) { arg0 = - arg0 ; } if ( arg0 > arg0 ) { arg0 = arg0 ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private int flipIfWarranted ( int arg0 ) { arg0 ^= arg0 >> 1 ; arg0 ^= arg0 >> 2 ; arg0 ^= arg0 >> 4 ; arg0 ^= arg0 >> 8 ; arg0 ^= arg0 >> 16 ; arg0 ^= arg0 >> 32 ; return arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_70_/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java_72-73": {
      "loc": "72-73",
      "input": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(min, max);\n}",
      "target": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    return solve(f, min, max);\n}",
      "function range": "70,5-73,5",
      "raw_output": [
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg0 ) ) ; } }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg1 ) ) ; } }",
        "double function ( final double arg0, final double arg1 ) { return 1 / ( 1 + Math. exp ( - arg1 ) ) ; }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg0 ; } }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg1 ; } }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg0 ) ) ; } }",
        "double function ( final double arg0, final double arg1 ) { return 1 / ( 1 + Math. exp ( - arg1 ) ) ; }",
        "double function ( final double arg0, final double arg1 ) { return 1 / ( 1 + Math. exp ( - arg0 ) ) ; }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg1 ) ) ; } }",
        "double function ( final double arg0, final double arg1 ) { return 1 / ( 1 + Math. exp ( - arg0 ) * arg1 ) ; }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg0 ) ) ; } }",
        "double function ( double arg0, double arg1 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg1 == 0.0 ) { return 1.0 ; } else { return arg1 / arg0 ; } }",
        "double function ( double arg0, double arg1 ) { return 1 / ( 1 + Math. exp ( - arg0 ) ) ; }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg1 ; } }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg0 ; } }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0 [ loc1 ] = loc2 ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; loc0 [ loc1 ] = loc2 ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ loc1 ]. length ; loc2 ++ ) { loc0 [ loc2 ] = arg0 [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ loc1 ]. length ; loc2 ++ ) { loc0 [ loc1 ] [ loc2 ] = 1 ; } } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ loc1 ]. length ; loc2 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ loc1 ]. length ; loc2 ++ ) { loc0 [ loc1 ] = arg0 [ loc2 ] [ loc1 ] ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Solve an univariate real function.",
        "Solve a single univariate real function.",
        "Solve a single univariate function.",
        "Solves a single univariate function.",
        "Solve an univariate complex function."
      ],
      "output": [
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg0 ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg1 ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( final double arg0, final double arg1 ) { return 1 / ( 1 + Math. exp ( - arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg0 ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( final double arg0, final double arg1 ) { return 1 / ( 1 + Math. exp ( - arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( final double arg0, final double arg1 ) { return 1 / ( 1 + Math. exp ( - arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg1 ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( final double arg0, final double arg1 ) { return 1 / ( 1 + Math. exp ( - arg0 ) * arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg0 ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg1 == 0.0 ) { return 1.0 ; } else { return arg1 / arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { return 1 / ( 1 + Math. exp ( - arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0 [ loc1 ] = loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { double loc2 = arg0 [ loc1 ] ; loc0 [ loc1 ] = loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ loc1 ]. length ; loc2 ++ ) { loc0 [ loc2 ] = arg0 [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ loc1 ]. length ; loc2 ++ ) { loc0 [ loc1 ] [ loc2 ] = 1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ loc1 ]. length ; loc2 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0 [ loc1 ]. length ; loc2 ++ ) { loc0 [ loc1 ] = arg0 [ loc2 ] [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Lang_45_/src/java/org/apache/commons/lang/WordUtils.java_613-614": {
      "loc": "613-614",
      "input": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return StringUtils.EMPTY;\n    }\n    if (upper == -1 || upper > str.length()) {\n        upper = str.length();\n    }\n    if (upper < lower) {\n        upper = lower;\n    }\n    StringBuffer result = new StringBuffer();\n    int index = StringUtils.indexOf(str, \" \", lower);\n    if (index == -1) {\n        result.append(str.substring(0, upper));\n        if (upper != str.length()) {\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n    } else if (index > upper) {\n        result.append(str.substring(0, upper));\n        result.append(StringUtils.defaultString(appendToEnd));\n    } else {\n        result.append(str.substring(0, index));\n        result.append(StringUtils.defaultString(appendToEnd));\n    }\n    return result.toString();\n}",
      "target": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return StringUtils.EMPTY;\n    }\n    if (lower > str.length()) {\n        lower = str.length();    \n    }\n    if (upper == -1 || upper > str.length()) {\n        upper = str.length();\n    }\n    if (upper < lower) {\n        upper = lower;\n    }\n    StringBuffer result = new StringBuffer();\n    int index = StringUtils.indexOf(str, \" \", lower);\n    if (index == -1) {\n        result.append(str.substring(0, upper));\n        if (upper != str.length()) {\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n    } else if (index > upper) {\n        result.append(str.substring(0, upper));\n        result.append(StringUtils.defaultString(appendToEnd));\n    } else {\n        result.append(str.substring(0, index));\n        result.append(StringUtils.defaultString(appendToEnd));\n    }\n    return result.toString();\n}",
      "function range": "605,5-642,5",
      "raw_output": [
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = Character. toLowerCase ( loc1 [ loc2 ] ) ; } return new String ( loc1 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) loc1 [ loc2 ] = ( char ) loc1 [ loc2 ] ; return new String ( loc1 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = ( char ) loc0 [ loc2 ] ; } return new String ( loc1 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc0 [ loc2 ] = ( char ) loc1 [ loc2 ] ; } return new String ( loc1 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = ( char ) loc0 [ loc2 ] ; if ( loc1 [ loc2 ] == arg0 ) return loc1 [ loc2 ] ; } return new String ( loc1 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isLetter ( loc2 ) ) loc0. append ( loc2 ) ; } return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isLetter ( loc2 ) ) { loc0. append ( loc2 ) ; } } return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isDigit ( loc2 ) ) loc0. append ( loc2 ) ; } return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isDigit ( loc2 ) ) { loc0. append ( loc2 ) ; } } return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isLetter ( loc2 ) ) loc0. append ( loc2 ) ; } return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isDigit ( loc2 ) ) loc0. append ( loc2 ) ; } return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } int loc0 = arg0. length ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0. charAt ( loc2 ) ; } return new String ( loc1 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0. toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = Character. toLowerCase ( loc1 [ loc2 ] ) ; } return new String ( loc1 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } int loc0 = arg0. length ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0. charAt ( loc2 ) ; } return new String ( loc1 ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = ( char ) loc0 [ loc2 ] ; } return new String ( loc1 ) ; }",
        "String function ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } StringBuilder loc0 = new StringBuilder ( arg0. length ( ) ) ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { loc0. append ( arg1 [ loc1 ] ) ; } return loc0. toString ( ) ; }",
        "String function ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } StringBuilder loc0 = new StringBuilder ( arg0. length ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg1 [ loc1 ] ) ; } return loc0. toString ( ) ; }",
        "String function ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } arg0 = arg0. trim ( ) ; for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( Character. isDigit ( arg1 [ loc0 ] ) ) { arg0 = arg0. substring ( 0, loc0 ) ; } } return arg0 ; }",
        "String function ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { loc0. append ( arg1 [ loc1 ] ) ; if ( loc1 < arg0. length ( ) - 1 ) { loc0. append ( arg0 [ loc1 ] ) ; } } return loc0. toString ( ) ; }",
        "String function ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { loc0. append ( arg1 [ loc1 ] ) ; } return loc0. toString ( ) ; }"
      ],
      "mid_translation": [
        "Abbreviate a string.",
        "Abbreviate a String.",
        "Abbreviate String.",
        "Abbreviate string.",
        "Abbreviates the specified string with the specified characters."
      ],
      "output": [
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = Character. toLowerCase ( loc1 [ loc2 ] ) ; } return new String ( loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) loc1 [ loc2 ] = ( char ) loc1 [ loc2 ] ; return new String ( loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = ( char ) loc0 [ loc2 ] ; } return new String ( loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc0 [ loc2 ] = ( char ) loc1 [ loc2 ] ; } return new String ( loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = ( char ) loc0 [ loc2 ] ; if ( loc1 [ loc2 ] == arg0 ) return loc1 [ loc2 ] ; } return new String ( loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isLetter ( loc2 ) ) loc0. append ( loc2 ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isLetter ( loc2 ) ) { loc0. append ( loc2 ) ; } } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isDigit ( loc2 ) ) loc0. append ( loc2 ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isDigit ( loc2 ) ) { loc0. append ( loc2 ) ; } } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isLetter ( loc2 ) ) loc0. append ( loc2 ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { char loc2 = arg0. charAt ( loc1 ) ; if ( Character. isDigit ( loc2 ) ) loc0. append ( loc2 ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } int loc0 = arg0. length ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0. charAt ( loc2 ) ; } return new String ( loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) loc0. append ( arg0. charAt ( loc1 ) ) ; return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) return null ; if ( arg0. length ( ) == 0 ) return \"srini_string\" ; StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg0. charAt ( loc1 ) ) ; } return loc0. toString ( ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = Character. toLowerCase ( loc1 [ loc2 ] ) ; } return new String ( loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return null ; } if ( arg0. length ( ) == 0 ) { return \"srini_string\" ; } int loc0 = arg0. length ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0. charAt ( loc2 ) ; } return new String ( loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0 ) { if ( arg0 == null ) { return null ; } arg0 = arg0. trim ( ) ; int loc0 = arg0. loc0 ( ) ; char [ ] loc1 = new char [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc1. length ; loc2 ++ ) { loc1 [ loc2 ] = ( char ) loc0 [ loc2 ] ; } return new String ( loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String abbreviate ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } StringBuilder loc0 = new StringBuilder ( arg0. length ( ) ) ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { loc0. append ( arg1 [ loc1 ] ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } StringBuilder loc0 = new StringBuilder ( arg0. length ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0. append ( arg1 [ loc1 ] ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } arg0 = arg0. trim ( ) ; for ( int loc0 = 0 ; loc0 < arg1. length ; loc0 ++ ) { if ( Character. isDigit ( arg1 [ loc0 ] ) ) { arg0 = arg0. substring ( 0, loc0 ) ; } } return arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String abbreviate ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { loc0. append ( arg1 [ loc1 ] ) ; if ( loc1 < arg0. length ( ) - 1 ) { loc0. append ( arg0 [ loc1 ] ) ; } } return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String abbreviate ( String arg0, char [ ] arg1 ) { if ( arg0 == null ) { return null ; } if ( arg1 == null ) { return arg0 ; } StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg1. length ; loc1 ++ ) { loc0. append ( arg1 [ loc1 ] ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Math_30_/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java_173-174": {
      "loc": "173-174",
      "input": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n    final int n1n2prod = n1 * n2;\n    final double EU = n1n2prod / 2.0;\n    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n    final double z = (Umin - EU) / FastMath.sqrt(VarU);\n    final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n    return 2 * standardNormal.cumulativeProbability(z);\n}",
      "target": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n    final double n1n2prod = n1 * n2;\n    final double EU = n1n2prod / 2.0;\n    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n    final double z = (Umin - EU) / FastMath.sqrt(VarU);\n    final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n    return 2 * standardNormal.cumulativeProbability(z);\n}",
      "function range": "168,5-184,5",
      "raw_output": [
        "double function ( double arg0 ) { return AsymptoticP ( arg0 ) ; }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else { return AsymptoticP ( arg0 ) ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 0.0 ; } else { return AsymptoticP ( arg0 ) ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return AsymptoticP ( arg0 ) ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return AsymptoticP. value ( arg0 ) ; } }",
        "double function ( double arg0 ) { return AsymptoticP ( arg0 ) ; }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return AsymptoticP. value ( arg0 ) ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else { return 0.0 ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return AsymptoticP ( arg0 ) ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return 0.0 ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else if ( arg0 <= 3.0 ) { return 3.0 ; } else { return arg0 ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else if ( arg0 <= 3.0 ) { return 3.0 ; } else { return 0.0 ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else { return AsymptoticPValue. AsymptoticPValue ( arg0 ) ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else if ( arg0 <= 3.0 ) { return 3.0 ; } else { return 2.0 ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 3.0 ; return arg0 ; }",
        "double function ( double arg0 ) { return AsymptoticP ( arg0 ) ; }",
        "double function ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 < 0.0 || arg0 > 1.0 ) { return 1.0 ; } else { return AsymptoticP - arg0 ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else { return AsymptoticP - arg0 ; } }",
        "double function ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 == 1.0 ) { return 1.0 ; } else if ( arg0 == 0.0 ) { return 0.0 ; } else { return AsymptoticP - arg0 ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 0.0 ; } else { return AsymptoticP - arg0 ; } }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 2.0 ; if ( arg0 <= 4.0 ) return 3.0 ; if ( arg0 <= 8.0 ) return 3.0 ; throw new IllegalArgumentException ( \"srini_string\" ) ; }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 3.0 ; if ( arg0 <= 4.0 ) return 3.0 ; if ( arg0 <= 8.0 ) return 3.0 ; throw new IllegalArgumentException ( \"srini_string\" ) ; }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; else if ( arg0 <= 1.0 ) return 1.0 ; else if ( arg0 <= 2.0 ) return 2.0 ; else if ( arg0 <= 3.0 ) return 3.0 ; else return 0.0 ; }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 3.0 ; return arg0 ; }",
        "double function ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 2.0 ; if ( arg0 <= 4.0 ) return 3.0 ; if ( arg0 <= 8.0 ) return 3.0 ; return 0.0 ; }"
      ],
      "mid_translation": [
        "Calculate the Asymptotic P value.",
        "Calculates the Asymptotic P value.",
        "Calculate the Asymptotic PValue.",
        "Calculate the Asymptotic P - value.",
        "Calculate the asymptotic P value."
      ],
      "output": [
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { return AsymptoticP ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else { return AsymptoticP ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 0.0 ; } else { return AsymptoticP ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return AsymptoticP ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return AsymptoticP. value ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { return AsymptoticP ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return AsymptoticP. value ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else { return 0.0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return AsymptoticP ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else { return 0.0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else if ( arg0 <= 3.0 ) { return 3.0 ; } else { return arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else if ( arg0 <= 3.0 ) { return 3.0 ; } else { return 0.0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else { return AsymptoticPValue. AsymptoticPValue ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else if ( arg0 <= 3.0 ) { return 3.0 ; } else { return 2.0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 3.0 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { return AsymptoticP ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 < 0.0 || arg0 > 1.0 ) { return 1.0 ; } else { return AsymptoticP - arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 2.0 ; } else { return AsymptoticP - arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 == 0.0 ) { return 0.0 ; } else if ( arg0 == 1.0 ) { return 1.0 ; } else if ( arg0 == 0.0 ) { return 0.0 ; } else { return AsymptoticP - arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) { return 0.0 ; } else if ( arg0 <= 1.0 ) { return 1.0 ; } else if ( arg0 <= 2.0 ) { return 0.0 ; } else { return AsymptoticP - arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 2.0 ; if ( arg0 <= 4.0 ) return 3.0 ; if ( arg0 <= 8.0 ) return 3.0 ; throw new IllegalArgumentException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 3.0 ; if ( arg0 <= 4.0 ) return 3.0 ; if ( arg0 <= 8.0 ) return 3.0 ; throw new IllegalArgumentException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; else if ( arg0 <= 1.0 ) return 1.0 ; else if ( arg0 <= 2.0 ) return 2.0 ; else if ( arg0 <= 3.0 ) return 3.0 ; else return 0.0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 3.0 ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private double calculateAsymptoticPValue ( double arg0 ) { if ( arg0 <= 0.0 ) return 0.0 ; if ( arg0 <= 1.0 ) return 1.0 ; if ( arg0 <= 2.0 ) return 2.0 ; if ( arg0 <= 3.0 ) return 2.0 ; if ( arg0 <= 4.0 ) return 3.0 ; if ( arg0 <= 8.0 ) return 3.0 ; return 0.0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_11_/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java_183-184": {
      "loc": "183-184",
      "input": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n        FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n        getExponentTerm(vals);\n}",
      "target": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n    return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n        FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n        getExponentTerm(vals);\n}",
      "function range": "177,5-186,5",
      "raw_output": [
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= 2.0 ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= loc2 ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 /= 2 ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) loc0 += density ( loc2 ) ; return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= 2.0 ; } return loc0 / arg0. size ( ) ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= loc2 ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= 2.0 ; } return loc1 / arg0. size ( ) ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= 2.0 ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0, Collection <? extends Number > arg1 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg1 ) { loc0 += density ( loc2, loc1 ) ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= loc2 ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0 ; for ( Number loc1 : arg0 ) { loc0 += density ( loc1 ) ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; for ( Number loc1 : arg0 ) { loc0 += density ( loc1 ) ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; } return loc0 ; }",
        "double function ( Collection <? extends Number > arg0 ) { double loc0 = 0 ; for ( Number loc1 : arg0 ) { if ( loc1!= null ) { loc0 += density ( loc1 ) ; } } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += density ( arg0. get ( loc1 ) ) ; return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += density ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return density ( loc0 ) ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += arg0. get ( loc1 ) ; return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += density ( arg0. get ( loc1 ) ) ; return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += density ( arg0. get ( loc1 ) ) ; return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += arg0. get ( loc1 ) ; return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return density ( loc0 ) ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; loc0 += density ( loc2, loc1 ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Compute the density of a set of values.",
        "Calculate the density of a set of values.",
        "Returns the density of a set of values.",
        "Compute the density of a vector.",
        "Calculate the density of a vector."
      ],
      "output": [
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= 2.0 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 /= 2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) loc0 += density ( loc2 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= 2.0 ; } return loc0 / arg0. size ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= 2.0 ; } return loc1 / arg0. size ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= 2.0 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0, Collection <? extends Number > arg1 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg1 ) { loc0 += density ( loc2, loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; loc1 *= loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0 ; for ( Number loc1 : arg0 ) { loc0 += density ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; for ( Number loc1 : arg0 ) { loc0 += density ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0.0 ; double loc1 = 1.0 ; for ( Number loc2 : arg0 ) { loc0 += density ( loc2 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Collection <? extends Number > arg0 ) { double loc0 = 0 ; for ( Number loc1 : arg0 ) { if ( loc1!= null ) { loc0 += density ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += density ( arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += density ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return density ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += arg0. get ( loc1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += density ( arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += density ( arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += arg0. get ( loc1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return density ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double density ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; loc0 += density ( loc2, loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_34_/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java_209-210": {
      "loc": "209-210",
      "input": "public Iterator<Chromosome> iterator() {\n    return chromosomes.iterator();\n}",
      "target": "public Iterator<Chromosome> iterator() {\n    return getChromosomes().iterator();\n}",
      "function range": "208,5-210,5",
      "raw_output": [
        "Iterator < Chromosome > function ( ) { return new ChromosomeIterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes_1_0. iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes. iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes ( ). iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes_1_1. iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes ( ). iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return new ChromosomeIterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes. iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes. values ( ). iterator ( ) ; }",
        "Iterator function ( ) { return chromosomes ( ). iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes ( ). iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return new ChromosomeIterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return new ChromosomeSetIterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return iterator ( Chromosome. class, \"srini_string\" ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes_set_iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes ( ). iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return Collections. list ( Chromosome. class ) ; }",
        "Iterator < Chromosome > function ( ) { return new ChromosomeIterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes. iterator ( ) ; }",
        "Iterator function ( ) { return chromosomes ( ). iterator ( ) ; }",
        "AbstractChromosomeIterator function ( ) { AbstractChromosomeIterator loc0 = new AbstractChromosomeIterator ( ) ; return loc0 ; }",
        "Iterator < Chromosome > function ( ) { return new ChromosomeIterator ( ) ; }",
        "AbstractChromosomeIterator function ( ) { return new AbstractChromosomeIterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes. iterator ( ) ; }",
        "Iterator < Chromosome > function ( ) { return chromosomes ( ). iterator ( ) ; }"
      ],
      "mid_translation": [
        "Returns an iterator over the list of chromosomes.",
        "Returns an iterator over the chromosomes.",
        "Returns an iterator over the set of chromosomes.",
        "Returns an iterator over all the chromosomes.",
        "Returns an iterator over the sequence of chromosomes."
      ],
      "output": [
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return new ChromosomeIterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes_1_0. iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes. iterator ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes ( ). iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes_1_1. iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes ( ). iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return new ChromosomeIterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes. iterator ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes. values ( ). iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator iterator ( ) { return chromosomes ( ). iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes ( ). iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return new ChromosomeIterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return new ChromosomeSetIterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return iterator ( Chromosome. class, \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes_set_iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes ( ). iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return Collections. list ( Chromosome. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return new ChromosomeIterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes. iterator ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Iterator iterator ( ) { return chromosomes ( ). iterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public AbstractChromosomeIterator iterator ( ) { AbstractChromosomeIterator loc0 = new AbstractChromosomeIterator ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return new ChromosomeIterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public AbstractChromosomeIterator iterator ( ) { return new AbstractChromosomeIterator ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes. iterator ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public Iterator < Chromosome > iterator ( ) { return chromosomes ( ). iterator ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_57_/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java_175-176": {
      "loc": "175-176",
      "input": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n        int sum = 0;\n        for (int i = 0; i < pointSet.size(); i++) {\n            final T p = pointSet.get(i);\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\n            final double d = p.distanceFrom(nearest.getCenter());\n            sum += d * d;\n            dx2[i] = sum;\n        }\n        final double r = random.nextDouble() * sum;\n        for (int i = 0 ; i < dx2.length; i++) {\n            if (dx2[i] >= r) {\n                final T p = pointSet.remove(i);\n                resultSet.add(new Cluster<T>(p));\n                break;\n            }\n        }\n    }\n    return resultSet;\n}",
      "target": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n        double sum = 0;\n        for (int i = 0; i < pointSet.size(); i++) {\n            final T p = pointSet.get(i);\n            final Cluster<T> nearest = getNearestCluster(resultSet, p);\n            final double d = p.distanceFrom(nearest.getCenter());\n            sum += d * d;\n            dx2[i] = sum;\n        }\n        final double r = random.nextDouble() * sum;\n        for (int i = 0 ; i < dx2.length; i++) {\n            if (dx2[i] >= r) {\n                final T p = pointSet.remove(i);\n                resultSet.add(new Cluster<T>(p));\n                break;\n            }\n        }\n    }\n    return resultSet;\n}",
      "function range": "161,5-198,5",
      "raw_output": [
        "List < Point2D > function ( Map < Integer, Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < Point2D > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) { loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; } return loc0 ; }",
        "List < Point2D > function ( Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < Point2D > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) { loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; } return loc0 ; }",
        "List < Point2D > function ( Map < Integer, Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < Point2D > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; return loc0 ; }",
        "List < Point2D > function ( Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < Point2D > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; return loc0 ; }",
        "List < Point2D > function ( Map < Integer, Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) { loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; } return loc0 ; }",
        "Collection < Point > function ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "Collection < Point > function ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "Collection < Point > function ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. getX ( ), loc1. getY ( ) ) ) ; } return loc0 ; }",
        "Collection < Point > function ( Collection < Point > arg0, double arg1 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "Collection < Point > function ( Collection < Coordinate > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Coordinate loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "Collection < Point > function ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "Collection < Point > function ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. getX ( ), loc1. getY ( ) ) ) ; } return loc0 ; }",
        "Collection < Point > function ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "Collection < Point > function ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) loc0. add ( new Point ( loc1. x, loc1. y ) ) ; return loc0 ; }",
        "Collection < Point > function ( Collection < Point > arg0, double arg1 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "List < Point > function ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "List < Point > function ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "List < Point > function ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) loc0. add ( new Point ( loc1. x, loc1. y ) ) ; return loc0 ; }",
        "List < Point > function ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < Point > ( ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
        "List < Point > function ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x - loc1. x / 2, loc1. y - loc1. y / 2 ) ) ; } return loc0 ; }",
        "Point function ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0. x = arg1 [ loc1 ] ; loc0. y = arg1 [ loc1 ] ; } return loc0 ; }",
        "Point function ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; arg1 [ loc1 ] = loc2 ; loc0. x = loc2 ; loc0. y = loc2 ; } return loc0 ; }",
        "Point function ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; double loc3 = arg1 [ loc1 ] ; loc0. set ( loc1, new Point ( loc2, loc3 ) ) ; } return loc0 ; }",
        "Point function ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0. x = arg1 [ loc1 ] ; loc0. y = arg1 [ loc1 ] ; loc0. z = arg1 [ loc1 ] ; } return loc0 ; }",
        "Point function ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. x = arg0 [ loc1 ] ; loc0. y = arg1 [ loc1 ] ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Choose initial centers.",
        "Choose initial centers from a collection of points.",
        "Choose initial centers of a collection of points.",
        "Choose initial centers from a set of points.",
        "Choose initial centers of a set of points."
      ],
      "output": [
        {
          "patch": "private static List < Point2D > chooseInitialCenters ( Map < Integer, Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < Point2D > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) { loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static List < Point2D > chooseInitialCenters ( Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < Point2D > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) { loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static List < Point2D > chooseInitialCenters ( Map < Integer, Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < Point2D > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static List < Point2D > chooseInitialCenters ( Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < Point2D > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static List < Point2D > chooseInitialCenters ( Map < Integer, Map < Integer, List < Point >> arg0 ) { List < Point2D > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Map. Entry < Integer, List < Point >> loc1 : arg0. entrySet ( ) ) { loc0. add ( new Point2D. Double ( loc1. getKey ( ), loc1. getValue ( ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. getX ( ), loc1. getY ( ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Point > arg0, double arg1 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Coordinate > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Coordinate loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. getX ( ), loc1. getY ( ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Point > arg0 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) loc0. add ( new Point ( loc1. x, loc1. y ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Collection < Point > chooseInitialCenters ( Collection < Point > arg0, double arg1 ) { Collection < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static List < Point > chooseInitialCenters ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static List < Point > chooseInitialCenters ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static List < Point > chooseInitialCenters ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) loc0. add ( new Point ( loc1. x, loc1. y ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static List < Point > chooseInitialCenters ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < Point > ( ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x, loc1. y ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static List < Point > chooseInitialCenters ( List < Point > arg0 ) { List < Point > loc0 = new ArrayList < Point > ( arg0. size ( ) ) ; for ( Point loc1 : arg0 ) { loc0. add ( new Point ( loc1. x - loc1. x / 2, loc1. y - loc1. y / 2 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Point chooseInitialCenters ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0. x = arg1 [ loc1 ] ; loc0. y = arg1 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Point chooseInitialCenters ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; arg1 [ loc1 ] = loc2 ; loc0. x = loc2 ; loc0. y = loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Point chooseInitialCenters ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; double loc3 = arg1 [ loc1 ] ; loc0. set ( loc1, new Point ( loc2, loc3 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Point chooseInitialCenters ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0. x = arg1 [ loc1 ] ; loc0. y = arg1 [ loc1 ] ; loc0. z = arg1 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static Point chooseInitialCenters ( double [ ] arg0, double [ ] arg1 ) { Point loc0 = new Point ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. x = arg0 [ loc1 ] ; loc0. y = arg1 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_101_/src/java/org/apache/commons/math/complex/ComplexFormat.java_377-378": {
      "loc": "377-378",
      "input": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if (\n        source.substring(startIndex, endIndex).compareTo(\n        getImaginaryCharacter()) != 0) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}",
      "target": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n    if ((startIndex >= source.length()) ||\n        (endIndex > source.length()) ||\n        source.substring(startIndex, endIndex).compareTo(\n        getImaginaryCharacter()) != 0) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    pos.setIndex(endIndex);\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}",
      "function range": "320,5-389,5",
      "raw_output": [
        "Complex function ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
        "Complex function ( String arg0 ) { try { return parse ( new StringReader ( arg0 ) ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
        "Complex function ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0, loc0 ) ; } }",
        "Complex function ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
        "Complex function ( String arg0 ) { try { return parse ( new StringReader ( arg0 ) ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
        "Complex function ( Source arg0 ) { return parse ( arg0, ( int ) 0 ) ; }",
        "Complex function ( Source arg0 ) { return parse ( arg0, 0 ) ; }",
        "Complex function ( Source arg0 ) { Complex loc0 = new Complex ( arg0 ) ; return loc0 ; }",
        "ComplexNumber function ( Source arg0 ) { return parse ( arg0, ( int ) 0 ) ; }",
        "ComplexNumber function ( Source arg0 ) { return parse ( arg0, 0 ) ; }",
        "Complex function ( String arg0 ) { try { return parse ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
        "Complex function ( String arg0 ) { try { return parse ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
        "Complex function ( String arg0 ) { try { return parse ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new Error ( \"srini_string\" ) ; } }",
        "Complex function ( String arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return parse ( new InputSource ( arg0 ) ) ; }",
        "Complex function ( String arg0 ) { return parse ( null, arg0 ) ; }",
        "Complex function ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
        "Complex function ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
        "Complex function ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
        "Complex function ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { Logger. getLogger ( \"srini_string\" ). error ( \"srini_string\" + arg0 ) ; } return null ; }",
        "Complex function ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { Logger. getLogger ( \"srini_string\" ). error ( \"srini_string\" + arg0 ) ; return null ; } }",
        "Complex function ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
        "Complex function ( String arg0 ) { try { return ParseComplex. parse ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
        "Complex function ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
        "Complex function ( String arg0 ) { try { return complex_parse ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
        "Complex function ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }"
      ],
      "mid_translation": [
        "Parse a Complex object from a String.",
        "Parse a complex number from the given source.",
        "Parse a complex number from the specified source.",
        "Parses a Complex object from a String.",
        "Parse a Complex object from the specified string."
      ],
      "output": [
        {
          "patch": "public Complex parse ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return parse ( new StringReader ( arg0 ) ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0, loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return parse ( new StringReader ( arg0 ) ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( Source arg0 ) { return parse ( arg0, ( int ) 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( Source arg0 ) { return parse ( arg0, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( Source arg0 ) { Complex loc0 = new Complex ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ComplexNumber parse ( Source arg0 ) { return parse ( arg0, ( int ) 0 ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public ComplexNumber parse ( Source arg0 ) { return parse ( arg0, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return parse ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return parse ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return parse ( arg0 ) ; } catch ( NumberFormatException loc0 ) { throw new Error ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return parse ( new InputSource ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { return parse ( null, arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 + \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { Logger. getLogger ( \"srini_string\" ). error ( \"srini_string\" + arg0 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { Logger. getLogger ( \"srini_string\" ). error ( \"srini_string\" + arg0 ) ; return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return ParseComplex. parse ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { StringReader loc0 = new StringReader ( arg0 ) ; return parse ( loc0 ) ; } catch ( IOException loc0 ) { throw new Error ( \"srini_string\", loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return complex_parse ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Complex parse ( String arg0 ) { try { return new Complex ( arg0 ) ; } catch ( Exception loc0 ) { throw new Error ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_82_/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java_82-83": {
      "loc": "82-83",
      "input": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = rhs / entry;\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i; \n            }\n        }\n    }\n    return minRatioPos;\n}",
      "target": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n        if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n            final double ratio = rhs / entry;\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i; \n            }\n        }\n    }\n    return minRatioPos;\n}",
      "function range": "76,5-91,5",
      "raw_output": [
        "ArrayList < Integer > function ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( new Integer ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) loc0. add ( loc1 ) ; return loc0 ; }",
        "ArrayList < Integer > function ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "PivotRow function ( Row arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return pivotRow ( arg0. getLeft ( ), arg0. getRight ( ) ) ; }",
        "PivotRow function ( Row arg0 ) { if ( arg0 == null ) return null ; return pivotRow ( arg0. getLeft ( ), arg0. getRight ( ) ) ; }",
        "PivotRow function ( Row arg0 ) { if ( arg0 == null ) return null ; pivotRow = arg0. pivotRow ; return pivotRow ; }",
        "pivot function ( Row arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return pivot ( arg0. getLeft ( ), arg0. getRight ( ) ) ; }",
        "PivotRow function ( Row arg0 ) { if ( arg0 == null ) throw new NullPointerException ( ) ; return pivotRow ( arg0. getLeft ( ), arg0. getRight ( ) ) ; }",
        "PivotRow function ( Row arg0 ) { PivotRow loc0 = arg0. getRow ( ) ; if ( loc0 == null ) loc0 = new PivotRow ( ) ; return loc0 ; }",
        "PivotRow function ( Row arg0 ) { if ( arg0 == null ) return null ; return ( PivotRow ) arg0. getRow ( ) ; }",
        "PivotRow function ( Row arg0 ) { if ( arg0 == null ) { return null ; } return ( PivotRow ) arg0. getRow ( ) ; }",
        "PivotRow function ( Row arg0 ) { if ( arg0 == null ) { return null ; } return ( PivotRow ) arg0. getParent ( ) ; }",
        "PivotRow function ( Row arg0 ) { if ( arg0 == null ) { return null ; } final PivotRow loc0 = ( PivotRow ) arg0. getParent ( ) ; return loc0 ; }",
        "ArrayList < Integer > function ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; pivot ( arg0, arg1, loc0 ) ; return loc0 ; }",
        "ArrayList < Integer > function ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( loc1 ) ; return loc0 ; }",
        "ArrayList < Integer > function ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; pivotRow ( arg0, arg1, loc0 ) ; return loc0 ; }",
        "ArrayList < Integer > function ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( loc1 ) ; return loc0 ; }",
        "PivotRow function ( Object arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return pivotRow ( arg0. getClass ( ). getName ( ), arg0 ) ; }",
        "PivotRow function ( Table arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; PivotRow loc0 = new PivotRow ( arg0 ) ; return loc0 ; }",
        "PivotRow function ( Object arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; PivotRow loc0 = new PivotRow ( arg0 ) ; return loc0 ; }",
        "PivotRow function ( Object arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; PivotRow loc0 = ( PivotRow ) arg0 ; return loc0 ; }",
        "pivotRow function ( int arg0, int arg1 ) { PivotRow loc0 = new PivotRow ( arg0, arg1 ) ; return loc0 ; }"
      ],
      "mid_translation": [
        "Gets pivot row.",
        "Get pivot row.",
        "Gets the pivot row.",
        "Get the pivot row.",
        "getPivotRow Method."
      ],
      "output": [
        {
          "patch": "private ArrayList < Integer > getPivotRow ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( new Integer ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private ArrayList < Integer > getPivotRow ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private ArrayList < Integer > getPivotRow ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private ArrayList < Integer > getPivotRow ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) loc0. add ( loc1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private ArrayList < Integer > getPivotRow ( List < Integer > arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Row arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return pivotRow ( arg0. getLeft ( ), arg0. getRight ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Row arg0 ) { if ( arg0 == null ) return null ; return pivotRow ( arg0. getLeft ( ), arg0. getRight ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Row arg0 ) { if ( arg0 == null ) return null ; pivotRow = arg0. pivotRow ; return pivotRow ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private pivot getPivotRow ( Row arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return pivot ( arg0. getLeft ( ), arg0. getRight ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Row arg0 ) { if ( arg0 == null ) throw new NullPointerException ( ) ; return pivotRow ( arg0. getLeft ( ), arg0. getRight ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Row arg0 ) { PivotRow loc0 = arg0. getRow ( ) ; if ( loc0 == null ) loc0 = new PivotRow ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Row arg0 ) { if ( arg0 == null ) return null ; return ( PivotRow ) arg0. getRow ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Row arg0 ) { if ( arg0 == null ) { return null ; } return ( PivotRow ) arg0. getRow ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Row arg0 ) { if ( arg0 == null ) { return null ; } return ( PivotRow ) arg0. getParent ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Row arg0 ) { if ( arg0 == null ) { return null ; } final PivotRow loc0 = ( PivotRow ) arg0. getParent ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private ArrayList < Integer > getPivotRow ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private ArrayList < Integer > getPivotRow ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; pivot ( arg0, arg1, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private ArrayList < Integer > getPivotRow ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( loc1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private ArrayList < Integer > getPivotRow ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; pivotRow ( arg0, arg1, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private ArrayList < Integer > getPivotRow ( int arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( loc1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Object arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; return pivotRow ( arg0. getClass ( ). getName ( ), arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Table arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; PivotRow loc0 = new PivotRow ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Object arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; PivotRow loc0 = new PivotRow ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private PivotRow getPivotRow ( Object arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; PivotRow loc0 = ( PivotRow ) arg0 ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private pivotRow getPivotRow ( int arg0, int arg1 ) { PivotRow loc0 = new PivotRow ( arg0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_73_/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java_136-137": {
      "loc": "136-137",
      "input": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
      "target": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n}",
      "function range": "98,5-140,5",
      "raw_output": [
        "RealFunction2D function ( final UnivariateRealFunction arg0 ) { return new RealFunction2D ( ) { @ Override public double apply ( double arg1 ) { return arg0. apply ( arg1 ) ; } } ; }",
        "RealFunction2D function ( final UnivariateRealFunction arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return new RealFunction2D ( arg0 ) ; }",
        "RealFunction2D function ( final UnivariateRealFunction arg0 ) { return new RealFunction2D ( arg0 ) ; }",
        "RealFunction2D function ( RealFunction2D arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return new RealFunction2D ( arg0 ) ; }",
        "RealFunction2D function ( final UnivariateRealFunction arg0, final double arg1 ) { return new RealFunction2D ( arg0, arg1 ) ; }",
        "double [ ] function ( final double [ ] arg0 ) { assert arg0. length == 1 : \"srini_string\" ; final double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 ; } return loc0 ; }",
        "double [ ] function ( final double [ ] arg0 ) { final double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 / arg0 [ loc1 ] ; } return loc0 ; }",
        "double [ ] function ( final double [ ] arg0 ) { assert arg0. length == 1 : \"srini_string\" ; double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 ; } return loc0 ; }",
        "double [ ] function ( final double [ ] arg0 ) { final double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "RealFunction2D function ( final double arg0, final double arg1 ) { return new RealFunction2D ( arg0, arg1 ) ; }",
        "RealFunction2D function ( final UnivariateRealFunction arg0, final double arg1 ) { return new RealFunction2D ( arg0, arg1 ) ; }",
        "RealFunction2D function ( final UnivariateRealFunction arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return new RealFunction2D ( arg0 ) ; }",
        "RealFunction2D function ( final UnivariateRealFunction arg0 ) { return new RealFunction2D ( arg0 ) ; }",
        "RealFunction2D function ( final UnivariateRealFunction arg0, final double arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return new RealFunction2D ( arg0, arg1 ) ; }",
        "double function ( final UnivariateRealFunction arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } final double loc0 = 1.0 ; return arg0. apply ( loc0 ) ; }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg0 ) ) ; } }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + arg0 * arg1 ) ; } }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg1 ) ) ; } }",
        "double function ( double arg0, double arg1 ) { if ( arg0 == 0.0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return 1 / ( 1.0 + Math. exp ( - arg1 ) ) ; }",
        "double function ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg1 ; } }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = f ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 / ( arg0 [ loc1 ] + 1 ) ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 / ( arg0 [ loc1 ] - 1 ) ; } return loc0 ; }",
        "double [ ] function ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 / arg0 [ loc1 ] ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Solve the given UnivariateRealFunction.",
        "Solve using the UnivariateRealFunction.",
        "Solve the specified UnivariateRealFunction.",
        "Solve the given univariate real function.",
        "Solve using the UnivariateRealFunction f"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealFunction2D solve ( final UnivariateRealFunction arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return new RealFunction2D ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealFunction2D solve ( final UnivariateRealFunction arg0 ) { return new RealFunction2D ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealFunction2D solve ( RealFunction2D arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return new RealFunction2D ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealFunction2D solve ( final UnivariateRealFunction arg0, final double arg1 ) { return new RealFunction2D ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( final double [ ] arg0 ) { assert arg0. length == 1 : \"srini_string\" ; final double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( final double [ ] arg0 ) { final double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 / arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( final double [ ] arg0 ) { assert arg0. length == 1 : \"srini_string\" ; double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( final double [ ] arg0 ) { final double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealFunction2D solve ( final double arg0, final double arg1 ) { return new RealFunction2D ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealFunction2D solve ( final UnivariateRealFunction arg0, final double arg1 ) { return new RealFunction2D ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealFunction2D solve ( final UnivariateRealFunction arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return new RealFunction2D ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealFunction2D solve ( final UnivariateRealFunction arg0 ) { return new RealFunction2D ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public RealFunction2D solve ( final UnivariateRealFunction arg0, final double arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return new RealFunction2D ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( final UnivariateRealFunction arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } final double loc0 = 1.0 ; return arg0. apply ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg0 ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + arg0 * arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / ( 1.0 + Math. exp ( - arg1 ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg0 == 0.0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return 1 / ( 1.0 + Math. exp ( - arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double solve ( double arg0, double arg1 ) { if ( arg1 == 0.0 ) { return 0.0 ; } else { return 1.0 / arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = f ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 / ( arg0 [ loc1 ] + 1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 / ( arg0 [ loc1 ] - 1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double [ ] solve ( double [ ] arg0 ) { double [ ] loc0 = new double [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = 1 / arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Time_15_/src/main/java/org/joda/time/field/FieldUtils.java_138-139": {
      "loc": "138-139",
      "input": "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0L;\n        case 1:\n            return val1;\n    }\n    long total = val1 * val2;\n    if (total / val2 != val1) {\n      throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n    }\n    return total;\n}",
      "target": "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n            if (val1 == Long.MIN_VALUE) {\n                throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n            }\n            return -val1;\n        case 0:\n            return 0L;\n        case 1:\n            return val1;\n    }\n    long total = val1 * val2;\n    if (total / val2 != val1) {\n      throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n    }\n    return total;\n}",
      "function range": "135,5-149,5",
      "raw_output": [
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( ( long ) arg1 ) ; } else if ( arg1 == 0 ) { return ( ( long ) arg0 ) ; } else { return ( ( long ) arg1 ) * arg0 ; } }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( ( long ) arg1 ) ; } else if ( arg1 == 0 ) { return ( ( long ) arg0 ) ; } else { return ( ( ( long ) arg1 ) * arg0 ) ; } }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return ( arg0 * arg1 ) ; } else { return ( arg0 * arg1 ) ; } }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( arg1 ) ; } else if ( arg1 == 0 ) { return ( arg0 * arg1 ) ; } else { return ( arg0 * arg1 ) ; } }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else if ( arg1 == 0 ) { return ( long ) arg0. longValue ( ) * arg1. longValue ( ) ; } else { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else if ( arg1 == 0 ) { return ( long ) arg0. longValue ( ) * arg1. longValue ( ) ; } else { return ( long ) arg1. longValue ( ) * arg0. longValue ( ) ; } }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else if ( arg1 == 0 ) { return ( ( long ) arg0 ) * arg1. longValue ( ) ; } else { return ( ( long ) arg1. longValue ( ) * arg1. longValue ( ) ) ; } }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) ; } else if ( arg1 == 0 ) { return ( long ) arg0. longValue ( ) * arg1. longValue ( ) ; } else { return ( long ) arg1. longValue ( ) * arg0. longValue ( ) ; } }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } }",
        "long function ( final long arg0, final long arg1 ) { return arg0 * arg1 ; }",
        "long function ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
        "long function ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } else if ( arg1 == 0 ) { return arg0 ; } else { return arg0 * arg1 ; } }",
        "long function ( final long arg0, final long arg1 ) { if ( arg0 < arg1 ) { return arg0 * arg1 ; } else if ( arg1 == 0 ) { return arg0 ; } else { return arg0 * arg1 ; } }",
        "long function ( final long arg0, final long arg1 ) { if ( arg0 == arg1 ) { return arg0 ; } else if ( arg1 == 0 ) { return arg0 ; } else { return arg0 * arg1 ; } }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 * arg1 ; } return arg0 * arg1 ; }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return ( arg0 * arg1 ) ; } return arg0 * arg1 ; }",
        "long function ( long arg0, long arg1 ) { if ( arg0 == arg1 ) { return arg0 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
        "long function ( final long arg0, final long arg1 ) { return arg0 * arg1 ; }",
        "long function ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
        "long function ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } else if ( arg1 == 0 ) { return arg0 ; } else { return arg0 * arg1 ; } }",
        "long function ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * ( arg1 - arg0 ) ; }",
        "long function ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } else if ( arg1 == 0 ) { return arg1 ; } else { return arg0 * arg1 ; } }",
        "float function ( float arg0, float arg1 ) { if ( arg0 == 0.0f && arg1 == 0.0f ) return 0.0f ; if ( arg1 == 0.0f ) return 1.0f ; return arg0 * arg1.0f ( ) ; }"
      ],
      "mid_translation": [
        "Multiplies two long values.",
        "Multiplies two longs.",
        "Safely multiply two long values",
        "Multiply two long values.",
        "Safely multiply two values."
      ],
      "output": [
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( ( long ) arg1 ) ; } else if ( arg1 == 0 ) { return ( ( long ) arg0 ) ; } else { return ( ( long ) arg1 ) * arg0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( ( long ) arg1 ) ; } else if ( arg1 == 0 ) { return ( ( long ) arg0 ) ; } else { return ( ( ( long ) arg1 ) * arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return ( arg0 * arg1 ) ; } else { return ( arg0 * arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( arg1 ) ; } else if ( arg1 == 0 ) { return ( arg0 * arg1 ) ; } else { return ( arg0 * arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else if ( arg1 == 0 ) { return ( long ) arg0. longValue ( ) * arg1. longValue ( ) ; } else { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else if ( arg1 == 0 ) { return ( long ) arg0. longValue ( ) * arg1. longValue ( ) ; } else { return ( long ) arg1. longValue ( ) * arg0. longValue ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else if ( arg1 == 0 ) { return ( ( long ) arg0 ) * arg1. longValue ( ) ; } else { return ( ( long ) arg1. longValue ( ) * arg1. longValue ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) ; } else if ( arg1 == 0 ) { return ( long ) arg0. longValue ( ) * arg1. longValue ( ) ; } else { return ( long ) arg1. longValue ( ) * arg0. longValue ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else if ( arg0 == 0 ) { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } else { return ( long ) arg1. longValue ( ) * arg1. longValue ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { return arg0 * arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } else if ( arg1 == 0 ) { return arg0 ; } else { return arg0 * arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { if ( arg0 < arg1 ) { return arg0 * arg1 ; } else if ( arg1 == 0 ) { return arg0 ; } else { return arg0 * arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { if ( arg0 == arg1 ) { return arg0 ; } else if ( arg1 == 0 ) { return arg0 ; } else { return arg0 * arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 * arg1 ; } return arg0 * arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return ( arg0 * arg1 ) ; } return arg0 * arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( long arg0, long arg1 ) { if ( arg0 == arg1 ) { return arg0 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { return arg0 * arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } else if ( arg1 == 0 ) { return arg0 ; } else { return arg0 * arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } return arg0 * ( arg1 - arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long safeMultiply ( final long arg0, final long arg1 ) { if ( arg0 == 0 ) { return arg1 ; } if ( arg1 == 0 ) { return arg0 ; } else if ( arg1 == 0 ) { return arg1 ; } else { return arg0 * arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static float safeMultiply ( float arg0, float arg1 ) { if ( arg0 == 0.0f && arg1 == 0.0f ) return 0.0f ; if ( arg1 == 0.0f ) return 1.0f ; return arg0 * arg1.0f ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_105_/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java_264-265": {
      "loc": "264-265",
      "input": "public double getSumSquaredErrors() {\n    return sumYY - sumXY * sumXY / sumXX;\n}",
      "target": "public double getSumSquaredErrors() {\n    return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n}",
      "function range": "263,5-265,5",
      "raw_output": [
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( double... arg0 ) { double loc0 = 0 ; for ( double loc1 : arg0 ) { loc0 += loc1 ; } return loc0 ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 3 ; loc1 ++ ) { loc0 += Math. pow ( ( double ) loc1, 2 ) ; } return loc0 ; }",
        "double function ( ) { double loc0 = 0 ; for ( int loc1 = 1 ; loc1 < 9 ; loc1 ++ ) { loc0 += Math. pow ( ( double ) loc1, 2 ) ; } return loc0 ; }",
        "double function ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { if ( arg0. data [ loc1 ] [ loc2 ] < arg0. data [ loc1 ] [ loc2 ] ) { loc0 += arg0. data [ loc1 ] [ loc2 ] ; } } } return loc0 ; }",
        "double function ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { loc0 += Math. pow ( arg0. data [ loc1 ] [ loc2 ], 2 ) ; } } return loc0 ; }",
        "double function ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { loc0 += arg0. data [ loc1 ] [ loc2 ] * arg0. data [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
        "double function ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { loc0 += arg0. data [ loc1 * arg0. dim2 + loc2 ] * arg0. data [ loc1 * arg0. dim2 + loc2 ] ; } } return loc0 ; }",
        "double function ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { if ( arg0. data [ loc1 ] < arg0. data [ loc1 ] ) { loc0 += arg0. data [ loc1 ] * arg0. data [ loc1 ] ; } else { loc0 += arg0. data [ loc1 ] * arg0. data [ loc1 ] ; } } return loc0 ; }",
        "double function ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { double loc2 = matrix [ loc1 ] [ loc1 ] ; loc0 += loc2 * loc2 ; } return Math. sqrt ( loc0 ) ; }",
        "double function ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < matrix. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < matrix. dim2 ; loc2 ++ ) { loc0 += matrix. matrix [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
        "double function ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { double loc2 = matrix [ loc1 ] [ loc1 ] ; loc0 += loc2 * loc2 ; } return loc0 ; }",
        "double function ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < matrix. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < matrix. dim2 ; loc2 ++ ) { loc0 += matrix. data [ loc1 * loc1 + loc2 ] ; } } return loc0 ; }",
        "double function ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < matrix. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < matrix. dim2 ; loc2 ++ ) { loc0 += matrix [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) loc0 = loc2 ; } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += Math. pow ( arg0. get ( loc1 ), 2 ) ; } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) loc0 = loc2 ; } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "double function ( ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 += Math. pow ( ( double ) arg0 [ loc1 ], 2 ) ; } return loc0 ; }",
        "double function ( ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) * arg0. get ( loc1 ) ; } return loc0 ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return ( loc0 / arg0. size ( ) ) ; }",
        "double function ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) loc0 = loc2 ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Returns the squared error of the errors.",
        "Returns the squared error of the matrix.",
        "Returns the squared error of this matrix.",
        "Returns the squared error of the data set.",
        "Gets the squared error of the data set."
      ],
      "output": [
        {
          "patch": "public double getSumSquaredErrors ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( double... arg0 ) { double loc0 = 0 ; for ( double loc1 : arg0 ) { loc0 += loc1 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 3 ; loc1 ++ ) { loc0 += Math. pow ( ( double ) loc1, 2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors ( ) { double loc0 = 0 ; for ( int loc1 = 1 ; loc1 < 9 ; loc1 ++ ) { loc0 += Math. pow ( ( double ) loc1, 2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public double getSumSquaredErrors ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { if ( arg0. data [ loc1 ] [ loc2 ] < arg0. data [ loc1 ] [ loc2 ] ) { loc0 += arg0. data [ loc1 ] [ loc2 ] ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { loc0 += Math. pow ( arg0. data [ loc1 ] [ loc2 ], 2 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { loc0 += arg0. data [ loc1 ] [ loc2 ] * arg0. data [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. dim2 ; loc2 ++ ) { loc0 += arg0. data [ loc1 * arg0. dim2 + loc2 ] * arg0. data [ loc1 * arg0. dim2 + loc2 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Matrix arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. dim1 ; loc1 ++ ) { if ( arg0. data [ loc1 ] < arg0. data [ loc1 ] ) { loc0 += arg0. data [ loc1 ] * arg0. data [ loc1 ] ; } else { loc0 += arg0. data [ loc1 ] * arg0. data [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { double loc2 = matrix [ loc1 ] [ loc1 ] ; loc0 += loc2 * loc2 ; } return Math. sqrt ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < matrix. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < matrix. dim2 ; loc2 ++ ) { loc0 += matrix. matrix [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 4 ; loc1 ++ ) { double loc2 = matrix [ loc1 ] [ loc1 ] ; loc0 += loc2 * loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < matrix. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < matrix. dim2 ; loc2 ++ ) { loc0 += matrix. data [ loc1 * loc1 + loc2 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < matrix. dim1 ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < matrix. dim2 ; loc2 ++ ) { loc0 += matrix [ loc1 ] [ loc2 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) loc0 = loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += Math. pow ( arg0. get ( loc1 ), 2 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Vector arg0 ) { double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Vector arg0 ) { double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) loc0 = loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 += Math. pow ( ( double ) arg0 [ loc1 ], 2 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } double loc0 = 0.0 ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) * arg0. get ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return ( loc0 / arg0. size ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public double getSumSquaredErrors ( Vector arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; if ( loc2 < loc0 ) loc0 = loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_34_/src/org/mockito/internal/invocation/InvocationMatcher.java_106-107": {
      "loc": "106-107",
      "input": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n        if (m instanceof CapturesArguments) {\n            ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n        }\n        k++;\n    }\n}",
      "target": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n        if (m instanceof CapturesArguments && i.getArguments().length > k) {\n            ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n        }\n        k++;\n    }\n}",
      "function range": "103,5-111,5",
      "raw_output": [
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
        "Object function ( MethodInvocation arg0, Class <? >... arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( ) ; }",
        "Object [ ] function ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArgumentCount ( ) ] ; return loc0 ; }",
        "Object function ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
        "Object function ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ ] { arg1 [ 0 ] }, arg1 [ 1 ] ) ; }",
        "Object function ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ ] { arg1 }, arg2 ) ; }",
        "Object function ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ arg2. length ] ) ; }",
        "Object [ ] function ( InvocationContext arg0 ) { return new Class < Object > [ ] { Object. class } ; }",
        "Object [ ] function ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArguments ( ). size ( ) ] ; return loc0 ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( new Object [ arg0. getArguments ( ). size ( ) ] ) ; }",
        "Object function ( EJBClientInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( new Object [ 0 ] ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getCaptures ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getCapturedArguments ( ) ; }",
        "Object function ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ ] { arg1 [ 0 ] }, arg1 [ 1 ] ) ; }",
        "Object function ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
        "Object function ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ ] { arg1 }, arg2 ) ; }",
        "Object function ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ arg2. length ] ) ; }",
        "Object function ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ ] { arg1, arg2 } ) ; }"
      ],
      "mid_translation": [
        "Capture arguments from the invocation.",
        "Capture arguments from an invocation.",
        "Capture arguments from invocation.",
        "Captures arguments from the invocation.",
        "Capture arguments from a invocation."
      ],
      "output": [
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0, Class <? >... arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArgumentCount ( ) ] ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ ] { arg1 [ 0 ] }, arg1 [ 1 ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ ] { arg1 }, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ arg2. length ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( InvocationContext arg0 ) { return new Class < Object > [ ] { Object. class } ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArguments ( ). size ( ) ] ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( new Object [ arg0. getArguments ( ). size ( ) ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( EJBClientInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( new Object [ 0 ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getCaptures ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getCapturedArguments ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ ] { arg1 [ 0 ] }, arg1 [ 1 ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ ] { arg1 }, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ arg2. length ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ ] { arg1, arg2 } ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_94_/src/java/org/apache/commons/math/util/MathUtils.java_412-413": {
      "loc": "412-413",
      "input": "public static int gcd(int u, int v) {\n    if (u * v == 0) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u > 0) {\n        u = -u;\n    } \n    if (v > 0) {\n        v = -v;\n    } \n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n        u /= 2;\n        v /= 2;\n        k++; \n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    do {\n        while ((t & 1) == 0) { \n            t /= 2; \n        }\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        t = (v - u) / 2;\n    } while (t != 0);\n    return -u * (1 << k); \n}",
      "target": "public static int gcd(int u, int v) {\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    if (u > 0) {\n        u = -u;\n    } \n    if (v > 0) {\n        v = -v;\n    } \n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { \n        u /= 2;\n        v /= 2;\n        k++; \n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    do {\n        while ((t & 1) == 0) { \n            t /= 2; \n        }\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        t = (v - u) / 2;\n    } while (t != 0);\n    return -u * (1 << k); \n}",
      "function range": "411,5-460,5",
      "raw_output": [
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return arg0 % arg1 ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( final int arg0, final int arg1 ) { return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { return ( arg0 % arg1 == 0? 1 : arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return arg0 % arg1 ; }",
        "int function ( int arg0, int arg1 ) { return ( arg0 % arg1 == 0? 1 : arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return arg0 % arg1 ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return arg0 % arg1 ; }",
        "int function ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return arg0 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg1 ) == 0 ) { return 0 ; } else { return 1 ; } }",
        "int function ( T arg0, T arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 0 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg1 ) == 0 ) { return 1 ; } else { return divisor ( arg0, arg1 ) ; } }",
        "int function ( T arg0, T arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 0 ; } else if ( arg0. compareTo ( arg1 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else { return divisor ( arg0, arg1 ) ; } }",
        "int function ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 0 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg1 ) == 0 ) { return 1 ; } else { return divisor ( arg0, arg1 ) ; } }",
        "int function ( T arg0, T arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 0 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg1 ) == 0 ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "int function ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return ( arg0 % arg1 ) ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return ( arg0 / arg1 ) ; } else { return ( arg0 % arg1 ) ; } }",
        "int function ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return gcd ( arg0, arg1 ) ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return arg0 ; } else { return gcd ( arg0, arg1 ) ; } }",
        "int function ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return ( arg0 % arg1 ) ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return ( arg0 % arg1 ) ; } else { return ( arg0 % arg1 ) ; } }",
        "int function ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return ( arg0 % arg1 ) ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return ( arg1 % arg0 ) ; } else { return ( arg0 % arg1 ) ; } }",
        "int function ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 2 ; } else if ( arg1. compareTo ( arg1 ) == 1 ) { return 0 ; } else { return 1 ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg1 % arg1 == 1 ) { return arg0 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg0 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }"
      ],
      "mid_translation": [
        "Greatest common divisor of two sets of integers.",
        "Greatest common divisor of two integers.",
        "Greatest common divisor of u and v.",
        "Returns the greatest common divisor of u and v.",
        "Compute the greatest common divisor of two integers."
      ],
      "output": [
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return arg0 % arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( final int arg0, final int arg1 ) { return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { return ( arg0 % arg1 == 0? 1 : arg0 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return arg0 % arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { return ( arg0 % arg1 == 0? 1 : arg0 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return arg0 % arg1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return arg0 % arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return arg0 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg1 ) == 0 ) { return 0 ; } else { return 1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( T arg0, T arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 0 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg1 ) == 0 ) { return 1 ; } else { return divisor ( arg0, arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int gcd ( T arg0, T arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 0 ; } else if ( arg0. compareTo ( arg1 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else { return divisor ( arg0, arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int gcd ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 0 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg1 ) == 0 ) { return 1 ; } else { return divisor ( arg0, arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int gcd ( T arg0, T arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 0 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg1 ) == 0 ) { return 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int gcd ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return ( arg0 % arg1 ) ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return ( arg0 / arg1 ) ; } else { return ( arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return gcd ( arg0, arg1 ) ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return arg0 ; } else { return gcd ( arg0, arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return ( arg0 % arg1 ) ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return ( arg0 % arg1 ) ; } else { return ( arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return ( arg0 % arg1 ) ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return ( arg1 % arg0 ) ; } else { return ( arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( Integer arg0, Integer arg1 ) { if ( arg0. compareTo ( arg1 ) == 0 ) { return 1 ; } else if ( arg1. compareTo ( arg0 ) == 0 ) { return 2 ; } else if ( arg1. compareTo ( arg1 ) == 1 ) { return 0 ; } else { return 1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg1 % arg1 == 1 ) { return arg0 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg0 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        }
      ]
    },
    "Time_16_/src/main/java/org/joda/time/format/DateTimeFormatter.java_709-710": {
      "loc": "709-710",
      "input": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
      "target": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}",
      "function range": "697,5-724,5",
      "raw_output": [
        "Instant function ( String arg0 ) { if ( arg0 == null ) { return null ; } Instant loc0 = Instant. parse ( arg0 ) ; return loc0 ; }",
        "Instant function ( String arg0 ) { Instant loc0 = Instant. parse ( arg0 ) ; return loc0 ; }",
        "Instant function ( String arg0 ) { if ( arg0 == null ) { return null ; } Instant loc0 = LocalDateTime. parse ( arg0 ) ; return loc0 ; }",
        "Instant function ( String arg0 ) { if ( arg0 == null ) { return null ; } return parse ( new StringReader ( arg0 ) ) ; }",
        "Instant function ( String arg0 ) { return parse ( arg0, null ) ; }",
        "ReadWritableInstant function ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. toInstant ( ) ) ; }",
        "ReadWritableInstant function ( String arg0, TextParseContext arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. getText ( ) ) ; }",
        "ReadWritableInstant function ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, TextFormat. getPrettyType ( ) ) ; }",
        "ReadWritableInstant function ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, TextFormat. getPrettyType ( ) ) ; }",
        "ReadWritableInstant function ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, TextMode. TEXT ) ; }",
        "ReadWritableInstant function ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1, ReadWritableInstant. class ) ; }",
        "ReadWritableInstant function ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, ReadWritableInstant. class ) ; }",
        "ReadWritableInstant function ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( StringUtil. isEmpty ( arg0 ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1 ) ; }",
        "ReadWritableInstant function ( String arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( StringUtil. isEmpty ( arg0 ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0 ) ; }",
        "ReadWritableInstant function ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ParseUtils. parse ( arg0, arg1 ) ; }",
        "ReadWritableInstant function ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. toInstant ( ) ) ; }",
        "ReadWritableInstant function ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1, ReadWritableInstant. builder ( ) ). build ( ) ; }",
        "ReadWritableInstant function ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, ReadWritableInstant. builder ( ) ). build ( ) ; }",
        "ReadWritableInstant function ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, ReadWritableInstant. class ) ; }",
        "ReadWritableInstant function ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1, ReadWritableInstant. class ) ; }",
        "ReadableInstant function ( String arg0, ReadableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0. trim ( ), arg1 ) ; }",
        "ReadableInstant function ( String arg0, ReadableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. toInstant ( ) ) ; }",
        "ReadableInstant function ( String arg0, ReadableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1. toInstant ( ) ) ; }",
        "ReadableInstant function ( String arg0, ReadableInstant arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. toInstant ( ) ) ; }",
        "ReadableInstant function ( String arg0 ) { if ( arg0 == null ) { return null ; } return ReadableInstant. parse ( arg0 ) ; }"
      ],
      "mid_translation": [
        "Parses the text into the specified read - only instant.",
        "Parses the text into the specified ReadWritableInstant.",
        "Parses the specified text into the specified ReadWritableInstant.",
        "Parses the given text into the specified ReadWritableInstant.",
        "Parses the text into the specified read - writable instant."
      ],
      "output": [
        {
          "patch": "public Instant parseInto ( String arg0 ) { if ( arg0 == null ) { return null ; } Instant loc0 = Instant. parse ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Instant parseInto ( String arg0 ) { Instant loc0 = Instant. parse ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Instant parseInto ( String arg0 ) { if ( arg0 == null ) { return null ; } Instant loc0 = LocalDateTime. parse ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Instant parseInto ( String arg0 ) { if ( arg0 == null ) { return null ; } return parse ( new StringReader ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Instant parseInto ( String arg0 ) { return parse ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. toInstant ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, TextParseContext arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. getText ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, TextFormat. getPrettyType ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, TextFormat. getPrettyType ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, TextMode. TEXT ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1, ReadWritableInstant. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, ReadWritableInstant. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( StringUtil. isEmpty ( arg0 ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( StringUtil. isEmpty ( arg0 ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ParseUtils. parse ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, ReadWritableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. toInstant ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1, ReadWritableInstant. builder ( ) ). build ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, ReadWritableInstant. builder ( ) ). build ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1, ReadWritableInstant. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadWritableInstant parseInto ( String arg0, TextFormat arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1, ReadWritableInstant. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadableInstant parseInto ( String arg0, ReadableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0. trim ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadableInstant parseInto ( String arg0, ReadableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. toInstant ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadableInstant parseInto ( String arg0, ReadableInstant arg1 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return parse ( arg0, arg1. toInstant ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadableInstant parseInto ( String arg0, ReadableInstant arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return deserialize ( arg0, arg1. toInstant ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ReadableInstant parseInto ( String arg0 ) { if ( arg0 == null ) { return null ; } return ReadableInstant. parse ( arg0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_46_/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java_156-157": {
      "loc": "156-157",
      "input": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(';');\n    return sb;\n}",
      "target": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n    sb.append(\">;\");\n    return sb;\n}",
      "function range": "150,5-158,5",
      "raw_output": [
        "Signature function ( Class <? extends java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? >> arg0 ) { return new Class <? extends java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? >> ( arg0 ) ; }",
        "Class <? extends java. lang. reflect. Signature > function ( ) { return ( Class <? extends java. lang. reflect. Signature > ) Signature. class ; }",
        "Signature function ( Class <? extends java. lang. reflect. Constructor <? > arg0, java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? >> arg1 ) { return ( Signature ) arg1. newInstance ( ) ; }",
        "Signature function ( Class <? extends java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? >> arg0 ) { return new Class <? extends java. lang. reflect. Constructor <? > > ( arg0 ) ; }",
        "Class <? extends java. lang. reflect. Signature > function ( ) { return Signature. class ; }",
        "String function ( ) { return Signature. forClass ( getClass ( ) ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( ) { Signature loc0 = Signature. get ( getClass ( ) ) ; loc0. setAccessible ( true ) ; return loc0. toString ( ) ; }",
        "String function ( ) { Signature loc0 = Signature. getInstance ( getClass ( ) ) ; loc0. setAccessible ( true ) ; return loc0. toString ( ) ; }",
        "String function ( ) { return Signature. fromSignature ( getClass ( ). getName ( ) ) ; }",
        "TypeSignature function ( ) { return null ; }",
        "TypeSignature function ( ) { return TypeSignature. forClass ( this ) ; }",
        "TypeSignature function ( ) { return TypeSignature. fromType ( this ) ; }",
        "TypeSignature function ( ) { return TypeSignature. forClass ( getClass ( ) ) ; }",
        "List < TypeSignature > function ( ) { return null ; }",
        "Class <? > [ ] function ( ) { return new Class <? > [ ] { Object. class } ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "Class <? > [ ] function ( ) { return null ; }",
        "Class <? extends java. lang. reflect. Constructor <? > [ ] function ( ) { return null ; }",
        "String function ( ) { return \"srini_string\" + getClass ( ). getName ( ) ; }",
        "TypeSignature function ( ) { return null ; }",
        "TypeSignature function ( ) { return TypeSignature. forClass ( this ) ; }",
        "TypeSignature function ( ) { return TypeSignature. get ( this ) ; }",
        "TypeSignature function ( ) { return TypeSignature. fromType ( this ) ; }",
        "TypeSignature function ( ) { return TypeSignature. create ( getClass ( ). getName ( ) ) ; }"
      ],
      "mid_translation": [
        "Get the generic signature.",
        "Returns the generic signature of this object.",
        "Returns the generic signature of this type.",
        "Get the generic signature of this object.",
        "Get the generic signature of this type."
      ],
      "output": [
        {
          "patch": "@Override\npublic Signature getGenericSignature ( Class <? extends java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? >> arg0 ) { return new Class <? extends java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? >> ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Class <? extends java. lang. reflect. Signature > getGenericSignature ( ) { return ( Class <? extends java. lang. reflect. Signature > ) Signature. class ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Signature getGenericSignature ( Class <? extends java. lang. reflect. Constructor <? > arg0, java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? >> arg1 ) { return ( Signature ) arg1. newInstance ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Signature getGenericSignature ( Class <? extends java. lang. reflect. Constructor <? extends java. lang. reflect. Constructor <? >> arg0 ) { return new Class <? extends java. lang. reflect. Constructor <? > > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Class <? extends java. lang. reflect. Signature > getGenericSignature ( ) { return Signature. class ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String getGenericSignature ( ) { return Signature. forClass ( getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String getGenericSignature ( ) { return \"srini_string\" ; }",
          "correctness": "timeout"
        },
        {
          "patch": "@Override\npublic String getGenericSignature ( ) { Signature loc0 = Signature. get ( getClass ( ) ) ; loc0. setAccessible ( true ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String getGenericSignature ( ) { Signature loc0 = Signature. getInstance ( getClass ( ) ) ; loc0. setAccessible ( true ) ; return loc0. toString ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String getGenericSignature ( ) { return Signature. fromSignature ( getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic TypeSignature getGenericSignature ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic TypeSignature getGenericSignature ( ) { return TypeSignature. forClass ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic TypeSignature getGenericSignature ( ) { return TypeSignature. fromType ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic TypeSignature getGenericSignature ( ) { return TypeSignature. forClass ( getClass ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic List < TypeSignature > getGenericSignature ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Class <? > [ ] getGenericSignature ( ) { return new Class <? > [ ] { Object. class } ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String getGenericSignature ( ) { return \"srini_string\" ; }",
          "correctness": "timeout"
        },
        {
          "patch": "@Override\npublic Class <? > [ ] getGenericSignature ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic Class <? extends java. lang. reflect. Constructor <? > [ ] getGenericSignature ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic String getGenericSignature ( ) { return \"srini_string\" + getClass ( ). getName ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic TypeSignature getGenericSignature ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic TypeSignature getGenericSignature ( ) { return TypeSignature. forClass ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic TypeSignature getGenericSignature ( ) { return TypeSignature. get ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic TypeSignature getGenericSignature ( ) { return TypeSignature. fromType ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic TypeSignature getGenericSignature ( ) { return TypeSignature. create ( getClass ( ). getName ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_27_/src/org/mockito/internal/util/MockUtil.java_64-66": {
      "loc": "64-66",
      "input": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n\n    ((Factory) mock).setCallback(0, newFilter);\n}",
      "target": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\n\n    ((Factory) mock).setCallback(0, newFilter);\n\n}",
      "function range": "62,5-67,5",
      "raw_output": [
        "void function ( ) { }",
        "void function ( ) { this. mock = null ; }",
        "void function ( ) { Log. reset ( ) ; }",
        "void function ( ) { Log. debug ( \"srini_string\" ) ; }",
        "void function ( ) { Log. info ( \"srini_string\" ) ; }",
        "void function ( ) { Log. debug ( \"srini_string\" ) ; }",
        "void function ( ) { Log. info ( \"srini_string\" ) ; }",
        "void function ( ) { Thread. currentThread ( ). setContext ( null ) ; }",
        "void function ( ) { Thread. currentThread ( ). reset ( ) ; }",
        "void function ( ) { Date loc0 = new Date ( ) ; Mockito. reset ( loc0 ) ; }",
        "void function ( ) { Log. reset ( ) ; }",
        "void function ( ) { LogMock. reset ( ) ; }",
        "void function ( ) { }",
        "void function ( ) { Log. debug ( \"srini_string\" ) ; }",
        "void function ( ) { TimePeriodMock. reset ( ) ; }",
        "void function ( ) { Log. reset ( ) ; }",
        "void function ( ) { Log. debug ( \"srini_string\" ) ; }",
        "void function ( ) { Log. info ( \"srini_string\" ) ; }",
        "void function ( ) { Thread. currentThread ( ). setContext ( null ) ; }",
        "void function ( ) { Thread. currentThread ( ). reset ( ) ; }",
        "void function ( ) { Log. debug ( \"srini_string\" ) ; }",
        "void function ( ) { Log. info ( \"srini_string\" ) ; }",
        "void function ( ) { }",
        "void function ( ) { Object loc0 = this ; this. loc0 = null ; }",
        "void function ( ) { Object loc0 = this. mock ; this. mock = null ; }"
      ],
      "mid_translation": [
        "Reset the mock.",
        "Reset a mock.",
        "Resets the mock.",
        "Resets a mock.",
        "Reset a mock object."
      ],
      "output": [
        {
          "patch": "public void resetMock ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { this. mock = null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. debug ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. info ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. debug ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. info ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Thread. currentThread ( ). setContext ( null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Thread. currentThread ( ). reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Date loc0 = new Date ( ) ; Mockito. reset ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { LogMock. reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. debug ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { TimePeriodMock. reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. debug ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. info ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Thread. currentThread ( ). setContext ( null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Thread. currentThread ( ). reset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. debug ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Log. info ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Object loc0 = this ; this. loc0 = null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void resetMock ( ) { Object loc0 = this. mock ; this. mock = null ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_38_/src/com/google/javascript/jscomp/CodeConsumer.java_245-246": {
      "loc": "245-246",
      "input": "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if (x < 0 && prev == '-') {\n    add(\" \");\n  }\n  if ((long) x == x && !negativeZero) {\n    long value = (long) x;\n    long mantissa = value;\n    int exp = 0;\n    if (Math.abs(x) >= 100) {\n      while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n        mantissa /= 10;\n        exp++;\n      }\n    }\n    if (exp > 2) {\n      add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n    } else {\n      add(Long.toString(value));\n    }\n  } else {\n    add(String.valueOf(x));\n  }\n}",
      "target": "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n  if ((x < 0 || negativeZero) && prev == '-') {\n    add(\" \");\n  }\n  if ((long) x == x && !negativeZero) {\n    long value = (long) x;\n    long mantissa = value;\n    int exp = 0;\n    if (Math.abs(x) >= 100) {\n      while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n        mantissa /= 10;\n        exp++;\n      }\n    }\n    if (exp > 2) {\n      add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n    } else {\n      add(Long.toString(value));\n    }\n  } else {\n    add(String.valueOf(x));\n  }\n}",
      "function range": "240,3-267,3",
      "raw_output": [
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { if ( arg0 == null ) { arg0 = new ArrayList < Integer > ( ) ; } arg0. add ( arg1 ) ; return arg0 ; }",
        "List < Integer > function ( Integer arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { if ( arg0 == null ) { arg0 = new ArrayList < > ( ) ; } arg0. add ( arg1 ) ; return arg0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { loc0 += loc1 ; } return arg0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "BigDecimal function ( double arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
        "BigDecimal function ( BigDecimal arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
        "BigDecimal function ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
        "BigDecimal function ( double arg0 ) { BigDecimal loc0 = new BigDecimal ( arg0 ) ; return loc0 ; }",
        "BigDecimal function ( BigDecimal arg0 ) { BigDecimal loc0 = new BigDecimal ( arg0. toString ( ) ) ; return loc0 ; }",
        "void function ( Number arg0 ) { }",
        "void function ( Integer arg0 ) { }",
        "int function ( Number arg0 ) { return arg0. intValue ( ) ; }",
        "R function ( Integer arg0 ) { R loc0 = null ; if ( arg0!= null ) { loc0 = arg0. intValue ( ) ; } return loc0 ; }",
        "int function ( Number arg0 ) { return arg0. longValue ( ) ; }",
        "BigDecimal function ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( arg0. doubleValue ( ) ) ; return loc0 ; }",
        "BigDecimal function ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0. doubleValue ( ) ) ; return loc0 ; }",
        "BigDecimal function ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
        "BigDecimal function ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. multiply ( arg0 ) ; return loc0 ; }",
        "BigDecimal function ( Number arg0 ) { BigDecimal loc0 = null ; if ( arg0!= null ) { loc0 = new BigDecimal ( arg0. toString ( ) ) ; } return loc0 ; }",
        "int [ ] function ( int [ ] arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return arg0 ; }",
        "String [ ] function ( String [ ] arg0, int arg1 ) { String [ ] loc0 = new String [ arg0. length + 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "String [ ] function ( String [ ] arg0, int arg1 ) { String [ ] loc0 = new String [ arg0. length + arg1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "int [ ] function ( int [ ] arg0, int arg1 ) { int [ ] loc0 = new int [ arg0. length + 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] += arg1 ; } return loc0 ; }",
        "int [ ] function ( int [ ] arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { arg0 [ loc1 ] += arg1 ; } return arg0 ; }"
      ],
      "mid_translation": [
        "Add a number to the list.",
        "Add a number to the result.",
        "addNumber Method.",
        "Add a number.",
        "Add a number to the array."
      ],
      "output": [
        {
          "patch": "List < Integer > addNumber ( List < Integer > arg0, int arg1 ) { if ( arg0 == null ) { arg0 = new ArrayList < Integer > ( ) ; } arg0. add ( arg1 ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < Integer > addNumber ( Integer arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < Integer > addNumber ( List < Integer > arg0, int arg1 ) { if ( arg0 == null ) { arg0 = new ArrayList < > ( ) ; } arg0. add ( arg1 ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < Integer > addNumber ( List < Integer > arg0, int arg1 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { loc0 += loc1 ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "List < Integer > addNumber ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( double arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( BigDecimal arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( double arg0 ) { BigDecimal loc0 = new BigDecimal ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( BigDecimal arg0 ) { BigDecimal loc0 = new BigDecimal ( arg0. toString ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "void addNumber ( Number arg0 ) { }",
          "correctness": "timeout"
        },
        {
          "patch": "void addNumber ( Integer arg0 ) { }",
          "correctness": "timeout"
        },
        {
          "patch": "int addNumber ( Number arg0 ) { return arg0. intValue ( ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "R addNumber ( Integer arg0 ) { R loc0 = null ; if ( arg0!= null ) { loc0 = arg0. intValue ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int addNumber ( Number arg0 ) { return arg0. longValue ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( arg0. doubleValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0. doubleValue ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. add ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( Number arg0 ) { BigDecimal loc0 = new BigDecimal ( ) ; loc0. multiply ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "BigDecimal addNumber ( Number arg0 ) { BigDecimal loc0 = null ; if ( arg0!= null ) { loc0 = new BigDecimal ( arg0. toString ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "int [ ] addNumber ( int [ ] arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] ; } return arg0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "String [ ] addNumber ( String [ ] arg0, int arg1 ) { String [ ] loc0 = new String [ arg0. length + 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "String [ ] addNumber ( String [ ] arg0, int arg1 ) { String [ ] loc0 = new String [ arg0. length + arg1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "int [ ] addNumber ( int [ ] arg0, int arg1 ) { int [ ] loc0 = new int [ arg0. length + 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] += arg1 ; } return loc0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "int [ ] addNumber ( int [ ] arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { arg0 [ loc1 ] += arg1 ; } return arg0 ; }",
          "correctness": "timeout"
        }
      ]
    },
    "Time_19_/src/main/java/org/joda/time/DateTimeZone.java_900-901": {
      "loc": "900-901",
      "input": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal != offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    } else if (offsetLocal > 0) {\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
      "target": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal != offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    } else if (offsetLocal >= 0) {\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}",
      "function range": "880,5-911,5",
      "raw_output": [
        "Offset function ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneId. systemDefault ( ) ) ; return Offset. of ( loc0 ) ; }",
        "Offset function ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneId. systemDefault ( ) ) ; return Offset. from ( loc0 ) ; }",
        "ZoneOffset function ( Instant arg0 ) { return ZoneOffset. ofEpochMilli ( arg0. atZone ( ZoneOffset. UTC ) ) ; }",
        "Offset function ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneId. systemDefault ( ) ) ; return loc0. atZone ( ZoneOffset. UTC ) ; }",
        "Offset function ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return loc0. atZone ( ZoneOffset. UTC ). getOffset ( ) ; }",
        "ZoneOffset function ( ) { return ZoneOffset. ofLocalTime ( ). atZone ( ZoneOffset. UTC ) ; }",
        "Offset function ( Instant arg0 ) { return Offsets. localTimeOffset ( arg0 ) ; }",
        "ZoneOffset function ( ) { return ZoneOffset. ofLocalTime ( ). atZone ( ZoneId. UTC ) ; }",
        "Offset function ( ) { Instant loc0 = DateTime. now ( ) ; return OffsetUtils. localTimeOffset ( loc0 ) ; }",
        "long function ( ) { return Instant. ofEpochMilli ( System. currentTimeMillis ( ) ) ; }",
        "Offset function ( Instant arg0 ) { return Offset. from ( arg0 ) ; }",
        "Offset function ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return new Offset ( loc0 ) ; }",
        "Offset function ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return Offset. from ( loc0 ) ; }",
        "Offset function ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return Offset. of ( loc0 ) ; }",
        "long function ( Instant arg0 ) { return arg0. atZone ( ZoneId. systemDefault ( ) ). toInstant ( ). getOffset ( ) ; }",
        "Offset function ( Time arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return new Offset ( loc0 ) ; }",
        "Offset function ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return new Offset ( loc0 ) ; }",
        "Offset function ( Instant arg0 ) { return Offset. from ( arg0. atZone ( ZoneOffset. UTC ) ) ; }",
        "Offset function ( Instant arg0 ) { return Offset. from ( arg0. atZone ( ZoneId. UTC ) ) ; }",
        "ZoneOffset function ( ) { return ZoneOffset. ofLocalTime ( ). atZone ( ZoneOffset. UTC ) ; }",
        "long function ( ) { return Instant. ofEpochMilli ( ). get ( ) ; }",
        "long function ( ) { return Instant. now ( ). atZone ( ZoneId. UTC ). getOffset ( ) ; }",
        "long function ( ) { return Instant. now ( ). atZone ( ZoneId. UTC ). get ( ) ; }",
        "Offset function ( Instant arg0 ) { return Offset. from ( arg0 ) ; }",
        "long function ( ) { return Instant. now ( ). atZone ( ZoneId. systemDefault ( ) ) ; }"
      ],
      "mid_translation": [
        "Gets the offset from the local instant.",
        "Gets the offset from the local time instant.",
        "Get the offset from the local instant.",
        "Get the offset from the local time instant.",
        "Gets the offset from the instant local."
      ],
      "output": [
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneId. systemDefault ( ) ) ; return Offset. of ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneId. systemDefault ( ) ) ; return Offset. from ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ZoneOffset getOffsetFromLocal ( Instant arg0 ) { return ZoneOffset. ofEpochMilli ( arg0. atZone ( ZoneOffset. UTC ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneId. systemDefault ( ) ) ; return loc0. atZone ( ZoneOffset. UTC ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return loc0. atZone ( ZoneOffset. UTC ). getOffset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ZoneOffset getOffsetFromLocal ( ) { return ZoneOffset. ofLocalTime ( ). atZone ( ZoneOffset. UTC ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { return Offsets. localTimeOffset ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ZoneOffset getOffsetFromLocal ( ) { return ZoneOffset. ofLocalTime ( ). atZone ( ZoneId. UTC ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( ) { Instant loc0 = DateTime. now ( ) ; return OffsetUtils. localTimeOffset ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getOffsetFromLocal ( ) { return Instant. ofEpochMilli ( System. currentTimeMillis ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { return Offset. from ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return new Offset ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return Offset. from ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return Offset. of ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getOffsetFromLocal ( Instant arg0 ) { return arg0. atZone ( ZoneId. systemDefault ( ) ). toInstant ( ). getOffset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Time arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return new Offset ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { Instant loc0 = arg0. atZone ( ZoneOffset. UTC ) ; return new Offset ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { return Offset. from ( arg0. atZone ( ZoneOffset. UTC ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { return Offset. from ( arg0. atZone ( ZoneId. UTC ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public ZoneOffset getOffsetFromLocal ( ) { return ZoneOffset. ofLocalTime ( ). atZone ( ZoneOffset. UTC ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getOffsetFromLocal ( ) { return Instant. ofEpochMilli ( ). get ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getOffsetFromLocal ( ) { return Instant. now ( ). atZone ( ZoneId. UTC ). getOffset ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getOffsetFromLocal ( ) { return Instant. now ( ). atZone ( ZoneId. UTC ). get ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Offset getOffsetFromLocal ( Instant arg0 ) { return Offset. from ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public long getOffsetFromLocal ( ) { return Instant. now ( ). atZone ( ZoneId. systemDefault ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_12_/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java_303-304": {
      "loc": "303-304",
      "input": "@Override\npublic boolean isCachable() {\n    return (_valueTypeDeserializer == null)\n            && (_ignorableProperties == null);\n}",
      "target": "@Override\npublic boolean isCachable() {\n    return (_valueDeserializer == null)\n            && (_keyDeserializer == null)\n            && (_valueTypeDeserializer == null)\n            && (_ignorableProperties == null);\n}",
      "function range": "298,5-305,5",
      "raw_output": [
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { return true ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; return true ; }",
        "boolean function ( Object arg0 ) { return arg0 instanceof Cacheable ; }",
        "boolean function ( Object arg0 ) { return arg0!= null && arg0 instanceof Cacheable ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { return true ; }",
        "boolean function ( Cacheable arg0 ) { return arg0 instanceof Cachable ; }",
        "boolean function ( ) { Cacheable loc0 = null ; return ( loc0!= null ) ; }",
        "boolean function ( Cacheable arg0 ) { return arg0 instanceof Cacheable ; }",
        "boolean function ( ) { return ConfigurationService. getInstance ( ). getCacheEnabled ( ) ; }",
        "boolean function ( ) { return ConfigurationService. getBoolean ( \"srini_string\", false ) ; }",
        "boolean function ( Configuration arg0 ) { return arg0. getBoolean ( PropertyKey. CACHE_ENABLED, false ) ; }",
        "boolean function ( ) { return ConfigurationService. getInstance ( ). getCacheEnabled ( ConfigurationService. getCacheName ( ) ) ; }",
        "boolean function ( ) { return ConfigurationService. getInstance ( ). getBoolean ( PropertyKey. CACHE_ENABLED, false ) ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { return cachedObj == null ; }",
        "boolean function ( ) { return cachedObjects == null || cachedObjects. isEmpty ( ) ; }",
        "boolean function ( ) { return null!= this ; }",
        "boolean function ( ) { return cachedObjects == null ||! cachedObjects. containsKey ( ) ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( ) { return Cache. get ( ) == null ; }",
        "boolean function ( ) { return Cache. get ( this ) == null ; }",
        "boolean function ( ) { return EnumerationCache. getInstance ( ) == null ; }",
        "boolean function ( ) { return Cache. getInstance ( ) == null ; }"
      ],
      "mid_translation": [
        "Returns true if this object can be cached.",
        "Returns true if this object is cachable.",
        "Returns true if the cache is enabled.",
        "Returns true if this object is not cached.",
        "Returns true if the enumeration is not cached."
      ],
      "output": [
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return false ; }",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return true ; }",
          "correctness": "timeout"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( Object arg0 ) { if ( arg0 == null ) return false ; return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( Object arg0 ) { return arg0 instanceof Cacheable ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( Object arg0 ) { return arg0!= null && arg0 instanceof Cacheable ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return false ; }",
          "correctness": "timeout"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( Cacheable arg0 ) { return arg0 instanceof Cachable ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { Cacheable loc0 = null ; return ( loc0!= null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( Cacheable arg0 ) { return arg0 instanceof Cacheable ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return ConfigurationService. getInstance ( ). getCacheEnabled ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return ConfigurationService. getBoolean ( \"srini_string\", false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( Configuration arg0 ) { return arg0. getBoolean ( PropertyKey. CACHE_ENABLED, false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return ConfigurationService. getInstance ( ). getCacheEnabled ( ConfigurationService. getCacheName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return ConfigurationService. getInstance ( ). getBoolean ( PropertyKey. CACHE_ENABLED, false ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return false ; }",
          "correctness": "timeout"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return cachedObj == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return cachedObjects == null || cachedObjects. isEmpty ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return null!= this ; }",
          "correctness": "wrong"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return cachedObjects == null ||! cachedObjects. containsKey ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return false ; }",
          "correctness": "plausible"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return Cache. get ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return Cache. get ( this ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return EnumerationCache. getInstance ( ) == null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "@Override\npublic boolean isCachable ( ) { return Cache. getInstance ( ) == null ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_1_/src/org/mockito/internal/invocation/InvocationMatcher.java_123-124": {
      "loc": "123-124",
      "input": "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        throw new UnsupportedOperationException();\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}",
      "target": "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < indexOfVararg; position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n        for (int position = indexOfVararg; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}",
      "function range": "120,5-150,5",
      "raw_output": [
        "Object function ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
        "Object function ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ ] { arg1 [ 0 ] }, arg1 [ 1 ] ) ; }",
        "Object function ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ ] { arg1 }, arg2 ) ; }",
        "Object function ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ arg2. length ] ) ; }",
        "Object [ ] function ( InvocationContext arg0 ) { return new Class < Object > [ ] { Object. class } ; }",
        "Object function ( InvocationOnMock arg0 ) { return arg0. getCaptures ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getCaptures ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getCapturesArguments ( ) ; }",
        "Object function ( InvocationOnMock arg0 ) { return arg0. getCapturedArguments ( ) ; }",
        "T function ( Invocation < T > arg0 ) { return arg0. getCaptures ( ) ; }",
        "Object function ( Invocation < T > arg0, Class < T > arg1, Class <? extends T >... arg2 ) { return captureArguments ( arg0, new Class <? extends T > [ ] { arg1 }, arg2 ) ; }",
        "Object function ( InvocationOnMock arg0 ) { return arg0. getCaptain ( ) ; }",
        "T function ( Invocation < T > arg0, Class < T > arg1 ) { return arg0. getCaptain ( ). apply ( arg1 ) ; }",
        "Object function ( InvocationOnMock arg0 ) { return arg0. getCaptureArguments ( ) ; }",
        "T function ( Invocation < T > arg0, Class < T > arg1, Class <? extends T > arg2 ) { return arg0. getCaptain ( ). apply ( arg1 ) ; }",
        "Object [ ] function ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArguments ( ). size ( ) ] ; loc0 [ 0 ] = arg0. getArguments ( ) ; return loc0 ; }",
        "Object [ ] function ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArguments ( ). size ( ) ] ; return loc0 ; }",
        "Object [ ] function ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArguments ( ). size ( ) ] ; arg0. getArguments ( ). toArray ( loc0 ) ; return loc0 ; }",
        "Object [ ] function ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getThis ( ). getClass ( ). getParameterTypes ( ). size ( ) ] ; return loc0 ; }",
        "Object [ ] function ( MethodInvocation arg0 ) { return new Object [ ] { arg0. getThis ( ) } ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
        "Object function ( MethodInvocation arg0, Class <? >... arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( ) ; }",
        "Object [ ] function ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArgumentCount ( ) ] ; return loc0 ; }"
      ],
      "mid_translation": [
        "Capture arguments from an invocation.",
        "Captures arguments from the given invocation.",
        "Capture arguments from the given invocation.",
        "Capture arguments from a method invocation.",
        "Capture arguments from the invocation."
      ],
      "output": [
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > [ ] arg1 ) { return arguments ( new Class <? > [ ] { arg1 [ 0 ] }, arg1 [ 1 ] ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ ] { arg1 }, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationContext arg0, Class <? > arg1, Class <? >... arg2 ) { return arguments ( new Class <? > [ arg2. length ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( InvocationContext arg0 ) { return new Class < Object > [ ] { Object. class } ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationOnMock arg0 ) { return arg0. getCaptures ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getCaptures ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getCapturesArguments ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationOnMock arg0 ) { return arg0. getCapturedArguments ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T captureArgumentsFrom ( Invocation < T > arg0 ) { return arg0. getCaptures ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( Invocation < T > arg0, Class < T > arg1, Class <? extends T >... arg2 ) { return captureArguments ( arg0, new Class <? extends T > [ ] { arg1 }, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationOnMock arg0 ) { return arg0. getCaptain ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T captureArgumentsFrom ( Invocation < T > arg0, Class < T > arg1 ) { return arg0. getCaptain ( ). apply ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( InvocationOnMock arg0 ) { return arg0. getCaptureArguments ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T captureArgumentsFrom ( Invocation < T > arg0, Class < T > arg1, Class <? extends T > arg2 ) { return arg0. getCaptain ( ). apply ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArguments ( ). size ( ) ] ; loc0 [ 0 ] = arg0. getArguments ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArguments ( ). size ( ) ] ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArguments ( ). size ( ) ] ; arg0. getArguments ( ). toArray ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getThis ( ). getClass ( ). getParameterTypes ( ). size ( ) ] ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( MethodInvocation arg0 ) { return new Object [ ] { arg0. getThis ( ) } ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ). get ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0, Class <? >... arg1 ) { return arguments ( new Class <? > [ arg1. length ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object captureArgumentsFrom ( MethodInvocation arg0 ) { return arg0. getArguments ( ). toArray ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object [ ] captureArgumentsFrom ( MethodInvocation arg0 ) { Object [ ] loc0 = new Object [ arg0. getArgumentCount ( ) ] ; return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_8_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_79-80": {
      "loc": "79-80",
      "input": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else {\n\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}",
      "target": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n        } else if (typeParameter != actualTypeArgument) {\n\n            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n        }\n    }\n}",
      "function range": "66,5-84,5",
      "raw_output": [
        "void function ( Injector arg0 ) { arg0. registerTypeVariables ( TypeVariable. class ) ; arg0. registerTypeVariables ( TypeVariable. class ) ; }",
        "void function ( Injector arg0, Class <? > arg1 ) { arg0. registerTypeVariables ( new TypeVariableRegistry ( arg1 ) ) ; }",
        "void function ( Injector arg0, Class <? > arg1 ) { arg0. registerTypeVariables ( new TypeVariables ( ) ) ; arg0. registerTypeVariables ( new TypeVariables ( ) ) ; }",
        "void function ( Injector arg0, Class <? > arg1, Map < String,? > arg2 ) { arg0. registerTypeVariables ( new TypeVariables ( arg1, arg2 ) ) ; }",
        "void function ( Injector arg0, Class <? > arg1, Map < String,? > arg2 ) { arg0. registerTypeVariables ( TypeVariables. class, arg1, arg2 ) ; }",
        "void function ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( final Class <? > arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( final Class <? > arg0, final Map < String,? > arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( final ClassType arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( Type arg0, Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( Type arg0, Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( final Class <? > arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( final Class arg0 ) { Type loc0 = arg0. getTypeLiteral ( ) ; Type loc1 = arg0. getTypeLiteral ( ) ; registerTypeVariables ( loc0, loc1 ) ; }",
        "void function ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). put ( \"srini_string\", arg1 ) ; }",
        "void function ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( final Class arg0, final Map arg1 ) { arg0. putAll ( arg1 ) ; }",
        "void function ( Class arg0, Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( final Class arg0, final Map arg1 ) { arg0. setVariables ( arg1 ) ; }",
        "void function ( Class arg0, Map arg1 ) { }",
        "void function ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( final Class <? > arg0, final Map < String,? > arg1 ) { arg0. putAll ( arg1 ) ; }",
        "void function ( final Class arg0, final Map arg1 ) { arg0. putAll ( arg1 ) ; }",
        "void function ( Class <? > arg0, Map < String,? > arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
        "void function ( Class <? > arg0, Map < String,? > arg1 ) { arg0. putAll ( arg1 ) ; }"
      ],
      "mid_translation": [
        "Register type variables on.",
        "Registers type variables on the class type.",
        "Register type variables on the class type.",
        "Registers the type variables on the class.",
        "Registers type variables on the class."
      ],
      "output": [
        {
          "patch": "protected void registerTypeVariablesOn ( Injector arg0 ) { arg0. registerTypeVariables ( TypeVariable. class ) ; arg0. registerTypeVariables ( TypeVariable. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Injector arg0, Class <? > arg1 ) { arg0. registerTypeVariables ( new TypeVariableRegistry ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Injector arg0, Class <? > arg1 ) { arg0. registerTypeVariables ( new TypeVariables ( ) ) ; arg0. registerTypeVariables ( new TypeVariables ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Injector arg0, Class <? > arg1, Map < String,? > arg2 ) { arg0. registerTypeVariables ( new TypeVariables ( arg1, arg2 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Injector arg0, Class <? > arg1, Map < String,? > arg2 ) { arg0. registerTypeVariables ( TypeVariables. class, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class <? > arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class <? > arg0, final Map < String,? > arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final ClassType arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Type arg0, Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Type arg0, Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class <? > arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class arg0 ) { Type loc0 = arg0. getTypeLiteral ( ) ; Type loc1 = arg0. getTypeLiteral ( ) ; registerTypeVariables ( loc0, loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). put ( \"srini_string\", arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class arg0, final Map arg1 ) { arg0. putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Class arg0, Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class arg0, final Map arg1 ) { arg0. setVariables ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Class arg0, Map arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class arg0, final Map arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class <? > arg0, final Map < String,? > arg1 ) { arg0. putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( final Class arg0, final Map arg1 ) { arg0. putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Class <? > arg0, Map < String,? > arg1 ) { arg0. getTypeVariables ( ). putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected void registerTypeVariablesOn ( Class <? > arg0, Map < String,? > arg1 ) { arg0. putAll ( arg1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_38_/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java_48-49": {
      "loc": "48-49",
      "input": "private boolean toStringEquals(Matcher m, Object arg) {\n    return StringDescription.toString(m).equals(arg.toString());\n\n}",
      "target": "private boolean toStringEquals(Matcher m, Object arg) {\n    return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n\n}",
      "function range": "47,5-49,5",
      "raw_output": [
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! loc0. equals ( arg1 ) ) { return false ; } return true ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! ( loc0 instanceof Message ) ) { return false ; } return ( ( Message ) loc0 ). getMessage ( ). equals ( arg1 ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! ( loc0 instanceof Message ) ) { return false ; } return ( ( Message ) loc0 ). getMessage ( ). equals ( \"srini_string\" ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! loc0. equals ( arg1 ) ) { return false ; } return true ; }",
        "boolean function ( Matcher arg0, Matcher arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( Matcher arg0, Matcher arg1 ) { return arg0. matches ( arg1 ) ; }",
        "boolean function ( Matcher arg0, Matcher arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( Matcher < T > arg0, Matcher < T > arg1 ) { return arg0. matches ( arg1 ) ; }",
        "boolean function ( Matcher < T > arg0, Matcher < T > arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return true ; } return ( arg0. compareTo ( arg1 ) == 0 ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { return ( arg0 == null || arg1 == null )? true : arg0. equals ( arg1 ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return true ; } if ( arg1 == null ) { return false ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. compareTo ( arg1 ) == 0 ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! ( loc0 instanceof Message ) ) { return false ; } return true ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return true ; } return ( arg0. compareTo ( arg1 ) == 0 ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! loc0. equals ( arg1 ) ) { return false ; } return true ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! ( loc0 instanceof Message ) ) { return false ; } return ( ( Message ) loc0 ). getMessage ( ). equals ( arg1 ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) return false ; if ( arg0 == null ||! ( arg1 instanceof Message ) ) return false ; Message loc0 = ( Message ) arg0 ; if (! loc0. equals ( arg1 ) ) return false ; return true ; }"
      ],
      "mid_translation": [
        "Returns true if m equals arg.",
        "Checks to see if two matchers are equal.",
        "returns true if m equals arg",
        "Returns true if m equals arg",
        "returns true if m equals arg."
      ],
      "output": [
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! loc0. equals ( arg1 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! ( loc0 instanceof Message ) ) { return false ; } return ( ( Message ) loc0 ). getMessage ( ). equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! ( loc0 instanceof Message ) ) { return false ; } return ( ( Message ) loc0 ). getMessage ( ). equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! loc0. equals ( arg1 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Matcher arg0, Matcher arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Matcher arg0, Matcher arg1 ) { return arg0. matches ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Matcher arg0, Matcher arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Matcher < T > arg0, Matcher < T > arg1 ) { return arg0. matches ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Matcher < T > arg0, Matcher < T > arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return true ; } return ( arg0. compareTo ( arg1 ) == 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { return ( arg0 == null || arg1 == null )? true : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return true ; } if ( arg1 == null ) { return false ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. compareTo ( arg1 ) == 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! ( loc0 instanceof Message ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == null ) { return true ; } return ( arg0. compareTo ( arg1 ) == 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! loc0. equals ( arg1 ) ) { return false ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null ||! ( arg1 instanceof Message ) ) { return false ; } Message loc0 = ( Message ) arg0 ; if (! ( loc0 instanceof Message ) ) { return false ; } return ( ( Message ) loc0 ). getMessage ( ). equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return ( arg0. hashCode ( ) == arg1. hashCode ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private boolean toStringEquals ( Message arg0, Message arg1 ) { if ( arg0 == null || arg1 == null ) return false ; if ( arg0 == null ||! ( arg1 instanceof Message ) ) return false ; Message loc0 = ( Message ) arg0 ; if (! loc0. equals ( arg1 ) ) return false ; return true ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Time_4_/src/main/java/org/joda/time/Partial.java_464-465": {
      "loc": "464-465",
      "input": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}",
      "target": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        Partial newPartial = new Partial(newTypes, newValues, iChronology);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}",
      "function range": "426,5-474,5",
      "raw_output": [
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long",
        "Too long"
      ],
      "mid_translation": [
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long",
        "Input too long"
      ],
      "output": [
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        },
        {
          "patch": "",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_28_/src/org/mockito/internal/configuration/DefaultInjectionEngine.java_93-94": {
      "loc": "93-94",
      "input": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n\n    }\n}",
      "target": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n\n        mocks.remove(injected);\n    }\n}",
      "function range": "91,5-95,5",
      "raw_output": [
        "Mocks function ( Candidate... arg0 ) { return inject ( Arrays. asList ( arg0 ) ) ; }",
        "void function ( MockitoAnnotations arg0 ) { MockitoAnnotations. arg0 = arg0 ; }",
        "void function ( MockitoAnnotations arg0, MockitoAnnotations arg1 ) { arg0. inject ( MockitoAnnotations. in ( arg1 ) ) ; }",
        "Mocks function ( Captures arg0 ) { return inject ( Arrays. asList ( arg0. getMockCandidates ( ) ) ) ; }",
        "Mocks function ( Mocks arg0 ) { return inject ( Arrays. asList ( arg0 ) ) ; }",
        "void function ( MockitoAnnotations arg0 ) { for ( MockitoAnnotations loc0 : arg0 ) { MockitoAnnotations. inject ( loc0 ) ; } }",
        "void function ( MockitoAnnotations arg0, MockitoAnnotations arg1 ) { arg0. inject ( mockCandidates ( arg1 ) ) ; }",
        "void function ( MockitoAnnotations arg0 ) { MockitoAnnotations. arg0 = arg0 ; }",
        "void function ( MockitoAnnotations arg0, MockitoAnnotations arg1 ) { arg0. inject ( MockitoAnnotations. in ( arg1 ) ) ; }",
        "void function ( MockitoAnnotations arg0 ) { arg0. inject ( mockCandidates ( arg0 ) ) ; }",
        "void function ( Injector arg0, T arg1 ) { arg0. injectMembers ( arg1 ) ; }",
        "void function ( Injector arg0, T arg1 ) { arg0. inject ( arg1 ) ; }",
        "void function ( T arg0 ) { arg0. inject ( mock ( T. class ) ) ; }",
        "void function ( T arg0 ) { arg0. inject ( Mockito. any ( ) ) ; }",
        "void function ( T arg0 ) { }",
        "void function ( Injector arg0, T arg1 ) { arg0. inject ( arg1 ) ; }",
        "void function ( T arg0 ) { Mockito. mock ( T. class ). inject ( arg0 ) ; }",
        "void function ( Injector arg0, Object arg1 ) { arg0. inject ( arg1 ) ; }",
        "void function ( T arg0 ) { arg0. inject ( mock ( T. class ) ) ; }",
        "T function ( T arg0 ) { return arg0 ; }",
        "void function ( Injector arg0, T arg1 ) { arg0. inject ( arg1 ) ; }",
        "void function ( T arg0 ) { Mockito. mock ( T. class ). inject ( arg0 ) ; }",
        "void function ( Injector arg0, T arg1 ) { arg0. inject ( mock ( T. class ), arg1 ) ; }",
        "void function ( T arg0 ) { Injector loc0 = Injector. getInstance ( ) ; loc0. inject ( arg0 ) ; }",
        "void function ( Injector arg0, T arg1 ) { arg0. inject ( Mockito. any ( ) ) ; }"
      ],
      "mid_translation": [
        "Inject a set of mock candidates.",
        "Injects a set of mock candidates.",
        "Injects the mock candidate.",
        "Injects a mock candidate.",
        "Inject a mock candidate."
      ],
      "output": [
        {
          "patch": "private Mocks injectMockCandidate ( Candidate... arg0 ) { return inject ( Arrays. asList ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( MockitoAnnotations arg0 ) { MockitoAnnotations. arg0 = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( MockitoAnnotations arg0, MockitoAnnotations arg1 ) { arg0. inject ( MockitoAnnotations. in ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Mocks injectMockCandidate ( Captures arg0 ) { return inject ( Arrays. asList ( arg0. getMockCandidates ( ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Mocks injectMockCandidate ( Mocks arg0 ) { return inject ( Arrays. asList ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( MockitoAnnotations arg0 ) { for ( MockitoAnnotations loc0 : arg0 ) { MockitoAnnotations. inject ( loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( MockitoAnnotations arg0, MockitoAnnotations arg1 ) { arg0. inject ( mockCandidates ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( MockitoAnnotations arg0 ) { MockitoAnnotations. arg0 = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( MockitoAnnotations arg0, MockitoAnnotations arg1 ) { arg0. inject ( MockitoAnnotations. in ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( MockitoAnnotations arg0 ) { arg0. inject ( mockCandidates ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( Injector arg0, T arg1 ) { arg0. injectMembers ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( Injector arg0, T arg1 ) { arg0. inject ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( T arg0 ) { arg0. inject ( mock ( T. class ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( T arg0 ) { arg0. inject ( Mockito. any ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( T arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( Injector arg0, T arg1 ) { arg0. inject ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( T arg0 ) { Mockito. mock ( T. class ). inject ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( Injector arg0, Object arg1 ) { arg0. inject ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( T arg0 ) { arg0. inject ( mock ( T. class ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private T injectMockCandidate ( T arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( Injector arg0, T arg1 ) { arg0. inject ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( T arg0 ) { Mockito. mock ( T. class ). inject ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( Injector arg0, T arg1 ) { arg0. inject ( mock ( T. class ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( T arg0 ) { Injector loc0 = Injector. getInstance ( ) ; loc0. inject ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void injectMockCandidate ( Injector arg0, T arg1 ) { arg0. inject ( Mockito. any ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_16_/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java_112-113": {
      "loc": "112-113",
      "input": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return (previous != null) && previous.equals(ann);\n}",
      "target": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n    return (previous == null) || !previous.equals(ann);\n}",
      "function range": "107,5-113,5",
      "raw_output": [
        "void function ( AnnotationCache arg0, Class <? extends Annotation > arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
        "void function ( AnnotationCache arg0, Class <? extends Annotation > arg1 ) { arg0. add ( arg1 ) ; }",
        "void function ( Annotations arg0, Class <? extends Annotation > arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
        "void function ( AnnotationCache arg0, Class <? extends java. lang. annotation. Annotation > arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
        "void function ( AnnotationCache arg0, String arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
        "void function ( Class <? extends Annotation > arg0, Annotation... arg1 ) { add ( arg0, Arrays. asList ( arg1 ) ) ; }",
        "void function ( Class <? extends Annotation > arg0, Annotation [ ] arg1 ) { add ( arg0, arg1, null ) ; }",
        "void function ( Class <? extends Annotation > arg0 ) { add ( arg0, new AnnotationHolder ( arg0 ) ) ; }",
        "void function ( Class <? extends Annotation > arg0, Annotation [ ] arg1 ) { add ( arg0, null, arg1 ) ; }",
        "void function ( Class <? extends Annotation > arg0 ) { add ( new AnnotationHolder ( arg0 ) ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
        "void function ( Class <? extends Annotation > arg0, Annotation... arg1 ) { add ( arg0, Arrays. asList ( arg1 ) ) ; }",
        "void function ( Class <? extends Annotation > arg0, Annotation... arg1 ) { addAnnotation ( arg0, Arrays. asList ( arg1 ) ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final Annotation... arg1 ) { add ( arg0, Arrays. asList ( arg1 ) ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final Annotation... arg1 ) { addAnnotation ( arg0, new Annotation [ ] { arg1 } ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg1. addAnnotation ( new AnnotationHolder ( arg0 ) ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg0. addAnnotation ( new AnnotationHolder ( arg1 ) ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg0. getAnnotation ( arg1 ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final Annotation... arg1 ) { addAnnotation ( arg0, null, arg1 ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final Annotation arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }",
        "void function ( Class <? extends Annotation > arg0, Annotation arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }",
        "void function ( Class <? extends Annotation > arg0, String arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }",
        "void function ( final Class <? extends Annotation > arg0, final String arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }",
        "void function ( Class <? extends Annotation > arg0, Annotation arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }"
      ],
      "mid_translation": [
        "Add an annotation to the cache.",
        "Add an annotation.",
        "Add an annotation to this class.",
        "Adds an annotation to this class.",
        "Add an annotation to the class hierarchy."
      ],
      "output": [
        {
          "patch": "protected final void _add ( AnnotationCache arg0, Class <? extends Annotation > arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( AnnotationCache arg0, Class <? extends Annotation > arg1 ) { arg0. add ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Annotations arg0, Class <? extends Annotation > arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( AnnotationCache arg0, Class <? extends java. lang. annotation. Annotation > arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( AnnotationCache arg0, String arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0, Annotation... arg1 ) { add ( arg0, Arrays. asList ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0, Annotation [ ] arg1 ) { add ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0 ) { add ( arg0, new AnnotationHolder ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0, Annotation [ ] arg1 ) { add ( arg0, null, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0 ) { add ( new AnnotationHolder ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0, Annotation... arg1 ) { add ( arg0, Arrays. asList ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0, Annotation... arg1 ) { addAnnotation ( arg0, Arrays. asList ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final Annotation... arg1 ) { add ( arg0, Arrays. asList ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final Annotation... arg1 ) { addAnnotation ( arg0, new Annotation [ ] { arg1 } ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg0. addAnnotation ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg1. addAnnotation ( new AnnotationHolder ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg0. addAnnotation ( new AnnotationHolder ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final Annotation. Builder arg1 ) { arg0. getAnnotation ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final Annotation... arg1 ) { addAnnotation ( arg0, null, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final Annotation arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0, Annotation arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0, String arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( final Class <? extends Annotation > arg0, final String arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "protected final void _add ( Class <? extends Annotation > arg0, Annotation arg1 ) { org. springframework. core. annotation. AnnotationUtils. addAnnotation ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_70_/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java_440-441": {
      "loc": "440-441",
      "input": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            found = key.equals(prop.getName());\n            if (found) {\n                _propsInOrder[_findFromOrdered(prop)] = null;\n                continue;\n            }\n        }\n        props.add(prop);\n    }\n    if (!found) {\n        throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n    }\n    init(props);\n}",
      "target": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n            found = key.equals(_hashArea[i-1]);\n            if (found) {\n                _propsInOrder[_findFromOrdered(prop)] = null;\n                continue;\n            }\n        }\n        props.add(prop);\n    }\n    if (!found) {\n        throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n    }\n    init(props);\n}",
      "function range": "426,5-453,5",
      "raw_output": [
        "void function ( String arg0 ) { Properties loc0 = ( Properties ) set. get ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
        "void function ( String arg0 ) { Properties loc0 = ( Properties ) this. set. get ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
        "void function ( String arg0 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
        "void function ( String arg0 ) { SecurityManager loc0 = System. getSecurityManager ( ) ; if ( loc0!= null ) loc0. removeProperty ( arg0 ) ; }",
        "void function ( String arg0 ) { Properties loc0 = ( Properties ) set ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
        "void function ( String arg0, String arg1 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0. containsKey ( arg0 ) ) { String loc1 = loc0. get ( arg0 ) ; System. setProperty ( arg0, loc1 ) ; } }",
        "void function ( String arg0, String arg1 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0. containsKey ( arg0 ) ) { loc0. remove ( arg0 ) ; } }",
        "void function ( String arg0, String arg1 ) { String loc0 = arg0. hashCode ( ) ; Object [ ] loc1 = { arg1 } ; hashArea. remove ( loc0 ) ; }",
        "void function ( String arg0 ) { Properties loc0 = Properties. getInstance ( ) ; loc0. remove ( arg0 ) ; }",
        "void function ( String arg0, String arg1 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
        "void function ( String arg0 ) { Properties loc0 = ( Properties ) set. get ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
        "void function ( String arg0 ) { SecurityManager loc0 = System. getSecurityManager ( ) ; if ( loc0!= null ) { loc0. removeProperty ( arg0 ) ; } }",
        "void function ( String arg0 ) { SecurityManager loc0 = System. getSecurityManager ( ) ; if ( loc0!= null ) loc0. removeProperty ( arg0 ) ; }",
        "void function ( Object arg0, String arg1 ) { Properties loc0 = ( Properties ) arg0 ; if ( loc0!= null ) { loc0. remove ( arg1 ) ; } }",
        "void function ( String arg0 ) { Properties loc0 = ( Properties ) set. remove ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( \"srini_string\" ) ; } }",
        "void function ( String arg0 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
        "void function ( String arg0 ) { SecurityManager loc0 = System. getSecurityManager ( ) ; if ( loc0!= null ) loc0. removeProperty ( arg0 ) ; }",
        "void function ( String arg0 ) { Properties loc0 = getProperties ( ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
        "void function ( String arg0 ) { Properties loc0 = System. getProperties ( ) ; loc0. remove ( arg0 ) ; }",
        "void function ( String arg0 ) { Properties loc0 = ( Properties ) set ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
        "void function ( Properties arg0, String arg1 ) { arg0. remove ( arg1 ) ; }",
        "void function ( Map arg0, String arg1 ) { arg0. remove ( arg1 ) ; }",
        "void function ( String arg0 ) { Cache. getInstance ( ). remove ( arg0 ) ; }",
        "boolean function ( Object arg0, String arg1 ) { return arg0 == null? false : cache. remove ( arg1 ) ; }",
        "void function ( String arg0 ) { Properties loc0 = Properties. getProperties ( arg0 ) ; cache. remove ( arg0 ) ; }"
      ],
      "mid_translation": [
        "Removes a property from the set.",
        "Removes a property from the hash area.",
        "Removes the specified property from the set.",
        "Remove a property from the set.",
        "Removes a property from the cache."
      ],
      "output": [
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = ( Properties ) set. get ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = ( Properties ) this. set. get ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "timeout"
        },
        {
          "patch": "public void remove ( String arg0 ) { SecurityManager loc0 = System. getSecurityManager ( ) ; if ( loc0!= null ) loc0. removeProperty ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = ( Properties ) set ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0, String arg1 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0. containsKey ( arg0 ) ) { String loc1 = loc0. get ( arg0 ) ; System. setProperty ( arg0, loc1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0, String arg1 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0. containsKey ( arg0 ) ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove ( String arg0, String arg1 ) { String loc0 = arg0. hashCode ( ) ; Object [ ] loc1 = { arg1 } ; hashArea. remove ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = Properties. getInstance ( ) ; loc0. remove ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0, String arg1 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "timeout"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = ( Properties ) set. get ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { SecurityManager loc0 = System. getSecurityManager ( ) ; if ( loc0!= null ) { loc0. removeProperty ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { SecurityManager loc0 = System. getSecurityManager ( ) ; if ( loc0!= null ) loc0. removeProperty ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( Object arg0, String arg1 ) { Properties loc0 = ( Properties ) arg0 ; if ( loc0!= null ) { loc0. remove ( arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = ( Properties ) set. remove ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = System. getProperties ( ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove ( String arg0 ) { SecurityManager loc0 = System. getSecurityManager ( ) ; if ( loc0!= null ) loc0. removeProperty ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = getProperties ( ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = System. getProperties ( ) ; loc0. remove ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = ( Properties ) set ( arg0 ) ; if ( loc0!= null ) { loc0. remove ( arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( Properties arg0, String arg1 ) { arg0. remove ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove ( Map arg0, String arg1 ) { arg0. remove ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void remove ( String arg0 ) { Cache. getInstance ( ). remove ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean remove ( Object arg0, String arg1 ) { return arg0 == null? false : cache. remove ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void remove ( String arg0 ) { Properties loc0 = Properties. getProperties ( arg0 ) ; cache. remove ( arg0 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_5_/src/org/mockito/internal/verification/VerificationOverTimeImpl.java_91-92": {
      "loc": "91-92",
      "input": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error != null) {\n        throw error;\n    }\n}",
      "target": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n        catch (AssertionError e) {\n            error = handleVerifyException(e);\n        }\n    }\n    if (error != null) {\n        throw error;\n    }\n}",
      "function range": "75,5-99,5",
      "raw_output": [
        "boolean function ( String arg0, String arg1 ) { return verifyCode ( arg0, arg1, 1 ) ; }",
        "boolean function ( String arg0, String arg1 ) { return verifyCode ( arg0, arg1, \"srini_string\" ) ; }",
        "boolean function ( String arg0, String arg1 ) { return verifyCode ( arg0, arg1, null ) ; }",
        "boolean function ( String arg0, String arg1, String arg2 ) { return verifyCode ( arg0, arg1, arg2, null ) ; }",
        "boolean function ( String arg0, String arg1 ) { return verifyCode ( arg0, arg1, 0 ) ; }",
        "boolean function ( @ Nonnull Computer arg0, @ Nonnull Computer arg1, @ CheckForNull String arg2 ) { return verify ( arg0, arg1, arg2, null ) ; }",
        "boolean function ( @ Nonnull Computer arg0, @ Nonnull Computer arg1, @ Nonnull TaskListener arg2 ) { return verify ( arg0, arg1, arg2, null ) ; }",
        "boolean function ( @ NotNull PsiFile arg0, @ NotNull VirtualFile arg1, @ NotNull TaskListener arg2 ) { return verify ( arg0, arg1, arg2, null ) ; }",
        "boolean function ( byte [ ] arg0, String arg1 ) { return verify ( arg0, arg1, null ) ; }",
        "boolean function ( @ Nonnull Computer arg0, @ Nonnull Computer arg1, String arg2 ) { return verify ( arg0, arg1, arg2, null ) ; }",
        "boolean function ( String arg0, String arg1 ) { String loc0 = \"srini_string\" ; return loc0. equals ( arg0 ) ; }",
        "boolean function ( String arg0, String arg1 ) { return arg0. equals ( \"srini_string\" ) ; }",
        "boolean function ( byte [ ] arg0, String arg1 ) { return arg0 [ 0 ] == arg1 ; }",
        "boolean function ( byte [ ] arg0, String arg1 ) { return true ; }",
        "boolean function ( String arg0, String arg1 ) { return arg0. equals ( arg1 ) ; }",
        "boolean function ( ITestSuite arg0, Object arg1 ) { ITestContext loc0 = arg0. getTestContext ( ) ; if ( loc0!= null ) { return loc0. isValid ( arg1 ) ; } return false ; }",
        "boolean function ( ITestSuite arg0, Object arg1 ) { ITestContext loc0 = arg0. getTestContext ( ) ; if ( loc0!= null ) { return loc0. isValid ( ) ; } return false ; }",
        "boolean function ( ITestSuite arg0, Object arg1 ) { ITestContext loc0 = arg0. getTestContext ( ) ; if ( loc0!= null ) { return loc0. isValid ( arg1 ) ; } else { return false ; } }",
        "boolean function ( Description arg0 ) { return true ; }",
        "boolean function ( ITestSuite arg0, ITestReporter arg1 ) { return true ; }",
        "boolean function ( String arg0, String arg1, Map < String, String > arg2, String arg3 ) { return verify ( arg0, arg1, arg2, arg3, true ) ; }",
        "boolean function ( String arg0, String arg1, Map < String, String > arg2, String arg3 ) { return verify ( arg0, arg1, arg2, arg3, 1 ) ; }",
        "PageVerificationResult function ( String arg0, String arg1 ) { PageVerificationResult loc0 = new PageVerificationResult ( ) ; return verify ( arg0, arg1, loc0 ) ; }",
        "boolean function ( String arg0, String arg1, Map < String, String > arg2, String arg3 ) { return verify ( arg0, arg1, arg2, arg3, null ) ; }",
        "boolean function ( Pageable arg0, String arg1 ) { return verify ( arg0, arg1, null ) ; }"
      ],
      "mid_translation": [
        "Perform a verification on a single page of code.",
        "Perform a verification.",
        "This method is called by the test suite to check if a verification data is valid.",
        "This method is called by the test suite to check if the test suite is valid.",
        "Perform a verification on a single page."
      ],
      "output": [
        {
          "patch": "public boolean verify ( String arg0, String arg1 ) { return verifyCode ( arg0, arg1, 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1 ) { return verifyCode ( arg0, arg1, \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1 ) { return verifyCode ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1, String arg2 ) { return verifyCode ( arg0, arg1, arg2, null ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1 ) { return verifyCode ( arg0, arg1, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( @ Nonnull Computer arg0, @ Nonnull Computer arg1, @ CheckForNull String arg2 ) { return verify ( arg0, arg1, arg2, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( @ Nonnull Computer arg0, @ Nonnull Computer arg1, @ Nonnull TaskListener arg2 ) { return verify ( arg0, arg1, arg2, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( @ NotNull PsiFile arg0, @ NotNull VirtualFile arg1, @ NotNull TaskListener arg2 ) { return verify ( arg0, arg1, arg2, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( byte [ ] arg0, String arg1 ) { return verify ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( @ Nonnull Computer arg0, @ Nonnull Computer arg1, String arg2 ) { return verify ( arg0, arg1, arg2, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1 ) { String loc0 = \"srini_string\" ; return loc0. equals ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1 ) { return arg0. equals ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( byte [ ] arg0, String arg1 ) { return arg0 [ 0 ] == arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( byte [ ] arg0, String arg1 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1 ) { return arg0. equals ( arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( ITestSuite arg0, Object arg1 ) { ITestContext loc0 = arg0. getTestContext ( ) ; if ( loc0!= null ) { return loc0. isValid ( arg1 ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( ITestSuite arg0, Object arg1 ) { ITestContext loc0 = arg0. getTestContext ( ) ; if ( loc0!= null ) { return loc0. isValid ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( ITestSuite arg0, Object arg1 ) { ITestContext loc0 = arg0. getTestContext ( ) ; if ( loc0!= null ) { return loc0. isValid ( arg1 ) ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( Description arg0 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( ITestSuite arg0, ITestReporter arg1 ) { return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1, Map < String, String > arg2, String arg3 ) { return verify ( arg0, arg1, arg2, arg3, true ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1, Map < String, String > arg2, String arg3 ) { return verify ( arg0, arg1, arg2, arg3, 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public PageVerificationResult verify ( String arg0, String arg1 ) { PageVerificationResult loc0 = new PageVerificationResult ( ) ; return verify ( arg0, arg1, loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( String arg0, String arg1, Map < String, String > arg2, String arg3 ) { return verify ( arg0, arg1, arg2, arg3, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean verify ( Pageable arg0, String arg1 ) { return verify ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_71_/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java_75-76": {
      "loc": "75-76",
      "input": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class || raw == Object.class) {\n        return StringKD.forType(raw);\n    } else if (raw == UUID.class) {\n        kind = TYPE_UUID;\n    } else if (raw == Integer.class) {\n        kind = TYPE_INT;\n    } else if (raw == Long.class) {\n        kind = TYPE_LONG;\n    } else if (raw == Date.class) {\n        kind = TYPE_DATE;\n    } else if (raw == Calendar.class) {\n        kind = TYPE_CALENDAR;\n    } else if (raw == Boolean.class) {\n        kind = TYPE_BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = TYPE_BYTE;\n    } else if (raw == Character.class) {\n        kind = TYPE_CHAR;\n    } else if (raw == Short.class) {\n        kind = TYPE_SHORT;\n    } else if (raw == Float.class) {\n        kind = TYPE_FLOAT;\n    } else if (raw == Double.class) {\n        kind = TYPE_DOUBLE;\n    } else if (raw == URI.class) {\n        kind = TYPE_URI;\n    } else if (raw == URL.class) {\n        kind = TYPE_URL;\n    } else if (raw == Class.class) {\n        kind = TYPE_CLASS;\n    } else if (raw == Locale.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n    } else if (raw == Currency.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n    } else {\n        return null;\n    }\n    return new StdKeyDeserializer(kind, raw);\n}",
      "target": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n    if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n        return StringKD.forType(raw);\n    } else if (raw == UUID.class) {\n        kind = TYPE_UUID;\n    } else if (raw == Integer.class) {\n        kind = TYPE_INT;\n    } else if (raw == Long.class) {\n        kind = TYPE_LONG;\n    } else if (raw == Date.class) {\n        kind = TYPE_DATE;\n    } else if (raw == Calendar.class) {\n        kind = TYPE_CALENDAR;\n    } else if (raw == Boolean.class) {\n        kind = TYPE_BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = TYPE_BYTE;\n    } else if (raw == Character.class) {\n        kind = TYPE_CHAR;\n    } else if (raw == Short.class) {\n        kind = TYPE_SHORT;\n    } else if (raw == Float.class) {\n        kind = TYPE_FLOAT;\n    } else if (raw == Double.class) {\n        kind = TYPE_DOUBLE;\n    } else if (raw == URI.class) {\n        kind = TYPE_URI;\n    } else if (raw == URL.class) {\n        kind = TYPE_URL;\n    } else if (raw == Class.class) {\n        kind = TYPE_CLASS;\n    } else if (raw == Locale.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n        return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n    } else if (raw == Currency.class) {\n        FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n        return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n    } else {\n        return null;\n    }\n    return new StdKeyDeserializer(kind, raw);\n}",
      "function range": "70,5-116,5",
      "raw_output": [
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "StdKeyDeserializer function ( Class arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "StdKeyDeserializer < K > function ( Class < K > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "StdKeyDeserializer < K > function ( Class < K > arg0, K arg1 ) { return new StdKeyDeserializer < K > ( arg0, arg1 ) ; }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdBlob. class ) { return new StdBlobDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == String. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdBlob. class ) { return new StdBlobDeserializer ( ) ; } else { throw new RuntimeException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new RuntimeException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new RuntimeException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "StdKeyDeserializer function ( Class arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new RuntimeException ( \"srini_string\" ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new RuntimeException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer < T > function ( Class < T > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return ( StdKeyDeserializer < T > ) arg0. getDeclaredConstructor ( StdKeyDeserializer. class ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return ( StdKeyDeserializer ) StdKeyDeserializer. newInstance ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return ( StdKeyDeserializer ) arg0. newInstance ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
        "StdKeyDeserializer function ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }"
      ],
      "mid_translation": [
        "Create a StdKeyDeserializer for a class.",
        "Create a StdKeyDeserializer for the given class.",
        "Returns a StdKeyDeserializer for the given class.",
        "Create a StdKeyDeserializer for a Class.",
        "Returns a StdKeyDeserializer for the specified class."
      ],
      "output": [
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer < K > forType ( Class < K > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer < K > forType ( Class < K > arg0, K arg1 ) { return new StdKeyDeserializer < K > ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdBlob. class ) { return new StdBlobDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == String. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdBlob. class ) { return new StdBlobDeserializer ( ) ; } else { throw new RuntimeException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new RuntimeException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new RuntimeException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else if ( arg0 == StdKey. class ) { return new StdKeyDeserializer ( \"srini_string\" ) ; } else { throw new RuntimeException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new RuntimeException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer < T > forType ( Class < T > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return ( StdKeyDeserializer < T > ) arg0. getDeclaredConstructor ( StdKeyDeserializer. class ) ; } else { throw new IllegalArgumentException ( \"srini_string\" + arg0. getName ( ) ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return ( StdKeyDeserializer ) StdKeyDeserializer. newInstance ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return ( StdKeyDeserializer ) arg0. newInstance ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static StdKeyDeserializer forType ( Class <? > arg0 ) { if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else if ( arg0 == StdKeyDeserializer. class ) { return new StdKeyDeserializer ( ) ; } else { throw new IllegalArgumentException ( \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_59_/src/main/java/org/apache/commons/math/util/FastMath.java_3482-3483": {
      "loc": "3482-3483",
      "input": "public static float max(final float a, final float b) {\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n}",
      "target": "public static float max(final float a, final float b) {\n    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n}",
      "function range": "3481,5-3483,5",
      "raw_output": [
        "float function ( float arg0, float arg1 ) { return Math. max ( arg0, Math. min ( arg1, arg0 ) ) ; }",
        "float function ( final float arg0, final float arg1 ) { return Math. max ( arg0, Math. min ( arg1, arg0 ) ) ; }",
        "float function ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
        "float function ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. min ( arg1, arg0 ) ; } }",
        "float function ( final float arg0, final float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
        "float function ( ) { return Float. MAX_VALUE ; }",
        "float function ( ) { return ( float ) Math. max ( ( float ) 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, loc0 ) ) ) ) ) ; }",
        "float function ( ) { return ( float ) Math. max ( ( float ) 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. max ( 1, loc0 ) ) ) ) ) ; }",
        "float function ( ) { return ( float ) Math. max ( ( float ) 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, loc0 ) ) ) ) ) ; }",
        "float function ( ) { return ( float ) Math. max ( 1f, ( float ) Math. min ( 1f, ( float ) Math. max ( 1f, ( float ) Math. min ( 1f, ( float ) Math. max ( 1f, ( float ) Math. min ( 1f, ( float ) Math. max ( 1f, ( float ) Math. max ( 1f, ( float ) Math. min ( 1f, ( float ) loc0 ) ) ) ) ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg0, arg1 ) ; } else { return Math. min ( arg0, arg1 ) ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg0, arg1 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. min ( arg1, arg0 ) ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 < arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. min ( arg1, arg0 ) ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 < arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. max ( arg1, arg0 ) ; } }",
        "float function ( float arg0, float arg1 ) { return Math. max ( arg0, Math. min ( arg1, arg0 ) ) ; }",
        "float function ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg0, arg1 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
        "float function ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg0, arg1 ) ; } else { return Math. min ( arg0, arg1 ) ; } }",
        "float function ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
        "float function ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. min ( arg1, arg0 ) ; } }",
        "int function ( Integer arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return Math. max ( arg0, Math. min ( 1, arg0. intValue ( ) ) ) ; }",
        "int function ( ) { return Math. max ( 1, ( int ) Math. min ( 1, ( int ) Math. max ( 1, ( int ) Math. min ( 1, ( int ) Math. max ( 1, loc0 ) ) ) ) ; }",
        "int function ( ) { return Math. max ( 1, ( int ) Math. min ( 1, ( int ) Math. max ( 1, ( int ) Math. min ( 1, ( int ) Math. max ( 1, arg0 ) ) ) ) ; }",
        "int function ( Integer arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return Math. max ( arg0, Integer. MIN_VALUE ) ; }",
        "int function ( Integer arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return Math. max ( arg0, Integer. MIN_VALUE ) ; }"
      ],
      "mid_translation": [
        "Returns the maximum of two float values.",
        "Max float.",
        "Returns the maximum value of two numbers.",
        "Returns the max of two float values.",
        "Get the max value."
      ],
      "output": [
        {
          "patch": "public static float max ( float arg0, float arg1 ) { return Math. max ( arg0, Math. min ( arg1, arg0 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static float max ( final float arg0, final float arg1 ) { return Math. max ( arg0, Math. min ( arg1, arg0 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static float max ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. min ( arg1, arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static float max ( final float arg0, final float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max ( ) { return Float. MAX_VALUE ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static float max ( ) { return ( float ) Math. max ( ( float ) 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, loc0 ) ) ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static float max ( ) { return ( float ) Math. max ( ( float ) 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. max ( 1, loc0 ) ) ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static float max ( ) { return ( float ) Math. max ( ( float ) 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, ( float ) Math. max ( 1, ( float ) Math. min ( 1, ( float ) Math. max ( 1, loc0 ) ) ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static float max ( ) { return ( float ) Math. max ( 1f, ( float ) Math. min ( 1f, ( float ) Math. max ( 1f, ( float ) Math. min ( 1f, ( float ) Math. max ( 1f, ( float ) Math. min ( 1f, ( float ) Math. max ( 1f, ( float ) Math. max ( 1f, ( float ) Math. min ( 1f, ( float ) loc0 ) ) ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg0, arg1 ) ; } else { return Math. min ( arg0, arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg0, arg1 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. min ( arg1, arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 < arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. min ( arg1, arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max ( int arg0, int arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 < arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. max ( arg1, arg0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static float max ( float arg0, float arg1 ) { return Math. max ( arg0, Math. min ( arg1, arg0 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static float max ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg0, arg1 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg0, arg1 ) ; } else { return Math. min ( arg0, arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static float max ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. max ( arg0, arg1 ) ; } }",
          "correctness": "plausible"
        },
        {
          "patch": "public static float max ( float arg0, float arg1 ) { if ( arg0 < arg1 ) { return Math. max ( arg0, arg1 ) ; } else if ( arg0 == arg1 ) { return Math. min ( arg1, arg0 ) ; } else { return Math. min ( arg1, arg0 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max ( Integer arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return Math. max ( arg0, Math. min ( 1, arg0. intValue ( ) ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max ( ) { return Math. max ( 1, ( int ) Math. min ( 1, ( int ) Math. max ( 1, ( int ) Math. min ( 1, ( int ) Math. max ( 1, loc0 ) ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max ( ) { return Math. max ( 1, ( int ) Math. min ( 1, ( int ) Math. max ( 1, ( int ) Math. min ( 1, ( int ) Math. max ( 1, arg0 ) ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max ( Integer arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return Math. max ( arg0, Integer. MIN_VALUE ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max ( Integer arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return Math. max ( arg0, Integer. MIN_VALUE ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_29_/src/org/mockito/internal/matchers/Same.java_29-30": {
      "loc": "29-30",
      "input": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted.toString());\n    appendQuoting(description);\n    description.appendText(\")\");\n}",
      "target": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n    description.appendText(wanted == null ? \"null\" : wanted.toString());\n    appendQuoting(description);\n    description.appendText(\")\");\n}",
      "function range": "26,5-32,5",
      "raw_output": [
        "String function ( ) { return \"srini_string\" + \"srini_string\" ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "void function ( String arg0 ) { System. err. println ( arg0 ) ; }",
        "void function ( final Description arg0 ) { arg0. describeTo ( this ) ; }",
        "void function ( final String arg0 ) { System. err. println ( arg0 ) ; }",
        "void function ( Description arg0 ) { arg0. describeTo ( this ) ; }",
        "void function ( final Description arg0 ) { arg0. describeTo ( this ) ; }",
        "void function ( Description arg0, String arg1 ) { arg0. describeTo ( this, arg1 ) ; }",
        "Description function ( Description arg0 ) { return arg0 ; }",
        "String function ( Description arg0 ) { return arg0. describeTo ( this ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "void function ( String arg0 ) { System. err. println ( \"srini_string\" + arg0 ) ; }",
        "void function ( String arg0 ) { System. err. println ( arg0 ) ; }",
        "void function ( String arg0 ) { System. out. println ( \"srini_string\" + arg0 ) ; }",
        "void function ( String arg0 ) { System. out. println ( arg0 ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "String function ( ) { return \"srini_string\" + \"srini_string\" ; }",
        "String function ( E arg0 ) { return \"srini_string\" ; }",
        "String function ( TungstenProperties arg0 ) { return \"srini_string\" ; }",
        "String function ( ) { return \"srini_string\" + getClass ( ). getName ( ) ; }",
        "void function ( Description arg0 ) { arg0. describeTo ( this ) ; }",
        "void function ( Description arg0 ) { arg0. describe ( this ) ; }",
        "void function ( Description arg0 ) { arg0. describe ( ) ; }",
        "void function ( final Description arg0 ) { arg0. describeTo ( this ) ; }",
        "void function ( Description arg0, String arg1 ) { arg0. describe ( arg1 ) ; }"
      ],
      "mid_translation": [
        "Describe to the given description.",
        "Describe to the given Description.",
        "Describe to the specified description.",
        "Describe to the description.",
        "Describe to the given Description object."
      ],
      "output": [
        {
          "patch": "public String describeTo ( ) { return \"srini_string\" + \"srini_string\" ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public String describeTo ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo ( String arg0 ) { System. err. println ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo ( final Description arg0 ) { arg0. describeTo ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void describeTo ( final String arg0 ) { System. err. println ( arg0 ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public void describeTo ( Description arg0 ) { arg0. describeTo ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void describeTo ( final Description arg0 ) { arg0. describeTo ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void describeTo ( Description arg0, String arg1 ) { arg0. describeTo ( this, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Description describeTo ( Description arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String describeTo ( Description arg0 ) { return arg0. describeTo ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String describeTo ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo ( String arg0 ) { System. err. println ( \"srini_string\" + arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo ( String arg0 ) { System. err. println ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo ( String arg0 ) { System. out. println ( \"srini_string\" + arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo ( String arg0 ) { System. out. println ( arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String describeTo ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String describeTo ( ) { return \"srini_string\" + \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public String describeTo ( E arg0 ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String describeTo ( TungstenProperties arg0 ) { return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public String describeTo ( ) { return \"srini_string\" + getClass ( ). getName ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void describeTo ( Description arg0 ) { arg0. describeTo ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void describeTo ( Description arg0 ) { arg0. describe ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void describeTo ( Description arg0 ) { arg0. describe ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void describeTo ( final Description arg0 ) { arg0. describeTo ( this ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void describeTo ( Description arg0, String arg1 ) { arg0. describe ( arg1 ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_52_/src/com/google/javascript/jscomp/CodeGenerator.java_745-746": {
      "loc": "745-746",
      "input": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return len > 0;\n}",
      "target": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n  return len > 0 && s.charAt(0) != '0';\n}",
      "function range": "737,3-746,3",
      "raw_output": [
        "boolean function ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0!= null && arg0. charAt ( 0 ) == '.' ; }",
        "boolean function ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0!= null && arg0. matches ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. length ( ) == 1 ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
        "boolean function ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
        "boolean function ( String arg0 ) { return arg0. length ( ) == 1 ; }",
        "boolean function ( String arg0 ) { return arg0. indexOf ( \"srini_string\" ) > - 1 ; }",
        "boolean function ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
        "boolean function ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
        "boolean function ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. length ( ) == 1 ; }"
      ],
      "mid_translation": [
        "Checks if a string is a simple number.",
        "Check if a string is a simple number.",
        "Check if string is a simple number.",
        "Checks if the string is a simple number.",
        "Checks if string is a simple number."
      ],
      "output": [
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0!= null && arg0. charAt ( 0 ) == '.' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0!= null && arg0. matches ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. length ( ) == 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. length ( ) == 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. indexOf ( \"srini_string\" ) > - 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. matches ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '.' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. charAt ( 0 ) == '-' ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. equals ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "static boolean isSimpleNumber ( String arg0 ) { return arg0. length ( ) == 1 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Mockito_7_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_379-380": {
      "loc": "379-380",
      "input": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n\n}",
      "target": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n    registerTypeParametersOn(new TypeVariable[] { typeVariable });\n\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n}",
      "function range": "375,9-380,9",
      "raw_output": [
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. TypeCode arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; if ( loc0 instanceof org. omg. CORBA. TypeCode ) return ( org. omg. CORBA. TypeCode ) loc0 ; return null ; }",
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. Object arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; if ( loc0 instanceof org. omg. CORBA. TypeCode ) return ( org. omg. CORBA. TypeCode ) loc0 ; return null ; }",
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. TypeCode arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; return readTypeVariables ( arg0, loc0 ) ; }",
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. TypeCode arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; if ( loc0 == null ) throw new java. lang. IllegalArgumentException ( \"srini_string\" ) ; return loc0 ; }",
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. TypeCode arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; if ( loc0 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; return loc0. getTypeVariable ( ) ; }",
        "void function ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( Map. Entry < String, Type > loc1 : loc0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; String loc3 = loc1. getValue ( ) ; arg0. setTypeVariables ( loc2, loc3 ) ; } }",
        "void function ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( int loc1 = 0 ; loc1 < loc0. size ( ) ; loc1 ++ ) { String loc2 = loc0. get ( loc1 ). getName ( ) ; arg0. setTypeVariables ( loc2 ) ; } }",
        "void function ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( Map. Entry < String, Type > loc1 : loc0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; String loc3 = loc1. getValue ( ) ; loc0. setTypeVariables ( loc2, loc3 ) ; } }",
        "void function ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { TypeVariables loc2 = loc0 [ loc1 ] ; if ( loc2 instanceof ParameterizedType ) { ParameterizedType loc3 = ( ParameterizedType ) loc2 ; loc3. setTypeVariables ( arg0 ) ; } } }",
        "void function ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { TypeVariables loc2 = loc0 [ loc1 ] ; if ( loc2 instanceof ParameterizedType ) { ParameterizedType loc3 = ( ParameterizedType ) loc2 ; loc3. setTypeVariable ( loc1 ) ; } } }",
        "TypeVariableFacade function ( Class <? > arg0 ) { return new TypeVariableFacade ( arg0 ) ; }",
        "TypeVariables function ( ) { return new TypeVariables ( ) ; }",
        "TypeVariables function ( ClassReader arg0 ) { return new TypeVariables ( arg0 ) ; }",
        "TypeVariableFacade function ( ) { return new TypeVariableFacade ( ) ; }",
        "TypeVariableFacade function ( Class <? > arg0 ) { return null ; }",
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. TypeCode arg0 ) { throw new NO_IMPLEMENT ( ) ; }",
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. TypeCode arg0 ) { return null ; }",
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. Object arg0 ) { return null ; }",
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. portable. CORBA. Object arg0 ) { return null ; }",
        "org. omg. CORBA. TypeCode function ( org. omg. CORBA. portable. OtpInputStream arg0 ) { return null ; }",
        "void function ( TypeVariableReader arg0, TypeVariable arg1 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0 ) ; readTypeVariables ( arg0, loc0, arg1 ) ; }",
        "void function ( TypeVariableReader arg0, CtClass arg1 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0 ) ; readTypeVariables ( arg0, loc0, arg1 ) ; }",
        "void function ( TypeVariableReader arg0, TypeVariable arg1 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0, arg1 ) ; readTypeVariables ( arg0, loc0 ) ; }",
        "void function ( TypeVariableReader arg0, CtClass arg1 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0, arg1 ) ; readTypeVariables ( arg0, loc0 ) ; }",
        "TypeVariable < T > function ( Class < T > arg0 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0 ) ; return loc0. readTypeVariables ( ) ; }"
      ],
      "mid_translation": [
        "Read the type variables of a type variable.",
        "Read the type variables.",
        "Read type variables.",
        "Read the type variables for this type variable.",
        "Reads the type variables of a type variable."
      ],
      "output": [
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. TypeCode arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; if ( loc0 instanceof org. omg. CORBA. TypeCode ) return ( org. omg. CORBA. TypeCode ) loc0 ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. Object arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; if ( loc0 instanceof org. omg. CORBA. TypeCode ) return ( org. omg. CORBA. TypeCode ) loc0 ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. TypeCode arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; return readTypeVariables ( arg0, loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. TypeCode arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; if ( loc0 == null ) throw new java. lang. IllegalArgumentException ( \"srini_string\" ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. TypeCode arg0 ) { org. omg. CORBA. TypeCode loc0 = arg0. getTypeVariable ( ) ; if ( loc0 == null ) throw new IllegalArgumentException ( \"srini_string\" ) ; return loc0. getTypeVariable ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void readTypeVariables ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( Map. Entry < String, Type > loc1 : loc0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; String loc3 = loc1. getValue ( ) ; arg0. setTypeVariables ( loc2, loc3 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void readTypeVariables ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( int loc1 = 0 ; loc1 < loc0. size ( ) ; loc1 ++ ) { String loc2 = loc0. get ( loc1 ). getName ( ) ; arg0. setTypeVariables ( loc2 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void readTypeVariables ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( Map. Entry < String, Type > loc1 : loc0. entrySet ( ) ) { String loc2 = loc1. getKey ( ) ; String loc3 = loc1. getValue ( ) ; loc0. setTypeVariables ( loc2, loc3 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void readTypeVariables ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { TypeVariables loc2 = loc0 [ loc1 ] ; if ( loc2 instanceof ParameterizedType ) { ParameterizedType loc3 = ( ParameterizedType ) loc2 ; loc3. setTypeVariables ( arg0 ) ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void readTypeVariables ( TypeVariables arg0 ) { TypeVariables loc0 = arg0. getTypeVariables ( ) ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { TypeVariables loc2 = loc0 [ loc1 ] ; if ( loc2 instanceof ParameterizedType ) { ParameterizedType loc3 = ( ParameterizedType ) loc2 ; loc3. setTypeVariable ( loc1 ) ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TypeVariableFacade readTypeVariables ( Class <? > arg0 ) { return new TypeVariableFacade ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TypeVariables readTypeVariables ( ) { return new TypeVariables ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TypeVariables readTypeVariables ( ClassReader arg0 ) { return new TypeVariables ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TypeVariableFacade readTypeVariables ( ) { return new TypeVariableFacade ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TypeVariableFacade readTypeVariables ( Class <? > arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. TypeCode arg0 ) { throw new NO_IMPLEMENT ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. TypeCode arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. Object arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. portable. CORBA. Object arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private org. omg. CORBA. TypeCode readTypeVariables ( org. omg. CORBA. portable. OtpInputStream arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void readTypeVariables ( TypeVariableReader arg0, TypeVariable arg1 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0 ) ; readTypeVariables ( arg0, loc0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void readTypeVariables ( TypeVariableReader arg0, CtClass arg1 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0 ) ; readTypeVariables ( arg0, loc0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void readTypeVariables ( TypeVariableReader arg0, TypeVariable arg1 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0, arg1 ) ; readTypeVariables ( arg0, loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void readTypeVariables ( TypeVariableReader arg0, CtClass arg1 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0, arg1 ) ; readTypeVariables ( arg0, loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private TypeVariable < T > readTypeVariables ( Class < T > arg0 ) { TypeVariableReader loc0 = new TypeVariableReader ( arg0 ) ; return loc0. readTypeVariables ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_55_/src/com/google/javascript/jscomp/FunctionRewriter.java_117-118": {
      "loc": "117-118",
      "input": "private static boolean isReduceableFunctionExpression(Node n) {\n  return NodeUtil.isFunctionExpression(n);\n}",
      "target": "private static boolean isReduceableFunctionExpression(Node n) {\n  return NodeUtil.isFunctionExpression(n)\n      && !NodeUtil.isGetOrSetKey(n.getParent());\n}",
      "function range": "116,3-118,3",
      "raw_output": [
        "boolean function ( Node arg0 ) { return arg0 instanceof ReduceableFunctionExpression ; }",
        "boolean function ( Node arg0 ) { if ( arg0 instanceof reduceable ) { reduceable = ( reduceable ) arg0 ; return true ; } return false ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof Reducer ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof reduceableFunctionExpression ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof ReduceableFunctionExpression || arg0 instanceof ReducerFunctionExpression ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPRESSION ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == TokenTypes. FUNCTION_EXPRESSION ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_DECLARATOR ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPONENT ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof FunctionCallExpression || arg0 instanceof BinaryOperator ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof ReduceableFunctionExpression ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. REDUCE_FUNCTION ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof Reducer ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof ReduceOp ) ; }",
        "boolean function ( Node arg0 ) { return arg0 instanceof ReduceableFunctionExpression ) ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPRESSION ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION && arg0. getLastChild ( ) == Token. FUNCTION ; }",
        "boolean function ( Node arg0 ) { return arg0. getJSDocInfo ( ) == null || arg0. getJSDocInfo ( ). getType ( ) == Token. FUNCTION ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION && arg0. getLastChild ( ) == Token. FUNCTION_EXPRESSION ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_STATEMENT ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPRESSION ; }",
        "boolean function ( ASTNode arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPRESSION ; }",
        "boolean function ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION && arg0. getLastChild ( ) == Token. FUNCTION ; }",
        "boolean function ( Node arg0 ) { return arg0. getJSDocInfo ( ) == null || arg0. getJSDocInfo ( ). getType ( ) == TokenTypes. FUNCTION_EXPRESSION ; }",
        "boolean function ( Node arg0 ) { return arg0. getJSDocInfo ( ) == null || arg0. getJSDocInfo ( ). getType ( ) == Token. FUNCTION ; }"
      ],
      "mid_translation": [
        "Returns true if n is a reduceable function expression.",
        "Returns true if n is a function expression.",
        "Checks if n is a reduceable function expression.",
        "Returns true if the node is a function expression.",
        "Returns true if the given node is a function expression."
      ],
      "output": [
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0 instanceof ReduceableFunctionExpression ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { if ( arg0 instanceof reduceable ) { reduceable = ( reduceable ) arg0 ; return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0 instanceof Reducer ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0 instanceof reduceableFunctionExpression ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0 instanceof ReduceableFunctionExpression || arg0 instanceof ReducerFunctionExpression ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPRESSION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == TokenTypes. FUNCTION_EXPRESSION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_DECLARATOR ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPONENT ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0 instanceof FunctionCallExpression || arg0 instanceof BinaryOperator ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0 instanceof ReduceableFunctionExpression ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. REDUCE_FUNCTION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0 instanceof Reducer ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0 instanceof ReduceOp ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0 instanceof ReduceableFunctionExpression ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPRESSION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION && arg0. getLastChild ( ) == Token. FUNCTION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getJSDocInfo ( ) == null || arg0. getJSDocInfo ( ). getType ( ) == Token. FUNCTION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION && arg0. getLastChild ( ) == Token. FUNCTION_EXPRESSION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_STATEMENT ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPRESSION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( ASTNode arg0 ) { return arg0. getType ( ) == Token. FUNCTION_EXPRESSION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getType ( ) == Token. FUNCTION && arg0. getLastChild ( ) == Token. FUNCTION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getJSDocInfo ( ) == null || arg0. getJSDocInfo ( ). getType ( ) == TokenTypes. FUNCTION_EXPRESSION ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static boolean isReduceableFunctionExpression ( Node arg0 ) { return arg0. getJSDocInfo ( ) == null || arg0. getJSDocInfo ( ). getType ( ) == Token. FUNCTION ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Math_63_/src/main/java/org/apache/commons/math/util/MathUtils.java_417-418": {
      "loc": "417-418",
      "input": "public static boolean equals(double x, double y) {\n    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n}",
      "target": "public static boolean equals(double x, double y) {\n    return equals(x, y, 1);\n}",
      "function range": "416,5-418,5",
      "raw_output": [
        "boolean function ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. getDistanceSquared ( ) ; double loc1 = arg1. getDistanceSquared ( ) ; if ( loc0 == loc1 ) { return true ; } else { return false ; } }",
        "boolean function ( Coordinate arg0, Coordinate arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 == null || arg1 == null ) { return false ; } else { return arg0. equals ( arg1 ) ; } }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getClass ( ). equals ( arg1. getClass ( ) ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }",
        "boolean function ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 < arg1 ) { return false ; } else { return true ; } }",
        "boolean function ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 >= arg1 ) ) { return false ; } else { return true ; } }",
        "boolean function ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 == null || arg1 == null ) ) { return false ; } else { return arg0 == arg1 ; } }",
        "boolean function ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 > arg1 ) ) { return false ; } else { return true ; } }",
        "boolean function ( double arg0, double arg1 ) { return Math. abs ( arg0 - arg1 ) == Math. abs ( arg1 ) ; }",
        "boolean function ( Number arg0, Number arg1 ) { return ( arg0 == null? arg1 == null : arg0. equals ( arg1 ) ) ; }",
        "boolean function ( Number arg0, Number arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Number arg0, Number arg1 ) { double loc0 = arg0. doubleValue ( ) ; double loc1 = arg1. doubleValue ( ) ; return ( loc0 == loc1 ) ; }",
        "boolean function ( Number arg0, Number arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; }",
        "boolean function ( Number arg0, Number arg1 ) { return ( arg0 == null && arg1 == null ) || ( arg0!= null && arg1!= null ) || ( arg0!= null && arg0. equals ( arg1 ) ) ; }",
        "boolean function ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 < arg1 ) { return false ; } else { return true ; } }",
        "boolean function ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 >= arg1 ) ) { return false ; } else { return true ; } }",
        "boolean function ( double arg0, double arg1 ) { return Math. abs ( arg0 - arg1 ) == Math. abs ( arg1 ) ; }",
        "boolean function ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 == null || arg1 == null ) ) { return false ; } else { return arg0 == arg1 ; } }",
        "boolean function ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 > arg1 ) ) { return false ; } else { return true ; } }",
        "boolean function ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 == arg1 ) { return true ; } else { return false ; } }",
        "boolean function ( Coordinate arg0, Coordinate arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0. compareTo ( arg1 ) == 0 ) { return true ; } else { return false ; } }",
        "boolean function ( Coordinate arg0, Coordinate arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 == arg1 ) { return true ; } else { return false ; } }",
        "boolean function ( Coordinate arg0, Coordinate arg1 ) { return arg0. compareTo ( arg1 ) == 0 ; }",
        "boolean function ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. loc0 ( ) ; double loc1 = arg1. loc0 ( ) ; return loc0 == loc1 ; }"
      ],
      "mid_translation": [
        "Returns true if x equals y.",
        "Checks if two doubles are equal.",
        "Checks if two numbers are equal.",
        "Check if two doubles are equal.",
        "Returns true if x == y."
      ],
      "output": [
        {
          "patch": "public static boolean equals ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. getDistanceSquared ( ) ; double loc1 = arg1. getDistanceSquared ( ) ; if ( loc0 == loc1 ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( Coordinate arg0, Coordinate arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 == null || arg1 == null ) { return false ; } else { return arg0. equals ( arg1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getClass ( ). equals ( arg1. getClass ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 < arg1 ) { return false ; } else { return true ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 >= arg1 ) ) { return false ; } else { return true ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 == null || arg1 == null ) ) { return false ; } else { return arg0 == arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 > arg1 ) ) { return false ; } else { return true ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { return Math. abs ( arg0 - arg1 ) == Math. abs ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( Number arg0, Number arg1 ) { return ( arg0 == null? arg1 == null : arg0. equals ( arg1 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( Number arg0, Number arg1 ) { return ( arg0 == null )? ( arg1 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( Number arg0, Number arg1 ) { double loc0 = arg0. doubleValue ( ) ; double loc1 = arg1. doubleValue ( ) ; return ( loc0 == loc1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals ( Number arg0, Number arg1 ) { return ( arg0 == null || arg1 == null )? ( arg0 == null ) : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( Number arg0, Number arg1 ) { return ( arg0 == null && arg1 == null ) || ( arg0!= null && arg1!= null ) || ( arg0!= null && arg0. equals ( arg1 ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 < arg1 ) { return false ; } else { return true ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 >= arg1 ) ) { return false ; } else { return true ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { return Math. abs ( arg0 - arg1 ) == Math. abs ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 == null || arg1 == null ) ) { return false ; } else { return arg0 == arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if (! ( arg0 > arg1 ) ) { return false ; } else { return true ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean equals ( double arg0, double arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 == arg1 ) { return true ; } else { return false ; } }",
          "correctness": "plausible"
        },
        {
          "patch": "public static boolean equals ( Coordinate arg0, Coordinate arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0. compareTo ( arg1 ) == 0 ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( Coordinate arg0, Coordinate arg1 ) { if ( arg0 == arg1 ) { return true ; } else if ( arg0 == arg1 ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( Coordinate arg0, Coordinate arg1 ) { return arg0. compareTo ( arg1 ) == 0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean equals ( Coordinate arg0, Coordinate arg1 ) { double loc0 = arg0. loc0 ( ) ; double loc1 = arg1. loc0 ( ) ; return loc0 == loc1 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_57_/src/com/google/javascript/jscomp/ClosureCodingConvention.java_197-198": {
      "loc": "197-198",
      "input": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee != null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target != null) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
      "target": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee != null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n        if (target != null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}",
      "function range": "188,3-204,3",
      "raw_output": [
        "String function ( Object arg0 ) { String loc0 = arg0. getClass ( ). getName ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
        "String function ( Object arg0 ) { String loc0 = arg0. toString ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
        "String function ( Object arg0 ) { try { return arg0. getClass ( ). getName ( ) ; } catch ( Exception loc0 ) { throw new RuntimeException ( \"srini_string\" + arg0, loc0 ) ; } }",
        "String function ( Object arg0 ) { return arg0 == null? \"srini_string\" : arg0. getClass ( ). getName ( ) ; }",
        "String function ( Object arg0 ) { String loc0 = arg0. toString ( ) ; if ( loc0. startsWith ( \"srini_string\" ) ) { loc0 = loc0. substring ( 0, 1 ). toUpperCase ( ) ; } return loc0 ; }",
        "String function ( String arg0 ) { if ( arg0. startsWith ( \"srini_string\" ) ) { return arg0. substring ( arg0. lastIndexOf ( \"srini_string\" ) + 1 ) ; } return arg0 ; }",
        "String function ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return \"srini_string\" ; } return arg0. substring ( 0, arg0. lastIndexOf ( \"srini_string\" ) ) ; }",
        "String function ( String arg0 ) { if ( arg0. startsWith ( \"srini_string\" ) ) { return arg0. substring ( 1, arg0. length ( ) ) ; } return arg0 ; }",
        "String function ( String arg0 ) { if ( arg0. startsWith ( \"srini_string\" ) ) { return arg0. substring ( arg0. lastIndexOf ( \"srini_string\" ) + 1, arg0. length ( ) ) ; } return arg0 ; }",
        "String function ( String arg0 ) { if ( arg0. startsWith ( \"srini_string\" ) ) { return arg0. substring ( arg0. lastIndexOf ( \"srini_string\" ) + 1 ) ; } return \"srini_string\" ; }",
        "String function ( Function < T, String > arg0 ) { if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } else if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } else { return arg0. getName ( ) ; } }",
        "String function ( Function < T, String > arg0 ) { if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } return arg0. getName ( ) ; }",
        "String function ( Function < T, String > arg0 ) { if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } return arg0. getDeclaringClass ( ). getName ( ) ; }",
        "String function ( Function < T, String > arg0 ) { String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
        "String function ( Function < T, String > arg0 ) { if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } return \"srini_string\" ; }",
        "String function ( Object arg0 ) { String loc0 = arg0. toString ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
        "String function ( Object arg0 ) { String loc0 = arg0. toString ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; if ( loc1 > 0 ) { return loc0. substring ( 0, loc1 ) ; } return \"srini_string\" ; }",
        "String function ( Object arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return arg0. getClass ( ). getName ( ) ; }",
        "String function ( Object arg0 ) { return arg0 == null? \"srini_string\" : arg0. getClass ( ). getName ( ) ; }",
        "String function ( Object arg0 ) { if ( arg0 instanceof Class ) { return ( ( Class ) arg0 ). getName ( ) ; } else { return arg0. getClass ( ). getName ( ) ; } }",
        "String function ( Class arg0 ) { String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
        "String function ( Class arg0 ) { if ( arg0 == null ) return null ; String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
        "String function ( Class arg0 ) { if ( arg0 == null ) return null ; String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
        "String function ( Class arg0 ) { String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
        "String function ( Object arg0 ) { if ( arg0 == null ) return \"srini_string\" ; String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }"
      ],
      "mid_translation": [
        "Extract class name if goog.",
        "Extract the class name if the function name is goog.",
        "Extract the class name if the function is goog.",
        "Extract the class name if goog.",
        "Extract class name if goog. class."
      ],
      "output": [
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { String loc0 = arg0. getClass ( ). getName ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { String loc0 = arg0. toString ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { try { return arg0. getClass ( ). getName ( ) ; } catch ( Exception loc0 ) { throw new RuntimeException ( \"srini_string\" + arg0, loc0 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { return arg0 == null? \"srini_string\" : arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { String loc0 = arg0. toString ( ) ; if ( loc0. startsWith ( \"srini_string\" ) ) { loc0 = loc0. substring ( 0, 1 ). toUpperCase ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( String arg0 ) { if ( arg0. startsWith ( \"srini_string\" ) ) { return arg0. substring ( arg0. lastIndexOf ( \"srini_string\" ) + 1 ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( String arg0 ) { if ( \"srini_string\". equals ( arg0 ) ) { return \"srini_string\" ; } return arg0. substring ( 0, arg0. lastIndexOf ( \"srini_string\" ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( String arg0 ) { if ( arg0. startsWith ( \"srini_string\" ) ) { return arg0. substring ( 1, arg0. length ( ) ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( String arg0 ) { if ( arg0. startsWith ( \"srini_string\" ) ) { return arg0. substring ( arg0. lastIndexOf ( \"srini_string\" ) + 1, arg0. length ( ) ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( String arg0 ) { if ( arg0. startsWith ( \"srini_string\" ) ) { return arg0. substring ( arg0. lastIndexOf ( \"srini_string\" ) + 1 ) ; } return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Function < T, String > arg0 ) { if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } else if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } else { return arg0. getName ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Function < T, String > arg0 ) { if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } return arg0. getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Function < T, String > arg0 ) { if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } return arg0. getDeclaringClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Function < T, String > arg0 ) { String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Function < T, String > arg0 ) { if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } if ( \"srini_string\". equals ( arg0. getName ( ) ) ) { return \"srini_string\" ; } return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { String loc0 = arg0. toString ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { String loc0 = arg0. toString ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; if ( loc1 > 0 ) { return loc0. substring ( 0, loc1 ) ; } return \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { if ( arg0 == null ) return \"srini_string\" ; return arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { return arg0 == null? \"srini_string\" : arg0. getClass ( ). getName ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { if ( arg0 instanceof Class ) { return ( ( Class ) arg0 ). getName ( ) ; } else { return arg0. getClass ( ). getName ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Class arg0 ) { String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Class arg0 ) { if ( arg0 == null ) return null ; String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( \"srini_string\" ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Class arg0 ) { if ( arg0 == null ) return null ; String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Class arg0 ) { String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private static String extractClassNameIfGoog ( Object arg0 ) { if ( arg0 == null ) return \"srini_string\" ; String loc0 = arg0. getName ( ) ; int loc1 = loc0. lastIndexOf ( '.' ) ; return ( loc1 > 0 )? loc0. substring ( 0, loc1 ) : \"srini_string\" ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_120_/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java_431-432": {
      "loc": "431-432",
      "input": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block != null; block = block.getParent()) {\n    if (block.isFunction) {\n      break;\n    } else if (block.isLoop) {\n      return false;\n    }\n  }\n  return true;\n}",
      "target": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block != null; block = block.getParent()) {\n    if (block.isFunction) {\n      if (ref.getSymbol().getScope() != ref.scope) {\n        return false;\n      }\n      break;\n    } else if (block.isLoop) {\n      return false;\n    }\n  }\n  return true;\n}",
      "function range": "421,5-438,5",
      "raw_output": [
        "boolean function ( ) { return true ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( Object arg0, Object arg1 ) { return ( arg0 == null && arg1 == null ) ; }",
        "boolean function ( Object arg0, long arg1 ) { return ( arg0 == null && arg1 == 0 ) ; }",
        "boolean function ( Object arg0 ) { return arg0 == null ; }",
        "boolean function ( Object arg0 ) { return arg0 == null ; }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } else if ( arg1 == 0 ) { return true ; } else { return arg0. getId ( ) == arg1 ; } }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } else if ( arg0 == null ) { return true ; } else if ( arg1 == 0 ) { return true ; } else { return false ; } }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == 0 ) { return true ; } return false ; }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } long loc0 = System. currentTimeMillis ( ) ; return ( loc0 - arg0. hashCode ( ) ) >= arg1 ; }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } long loc0 = System. currentTimeMillis ( ) ; long loc1 = arg0. getId ( ) ; return ( loc0 - loc1 ) >= arg1 ; }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } long loc0 = System. currentTimeMillis ( ) ; long loc1 = arg0. getId ( ) ; return ( loc0 - loc1 ) > arg1 ; }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } synchronized ( arg0 ) { return ( System. currentTimeMillis ( ) - arg0. hashCode ( ) ) >= arg1 ; } }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } long loc0 = System. currentTimeMillis ( ) ; return ( loc0 - arg0. getId ( ) ) >= arg1 ; }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0 ) { return arg0 == null ; }",
        "boolean function ( Object arg0, long arg1 ) { return ( arg0 == null )? arg1 == 0 : arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } else if ( arg0 == null ) { return true ; } else if ( arg1 == 0 ) { return true ; } else { return false ; } }",
        "boolean function ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } else if ( arg1 == 0 ) { return true ; } else { return arg0. getId ( ) == arg1 ; } }",
        "boolean function ( ) { return true ; }",
        "boolean function ( ) { return false ; }",
        "boolean function ( Object arg0 ) { return arg0 == null ; }",
        "boolean function ( Object arg0, Object arg1 ) { return arg0 == arg1 ; }",
        "boolean function ( Object arg0 ) { return ( arg0 == null ) ; }"
      ],
      "mid_translation": [
        "Is one and only assignment once in lifetime?",
        "Checks if a reference is assigned once in lifetime.",
        "Returns true if a reference is assigned once in lifetime.",
        "Check if a reference is assigned once in lifetime.",
        "Is one and only assignment once in lifetime."
      ],
      "output": [
        {
          "patch": "boolean isAssignedOnceInLifetime ( ) { return true ; }",
          "correctness": "timeout"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( ) { return false ; }",
          "correctness": "timeout"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, Object arg1 ) { return ( arg0 == null && arg1 == null ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { return ( arg0 == null && arg1 == 0 ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0 ) { return arg0 == null ; }",
          "correctness": "timeout"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0 ) { return arg0 == null ; }",
          "correctness": "timeout"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } else if ( arg1 == 0 ) { return true ; } else { return arg0. getId ( ) == arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } else if ( arg0 == null ) { return true ; } else if ( arg1 == 0 ) { return true ; } else { return false ; } }",
          "correctness": "timeout"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } if ( arg1 == 0 ) { return true ; } return false ; }",
          "correctness": "timeout"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } long loc0 = System. currentTimeMillis ( ) ; return ( loc0 - arg0. hashCode ( ) ) >= arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } long loc0 = System. currentTimeMillis ( ) ; long loc1 = arg0. getId ( ) ; return ( loc0 - loc1 ) >= arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } long loc0 = System. currentTimeMillis ( ) ; long loc1 = arg0. getId ( ) ; return ( loc0 - loc1 ) > arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } synchronized ( arg0 ) { return ( System. currentTimeMillis ( ) - arg0. hashCode ( ) ) >= arg1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } if ( arg1 == 0 ) { return true ; } long loc0 = System. currentTimeMillis ( ) ; return ( loc0 - arg0. getId ( ) ) >= arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0 ) { return arg0 == null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { return ( arg0 == null )? arg1 == 0 : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } else if ( arg0 == null ) { return true ; } else if ( arg1 == 0 ) { return true ; } else { return false ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, long arg1 ) { if ( arg0 == null ) { return false ; } else if ( arg1 == 0 ) { return true ; } else { return arg0. getId ( ) == arg1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( ) { return true ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( ) { return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0 ) { return arg0 == null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0, Object arg1 ) { return arg0 == arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "boolean isAssignedOnceInLifetime ( Object arg0 ) { return ( arg0 == null ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "JacksonDatabind_17_/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java_180-181": {
      "loc": "180-181",
      "input": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_FINAL:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n    default:\n        return (t.getRawClass() == Object.class);\n    }\n}",
      "target": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                        && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_FINAL:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n    default:\n        return (t.getRawClass() == Object.class);\n    }\n}",
      "function range": "167,9-193,9",
      "raw_output": [
        "boolean function ( Object arg0 ) { if ( arg0 instanceof TreeNode ) return true ; else if ( ( ( TreeNode ) arg0 ). getType ( ) == TreeNode. class ) return true ; else return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { TreeNode loc0 = ( TreeNode ) arg0 ; return ( ( TreeNode ) loc0 ). getType ( ) == TreeNode. class ; } return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0. getType ( ) == TreeNode. class ) ; } return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { return true ; } else if ( ( ( TreeNode ) arg0 ). getType ( ) == TreeNode. class ) { return true ; } else { return false ; } }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { return true ; } else if ( ( ( TreeNode ) arg0 ). getType ( ) == TreeNode. class ) { return true ; } return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; if ( \"srini_string\". equals ( loc0 ) || \"srini_string\". equals ( loc0 ) ) return true ; return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; if ( \"srini_string\". equals ( loc0 ) ) return true ; return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; String loc1 = loc0. getName ( ) ; return loc1. equals ( \"srini_string\" ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; if ( loc0!= null && loc0. isInstance ( arg0 ) ) return true ; return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; if ( loc0. isInstance ( arg0 ) ) return true ; return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Node ) { return true ; } else if ( ( ( Node ) arg0 ). getNodeType ( ) == Node. ELEMENT_NODE ) { return true ; } else { return false ; } }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Node ) { return true ; } else if ( ( ( Node ) arg0 ). getNodeType ( ) == Token. ELEMENT_NODE ) { return true ; } else { return false ; } }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Node ) { return true ; } else if ( ( ( Node ) arg0 ). getNodeType ( ) == Node. ELEMENT_NODE ) { return true ; } return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Node ) return true ; else if ( ( ( Node ) arg0 ). getNodeType ( ) == Node. ELEMENT_NODE ) return true ; else return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof Node ) { return true ; } else if ( ( ( Node ) arg0 ). getNodeType ( ) == Token. NODE ) { return true ; } else { return false ; } }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0 instanceof TreeNode ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) { return false ; } TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0 instanceof TreeNode ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; if ( arg0 instanceof TreeNode ) return true ; TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0 instanceof TreeNode ) ; }",
        "boolean function ( Object arg0 ) { if ( arg0 == null ) return false ; TreeNode loc0 = ( TreeNode ) arg0 ; if ( loc0 instanceof TreeNode ) return true ; return false ; }",
        "boolean function ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0. getType ( ) == TreeNode. class ) ; } return false ; }",
        "boolean function ( Type arg0 ) { return arg0 instanceof TreeNodeType ; }",
        "boolean function ( Type arg0 ) { return ( arg0 instanceof TreeNodeType ) ; }",
        "boolean function ( Type arg0 ) { return ( arg0 instanceof TreeNode ) ; }",
        "boolean function ( Type arg0 ) { if ( arg0 instanceof TreeNode ) return true ; else return false ; }",
        "boolean function ( Type arg0 ) { if ( arg0 instanceof TreeNodeType ) return true ; return false ; }"
      ],
      "mid_translation": [
        "Returns true if the type of the target object is a TreeNode type.",
        "Returns true if the type of the target object is the type of the target object.",
        "Returns true if the type of the target object is a node type.",
        "Returns true if the type of the target object is an instance of TreeNode.",
        "Returns true if the type t is a TreeNode type."
      ],
      "output": [
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof TreeNode ) return true ; else if ( ( ( TreeNode ) arg0 ). getType ( ) == TreeNode. class ) return true ; else return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { TreeNode loc0 = ( TreeNode ) arg0 ; return ( ( TreeNode ) loc0 ). getType ( ) == TreeNode. class ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0. getType ( ) == TreeNode. class ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { return true ; } else if ( ( ( TreeNode ) arg0 ). getType ( ) == TreeNode. class ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { return true ; } else if ( ( ( TreeNode ) arg0 ). getType ( ) == TreeNode. class ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; if ( \"srini_string\". equals ( loc0 ) || \"srini_string\". equals ( loc0 ) ) return true ; return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; if ( \"srini_string\". equals ( loc0 ) ) return true ; return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; String loc1 = loc0. getName ( ) ; return loc1. equals ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; if ( loc0!= null && loc0. isInstance ( arg0 ) ) return true ; return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 == null ) return false ; if ( getClass ( )!= arg0. getClass ( ) ) return false ; Class <? > loc0 = ( Class <? > ) arg0 ; if ( loc0. isInstance ( arg0 ) ) return true ; return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof Node ) { return true ; } else if ( ( ( Node ) arg0 ). getNodeType ( ) == Node. ELEMENT_NODE ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof Node ) { return true ; } else if ( ( ( Node ) arg0 ). getNodeType ( ) == Token. ELEMENT_NODE ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof Node ) { return true ; } else if ( ( ( Node ) arg0 ). getNodeType ( ) == Node. ELEMENT_NODE ) { return true ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof Node ) return true ; else if ( ( ( Node ) arg0 ). getNodeType ( ) == Node. ELEMENT_NODE ) return true ; else return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof Node ) { return true ; } else if ( ( ( Node ) arg0 ). getNodeType ( ) == Token. NODE ) { return true ; } else { return false ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 == null ) return false ; TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0 instanceof TreeNode ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 == null ) { return false ; } TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0 instanceof TreeNode ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 == null ) return false ; if ( arg0 instanceof TreeNode ) return true ; TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0 instanceof TreeNode ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 == null ) return false ; TreeNode loc0 = ( TreeNode ) arg0 ; if ( loc0 instanceof TreeNode ) return true ; return false ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Object arg0 ) { if ( arg0 instanceof TreeNode ) { TreeNode loc0 = ( TreeNode ) arg0 ; return ( loc0. getType ( ) == TreeNode. class ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Type arg0 ) { return arg0 instanceof TreeNodeType ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Type arg0 ) { return ( arg0 instanceof TreeNodeType ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public boolean useForType ( Type arg0 ) { return ( arg0 instanceof TreeNode ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public boolean useForType ( Type arg0 ) { if ( arg0 instanceof TreeNode ) return true ; else return false ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public boolean useForType ( Type arg0 ) { if ( arg0 instanceof TreeNodeType ) return true ; return false ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_22_/src/org/mockito/internal/matchers/Equality.java_13-14": {
      "loc": "13-14",
      "input": "public static boolean areEqual(Object o1, Object o2) {\n    if (o1 == null || o2 == null) {\n\n        return o1 == null && o2 == null;\n    } else if (isArray(o1)) {\n        return isArray(o2) && areArraysEqual(o1, o2);\n    } else {\n        return o1.equals(o2);\n    }\n}",
      "target": "public static boolean areEqual(Object o1, Object o2) {\n    if (o1 == o2 ) {\n\n        return true;\n}else if (o1 == null || o2 == null) {\n        return o1 == null && o2 == null;\n    } else if (isArray(o1)) {\n        return isArray(o2) && areArraysEqual(o1, o2);\n    } else {\n        return o1.equals(o2);\n    }\n}",
      "function range": "12,5-20,5",
      "raw_output": [
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( final Object arg0, final Object arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null && arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( final Object arg0, final Object arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null && arg1 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == null ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. getClass ( ). equals ( arg1. getClass ( ) ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null && arg1 == null ) { return arg0 == null ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }",
        "boolean function ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }"
      ],
      "mid_translation": [
        "Checks if two objects are equal.",
        "Returns true if the two objects are equal.",
        "Returns true if two objects are equal.",
        "Check if two objects are equal.",
        "Returns true if two objects are the same."
      ],
      "output": [
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( final Object arg0, final Object arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null && arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return false ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( final Object arg0, final Object arg1 ) { return arg0 == null? arg1 == null : arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null && arg1 == null ) { return arg1 == null ; } return arg0. equals ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return arg0 == null ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null ) { return arg1 == null ; } if ( arg1 == null ) { return arg0 == null ; } return arg0. getClass ( ). equals ( arg1. getClass ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null && arg1 == null ) { return arg0 == null ; } if ( arg0 == null || arg1 == null ) { return arg1 == null ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean areEqual ( Object arg0, Object arg1 ) { if ( arg0 == null || arg1 == null ) { return false ; } if ( arg0 == null || arg1 == null ) { return true ; } return arg0. getClass ( ) == arg1. getClass ( ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "Closure_122_/src/com/google/javascript/jscomp/parsing/IRFactory.java_252-253": {
      "loc": "252-253",
      "input": "private void handleBlockComment(Comment comment) {\n  if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n    errorReporter.warning(\n        SUSPICIOUS_COMMENT_WARNING,\n        sourceName,\n        comment.getLineno(), \"\", 0);\n  }\n}",
      "target": "private void handleBlockComment(Comment comment) {\n  Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n  if (p.matcher(comment.getValue()).find()) {\n    errorReporter.warning(\n        SUSPICIOUS_COMMENT_WARNING,\n        sourceName,\n        comment.getLineno(), \"\", 0);\n  }\n}",
      "function range": "251,3-258,3",
      "raw_output": [
        "void function ( BlockComment arg0, A arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( CommentBlock arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( BlockComment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( CommentContext arg0, Block arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( Comment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( BlockComment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( Comment arg0 ) { System. out. println ( \"srini_string\" + arg0. getLineNumber ( ) + \"srini_string\" ) ; }",
        "void function ( BlockComment arg0 ) { System. out. println ( \"srini_string\" + arg0. getLineNumber ( ) + \"srini_string\" ) ; }",
        "void function ( Comment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( BlockComment arg0 ) { System. out. println ( \"srini_string\" = \"srini_string\" ) ; }",
        "void function ( @ NotNull BlockComment arg0, @ NotNull VirtualFile arg1 ) { }",
        "void function ( @ NotNull BlockComment arg0, @ NotNull ParserContext arg1 ) { }",
        "void function ( BlockCommentContext arg0, BlockComment [ ] arg1 ) { }",
        "void function ( @ NotNull BlockComment arg0, @ NotNull BlockCommentList arg1 ) { }",
        "void function ( @ NotNull BlockComment arg0, @ NotNull PageFormatter arg1 ) { }",
        "void function ( @ NotNull BlockComment arg0, @ NotNull ParserRuleContext arg1 ) { }",
        "void function ( Context arg0, BlockComment arg1 ) { }",
        "void function ( CommentContext arg0, Block arg1 ) { }",
        "void function ( CommentContext arg0, BlockComment arg1 ) { }",
        "void function ( @ NotNull Block arg0, @ NotNull String arg1 ) { }",
        "void function ( BlockComment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( BlockComment arg0, A arg1 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( Comment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( Comment arg0 ) { System. out. println ( \"srini_string\" + arg0. getLineNumber ( ) + \"srini_string\" ) ; }",
        "void function ( BlockCommentEvent arg0 ) { System. out. println ( \"srini_string\" ) ; }"
      ],
      "mid_translation": [
        "Handle a block comment.",
        "Handle block comment.",
        "Handle block comments.",
        "Handles a block comment.",
        "Handle the block comment."
      ],
      "output": [
        {
          "patch": "private void handleBlockComment ( BlockComment arg0, A arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( CommentBlock arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( BlockComment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( CommentContext arg0, Block arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( Comment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private void handleBlockComment ( BlockComment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( Comment arg0 ) { System. out. println ( \"srini_string\" + arg0. getLineNumber ( ) + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( BlockComment arg0 ) { System. out. println ( \"srini_string\" + arg0. getLineNumber ( ) + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( Comment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private void handleBlockComment ( BlockComment arg0 ) { System. out. println ( \"srini_string\" = \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( @ NotNull BlockComment arg0, @ NotNull VirtualFile arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( @ NotNull BlockComment arg0, @ NotNull ParserContext arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( BlockCommentContext arg0, BlockComment [ ] arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( @ NotNull BlockComment arg0, @ NotNull BlockCommentList arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( @ NotNull BlockComment arg0, @ NotNull PageFormatter arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( @ NotNull BlockComment arg0, @ NotNull ParserRuleContext arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( Context arg0, BlockComment arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( CommentContext arg0, Block arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( CommentContext arg0, BlockComment arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( @ NotNull Block arg0, @ NotNull String arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( BlockComment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( BlockComment arg0, A arg1 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( Comment arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "private void handleBlockComment ( Comment arg0 ) { System. out. println ( \"srini_string\" + arg0. getLineNumber ( ) + \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void handleBlockComment ( BlockCommentEvent arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Mockito_24_/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java_76-77": {
      "loc": "76-77",
      "input": "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        return 1;\n    }\n    Class<?> returnType = invocation.getMethod().getReturnType();\n    return returnValueFor(returnType);\n}",
      "target": "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n        return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n    }\n    Class<?> returnType = invocation.getMethod().getReturnType();\n    return returnValueFor(returnType);\n}",
      "function range": "63,5-81,5",
      "raw_output": [
        "T function ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
        "MethodInvocationResult < T > function ( MethodInvocation < T > arg0 ) { return new MethodInvocationResult < T > ( arg0 ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ). get ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return arg0. getTarget ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ). get ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return arg0. proceed ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getThis ( ) ; }",
        "T function ( InvocationContext arg0 ) { return ( T ) arg0. getThis ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
        "Object function ( EJBClientInvocationContext arg0 ) { return null ; }",
        "T function ( Callable < T > arg0 ) { return ( T ) arg0. get ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return getValue ( arg0. getThis ( ) ) ; }",
        "Object function ( MethodInvocation arg0 ) { return null ; }",
        "T function ( MethodInvocation arg0 ) { return ( T ) arg0. getThis ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
        "T function ( MethodInvocation arg0 ) { T loc0 = ( T ) arg0. getThis ( ) ; return loc0 ; }",
        "Object function ( MethodInvocation arg0 ) { return null ; }",
        "T function ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
        "T function ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ) ; }",
        "T function ( MethodInvocation arg0 ) { return ( T ) arg0. getThis ( ) ; }",
        "Object function ( MethodInvocation arg0 ) { return arg0. getThis ( ) ; }"
      ],
      "mid_translation": [
        "Answer for a method invocation.",
        "Answer for method invocation.",
        "Answer for an invocation.",
        "Answer the return value for an invocation.",
        "Answer for a method invocation"
      ],
      "output": [
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public MethodInvocationResult < T > answer ( MethodInvocation < T > arg0 ) { return new MethodInvocationResult < T > ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ). get ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return arg0. getTarget ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ). get ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return arg0. proceed ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object answer ( MethodInvocation arg0 ) { return arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( InvocationContext arg0 ) { return ( T ) arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object answer ( EJBClientInvocationContext arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( Callable < T > arg0 ) { return ( T ) arg0. get ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object answer ( MethodInvocation arg0 ) { return getValue ( arg0. getThis ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object answer ( MethodInvocation arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation arg0 ) { return ( T ) arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation arg0 ) { T loc0 = ( T ) arg0. getThis ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object answer ( MethodInvocation arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return ( T ) arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation < T > arg0 ) { return arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public T answer ( MethodInvocation arg0 ) { return ( T ) arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public Object answer ( MethodInvocation arg0 ) { return arg0. getThis ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "Closure_125_/src/com/google/javascript/jscomp/TypeCheck.java_1661-1662": {
      "loc": "1661-1662",
      "input": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType != null) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}",
      "target": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType != null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}",
      "function range": "1656,3-1671,3",
      "raw_output": [
        "NewNode function ( ) { return NEW_NODE ; }",
        "NewNode function ( ) { return new Node ( ) ; }",
        "NewNode function ( ASTNode arg0 ) { return arg0 ; }",
        "NewNode function ( ) { return new NewNode ( ) ; }",
        "NODE function ( ASTNode arg0 ) { return arg0 ; }",
        "void function ( NewNode arg0 ) { }",
        "R function ( NewNode arg0 ) { return null ; }",
        "void function ( NewStatement arg0 ) { }",
        "void function ( ASTNew arg0 ) { }",
        "void function ( NEW_NODE arg0 ) { }",
        "void function ( NewNode arg0 ) { }",
        "R function ( NewNode arg0 ) { return null ; }",
        "void function ( NewStatement arg0 ) { }",
        "void function ( NEW_NODE arg0 ) { }",
        "void function ( NewNode arg0, A arg1 ) { }",
        "NewNode function ( ) { return new Node ( ) ; }",
        "NewNode function ( ) { return new NewNode ( ) ; }",
        "NewNode function ( ASTNode arg0 ) { return arg0 ; }",
        "void function ( ASTNode arg0 ) { }",
        "Node function ( ASTNode arg0 ) { return arg0 ; }",
        "void function ( ASTNode arg0 ) { }",
        "void function ( NewNode arg0 ) { }",
        "void function ( NEW_NODE arg0 ) { }",
        "void function ( Node arg0 ) { }",
        "void function ( NewStatement arg0 ) { }"
      ],
      "mid_translation": [
        "Visits a NEW node.",
        "Visit a NEW node.",
        "Visit an NEW node.",
        "Visits an NEW node.",
        "Visits the NEW node."
      ],
      "output": [
        {
          "patch": "private NewNode visitNew ( ) { return NEW_NODE ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NewNode visitNew ( ) { return new Node ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NewNode visitNew ( ASTNode arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NewNode visitNew ( ) { return new NewNode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NODE visitNew ( ASTNode arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NewNode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitNew ( NewNode arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NewStatement arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( ASTNew arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NEW_NODE arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NewNode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private R visitNew ( NewNode arg0 ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NewStatement arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NEW_NODE arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NewNode arg0, A arg1 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NewNode visitNew ( ) { return new Node ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NewNode visitNew ( ) { return new NewNode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private NewNode visitNew ( ASTNode arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( ASTNode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private Node visitNew ( ASTNode arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( ASTNode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NewNode arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NEW_NODE arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( Node arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "private void visitNew ( NewStatement arg0 ) { }",
          "correctness": "uncompilable"
        }
      ]
    },
    "JacksonDatabind_98_/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java_298-299": {
      "loc": "298-299",
      "input": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                buffer.assignParameter(typeProp, typeId);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}",
      "target": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                final Object v;\n                if (typeProp.getType().hasRawClass(String.class)) {\n                    v = typeId;\n                } else {\n                    TokenBuffer tb = new TokenBuffer(p, ctxt);\n                    tb.writeString(typeId);\n                    v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt);\n                    tb.close();\n                }\n                buffer.assignParameter(typeProp, v);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}",
      "function range": "255,5-311,5",
      "raw_output": [
        "void function ( ) { }",
        "void function ( ServletContext arg0 ) { }",
        "void function ( OutputEventListener arg0 ) { arg0. complete ( ) ; }",
        "void function ( BeanInfo arg0 ) { }",
        "void function ( Map arg0 ) { }",
        "void function ( ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( String arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( ) { }",
        "void function ( Integer arg0 ) { System. out. println ( \"srini_string\" ) ; }",
        "void function ( Map arg0 ) { }",
        "void function ( ) { }",
        "void function ( Map arg0 ) { }",
        "void function ( String arg0, Map arg1 ) { }",
        "String function ( ) { return \"srini_string\" ; }",
        "void function ( String arg0 ) { }",
        "void function ( ) { }",
        "void function ( Map arg0 ) { }",
        "String function ( ) { return \"srini_string\" ; }",
        "void function ( String arg0, Map arg1 ) { }",
        "void function ( Map arg0, Object arg1 ) { }",
        "void function ( ) { }",
        "void function ( BeanInfo arg0 ) { }",
        "void function ( BeanContext arg0 ) { }",
        "void function ( ServletContext arg0 ) { }",
        "void function ( BeanDefinition arg0 ) { }"
      ],
      "mid_translation": [
        "Completes the bean.",
        "Method complete.",
        "This method is called to complete the bean.",
        "This method is used to complete the bean.",
        "Completes the Bean."
      ],
      "output": [
        {
          "patch": "public void complete ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( ServletContext arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void complete ( OutputEventListener arg0 ) { arg0. complete ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void complete ( BeanInfo arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void complete ( Map arg0 ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( String arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( Integer arg0 ) { System. out. println ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( Map arg0 ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( Map arg0 ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( String arg0, Map arg1 ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public String complete ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( String arg0 ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( Map arg0 ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public String complete ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( String arg0, Map arg1 ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( Map arg0, Object arg1 ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( ) { }",
          "correctness": "wrong"
        },
        {
          "patch": "public void complete ( BeanInfo arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void complete ( BeanContext arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void complete ( ServletContext arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public void complete ( BeanDefinition arg0 ) { }",
          "correctness": "uncompilable"
        }
      ]
    }
  }
}