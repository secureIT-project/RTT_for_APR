{
  "config": "CODET5_REFINE_CODEFORM_NOCOMMENT",
  "data": {
    "BITCOUNT": {
      "loc": "15-16",
      "input": "public static int bitcount(int n) {\nint count = 0;\nwhile (n != 0) {\n    n = (n ^ (n - 1)); \n    count++;\n}\nreturn count;\n}",
      "target": "public static int bitcount(int n) {\nint count = 0;\nwhile (n != 0) { \n    n = (n & (n - 1));\n    count++;\n}\nreturn count;\n}",
      "function range": "12,5-19,5",
      "raw_output": [
        "public static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( long n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "static int bitCount ( long n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitCount ( long n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n"
      ],
      "mid_translation": [
        "int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "int bitcount ( unsigned int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "int bitcount ( unsigned n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "unsigned int bitcount ( unsigned int n ) {\n  unsigned int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n"
      ],
      "output": [
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( long n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( long n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( int n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    ++ count ;\n  }\n  return count ;\n}\n",
        "public static int bitcount ( long n ) {\n  int count = 0 ;\n  while ( n != 0 ) {\n    n = ( n ^ ( n - 1 ) ) ;\n    count ++ ;\n  }\n  return count ;\n}\n"
      ]
    },
    "BREADTH_FIRST_SEARCH": {
      "loc": "24-25",
      "input": "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (true) { \n        Node node = queue.removeFirst();\n        if (node == goalnode) {\n            return true;\n        } else {\n            for (Node successor_node : node.getSuccessors()) {\n                if (!nodesvisited.contains(successor_node)) {\n                    queue.addFirst(successor_node);\n                    nodesvisited.add(successor_node);\n                }\n            }\n        }\n    }\n    return false;\n}",
      "target": "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode); \n    while (!queue.isEmpty()) {\n        Node node = queue.removeFirst();\n        if (node == goalnode) {\n            return true;\n        } else {\n            for (Node successor_node : node.getSuccessors()) {\n                if (!nodesvisited.contains(successor_node)) {\n                    queue.addFirst(successor_node);\n                    nodesvisited.add(successor_node);\n                }\n            }\n        }\n    }\n     return false;\n}",
      "function range": "18,5-39,5",
      "raw_output": [
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Queue < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Queue < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Queue < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Queue < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadthFirstSearch ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n"
      ],
      "mid_translation": [
        "bool breadth_first_search ( Node * startnode , Node * goalnode ) {\n  std :: deque < Node * > queue ;\n  queue . push_back ( startnode ) ;\n  nodesvisited . insert ( startnode ) ;\n  while ( true ) {\n    Node * node = queue . front ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node * successor_node : node -> successors ) {\n        if ( ! nodesvisited . count ( successor_node ) ) {\n          queue . push_front ( successor_node ) ;\n          nodesvisited . insert ( successor_node ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "bool breadth_first_search ( Node * startnode , Node * goalnode ) {\n  std :: deque < Node * > queue ;\n  queue . push_back ( startnode ) ;\n  nodesvisited . insert ( startnode ) ;\n  while ( true ) {\n    Node * node = queue . front ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node * successor_node : node -> successors ) {\n        if ( ! nodesvisited . count ( successor_node ) ) {\n          queue . pop_front ( ) ;\n          nodesvisited . insert ( successor_node ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "bool breadth_first_search ( Node * startnode , Node * goalnode ) {\n  std :: deque < Node * > queue ;\n  queue . push_back ( startnode ) ;\n  nodesvisited . push_back ( startnode ) ;\n  while ( true ) {\n    Node * node = queue . front ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node * successor_node : node -> successors ) {\n        if ( ! nodesvisited . count ( successor_node ) ) {\n          queue . push_front ( successor_node ) ;\n          nodesvisited . insert ( successor_node ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "bool breadth_first_search ( Node * startnode , Node * goalnode ) {\n  std :: deque < Node * > queue ;\n  queue . push_back ( startnode ) ;\n  nodesvisited . insert ( startnode ) ;\n  while ( true ) {\n    Node * node = queue . front ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node * successor_node : node -> successors ) {\n        if ( ! nodesvisited . count ( successor_node ) ) {\n          queue . push_front ( successor_node ) ;\n          nodesvisited . insert ( successor_node ) ;\n        }\n      }\n    }\n  }\n}\n",
        "bool breadth_first_search ( Node * startnode , Node * goalnode ) {\n  std :: deque < Node * > queue ;\n  queue . push_back ( startnode ) ;\n  nodesvisited . insert ( startnode ) ;\n  while ( true ) {\n    Node * node = queue . front ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node * successor_node : node -> successors ( ) ) {\n        if ( ! nodesvisited . count ( successor_node ) ) {\n          queue . push_front ( successor_node ) ;\n          nodesvisited . insert ( successor_node ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n"
      ],
      "output": [
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Queue < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Queue < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Queue < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Queue < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new ArrayDeque < Node > ( ) ;\n  queue . push ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . pop ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . push ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n",
        "public static boolean breadth_first_search ( Node startnode , Node goalnode ) {\n  Deque < Node > queue = new LinkedList < Node > ( ) ;\n  queue . add ( startnode ) ;\n  nodesvisited . add ( startnode ) ;\n  while ( true ) {\n    Node node = queue . poll ( ) ;\n    if ( node == goalnode ) {\n      return true ;\n    }\n    else {\n      for ( Node successorNode : node . getSuccessors ( ) ) {\n        if ( ! nodesvisited . contains ( successorNode ) ) {\n          queue . add ( successorNode ) ;\n          nodesvisited . add ( successorNode ) ;\n        }\n      }\n    }\n  }\n}\n"
      ]
    },
    "BUCKETSORT": {
      "loc": "22-23",
      "input": "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n    int i = 0;\n    for (Integer count : arr) {  \n        sorted_arr.addAll(Collections.nCopies(count, i));\n        i++;\n    }\n    return sorted_arr;\n}",
      "target": "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n    int i = 0;\n    for (Integer count : counts) { \n        sorted_arr.addAll(Collections.nCopies(count, i));\n        i++;\n    }\n    return sorted_arr;\n}",
      "function range": "14,5-28,5",
      "raw_output": [
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , 0 , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( k , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( k , 0 ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , 0 , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , 0 , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( k , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , 0 , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtils . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( k , 0 ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n"
      ],
      "mid_translation": [
        "vector < int > bucketsort ( vector < int > arr , int k ) {\n  vector < int > counts ( std :: nth_element ( arr . begin ( ) , arr . end ( ) , 0 ) , 0 ) ;\n  for ( auto x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  vector < int > sorted_arr ( 100 , 0 ) ;\n  int i = 0 ;\n  for ( auto count : arr ) {\n    sorted_arr . insert ( sorted_arr . end ( ) , count ) ;\n    i ++ ;\n  }\n  return sorted_arr ;\n}\n",
        "vector < int > bucketsort ( vector < int > arr , int k ) {\n  vector < int > counts ( std :: nth_element ( arr . begin ( ) , arr . end ( ) , 0 ) , 0 ) ;\n  for ( auto x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  vector < int > sorted_arr ( 100 ) ;\n  int i = 0 ;\n  for ( auto count : arr ) {\n    sorted_arr . insert ( sorted_arr . end ( ) , count ) ;\n    i ++ ;\n  }\n  return sorted_arr ;\n}\n",
        "vector < int > bucketsort ( vector < int > arr , int k ) {\n  vector < int > counts ( std :: nth_element ( arr . begin ( ) , arr . end ( ) , 0 ) , 0 ) ;\n  for ( auto x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  vector < int > sorted_arr ( 100 ) ;\n  int i = 0 ;\n  for ( auto count : arr ) {\n    sorted_arr . insert ( sorted_arr . end ( ) , count ) ;\n    i ++ ;\n  }\n  return sorted_arr ;\n}\n",
        "vector < int > bucketsort ( vector < int > arr , int k ) {\n  vector < int > counts ( std :: nth_element ( arr . begin ( ) , arr . end ( ) , 0 ) , 0 ) ;\n  for ( auto x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  vector < int > sorted_arr ( 100 , 0 ) ;\n  int i = 0 ;\n  for ( auto count : arr ) {\n    sorted_arr . insert ( sorted_arr . end ( ) , count , i ) ;\n    i ++ ;\n  }\n  return sorted_arr ;\n}\n",
        "vector < int > bucketsort ( vector < int > arr , int k ) {\n  vector < int > counts ( std :: nth_element ( arr . begin ( ) , arr . end ( ) , 0 ) , 0 ) ;\n  for ( auto x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  vector < int > sorted_arr ( 100 , 0 ) ;\n  int i = 0 ;\n  for ( auto count : arr ) {\n    sorted_arr . insert ( sorted_arr . end ( ) , count ) ;\n    i ++ ;\n  }\n  return sorted_arr ;\n}\n"
      ],
      "output": [
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , 0 , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( k , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( k , 0 ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , 0 , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , 0 , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( k , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , 0 , k ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtils . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) counts [ x ] = counts [ x ] + 1 ;\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . min ( arr . length , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( arr . length , 0 ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Math . max ( arr . length , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ ArrayUtil . nCopies ( k , 0 ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n",
        "public static int [ ] bucketsort ( int [ ] arr , int k ) {\n  int [ ] counts = new int [ Arrays . binarySearch ( arr , k ) ] ;\n  for ( int x : arr ) {\n    counts [ x ] = counts [ x ] + 1 ;\n  }\n  int [ ] sortedArr = new int [ 100 ] ;\n  int i = 0 ;\n  for ( int count : arr ) {\n    sortedArr [ i ] = count ;\n    i ++ ;\n  }\n  return sortedArr ;\n}\n"
      ]
    },
    "DEPTH_FIRST_SEARCH": {
      "loc": "22-22",
      "input": "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        for (Node successornodes : node.getSuccessors()) { \n            if (search(successornodes)) { return true; }\n        }\n    }\n    return false;\n}",
      "target": "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true; \n    } else {\n            nodesvisited.add(node);\n        for (Node successornodes : node.getSuccessors()) {\n            if (search(successornodes)) { return true; }\n        }\n    }\n    return false;\n}",
      "function range": "16,13-27,13",
      "raw_output": [
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessorNodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessorNodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node . equals ( goalnode ) ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) return false ;\n  else if ( node == goalnode ) return true ;\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) return true ;\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) return false ;\n  else if ( node == goalnode ) return true ;\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) return true ;\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessorNodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessorNodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "public static boolean search ( Node node ) {\n  if ( nodesVisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n"
      ],
      "mid_translation": [
        "bool search ( Node * node ) {\n  if ( nodesvisited . count ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node * successornodes : node -> successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "bool search ( Node * node ) {\n  if ( nodesvisited . find ( node ) != nodesvisited . end ( ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node * successornodes : node -> successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "bool search ( Node * node ) {\n  if ( nodesvisited . count ( node ) ) return false ;\n  else if ( node == goalnode ) return true ;\n  else {\n    for ( Node * successornodes : node -> successors ) {\n      if ( search ( successornodes ) ) return true ;\n    }\n  }\n  return false ;\n}\n",
        "bool search ( Node * node ) {\n  if ( nodesvisited . count ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node * successornodes : node -> successors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "bool search ( node * node ) {\n  if ( nodesvisited . count ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( node * successornodes : node -> successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n"
      ],
      "output": [
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessorNodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessorNodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node . equals ( goalnode ) ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) return false ;\n  else if ( node == goalnode ) return true ;\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) return true ;\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) return false ;\n  else if ( node == goalnode ) return true ;\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) return true ;\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessorNodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . successors ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessorNodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesvisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessornodes ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n",
        "boolean search ( Node node ) {\n  if ( nodesVisited . contains ( node ) ) {\n    return false ;\n  }\n  else if ( node == goalnode ) {\n    return true ;\n  }\n  else {\n    for ( Node successornodes : node . getSuccessors ( ) ) {\n      if ( search ( successornodes ) ) {\n        return true ;\n      }\n    }\n  }\n  return false ;\n}\n"
      ]
    },
    "DETECT_CYCLE": {
      "loc": "18-19",
      "input": "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n        if (hare.getSuccessor() == null) \n            return false;\n        tortoise = tortoise.getSuccessor();\n        hare = hare.getSuccessor().getSuccessor();\n        if (hare == tortoise)\n            return true;\n    }\n}",
      "target": "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n        if (null==hare ||hare.getSuccessor() == null)\n            return false;\n        tortoise = tortoise.getSuccessor();\n        hare = hare.getSuccessor().getSuccessor();\n        if (hare == tortoise)\n            return true;\n    }\n}",
      "function range": "13,5-27,5",
      "raw_output": [
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . successor == null ) return false ;\n    tortoise = tortoise . successor ;\n    hare = hare . successor . successor ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . successor == null ) {\n      return false ;\n    }\n    tortoise = tortoise . successor ;\n    hare = hare . successor . successor ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) return false ;\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) return false ;\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) {\n      return false ;\n    }\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) {\n      return false ;\n    }\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare . equals ( tortoise ) ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) return false ;\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . Successor == null ) return false ;\n    tortoise = tortoise . Successor ;\n    hare = hare . Successor . Successor ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . Successor == null ) return false ;\n    tortoise = tortoise . Successor ;\n    hare = hare . Successor . Successor ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detectCycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . Successor == null ) return false ;\n    tortoise = tortoise . Successor ;\n    hare = hare . Successor . Successor ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n"
      ],
      "mid_translation": [
        "bool detect_cycle ( node * node ) {\n  node * hare = node ;\n  node * tortoise = node ;\n  while ( true ) {\n    if ( hare -> successor == NULL ) return false ;\n    tortoise = tortoise -> successor ;\n    hare = hare -> successor -> successor ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "bool detect_cycle ( node * node ) {\n  node * hare = node ;\n  node * tortoise = node ;\n  while ( true ) {\n    if ( hare -> next == NULL ) return false ;\n    tortoise = tortoise -> next ;\n    hare = hare -> next -> next ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "bool detect_cycle ( node * node ) {\n  node * hare = node ;\n  node * tortoise = node ;\n  while ( true ) {\n    if ( hare -> Successor == NULL ) return false ;\n    tortoise = tortoise -> Successor ;\n    hare = hare -> Successor -> Successor ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "bool detect_cycle ( Node * node ) {\n  Node * hare = node ;\n  Node * tortoise = node ;\n  while ( true ) {\n    if ( hare -> getSuccessor ( ) == NULL ) return false ;\n    tortoise = tortoise -> getSuccessor ( ) ;\n    hare = hare -> getSuccessor ( ) -> getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "bool detect_cycle ( Node * node ) {\n  Node * hare = node ;\n  Node * tortoise = node ;\n  while ( true ) {\n    if ( hare -> Successor == NULL ) return false ;\n    tortoise = tortoise -> Successor ;\n    hare = hare -> Successor -> Successor ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n"
      ],
      "output": [
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . successor == null ) return false ;\n    tortoise = tortoise . successor ;\n    hare = hare . successor . successor ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . successor == null ) {\n      return false ;\n    }\n    tortoise = tortoise . successor ;\n    hare = hare . successor . successor ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) return false ;\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) return false ;\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) {\n      return false ;\n    }\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) {\n      return false ;\n    }\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare . equals ( tortoise ) ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . next == null ) return false ;\n    tortoise = tortoise . next ;\n    hare = hare . next . next ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . Successor == null ) return false ;\n    tortoise = tortoise . Successor ;\n    hare = hare . Successor . Successor ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . Successor == null ) return false ;\n    tortoise = tortoise . Successor ;\n    hare = hare . Successor . Successor ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare == tortoise ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) return false ;\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) return true ;\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . getSuccessor ( ) == null ) {\n      return false ;\n    }\n    tortoise = tortoise . getSuccessor ( ) ;\n    hare = hare . getSuccessor ( ) . getSuccessor ( ) ;\n    if ( hare . equals ( tortoise ) ) {\n      return true ;\n    }\n  }\n}\n",
        "public static boolean detect_cycle ( Node node ) {\n  Node hare = node ;\n  Node tortoise = node ;\n  while ( true ) {\n    if ( hare . Successor == null ) return false ;\n    tortoise = tortoise . Successor ;\n    hare = hare . Successor . Successor ;\n    if ( hare == tortoise ) return true ;\n  }\n}\n"
      ]
    },
    "FIND_FIRST_IN_SORTED": {
      "loc": "19-20",
      "input": "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo <= hi) { \n        int mid = (lo + hi) / 2; \n        if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n            return mid;\n        } else if (x <= arr[mid]) {\n            hi = mid;\n        } else {\n            lo = mid + 1;\n        }\n    }\n    return -1;\n}",
      "target": "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) { \n        int mid = (lo + hi) / 2; \n        if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n            return mid;\n        } else if (x <= arr[mid]) {\n            hi = mid;\n        } else {\n            lo = mid + 1;\n        }\n    }\n    return -1;\n}",
      "function range": "15,5-32,5",
      "raw_output": [
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int firstInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int firstInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int firstInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int firstInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "static int indexOfInSorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n"
      ],
      "mid_translation": [
        "public : int find_first_in_sorted ( vector < int > & arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . size ( ) ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public : int find_first_in_sorted ( vector < int > & arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . size ( ) ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public : int find_first_in_sorted ( vector < int > arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . size ( ) ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public : int find_first_in_sorted ( vector < int > arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . size ( ) ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "int find_first_in_sorted ( vector < int > & arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . size ( ) ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n"
      ],
      "output": [
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) return mid ;\n    else if ( x <= arr [ mid ] ) hi = mid ;\n    else lo = mid + 1 ;\n  }\n  return - 1 ;\n}\n",
        "public static int find_first_in_sorted ( int [ ] arr , int x ) {\n  int lo = 0 ;\n  int hi = arr . length ;\n  while ( lo <= hi ) {\n    int mid = ( lo + hi ) / 2 ;\n    if ( x == arr [ mid ] && ( mid == 0 || x != arr [ mid - 1 ] ) ) {\n      return mid ;\n    }\n    else if ( x <= arr [ mid ] ) {\n      hi = mid ;\n    }\n    else {\n      lo = mid + 1 ;\n    }\n  }\n  return - 1 ;\n}\n"
      ]
    },
    "FIND_IN_SORTED": {
      "loc": "20-21",
      "input": "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid, end); \n    } else {\n        return mid;\n    }\n}",
      "target": "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) { \n        return binsearch(arr, x, mid+1, end);\n    } else {\n        return mid;\n    }\n}",
      "function range": "12,5-24,5",
      "raw_output": [
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binSearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binSearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binSearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binSearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binSearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binSearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binSearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binSearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binSearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binSearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binSearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binSearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static final int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n"
      ],
      "mid_translation": [
        "int binsearch ( int * arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "int binsearch ( int * arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public : int binsearch ( vector < int > & arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n"
      ],
      "output": [
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binSearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binSearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) return - 1 ;\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binSearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binSearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) return binsearch ( arr , x , start , mid ) ;\n  else if ( x > arr [ mid ] ) return binsearch ( arr , x , mid , end ) ;\n  else return mid ;\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binSearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binSearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binSearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binSearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int arr [ ] , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n",
        "public static int binsearch ( int [ ] arr , int x , int start , int end ) {\n  if ( start == end ) {\n    return - 1 ;\n  }\n  int mid = start + ( end - start ) / 2 ;\n  if ( x < arr [ mid ] ) {\n    return binsearch ( arr , x , start , mid ) ;\n  }\n  else if ( x > arr [ mid ] ) {\n    return binsearch ( arr , x , mid , end ) ;\n  }\n  else {\n    return mid ;\n  }\n}\n"
      ]
    },
    "FLATTEN": {
      "loc": "21-26",
      "input": "public static Object flatten(Object arr) {\n    if (arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n        ArrayList result = new ArrayList(50);\n        for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(flatten(x)); \n            } \n        } \n        return result; \n    } else { \n        return flatten(arr);\n    }\n}",
      "target": "public static Object flatten(Object arr) {\n    if (arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n        ArrayList result = new ArrayList(50);\n        for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else { \n                result.add((x)); \n            } \n        } \n        return result; \n    } else {\n        return arr;\n    }\n}",
      "function range": "13,5-28,5",
      "raw_output": [
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] instanceof Object [ ] ) {\n        result [ i ] = ( Object [ ] ) narr [ i ] ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] == null ) {\n        result [ i ] = null ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr . clone ( ) ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = null ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr . clone ( ) ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = null ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr . length > 0 ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr . clone ( ) ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] instanceof Object [ ] ) {\n        result [ i ] = ( Object [ ] ) narr [ i ] ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] == null ) {\n        result [ i ] = null ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof List ) {\n        result [ 0 ] = flatten ( ( List ) x ) ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] instanceof Object [ ] ) {\n        result [ i ] = ( Object [ ] ) narr [ i ] ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result [ 0 ] = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result [ 0 ] = ( Object ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result [ 0 ] = ( Object ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] instanceof Object [ ] ) {\n        result [ i ] = ( Object [ ] ) narr [ i ] ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr . clone ( ) ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = null ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] == null ) {\n        result [ i ] = null ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n"
      ],
      "mid_translation": [
        "object flatten ( const object & arr ) {\n  if ( arr . is_array ( ) ) {\n    object narr = arr ;\n    object result ( 50 ) ;\n    for ( object x : narr ) {\n      if ( x . is_array ( ) ) result . reserve ( x . size ( ) ) ;\n      else result . push_back ( flatten ( x ) ) ;\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "object flatten ( const object & arr ) {\n  if ( arr . is_array ( ) ) {\n    const object & narr = arr ;\n    object result ( 50 ) ;\n    for ( object x : narr ) {\n      if ( x . is_array ( ) ) result . reserve ( x . size ( ) ) ;\n      else result . push_back ( flatten ( x ) ) ;\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "object flatten ( const object & arr ) {\n  if ( arr . is_array ( ) ) {\n    object narr = arr ;\n    object result ( 50 ) ;\n    for ( object x : narr ) {\n      if ( x . is_array ( ) ) result . reserve ( x . size ( ) ) ;\n      else result . push_back ( flatten ( x ) ) ;\n    }\n    return result ;\n  }\n  else return flatten ( arr ) ;\n}\n",
        "object flatten ( const object & arr ) {\n  if ( arr . is_array ( ) ) {\n    object narr = arr ;\n    object result ( 50 ) ;\n    for ( object x : narr ) {\n      if ( x . is_array ( ) ) result . swap ( x ) ;\n      else result . push_back ( flatten ( x ) ) ;\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "object flatten ( const object & arr ) {\n  if ( arr . is_array ( ) ) {\n    const object & narr = arr ;\n    object result ( 50 ) ;\n    for ( object x : narr ) {\n      if ( x . is_array ( ) ) result . reserve ( x . size ( ) ) ;\n      else result . push_back ( flatten ( x ) ) ;\n    }\n    return result ;\n  }\n  else return flatten ( arr ) ;\n}\n"
      ],
      "output": [
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] instanceof Object [ ] ) {\n        result [ i ] = ( Object [ ] ) narr [ i ] ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] == null ) {\n        result [ i ] = null ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr . clone ( ) ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = null ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr . clone ( ) ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = null ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr . length > 0 ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr . clone ( ) ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] instanceof Object [ ] ) {\n        result [ i ] = ( Object [ ] ) narr [ i ] ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] == null ) {\n        result [ i ] = null ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof List ) {\n        result [ 0 ] = flatten ( ( List ) x ) ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] instanceof Object [ ] ) {\n        result [ i ] = ( Object [ ] ) narr [ i ] ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result [ 0 ] = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result [ 0 ] = ( Object ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result [ 0 ] = ( Object ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x instanceof Object [ ] ) {\n        result = ( Object [ ] ) x ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] instanceof Object [ ] ) {\n        result [ i ] = ( Object [ ] ) narr [ i ] ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr . clone ( ) ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( Object x : narr ) {\n      if ( x == null ) {\n        result [ 0 ] = null ;\n      }\n      else {\n        result [ 0 ] = flatten ( x ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n",
        "public static Object [ ] flatten ( Object [ ] arr ) {\n  if ( arr != null ) {\n    Object [ ] narr = arr ;\n    Object [ ] result = new Object [ 50 ] ;\n    for ( int i = 0 ;\n    i < narr . length ;\n    i ++ ) {\n      if ( narr [ i ] == null ) {\n        result [ i ] = null ;\n      }\n      else {\n        result [ i ] = flatten ( narr [ i ] ) ;\n      }\n    }\n    return result ;\n  }\n  else {\n    return flatten ( arr ) ;\n  }\n}\n"
      ]
    },
    "GCD": {
      "loc": "19-20",
      "input": "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(a % b, b); \n    }\n}",
      "target": "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a%b); \n    }\n}",
      "function range": "15,5-21,5",
      "raw_output": [
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( ! b ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( ! b ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( ! b ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "static long gcd ( long a , long b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n"
      ],
      "mid_translation": [
        "int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "int gcd ( int a , int b ) {\n  if ( ! b ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "template < typename T > T gcd ( T a , T b ) {\n  if ( ! b ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "template < typename T > T gcd ( T a , T b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n"
      ],
      "output": [
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( ! b ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( ! b ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( ! b ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n",
        "public static int gcd ( int a , int b ) {\n  if ( b == 0 ) {\n    return a ;\n  }\n  else {\n    return gcd ( a % b , b ) ;\n  }\n}\n",
        "public static long gcd ( long a , long b ) {\n  if ( b == 0 ) return a ;\n  else return gcd ( a % b , b ) ;\n}\n"
      ]
    },
    "GET_FACTORS": {
      "loc": "27-28",
      "input": "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    return new ArrayList<Integer>(); \n}",
      "target": "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    return new ArrayList<Integer>(Arrays.asList(n));\n}",
      "function range": "14,5-28,5",
      "raw_output": [
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static int [ ] getFactors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      prepend . addAll ( getFactors ( n / i ) + 1 ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      prepend . add ( getFactors ( n / i ) + 1 ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static int [ ] getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new int [ 0 ] ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) + 1 ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new int [ 0 ] ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static List < Integer > getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      List < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      prepend . addAll ( getFactors ( n / i ) + 1 ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static List < Integer > getFactors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      List < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static int [ ] getFactors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static List < Integer > getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      List < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static int [ ] getFactors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static List < Integer > getFactors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      List < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( 0 ) ;\n}\n",
        "public static int [ ] getFactors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) + 1 ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] getFactors ( int n ) {\n  if ( n == 1 ) {\n    return new int [ 0 ] ;\n  }\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) + 1 ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) return null ;\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return null ;\n}\n",
        "public static ArrayList < Integer > getFactors ( int n ) {\n  if ( n == 1 ) {\n    return null ;\n  }\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return null ;\n}\n",
        "public static int [ ] getFactors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n"
      ],
      "mid_translation": [
        "vector < int > get_factors ( int n ) {\n  if ( n == 1 ) return {\n  }\n  ;\n  int max = ( int ) ( sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      vector < int > prepend ( 0 ) ;\n      prepend . push_back ( i ) ;\n      prepend . insert ( prepend . end ( ) , get_factors ( n / i ) , get_factors ( n / i ) + 1 ) ;\n      return prepend ;\n    }\n  }\n  return {\n  }\n  ;\n}\n",
        "vector < int > get_factors ( int n ) {\n  if ( n == 1 ) {\n    return {\n    }\n    ;\n  }\n  int max = ( int ) ( sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      vector < int > prepend ( 0 ) ;\n      prepend . push_back ( i ) ;\n      prepend . insert ( prepend . end ( ) , get_factors ( n / i ) , get_factors ( n / i ) + 1 ) ;\n      return prepend ;\n    }\n  }\n  return {\n  }\n  ;\n}\n",
        "vector < int > get_factors ( int n ) {\n  if ( n == 1 ) return {\n  }\n  ;\n  int max = ( int ) ( sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      vector < int > prepend ( 0 , i ) ;\n      prepend . insert ( prepend . end ( ) , get_factors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return {\n  }\n  ;\n}\n",
        "vector < int > get_factors ( int n ) {\n  if ( n == 1 ) return {\n  }\n  ;\n  int max = ( int ) ( sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      vector < int > prepend ( 0 ) ;\n      prepend . push_back ( i ) ;\n      prepend . insert ( prepend . end ( ) , get_factors ( n / i ) , get_factors ( n / i + 1 ) ) ;\n      return prepend ;\n    }\n  }\n  return {\n  }\n  ;\n}\n",
        "vector < int > get_factors ( int n ) {\n  if ( n == 1 ) return vector < int > ( ) ;\n  int max = int ( sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      vector < int > prepend ( 0 ) ;\n      prepend . push_back ( i ) ;\n      prepend . insert ( prepend . end ( ) , get_factors ( n / i ) , get_factors ( n / i ) + 1 ) ;\n      return prepend ;\n    }\n  }\n  return vector < int > ( ) ;\n}\n"
      ],
      "output": [
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static int [ ] get_factors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      prepend . addAll ( getFactors ( n / i ) + 1 ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      prepend . add ( getFactors ( n / i ) + 1 ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static int [ ] get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new int [ 0 ] ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) + 1 ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new int [ 0 ] ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static List < Integer > get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      List < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      prepend . addAll ( getFactors ( n / i ) + 1 ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static List < Integer > get_factors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      List < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static int [ ] get_factors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static List < Integer > get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      List < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static int [ ] get_factors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static List < Integer > get_factors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      List < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( ) ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) return new ArrayList < Integer > ( ) ;\n  int max = ( int ) ( Math . sqrt ( n ) + 1.0 ) ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return new ArrayList < Integer > ( 0 ) ;\n}\n",
        "public static int [ ] get_factors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) + 1 ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] get_factors ( int n ) {\n  if ( n == 1 ) {\n    return new int [ 0 ] ;\n  }\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) + 1 ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) return null ;\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return null ;\n}\n",
        "public static ArrayList < Integer > get_factors ( int n ) {\n  if ( n == 1 ) {\n    return null ;\n  }\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      ArrayList < Integer > prepend = new ArrayList < Integer > ( 0 ) ;\n      prepend . add ( i ) ;\n      prepend . addAll ( getFactors ( n / i ) ) ;\n      return prepend ;\n    }\n  }\n  return null ;\n}\n",
        "public static int [ ] get_factors ( int n ) {\n  if ( n == 1 ) return new int [ 0 ] ;\n  int max = ( int ) Math . sqrt ( n ) + 1.0 ;\n  for ( int i = 2 ;\n  i < max ;\n  i ++ ) {\n    if ( n % i == 0 ) {\n      int [ ] prepend = new int [ 0 ] ;\n      prepend [ 0 ] = i ;\n      prepend [ 1 ] = getFactors ( n / i ) ;\n      return prepend ;\n    }\n  }\n  return new int [ 0 ] ;\n}\n"
      ]
    },
    "HANOI": {
      "loc": "27-28",
      "input": "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(start, helper)); \n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}",
      "target": "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(start, end)); \n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}",
      "function range": "15,5-32,5",
      "raw_output": [
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet . add ( 49 ) ;\n    crapSet . add ( 50 ) ;\n  }\n  ",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet . add ( 49 ) ;\n    crapSet . add ( 50 ) ;\n  }\n  ",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet . add ( 49 ) ;\n    crapSet . add ( 50 ) ;\n    return",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 )",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 )",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . poll ( ) ;\n    crapSet . poll ( ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . poll ( ) ;\n    crapSet . poll ( ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . remove ( 1 ) ;\n    crapSet . remove ( 2 ) ;\n    crapSet . remove ( 3 ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n  }\n  return steps ;\n}\n",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n  }\n  return steps ;\n}\n",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = null ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 )",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 )",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = null ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    c @ @",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n  }\n  return steps ;\n}\n",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . poll ( ) ;\n    crapSet . poll ( ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet . add",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . poll ( ) ;\n    crapSet . poll ( ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n"
      ],
      "mid_translation": [
        "vector < pair < int , int >> hanoi ( int height , int start , int end ) {\n  vector < pair < int , int >> steps ;\n  if ( height > 0 ) {\n    priority_queue < int , vector < int > , greater < int >> crap_set ;\n    crap_set . push ( 1 ) ;\n    crap_set . push ( 2 ) ;\n    crap_set . push ( 3 ) ;\n    crap_set . pop ( ) ;\n    crap_set . pop ( ) ;\n    int helper = crap_set . top ( ) ;\n    steps . reserve ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . push_back ( make_pair ( start , helper ) ) ;\n    steps . reserve ( hanoi ( height - 1 , helper , end ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    ",
        "vector < pair < int , int >> hanoi ( int height , int start , int end ) {\n  vector < pair < int , int >> steps ;\n  if ( height > 0 ) {\n    priority_queue < int , vector < int >> crap_set ;\n    crap_set . push ( 1 ) ;\n    crap_set . push ( 2 ) ;\n    crap_set . push ( 3 ) ;\n    crap_set . pop ( ) ;\n    crap_set . pop ( ) ;\n    int helper = crap_set . top ( ) ;\n    steps . swap ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . push_back ( make_pair ( start , helper ) ) ;\n    steps . push_back ( make_pair ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "vector < pair < int , int >> hanoi ( int height , int start , int end ) {\n  vector < pair < int , int >> steps ;\n  if ( height > 0 ) {\n    priority_queue < int , vector < int >> crap_set ;\n    crap_set . push ( 1 ) ;\n    crap_set . push ( 2 ) ;\n    crap_set . push ( 3 ) ;\n    crap_set . pop ( ) ;\n    crap_set . pop ( ) ;\n    int helper = crap_set . top ( ) ;\n    steps . reserve ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . push_back ( make_pair ( start , helper ) ) ;\n    steps . reserve ( hanoi ( height - 1 , helper , end ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end , helper ) ) ;\n    steps . push_back ( make_pair ( end ,",
        "vector < pair < int , int >> hanoi ( int height , int start , int end ) {\n  vector < pair < int , int >> steps ;\n  if ( height > 0 ) {\n    priority_queue < int , vector < int >> crap_set ;\n    crap_set . push ( 1 ) ;\n    crap_set . push ( 2 ) ;\n    crap_set . push ( 3 ) ;\n    crap_set . pop ( ) ;\n    crap_set . pop ( ) ;\n    int helper = crap_set . top ( ) ;\n    steps . reserve ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . push_back ( make_pair ( start , helper ) ) ;\n    steps . push_back ( make_pair ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "vector < pair < int , int >> hanoi ( int height , int start , int end ) {\n  vector < pair < int , int >> steps ;\n  if ( height > 0 ) {\n    priority_queue < int , vector < int > , greater < int >> crap_set ;\n    crap_set . push ( 1 ) ;\n    crap_set . push ( 2 ) ;\n    crap_set . push ( 3 ) ;\n    crap_set . pop ( ) ;\n    crap_set . pop ( ) ;\n    int helper = crap_set . top ( ) ;\n    steps . swap ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . push_back ( make_pair ( start , helper ) ) ;\n    steps . push_back ( make_pair ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n"
      ],
      "output": [
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet . add ( 49 ) ;\n    crapSet . add ( 50 ) ;\n  }\n  ",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet . add ( 49 ) ;\n    crapSet . add ( 50 ) ;\n  }\n  ",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet . add ( 49 ) ;\n    crapSet . add ( 50 ) ;\n    return",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 )",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 )",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . poll ( ) ;\n    crapSet . poll ( ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . poll ( ) ;\n    crapSet . poll ( ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . remove ( 1 ) ;\n    crapSet . remove ( 2 ) ;\n    crapSet . remove ( 3 ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n  }\n  return steps ;\n}\n",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n  }\n  return steps ;\n}\n",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = null ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 )",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 )",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = null ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    c @ @",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n  }\n  return steps ;\n}\n",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . poll ( ) ;\n    crapSet . poll ( ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n",
        "public static List < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  List < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . add ( 4 ) ;\n    crapSet . add ( 5 ) ;\n    crapSet . add ( 6 ) ;\n    crapSet . add ( 7 ) ;\n    crapSet . add ( 8 ) ;\n    crapSet . add ( 9 ) ;\n    crapSet . add ( 10 ) ;\n    crapSet . add ( 11 ) ;\n    crapSet . add ( 12 ) ;\n    crapSet . add ( 13 ) ;\n    crapSet . add ( 14 ) ;\n    crapSet . add ( 15 ) ;\n    crapSet . add ( 16 ) ;\n    crapSet . add ( 17 ) ;\n    crapSet . add ( 18 ) ;\n    crapSet . add ( 19 ) ;\n    crapSet . add ( 20 ) ;\n    crapSet . add ( 21 ) ;\n    crapSet . add ( 22 ) ;\n    crapSet . add ( 23 ) ;\n    crapSet . add ( 24 ) ;\n    crapSet . add ( 25 ) ;\n    crapSet . add ( 26 ) ;\n    crapSet . add ( 27 ) ;\n    crapSet . add ( 28 ) ;\n    crapSet . add ( 29 ) ;\n    crapSet . add ( 30 ) ;\n    crapSet . add ( 31 ) ;\n    crapSet . add ( 32 ) ;\n    crapSet . add ( 33 ) ;\n    crapSet . add ( 34 ) ;\n    crapSet . add ( 35 ) ;\n    crapSet . add ( 36 ) ;\n    crapSet . add ( 37 ) ;\n    crapSet . add ( 38 ) ;\n    crapSet . add ( 39 ) ;\n    crapSet . add ( 40 ) ;\n    crapSet . add ( 41 ) ;\n    crapSet . add ( 42 ) ;\n    crapSet . add ( 43 ) ;\n    crapSet . add ( 44 ) ;\n    crapSet . add ( 45 ) ;\n    crapSet . add ( 46 ) ;\n    crapSet . add ( 47 ) ;\n    crapSet . add ( 48 ) ;\n    crapSet . add",
        "public static ArrayList < Pair < Integer , Integer >> hanoi ( int height , int start , int end ) {\n  ArrayList < Pair < Integer , Integer >> steps = new ArrayList < Pair < Integer , Integer >> ( ) ;\n  if ( height > 0 ) {\n    PriorityQueue < Integer > crapSet = new PriorityQueue < Integer > ( ) ;\n    crapSet . add ( 1 ) ;\n    crapSet . add ( 2 ) ;\n    crapSet . add ( 3 ) ;\n    crapSet . poll ( ) ;\n    crapSet . poll ( ) ;\n    int helper = crapSet . poll ( ) ;\n    steps . addAll ( hanoi ( height - 1 , start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( start , helper ) ) ;\n    steps . add ( new Pair < Integer , Integer > ( height - 1 , helper , end ) ) ;\n  }\n  return steps ;\n}\n"
      ]
    },
    "IS_VALID_PARENTHESIZATION": {
      "loc": "24-25",
      "input": "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\n    for (int i = 0; i < parens.length(); i++) {\n        Character paren = parens.charAt(i);\n        if (paren.equals('(')) {\n            depth++;\n        } else {\n            depth--;\n            if (depth < 0) { return false; }\n        }\n    }\n    return true; \n}",
      "target": "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\n    for (int i = 0; i < parens.length(); i++) {\n        Character paren = parens.charAt(i);\n        if (paren.equals('(')) {\n            depth++;\n        } else {\n            depth--;\n            if (depth < 0) { return false; }\n        }\n    } \n    return depth==0;\n}",
      "function range": "13,5-25,5",
      "raw_output": [
        "public static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) depth ++ ;\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return Boolean . FALSE ;\n      }\n    }\n  }\n  return Boolean . TRUE ;\n}\n",
        "public static Boolean isValidParenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "static Boolean isValidParenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return Boolean . FALSE ;\n      }\n    }\n  }\n  return Boolean . TRUE ;\n}\n",
        "public static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) depth ++ ;\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) depth ++ ;\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean isValidParenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "static Boolean isValidParenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n"
      ],
      "mid_translation": [
        "Boolean is_valid_parenthesization ( const char * parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < strlen ( parens ) ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return False ;\n      }\n    }\n  }\n  return True ;\n}\n",
        "Boolean is_valid_parenthesization ( char * parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < strlen ( parens ) ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return False ;\n      }\n    }\n  }\n  return True ;\n}\n",
        "Boolean is_valid_parenthesization ( const char * parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < strlen ( parens ) ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) return False ;\n    }\n  }\n  return True ;\n}\n",
        "Boolean is_valid_parenthesization ( char * parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < strlen ( parens ) ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) return False ;\n    }\n  }\n  return True ;\n}\n",
        "Boolean is_valid_parenthesization ( char * parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < strlen ( parens ) ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) depth ++ ;\n    else {\n      depth -- ;\n      if ( depth < 0 ) return False ;\n    }\n  }\n  return True ;\n}\n"
      ],
      "output": [
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) depth ++ ;\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return Boolean . FALSE ;\n      }\n    }\n  }\n  return Boolean . TRUE ;\n}\n",
        "public static Boolean is_valid_parenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return Boolean . FALSE ;\n      }\n    }\n  }\n  return Boolean . TRUE ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) depth ++ ;\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) depth ++ ;\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) return false ;\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( CharSequence parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( String parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ( ) ;\n  i ++ ) {\n    char paren = parens . charAt ( i ) ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n",
        "public static Boolean is_valid_parenthesization ( char [ ] parens ) {\n  int depth = 0 ;\n  for ( int i = 0 ;\n  i < parens . length ;\n  i ++ ) {\n    char paren = parens [ i ] ;\n    if ( paren == '(' ) {\n      depth ++ ;\n    }\n    else {\n      depth -- ;\n      if ( depth < 0 ) {\n        return false ;\n      }\n    }\n  }\n  return true ;\n}\n"
      ]
    },
    "KHEAPSORT": {
      "loc": "27-28",
      "input": "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    for (Integer x : arr) { \n        heap.add(x);\n        Integer popped = heap.poll();\n        output.add(popped);\n    }\n    while (!heap.isEmpty()) {\n        output.add(heap.poll());\n    }\n    return output;\n}",
      "target": "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>(); \n    for (Integer x : arr.subList(k, arr.size())) {\n        heap.add(x);\n        Integer popped = heap.poll();\n        output.add(popped);\n    }\n    while (!heap.isEmpty()) {\n        output.add(heap.poll());\n    }\n    return output;\n}",
      "function range": "20,5-39,5",
      "raw_output": [
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static ArrayList < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  ArrayList < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static List < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  List < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( k ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ 0 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ x ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static ArrayList < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  ArrayList < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static List < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  List < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static List < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  List < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ x ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n"
      ],
      "mid_translation": [
        "vector < int > kheapsort ( vector < int > arr , int k ) {\n  priority_queue < int , vector < int > , greater < int >> heap ;\n  for ( auto v : arr ) heap . push ( v ) ;\n  vector < int > output ;\n  for ( auto x : arr ) {\n    heap . push ( x ) ;\n    auto popped = heap . top ( ) ;\n    output . push_back ( popped ) ;\n  }\n  while ( ! heap . empty ( ) ) output . push_back ( heap . top ( ) ) ;\n  return output ;\n}\n",
        "vector < int > kheapsort ( vector < int > arr , int k ) {\n  priority_queue < int , vector < int > , greater < int >> heap ;\n  for ( auto v : arr ) heap . push ( v ) ;\n  vector < int > output ;\n  for ( auto x : arr ) {\n    heap . push ( x ) ;\n    auto popped = heap . pop ( ) ;\n    output . push_back ( popped ) ;\n  }\n  while ( ! heap . empty ( ) ) output . push_back ( heap . top ( ) ) ;\n  return output ;\n}\n",
        "vector < int > kheapsort ( vector < int > arr , int k ) {\n  priority_queue < int , vector < int > , greater < int >> heap ;\n  for ( int v : arr ) heap . push ( v ) ;\n  vector < int > output ;\n  for ( int x : arr ) {\n    heap . push ( x ) ;\n    int popped = heap . top ( ) ;\n    output . push_back ( popped ) ;\n  }\n  while ( ! heap . empty ( ) ) output . push_back ( heap . top ( ) ) ;\n  return output ;\n}\n",
        "vector < int > kheapsort ( vector < int > arr , int k ) {\n  priority_queue < int , vector < int >> heap ;\n  for ( auto v : arr ) heap . push ( v ) ;\n  vector < int > output ;\n  for ( auto x : arr ) {\n    heap . push ( x ) ;\n    auto popped = heap . top ( ) ;\n    output . push_back ( popped ) ;\n  }\n  while ( ! heap . empty ( ) ) output . push_back ( heap . top ( ) ) ;\n  return output ;\n}\n",
        "vector < int > kheapsort ( vector < int > arr , int k ) {\n  priority_queue < int , vector < int >> heap ;\n  for ( auto v : arr ) heap . push ( v ) ;\n  vector < int > output ;\n  for ( auto x : arr ) {\n    heap . push ( x ) ;\n    auto popped = heap . pop ( ) ;\n    output . push_back ( popped ) ;\n  }\n  while ( ! heap . empty ( ) ) output . push_back ( heap . top ( ) ) ;\n  return output ;\n}\n"
      ],
      "output": [
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static ArrayList < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  ArrayList < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static List < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  List < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( k ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ 0 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ x ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static ArrayList < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  ArrayList < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static List < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  List < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . peek ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static List < Integer > kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  List < Integer > output = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output . add ( popped ) ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output . add ( heap . poll ( ) ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    int popped = heap . poll ( ) ;\n    output [ heap . size ( ) - 1 ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n",
        "public static int [ ] kheapsort ( int [ ] arr , int k ) {\n  PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ) ;\n  for ( int v : arr ) {\n    heap . add ( v ) ;\n  }\n  int [ ] output = new int [ heap . size ( ) ] ;\n  for ( int x : arr ) {\n    heap . add ( x ) ;\n    Integer popped = heap . poll ( ) ;\n    output [ x ] = popped ;\n  }\n  while ( ! heap . isEmpty ( ) ) {\n    output [ heap . size ( ) - 1 ] = heap . poll ( ) ;\n  }\n  return output ;\n}\n"
      ]
    },
    "KNAPSACK": {
      "loc": "30-31",
      "input": "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            }\n            else if (weight < j) { \n                memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n            }\n            else {\n                memo[i][j] = memo [i-1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}",
      "target": "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } \n            else if (weight <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n            }\n            else {\n                memo[i][j] = memo [i-1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}",
      "function range": "14,5-40,5",
      "raw_output": [
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , List < List < Integer >> items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . size ( ) ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items . get ( i - 1 ) . get ( 0 ) ;\n      value = items . get ( i - 1 ) . get ( 1 ) ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int memo [ ] [ ] = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , List < List < Integer >> items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . size ( ) ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items . get ( i - 1 ) . get ( 0 ) ;\n      value = items . get ( i - 1 ) . get ( 1 ) ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n"
      ],
      "mid_translation": [
        "public : int knapsack ( int capacity , vector < vector < int >> & items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . size ( ) ;\n  vector < vector < int >> memo ( n + 1 , vector < int > ( capacity + 1 , 0 ) ) ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "int knapsack ( int capacity , vector < vector < int >> & items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . size ( ) ;\n  vector < vector < int >> memo ( n + 1 , vector < int > ( capacity + 1 , 0 ) ) ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "int knapsack ( int capacity , vector < vector < int >> & items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . size ( ) ;\n  int memo [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public : int knapsack ( int capacity , vector < vector < int >> & items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . size ( ) ;\n  int memo [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "int knapsack ( int capacity , vector < vector < int >> & items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . size ( ) ;\n  vector < vector < int >> memo ( n + 1 , vector < int > ( capacity + 1 ) ) ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n"
      ],
      "output": [
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , List < List < Integer >> items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . size ( ) ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items . get ( i - 1 ) . get ( 0 ) ;\n      value = items . get ( i - 1 ) . get ( 1 ) ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int memo [ ] [ ] = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , List < List < Integer >> items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . size ( ) ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items . get ( i - 1 ) . get ( 0 ) ;\n      value = items . get ( i - 1 ) . get ( 1 ) ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) {\n        memo [ i ] [ j ] = 0 ;\n      }\n      else if ( weight < j ) {\n        memo [ i ] [ j ] = max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      }\n      else {\n        memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n      }\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n",
        "public static int knapsack ( int capacity , int [ ] [ ] items ) {\n  int weight = 0 , value = 0 ;\n  int n = items . length ;\n  int [ ] [ ] memo = new int [ n + 1 ] [ capacity + 1 ] ;\n  for ( int i = 0 ;\n  i <= n ;\n  i ++ ) {\n    if ( i - 1 >= 0 ) {\n      weight = items [ i - 1 ] [ 0 ] ;\n      value = items [ i - 1 ] [ 1 ] ;\n    }\n    for ( int j = 0 ;\n    j <= capacity ;\n    j ++ ) {\n      if ( i == 0 || j == 0 ) memo [ i ] [ j ] = 0 ;\n      else if ( weight < j ) memo [ i ] [ j ] = Math . max ( memo [ i - 1 ] [ j ] , value + memo [ i - 1 ] [ j - weight ] ) ;\n      else memo [ i ] [ j ] = memo [ i - 1 ] [ j ] ;\n    }\n  }\n  return memo [ n ] [ capacity ] ;\n}\n"
      ]
    },
    "KTH": {
      "loc": "25-26",
      "input": "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k); \n    } else {\n        return pivot;\n    }\n}",
      "target": "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    } \n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k-num_lessoreq);\n    } else {\n        return pivot;\n    }\n}",
      "function range": "7,5-29,5",
      "raw_output": [
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numLess = below . length ;\n  int numLessoreq = arr . length - above . length ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numless = below . length ;\n  int numlessoreq = arr . length - above . length ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numLess = below . length ;\n  int numLessoreq = arr . length - above . length ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numless = below . length ;\n  int numlessoreq = arr . length - above . length ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numLess = below . length ;\n  int numLessoreq = arr . length - above . length ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numless = below . length ;\n  int numlessoreq = arr . length - above . length ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numLess = below . length ;\n  int numLessoreq = arr . length - above . length ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numless = below . length ;\n  int numlessoreq = arr . length - above . length ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < > ( arr . length ) ;\n  above = new ArrayList < > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n"
      ],
      "mid_translation": [
        "public : Integer kth ( vector < int > & arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  vector < int > below , above ;\n  below . reserve ( arr . size ( ) ) ;\n  above . reserve ( arr . size ( ) ) ;\n  for ( auto x : arr ) {\n    if ( x < pivot ) below . push_back ( x ) ;\n    else if ( x > pivot ) above . push_back ( x ) ;\n  }\n  int num_less = below . size ( ) ;\n  int num_lessoreq = arr . size ( ) - above . size ( ) ;\n  if ( k < num_less ) return kth ( below , k ) ;\n  else if ( k >= num_lessoreq ) return kth ( above , k ) ;\n  else return pivot ;\n}\n",
        "public : int kth ( vector < int > & arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  vector < int > below , above ;\n  below . reserve ( arr . size ( ) ) ;\n  above . reserve ( arr . size ( ) ) ;\n  for ( auto x : arr ) {\n    if ( x < pivot ) below . push_back ( x ) ;\n    else if ( x > pivot ) above . push_back ( x ) ;\n  }\n  int num_less = below . size ( ) ;\n  int num_lessoreq = arr . size ( ) - above . size ( ) ;\n  if ( k < num_less ) return kth ( below , k ) ;\n  else if ( k >= num_lessoreq ) return kth ( above , k ) ;\n  else return pivot ;\n}\n",
        "public : int32_t kth ( vector < int > & arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  vector < int > below , above ;\n  below . reserve ( arr . size ( ) ) ;\n  above . reserve ( arr . size ( ) ) ;\n  for ( auto x : arr ) {\n    if ( x < pivot ) below . push_back ( x ) ;\n    else if ( x > pivot ) above . push_back ( x ) ;\n  }\n  int num_less = below . size ( ) ;\n  int num_lessoreq = arr . size ( ) - above . size ( ) ;\n  if ( k < num_less ) return kth ( below , k ) ;\n  else if ( k >= num_lessoreq ) return kth ( above , k ) ;\n  else return pivot ;\n}\n",
        "public : int kth ( vector < int > & arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  vector < int > below , above ;\n  below . reserve ( arr . size ( ) ) ;\n  above . reserve ( arr . size ( ) ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) below . push_back ( x ) ;\n    else if ( x > pivot ) above . push_back ( x ) ;\n  }\n  int num_less = below . size ( ) ;\n  int num_lessoreq = arr . size ( ) - above . size ( ) ;\n  if ( k < num_less ) return kth ( below , k ) ;\n  else if ( k >= num_lessoreq ) return kth ( above , k ) ;\n  else return pivot ;\n}\n",
        "int32_t kth ( vector < int > & arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  vector < int > below , above ;\n  below . reserve ( arr . size ( ) ) ;\n  above . reserve ( arr . size ( ) ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) below . push_back ( x ) ;\n    else if ( x > pivot ) above . push_back ( x ) ;\n  }\n  int num_less = below . size ( ) ;\n  int num_lessoreq = arr . size ( ) - above . size ( ) ;\n  if ( k < num_less ) return kth ( below , k ) ;\n  else if ( k >= num_lessoreq ) return kth ( above , k ) ;\n  else return pivot ;\n}\n"
      ],
      "output": [
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numLess = below . length ;\n  int numLessoreq = arr . length - above . length ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numless = below . length ;\n  int numlessoreq = arr . length - above . length ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numLess = below . length ;\n  int numLessoreq = arr . length - above . length ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numless = below . length ;\n  int numlessoreq = arr . length - above . length ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numLess = below . length ;\n  int numLessoreq = arr . length - above . length ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numless = below . length ;\n  int numlessoreq = arr . length - above . length ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numLess = below . length ;\n  int numLessoreq = arr . length - above . length ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static int kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  int [ ] below , above ;\n  below = new int [ arr . length ] ;\n  above = new int [ arr . length ] ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below [ x ] = x ;\n    }\n    else if ( x > pivot ) {\n      above [ x ] = x ;\n    }\n  }\n  int numless = below . length ;\n  int numlessoreq = arr . length - above . length ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( arr . length ) ;\n  above = new ArrayList < Integer > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < Integer > ( ) ;\n  above = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numless = below . size ( ) ;\n  int numlessoreq = arr . length - above . size ( ) ;\n  if ( k < numless ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numlessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n",
        "public static Integer kth ( int [ ] arr , int k ) {\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > below , above ;\n  below = new ArrayList < > ( arr . length ) ;\n  above = new ArrayList < > ( arr . length ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      below . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      above . add ( x ) ;\n    }\n  }\n  int numLess = below . size ( ) ;\n  int numLessoreq = arr . length - above . size ( ) ;\n  if ( k < numLess ) {\n    return kth ( below , k ) ;\n  }\n  else if ( k >= numLessoreq ) {\n    return kth ( above , k ) ;\n  }\n  else {\n    return pivot ;\n  }\n}\n"
      ]
    },
    "LCS_LENGTH": {
      "loc": "35-37",
      "input": "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                if (dp.containsKey(i-1)) { \n                    Map<Integer, Integer> internal_map = dp.get(i); \n                    int insert_value = dp.get(i-1).get(j) + 1;\n                    internal_map.put(j, insert_value);\n                    dp.put(i,internal_map);\n                } else {\n                    Map<Integer, Integer> internal_map = dp.get(i);\n                    internal_map.put(j,1);\n                    dp.put(i,internal_map);\n                }\n            }\n        }\n    }\n    if (!dp.isEmpty()) {\n        List<Integer> ret_list = new ArrayList<Integer>();\n        for (int i=0; i<s.length(); i++) {\n            ret_list.add(!dp.get(i).isEmpty() ? Collections.max(dp.get(i).values()) : 0);\n        }\n        return Collections.max(ret_list);\n    } else {\n        return 0;\n    }\n}",
      "target": "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                if (dp.containsKey(i-1)&&dp.get(i-1).containsKey(j-1)) {\n                    Map<Integer, Integer> internal_map = dp.get(i);\n                    int insert_value = dp.get(i-1).get(j-1) + 1;\n                    internal_map.put(j, insert_value);\n                    dp.put(i,internal_map);\n                } else {\n                    Map<Integer, Integer> internal_map = dp.get(i);\n                    internal_map.put(j,1);\n                    dp.put(i,internal_map);\n                }\n            }\n        }\n    }\n    if (!dp.isEmpty()) {\n        List<Integer> ret_list = new ArrayList<Integer>();\n        for (int i=0; i<s.length(); i++) {\n            ret_list.add(!dp.get(i).isEmpty() ? Collections.max(dp.get(i).values()) : 0);\n        }\n        return Collections.max(ret_list);\n    } else {\n        return 0;\n    }\n}",
      "function range": "13,5-58,5",
      "raw_output": [
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    ArrayList < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return null ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = dp . get ( i ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    ArrayList < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return null ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = dp . get ( i ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . get ( i ) . isEmpty ( ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) . get ( j ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) . get ( j ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return null ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    ArrayList < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return null ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . get ( i ) . isEmpty ( ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) . get ( j ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcsLength ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) . get ( j ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n"
      ],
      "mid_translation": [
        "int32_t lcs_length ( string s , string t ) {\n  map < int , map < int , int >> dp ;\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    map < int , int > initialize ;\n    dp [ i ] = initialize ;\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      map < int , int > internal_map = dp [ i ] ;\n      internal_map [ j ] = 0 ;\n      dp [ i ] = internal_map ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      if ( s [ i ] == t [ j ] ) {\n        if ( dp . count ( i - 1 ) ) {\n          map < int , int > internal_map = dp [ i ] ;\n          int insert_value = dp [ i - 1 ] [ j ] + 1 ;\n          internal_map [ j ] = insert_value ;\n          dp [ i ] = internal_map ;\n        }\n        else {\n          map < int , int > internal_map = dp [ i ] ;\n          internal_map [ j ] = 1 ;\n          dp [ i ] = internal_map ;\n        }\n      }\n    }\n  }\n  if ( ! dp . empty ( ) ) {\n    vector < int > ret_vec ;\n    for ( int i = 0 ;\n    i < s . size ( ) ;\n    i ++ ) {\n      ret_vec . push_back ( ! dp [ i ] . empty ( ) ? std :: max ( dp [ i ] . begin ( ) , dp [ i ] . end ( ) ) : 0 ) ;\n    }\n    return std :: max ( ret_vec . begin ( ) , ret_vec . end ( ) ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "int32_t lcs_length ( string s , string t ) {\n  map < int , map < int , int >> dp ;\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    map < int , int > initialize ;\n    dp [ i ] = initialize ;\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      map < int , int > internal_map = dp [ i ] ;\n      internal_map [ j ] = 0 ;\n      dp [ i ] = internal_map ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      if ( s [ i ] == t [ j ] ) {\n        if ( dp . count ( i - 1 ) ) {\n          map < int , int > internal_map = dp [ i ] ;\n          int insert_value = dp [ i - 1 ] [ j ] + 1 ;\n          internal_map [ j ] = insert_value ;\n          dp [ i ] = internal_map ;\n        }\n        else {\n          map < int , int > internal_map = dp [ i ] ;\n          internal_map [ j ] = 1 ;\n          dp [ i ] = internal_map ;\n        }\n      }\n    }\n  }\n  if ( ! dp . empty ( ) ) {\n    vector < int > ret_vec ;\n    for ( int i = 0 ;\n    i < s . size ( ) ;\n    i ++ ) {\n      ret_vec . push_back ( ! dp [ i ] . empty ( ) ? std :: max ( dp [ i ] . begin ( ) , dp [ i ] . end ( ) ) : 0 ) ;\n    }\n    return std :: max ( ret_vec . begin ( ) , ret_vec . end ( ) ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "int32_t lcs_length ( string s , string t ) {\n  map < int , map < int , int >> dp ;\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    map < int , int > initialize ;\n    dp [ i ] [ i ] = initialize ;\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      map < int , int > internal_map = dp [ i ] [ j ] ;\n      internal_map [ j ] = 0 ;\n      dp [ i ] [ j ] = internal_map ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      if ( s [ i ] == t [ j ] ) {\n        if ( dp . count ( i - 1 ) ) {\n          map < int , int > internal_map = dp [ i ] [ j ] ;\n          int insert_value = dp [ i - 1 ] [ j ] + 1 ;\n          internal_map [ j ] = insert_value ;\n          dp [ i ] [ j ] = internal_map ;\n        }\n        else {\n          map < int , int > internal_map = dp [ i ] [ j ] ;\n          internal_map [ j ] = 1 ;\n          dp [ i ] [ j ] = internal_map ;\n        }\n      }\n    }\n  }\n  if ( ! dp . empty ( ) ) {\n    vector < int > ret_vec ;\n    for ( int i = 0 ;\n    i < s . size ( ) ;\n    i ++ ) {\n      ret_vec . push_back ( ! dp [ i ] . empty ( ) ? std :: max ( dp [ i ] . begin ( ) , dp [ i ] . end ( ) ) : 0 ) ;\n    }\n    return std :: max ( ret_vec . begin ( ) , ret_vec . end ( ) ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "int32_t lcs_length ( string s , string t ) {\n  map < int , map < int , int >> dp ;\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    map < int , int > initialize ;\n    dp [ i ] = initialize ;\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      map < int , int > internal_map = dp [ i ] ;\n      internal_map [ j ] = 0 ;\n      dp [ i ] = internal_map ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      if ( s [ i ] == t [ j ] ) {\n        if ( dp . count ( i - 1 ) ) {\n          map < int , int > internal_map = dp [ i ] ;\n          int insert_value = dp [ i - 1 ] [ j ] + 1 ;\n          internal_map [ j ] = insert_value ;\n          dp [ i ] = internal_map ;\n        }\n        else {\n          map < int , int > internal_map = dp [ i ] ;\n          internal_map [ j ] = 1 ;\n          dp [ i ] = internal_map ;\n        }\n      }\n    }\n  }\n  if ( ! dp . empty ( ) ) {\n    vector < int > ret_vec ;\n    for ( int i = 0 ;\n    i < s . size ( ) ;\n    i ++ ) ret_vec . push_back ( ! dp [ i ] . empty ( ) ? std :: max ( dp [ i ] . begin ( ) , dp [ i ] . end ( ) ) : 0 ) ;\n    return std :: max ( ret_vec . begin ( ) , ret_vec . end ( ) ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "int32_t lcs_length ( string s , string t ) {\n  map < int , map < int , int >> dp ;\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    map < int , int > initialize ;\n    dp [ i ] [ i ] = initialize ;\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      map < int , int > internal_map = dp [ i ] [ j ] ;\n      internal_map [ j ] = 0 ;\n      dp [ i ] [ j ] = internal_map ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . size ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . size ( ) ;\n    j ++ ) {\n      if ( s [ i ] == t [ j ] ) {\n        if ( dp . count ( i - 1 ) ) {\n          map < int , int > internal_map = dp [ i ] [ j ] ;\n          int insert_value = dp [ i - 1 ] [ j ] + 1 ;\n          internal_map [ j ] = insert_value ;\n          dp [ i ] [ j ] = internal_map ;\n        }\n        else {\n          map < int , int > internal_map = dp [ i ] [ j ] ;\n          internal_map [ j ] = 1 ;\n          dp [ i ] [ j ] = internal_map ;\n        }\n      }\n    }\n  }\n  if ( ! dp . empty ( ) ) {\n    vector < int > ret_vec ;\n    for ( int i = 0 ;\n    i < s . size ( ) ;\n    i ++ ) {\n      ret_vec . push_back ( ! dp [ i ] . empty ( ) ? std :: max ( dp [ i ] . begin ( ) , dp [ i ] . end ( ) ) : 0 ) ;\n    }\n    return std :: max ( ret_vec . begin ( ) , ret_vec . end ( ) ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n"
      ],
      "output": [
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    ArrayList < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return null ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = dp . get ( i ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    ArrayList < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return null ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = dp . get ( i ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . get ( i ) . isEmpty ( ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) . get ( j ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) . get ( j ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return null ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    ArrayList < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return null ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . get ( i ) . isEmpty ( ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          Integer insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) . get ( j ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n",
        "public static Integer lcs_length ( String s , String t ) {\n  Map < Integer , Map < Integer , Integer >> dp = new HashMap < Integer , Map < Integer , Integer >> ( ) ;\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    Map < Integer , Integer > initialize = new HashMap < Integer , Integer > ( ) ;\n    dp . put ( i , initialize ) ;\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      Map < Integer , Integer > internalMap = dp . get ( i ) ;\n      internalMap . put ( j , 0 ) ;\n      dp . put ( i , internalMap ) ;\n    }\n  }\n  for ( int i = 0 ;\n  i < s . length ( ) ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < t . length ( ) ;\n    j ++ ) {\n      if ( s . charAt ( i ) == t . charAt ( j ) ) {\n        if ( dp . containsKey ( i - 1 ) ) {\n          Map < Integer , Integer > internalMap = dp . get ( i ) ;\n          int insertValue = dp . get ( i - 1 ) . get ( j ) + 1 ;\n          internalMap . put ( j , insertValue ) ;\n          dp . put ( i , internalMap ) ;\n        }\n        else {\n          Map < Integer , Integer > internalMap = dp . get ( i ) . get ( j ) ;\n          internalMap . put ( j , 1 ) ;\n          dp . put ( i , internalMap ) ;\n        }\n      }\n    }\n  }\n  if ( ! dp . isEmpty ( ) ) {\n    List < Integer > retList = new ArrayList < Integer > ( ) ;\n    for ( int i = 0 ;\n    i < s . length ( ) ;\n    i ++ ) {\n      retList . add ( ! dp . containsKey ( i ) ? Collections . max ( dp . get ( i ) ) : 0 ) ;\n    }\n    return Collections . max ( retList ) ;\n  }\n  else {\n    return 0 ;\n  }\n}\n"
      ]
    },
    "LEVENSHTEIN": {
      "loc": "17-18",
      "input": "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty() ? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return 1 + levenshtein(source.substring(1), target.substring(1)); \n    } else {\n        return 1 + Math.min(Math.min(\n                levenshtein(source,              target.substring(1)),\n                levenshtein(source.substring(1), target.substring(1))),\n                levenshtein(source.substring(1), target)\n    );\n    }\n}",
      "target": "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty() ? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return levenshtein(source.substring(1), target.substring(1)); \n    } else {\n        return 1 + Math.min(Math.min(\n                levenshtein(source,              target.substring(1)),\n                levenshtein(source.substring(1), target.substring(1))),\n                levenshtein(source.substring(1), target)\n    );\n    }\n}",
      "function range": "13,5-25,5",
      "raw_output": [
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . isEmpty ( ) ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) return source == null ? target . length ( ) : source . length ( ) ;\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  else return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) return source == null ? target . length ( ) : source . length ( ) ;\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  else return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target == null ? source . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . isEmpty ( ) ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) return source == null ? target . length ( ) : source . length ( ) ;\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  else return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n"
      ],
      "mid_translation": [
        "int levenshtein ( string source , string target ) {\n  if ( source . empty ( ) || target . empty ( ) ) {\n    return source . empty ( ) ? target . size ( ) : source . size ( ) ;\n  }\n  else if ( source [ 0 ] == target [ 0 ] ) {\n    return 1 + levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substr ( 1 ) ) , levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ) , levenshtein ( source . substr ( 1 ) , target ) ) ;\n  }\n}\n",
        "int levenshtein ( string source , string target ) {\n  if ( source . empty ( ) || target . empty ( ) ) return source . empty ( ) ? target . size ( ) : source . size ( ) ;\n  else if ( source [ 0 ] == target [ 0 ] ) return 1 + levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ;\n  else return 1 + min ( min ( levenshtein ( source , target . substr ( 1 ) ) , levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ) , levenshtein ( source . substr ( 1 ) , target ) ) ;\n}\n",
        "int levenshtein ( const string & source , const string & target ) {\n  if ( source . empty ( ) || target . empty ( ) ) return source . empty ( ) ? target . size ( ) : source . size ( ) ;\n  else if ( source [ 0 ] == target [ 0 ] ) return 1 + levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ;\n  else return 1 + min ( min ( levenshtein ( source , target . substr ( 1 ) ) , levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ) , levenshtein ( source . substr ( 1 ) , target ) ) ;\n}\n",
        "int levenshtein ( string source , string target ) {\n  if ( source . empty ( ) || target . empty ( ) ) {\n    return source . empty ( ) ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source [ 0 ] == target [ 0 ] ) {\n    return 1 + levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substr ( 1 ) ) , levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ) , levenshtein ( source . substr ( 1 ) , target ) ) ;\n  }\n}\n",
        "int levenshtein ( string source , string target ) {\n  if ( source . empty ( ) || target . empty ( ) ) return source . empty ( ) ? target . length ( ) : source . length ( ) ;\n  else if ( source [ 0 ] == target [ 0 ] ) return 1 + levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ;\n  else return 1 + min ( min ( levenshtein ( source , target . substr ( 1 ) ) , levenshtein ( source . substr ( 1 ) , target . substr ( 1 ) ) ) , levenshtein ( source . substr ( 1 ) , target ) ) ;\n}\n"
      ],
      "output": [
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . isEmpty ( ) ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) return source == null ? target . length ( ) : source . length ( ) ;\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  else return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) return source == null ? target . length ( ) : source . length ( ) ;\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  else return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target == null ? source . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . isEmpty ( ) ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) return source == null ? target . length ( ) : source . length ( ) ;\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  else return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + min ( min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source . length ( ) == 0 ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . charAt ( 0 ) == target . charAt ( 0 ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n",
        "public static int levenshtein ( String source , String target ) {\n  if ( source == null || target == null ) {\n    return source == null ? target . length ( ) : source . length ( ) ;\n  }\n  else if ( source . startsWith ( target ) ) {\n    return 1 + levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ;\n  }\n  else {\n    return 1 + Math . min ( Math . min ( levenshtein ( source , target . substring ( 1 ) ) , levenshtein ( source . substring ( 1 ) , target . substring ( 1 ) ) ) , levenshtein ( source . substring ( 1 ) , target ) ) ;\n  }\n}\n"
      ]
    },
    "LIS": {
      "loc": "31-32",
      "input": "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length + 1; \n        }\n        i++;\n    }\n    return longest;\n}",
      "target": "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = Math.max(longest,length + 1); \n        }\n        i++;\n    }\n    return longest;\n}",
      "function range": "13,5-37,5",
      "raw_output": [
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    int [ ] prefixLengths = new int [ 100 ] ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths [ j ] = j ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . length , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 , 0 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    int [ ] prefixLengths = new int [ 100 ] ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths [ j ] = j ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . length , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    int [ ] prefixLengths = new int [ 100 ] ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths [ j ] = j ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . length , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . toArray ( new Integer [ prefixLengths . size ( ) ] ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n"
      ],
      "mid_translation": [
        "public : int lis ( vector < int > arr ) {\n  map < int , int > ends ( 100 , 0 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    vector < int > prefix_lengths ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends [ j ] ] < val ) prefix_lengths [ j ] = j ;\n    }\n    int length = ! prefix_lengths . empty ( ) ? std :: max ( prefix_lengths . begin ( ) , prefix_lengths . end ( ) ) : 0 ;\n    if ( length == longest || val < arr [ ends [ length + 1 ] ] ) {\n      ends [ length + 1 ] = i ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public : int lis ( vector < int > arr ) {\n  map < int , int > ends ( 100 , 0 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    vector < int > prefix_lengths ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends [ j ] ] < val ) prefix_lengths . push_back ( j ) ;\n    }\n    int length = ! prefix_lengths . empty ( ) ? std :: max ( prefix_lengths . begin ( ) , prefix_lengths . end ( ) ) : 0 ;\n    if ( length == longest || val < arr [ ends [ length + 1 ] ] ) {\n      ends [ length + 1 ] = i ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public : int lis ( vector < int > arr ) {\n  map < int , int > ends ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    vector < int > prefix_lengths ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends [ j ] ] < val ) prefix_lengths [ j ] = j ;\n    }\n    int length = ! prefix_lengths . empty ( ) ? std :: max ( prefix_lengths . begin ( ) , prefix_lengths . end ( ) ) : 0 ;\n    if ( length == longest || val < arr [ ends [ length + 1 ] ] ) {\n      ends [ length + 1 ] = i ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public : int lis ( vector < int > arr ) {\n  map < int , int > ends ( 100 , 0 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    vector < int > prefix_lengths ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends [ j ] ] < val ) prefix_lengths [ j ] = j ;\n    }\n    int length = ! prefix_lengths . empty ( ) ? max ( prefix_lengths . begin ( ) , prefix_lengths . end ( ) ) : 0 ;\n    if ( length == longest || val < arr [ ends [ length + 1 ] ] ) {\n      ends [ length + 1 ] = i ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public : int lis ( vector < int > arr ) {\n  map < int , int > ends ( 100 , 0 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    vector < int > prefix_lengths ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends [ j ] ] < val ) prefix_lengths . push_back ( j ) ;\n    }\n    int length = ! prefix_lengths . empty ( ) ? max ( prefix_lengths . begin ( ) , prefix_lengths . end ( ) ) : 0 ;\n    if ( length == longest || val < arr [ ends [ length + 1 ] ] ) {\n      ends [ length + 1 ] = i ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n"
      ],
      "output": [
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    int [ ] prefixLengths = new int [ 100 ] ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths [ j ] = j ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . length , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 , 0 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Collections . max ( prefixLengths ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    int [ ] prefixLengths = new int [ 100 ] ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths [ j ] = j ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . length , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    int [ ] prefixLengths = new int [ 100 ] ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths [ j ] = j ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . length , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . size ( ) , longest ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . get ( 0 ) , prefixLengths . get ( 1 ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n",
        "public static int lis ( int [ ] arr ) {\n  Map < Integer , Integer > ends = new HashMap < Integer , Integer > ( 100 ) ;\n  int longest = 0 ;\n  int i = 0 ;\n  for ( int val : arr ) {\n    List < Integer > prefixLengths = new ArrayList < Integer > ( 100 ) ;\n    for ( int j = 1 ;\n    j < longest + 1 ;\n    j ++ ) {\n      if ( arr [ ends . get ( j ) ] < val ) {\n        prefixLengths . add ( j ) ;\n      }\n    }\n    int length = ! prefixLengths . isEmpty ( ) ? Math . max ( prefixLengths . toArray ( new Integer [ prefixLengths . size ( ) ] ) ) : 0 ;\n    if ( length == longest || val < arr [ ends . get ( length + 1 ) ] ) {\n      ends . put ( length + 1 , i ) ;\n      longest = length + 1 ;\n    }\n    i ++ ;\n  }\n  return longest ;\n}\n"
      ]
    },
    "LONGEST_COMMON_SUBSEQUENCE": {
      "loc": "18-19",
      "input": "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a.charAt(0) + longest_common_subsequence(a.substring(1), b); \n    } else {\n        String fst = longest_common_subsequence(a, b.substring(1));\n        String snd = longest_common_subsequence(a.substring(1), b);\n        return fst.length() >= snd.length() ? fst : snd;\n    }\n}",
      "target": "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1)); \n    } else {\n        String fst = longest_common_subsequence(a, b.substring(1));\n        String snd = longest_common_subsequence(a.substring(1), b);\n        return fst.length() >= snd.length() ? fst : snd;\n    }\n}",
      "function range": "14,5-25,5",
      "raw_output": [
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . startsWith ( b ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , a . length ( ) ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , a . length ( ) ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , a . length ( ) ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longestCommonSubsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == 0 ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n"
      ],
      "mid_translation": [
        "string longestCommonSubsequence ( string a , string b ) {\n  if ( a . empty ( ) || b . empty ( ) ) {\n    return \"\" ;\n  }\n  else if ( a [ 0 ] == b [ 0 ] ) {\n    return a [ 0 ] + longestCommonSubsequence ( a . substr ( 1 ) , b ) ;\n  }\n  else {\n    string fst = longestCommonSubsequence ( a , b . substr ( 1 ) ) ;\n    string snd = longestCommonSubsequence ( a . substr ( 1 ) , b ) ;\n    return fst . size ( ) >= snd . size ( ) ? fst : snd ;\n  }\n}\n",
        "string longest_common_subsequence ( string a , string b ) {\n  if ( a . empty ( ) || b . empty ( ) ) {\n    return \"\" ;\n  }\n  else if ( a [ 0 ] == b [ 0 ] ) {\n    return a [ 0 ] + longest_common_subsequence ( a . substr ( 1 ) , b ) ;\n  }\n  else {\n    string fst = longest_common_subsequence ( a , b . substr ( 1 ) ) ;\n    string snd = longest_common_subsequence ( a . substr ( 1 ) , b ) ;\n    return fst . size ( ) >= snd . size ( ) ? fst : snd ;\n  }\n}\n",
        "string longestCommonSubsequence ( string a , string b ) {\n  if ( a . empty ( ) || b . empty ( ) ) {\n    return \"\" ;\n  }\n  else if ( a [ 0 ] == b [ 0 ] ) {\n    return a [ 0 ] + longestCommonSubsequence ( a . substr ( 1 ) , b ) ;\n  }\n  else {\n    string fst = longestCommonSubsequence ( a , b . substr ( 1 ) ) ;\n    string snd = longestCommonSubsequence ( a . substr ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "string longest_common_subsequence ( string a , string b ) {\n  if ( a . empty ( ) || b . empty ( ) ) {\n    return \"\" ;\n  }\n  else if ( a [ 0 ] == b [ 0 ] ) {\n    return a [ 0 ] + longest_common_subsequence ( a . substr ( 1 ) , b ) ;\n  }\n  else {\n    string fst = longest_common_subsequence ( a , b . substr ( 1 ) ) ;\n    string snd = longest_common_subsequence ( a . substr ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public : string longestCommonSubsequence ( string a , string b ) {\n  if ( a . empty ( ) || b . empty ( ) ) {\n    return \"\" ;\n  }\n  else if ( a [ 0 ] == b [ 0 ] ) {\n    return a [ 0 ] + longestCommonSubsequence ( a . substr ( 1 ) , b ) ;\n  }\n  else {\n    string fst = longestCommonSubsequence ( a , b . substr ( 1 ) ) ;\n    string snd = longestCommonSubsequence ( a . substr ( 1 ) , b ) ;\n    return fst . size ( ) >= snd . size ( ) ? fst : snd ;\n  }\n}\n"
      ],
      "output": [
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . startsWith ( b ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , a . length ( ) ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , a . length ( ) ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , a . length ( ) ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) {\n    return a . charAt ( 0 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == b . length ( ) ) {\n    return a + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n",
        "public static String longest_common_subsequence ( String a , String b ) {\n  if ( a == null || b == null ) {\n    return \"\" ;\n  }\n  else if ( a . length ( ) == 0 ) {\n    return a . substring ( 0 , 1 ) + longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n  }\n  else {\n    String fst = longestCommonSubsequence ( a , b . substring ( 1 ) ) ;\n    String snd = longestCommonSubsequence ( a . substring ( 1 ) , b ) ;\n    return fst . length ( ) >= snd . length ( ) ? fst : snd ;\n  }\n}\n"
      ]
    },
    "MAX_SUBLIST_SUM": {
      "loc": "19-20",
      "input": "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n        max_ending_here = max_ending_here + x; \n        max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n}",
      "target": "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n        max_ending_here = Math.max(0,max_ending_here + x); \n        max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n}",
      "function range": "14,5-24,5",
      "raw_output": [
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int maxsublistSum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n"
      ],
      "mid_translation": [
        "public : int max_sublist_sum ( vector < int > arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( auto x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "int max_sublist_sum ( vector < int > arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( auto x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "int max_sublist_sum ( vector < int > arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public : int max_sublist_sum ( vector < int > arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public : int maxsublist_sum ( vector < int > arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( auto x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n"
      ],
      "output": [
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxendingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    maxending_here = maxending_here + x ;\n    max_so_far = Math . max ( max_so_far , maxending_here ) ;\n  }\n  return max_so_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxendingHere = 0 ;\n  int maxSo_far = 0 ;\n  for ( int x : arr ) {\n    maxendingHere = maxendingHere + x ;\n    maxSo_far = Math . max ( maxSo_far , maxendingHere ) ;\n  }\n  return maxSo_far ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int maxEndingHere = 0 ;\n  int maxSoFar = 0 ;\n  for ( int x : arr ) {\n    maxEndingHere = maxEndingHere + x ;\n    maxSoFar = Math . max ( maxSoFar , maxEndingHere ) ;\n  }\n  return maxSoFar ;\n}\n",
        "public static int max_sublist_sum ( int [ ] arr ) {\n  int max_ending_here = 0 ;\n  int max_so_far = 0 ;\n  for ( int x : arr ) {\n    max_ending_here = max_ending_here + x ;\n    max_so_far = Math . max ( max_so_far , max_ending_here ) ;\n  }\n  return max_so_far ;\n}\n"
      ]
    },
    "MERGESORT": {
      "loc": "38-39",
      "input": "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n    if (arr.size() == 0) {  \n        return arr;\n    } else {\n        int middle = arr.size() / 2;\n        ArrayList<Integer> left = new ArrayList<Integer>(100);\n        left.addAll(arr.subList(0,middle));\n        left = mergesort(left);\n        ArrayList<Integer> right = new ArrayList<Integer>(100);\n        right.addAll(arr.subList(middle, arr.size()));\n        right = mergesort(right);\n        return merge(left, right);\n    }\n}",
      "target": "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n    if (arr.size() <= 1) { \n        return arr;\n    } else {\n        int middle = arr.size() / 2;\n        ArrayList<Integer> left = new ArrayList<Integer>(100);\n        left.addAll(arr.subList(0,middle));\n        left = mergesort(left);\n        ArrayList<Integer> right = new ArrayList<Integer>(100);\n        right.addAll(arr.subList(middle, arr.size()));\n        right = mergesort(right);\n        return merge(left, right);\n    }\n}",
      "function range": "37,5-51,5",
      "raw_output": [
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    Arrays . fill ( left , arr [ middle ] ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    Arrays . fill ( right , arr [ middle ] ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    left [ 0 ] = arr [ middle ] ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    right [ 0 ] = arr [ middle ] ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    left [ middle ] = arr [ middle ] ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    right [ middle ] = arr [ middle ] ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    ArrayList < Integer > left = new ArrayList < Integer > ( 100 ) ;\n    left . addAll ( arr ) ;\n    left = mergesort ( left ) ;\n    ArrayList < Integer > right = new ArrayList < Integer > ( 100 ) ;\n    right . addAll ( arr ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static List < Integer > mergesort ( List < Integer > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    List < Integer > left = new ArrayList < Integer > ( 100 ) ;\n    left . addAll ( arr ) ;\n    left = mergesort ( left ) ;\n    List < Integer > right = new ArrayList < Integer > ( 100 ) ;\n    right . addAll ( arr ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static List < Integer > mergesort ( List < Integer > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    List < Integer > left = new ArrayList < > ( 100 ) ;\n    left . addAll ( arr ) ;\n    left = mergesort ( left ) ;\n    List < Integer > right = new ArrayList < > ( 100 ) ;\n    right . addAll ( arr ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    Arrays . fill ( left , arr [ middle ] ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    Arrays . fill ( right , arr [ middle ] ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static List < Integer > mergesort ( List < Integer > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    List < Integer > left = new ArrayList < Integer > ( 100 ) ;\n    left . addAll ( arr ) ;\n    left = mergesort ( left ) ;\n    List < Integer > right = new ArrayList < Integer > ( 100 ) ;\n    right . addAll ( arr ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) return arr ;\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    Arrays . fill ( left , arr [ middle ] ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    Arrays . fill ( right , arr [ middle ] ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) return arr ;\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    Arrays . fill ( left , arr [ middle ] ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    Arrays . fill ( right , arr [ middle ] ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    left [ 0 ] = arr [ middle ] ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    right [ 0 ] = arr [ middle ] ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    left [ middle ] = arr [ middle ] ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    right [ middle ] = arr [ middle ] ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n"
      ],
      "mid_translation": [
        "vector < int > mergesort ( vector < int > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    vector < int > left ( 100 ) ;\n    left . insert ( left . end ( ) , arr . begin ( ) + middle , arr . end ( ) ) ;\n    left = mergesort ( left ) ;\n    vector < int > right ( 100 ) ;\n    right . insert ( right . end ( ) , arr . begin ( ) + middle , arr . end ( ) ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "vector < int > mergesort ( vector < int > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    vector < int > left ( 100 ) ;\n    left . insert ( left . end ( ) , arr . begin ( ) , arr . end ( ) ) ;\n    left = mergesort ( left ) ;\n    vector < int > right ( 100 ) ;\n    right . insert ( right . end ( ) , arr . begin ( ) , arr . end ( ) ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "vector < int > mergesort ( vector < int > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    vector < int > left ( 100 ) ;\n    left . insert ( left . end ( ) , arr . begin ( ) + middle , arr . begin ( ) + middle + 1 ) ;\n    left = mergesort ( left ) ;\n    vector < int > right ( 100 ) ;\n    right . insert ( right . end ( ) , arr . begin ( ) + middle , arr . begin ( ) + middle + 1 ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "vector < int > mergesort ( vector < int > arr ) {\n  if ( arr . size ( ) == 0 ) return arr ;\n  else {\n    int middle = arr . size ( ) / 2 ;\n    vector < int > left ( 100 ) ;\n    left . insert ( left . end ( ) , arr . begin ( ) + middle , arr . end ( ) ) ;\n    left = mergesort ( left ) ;\n    vector < int > right ( 100 ) ;\n    right . insert ( right . end ( ) , arr . begin ( ) + middle , arr . end ( ) ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "vector < int > mergesort ( vector < int > & arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    vector < int > left ( 100 ) ;\n    left . insert ( left . end ( ) , arr . begin ( ) + middle , arr . end ( ) ) ;\n    left = mergesort ( left ) ;\n    vector < int > right ( 100 ) ;\n    right . insert ( right . end ( ) , arr . begin ( ) + middle , arr . end ( ) ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n"
      ],
      "output": [
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    Arrays . fill ( left , arr [ middle ] ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    Arrays . fill ( right , arr [ middle ] ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    left [ 0 ] = arr [ middle ] ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    right [ 0 ] = arr [ middle ] ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    left [ middle ] = arr [ middle ] ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    right [ middle ] = arr [ middle ] ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    ArrayList < Integer > left = new ArrayList < Integer > ( 100 ) ;\n    left . addAll ( arr ) ;\n    left = mergesort ( left ) ;\n    ArrayList < Integer > right = new ArrayList < Integer > ( 100 ) ;\n    right . addAll ( arr ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static List < Integer > mergesort ( List < Integer > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    List < Integer > left = new ArrayList < Integer > ( 100 ) ;\n    left . addAll ( arr ) ;\n    left = mergesort ( left ) ;\n    List < Integer > right = new ArrayList < Integer > ( 100 ) ;\n    right . addAll ( arr ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static List < Integer > mergesort ( List < Integer > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    List < Integer > left = new ArrayList < > ( 100 ) ;\n    left . addAll ( arr ) ;\n    left = mergesort ( left ) ;\n    List < Integer > right = new ArrayList < > ( 100 ) ;\n    right . addAll ( arr ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    Arrays . fill ( left , arr [ middle ] ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    Arrays . fill ( right , arr [ middle ] ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static List < Integer > mergesort ( List < Integer > arr ) {\n  if ( arr . size ( ) == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . size ( ) / 2 ;\n    List < Integer > left = new ArrayList < Integer > ( 100 ) ;\n    left . addAll ( arr ) ;\n    left = mergesort ( left ) ;\n    List < Integer > right = new ArrayList < Integer > ( 100 ) ;\n    right . addAll ( arr ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) return arr ;\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    Arrays . fill ( left , arr [ middle ] ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    Arrays . fill ( right , arr [ middle ] ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) return arr ;\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , middle , right , 0 , arr . length ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , left , 0 , middle ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    System . arraycopy ( arr , 0 , right , 0 , middle ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    Arrays . fill ( left , arr [ middle ] ) ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    Arrays . fill ( right , arr [ middle ] ) ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    left [ 0 ] = arr [ middle ] ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    right [ 0 ] = arr [ middle ] ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n",
        "public static int [ ] mergesort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return arr ;\n  }\n  else {\n    int middle = arr . length / 2 ;\n    int [ ] left = new int [ 100 ] ;\n    left [ middle ] = arr [ middle ] ;\n    left = mergesort ( left ) ;\n    int [ ] right = new int [ 100 ] ;\n    right [ middle ] = arr [ middle ] ;\n    right = mergesort ( right ) ;\n    return merge ( left , right ) ;\n  }\n}\n"
      ]
    },
    "MINIMUM_SPANNING_TREE": {
      "loc": "28-29",
      "input": "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                groupByNode = update(groupByNode, node, vertex_u); \n            }\n        }\n    }\n    return minSpanningTree;\n}",
      "target": "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge); \n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                groupByNode.put(node,  groupByNode.get(vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n}",
      "function range": "7,5-33,5",
      "raw_output": [
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( ArrayList < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( ArrayList < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( ArrayList < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) . size ( ) != groupByNode . get ( vertexV ) . size ( ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimumSpanningTree ( ArrayList < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n"
      ],
      "mid_translation": [
        "set < WeightedEdge * > minimum_spanning_tree ( vector < WeightedEdge * > & weighted_edges ) {\n  map < Node * , set < Node * >> group_by_node ;\n  set < WeightedEdge * > min_spanning_tree ;\n  sort ( weighted_edges . begin ( ) , weighted_edges . end ( ) ) ;\n  for ( auto & edge : weighted_edges ) {\n    Node * vertex_u = edge . node1 ;\n    Node * vertex_v = edge . node2 ;\n    if ( ! group_by_node . count ( vertex_u ) ) group_by_node [ vertex_u ] . insert ( std :: make_pair ( vertex_u , std :: move ( vertex_u ) ) ) ;\n    if ( ! group_by_node . count ( vertex_v ) ) group_by_node [ vertex_v ] . insert ( std :: make_pair ( vertex_v , std :: move ( vertex_v ) ) ) ;\n    if ( group_by_node [ vertex_u ] != group_by_node [ vertex_v ] ) {\n      min_spanning_tree . insert ( edge ) ;\n      group_by_node = update ( group_by_node , vertex_u , vertex_v ) ;\n      for ( auto & node : group_by_node [ vertex_v ] ) group_by_node = update ( group_by_node , node , vertex_u ) ;\n    }\n  }\n  return min_spanning_tree ;\n}\n",
        "set < WeightedEdge * > minimum_spanning_tree ( vector < WeightedEdge * > & weighted_edges ) {\n  map < Node * , set < Node * >> group_by_node ;\n  set < WeightedEdge * > min_spanning_tree ;\n  sort ( weighted_edges . begin ( ) , weighted_edges . end ( ) ) ;\n  for ( auto edge : weighted_edges ) {\n    Node * vertex_u = edge -> node1 ;\n    Node * vertex_v = edge -> node2 ;\n    if ( ! group_by_node . count ( vertex_u ) ) group_by_node [ vertex_u ] . insert ( std :: make_pair ( vertex_u , std :: move ( vertex_u ) ) ) ;\n    if ( ! group_by_node . count ( vertex_v ) ) group_by_node [ vertex_v ] . insert ( std :: make_pair ( vertex_v , std :: move ( vertex_v ) ) ) ;\n    if ( group_by_node [ vertex_u ] != group_by_node [ vertex_v ] ) {\n      min_spanning_tree . insert ( edge ) ;\n      group_by_node = update ( group_by_node , vertex_u , vertex_v ) ;\n      for ( auto node : group_by_node [ vertex_v ] ) group_by_node = update ( group_by_node , node , vertex_u ) ;\n    }\n  }\n  return min_spanning_tree ;\n}\n",
        "set < WeightedEdge * > minimum_spanning_tree ( vector < WeightedEdge * > & weighted_edges ) {\n  map < Node * , set < Node * >> group_by_node ;\n  set < WeightedEdge * > min_spanning_tree ;\n  sort ( weighted_edges . begin ( ) , weighted_edges . end ( ) ) ;\n  for ( auto & edge : weighted_edges ) {\n    Node * vertex_u = edge -> node1 ;\n    Node * vertex_v = edge -> node2 ;\n    if ( ! group_by_node . count ( vertex_u ) ) group_by_node [ vertex_u ] . insert ( std :: make_pair ( vertex_u , std :: move ( vertex_u ) ) ) ;\n    if ( ! group_by_node . count ( vertex_v ) ) group_by_node [ vertex_v ] . insert ( std :: make_pair ( vertex_v , std :: move ( vertex_v ) ) ) ;\n    if ( group_by_node [ vertex_u ] != group_by_node [ vertex_v ] ) {\n      min_spanning_tree . insert ( edge ) ;\n      group_by_node = update ( group_by_node , vertex_u , vertex_v ) ;\n      for ( auto & node : group_by_node [ vertex_v ] ) group_by_node = update ( group_by_node , node , vertex_u ) ;\n    }\n  }\n  return min_spanning_tree ;\n}\n",
        "set < WeightedEdge * > minimum_spanning_tree ( const vector < WeightedEdge * > & weighted_edges ) {\n  map < Node * , set < Node * >> group_by_node ;\n  set < WeightedEdge * > min_spanning_tree ;\n  sort ( weighted_edges . begin ( ) , weighted_edges . end ( ) ) ;\n  for ( auto edge : weighted_edges ) {\n    Node * vertex_u = edge -> node1 ;\n    Node * vertex_v = edge -> node2 ;\n    if ( ! group_by_node . count ( vertex_u ) ) group_by_node [ vertex_u ] . insert ( std :: make_pair ( vertex_u , std :: move ( vertex_u ) ) ) ;\n    if ( ! group_by_node . count ( vertex_v ) ) group_by_node [ vertex_v ] . insert ( std :: make_pair ( vertex_v , std :: move ( vertex_v ) ) ) ;\n    if ( group_by_node [ vertex_u ] != group_by_node [ vertex_v ] ) {\n      min_spanning_tree . insert ( edge ) ;\n      group_by_node = update ( group_by_node , vertex_u , vertex_v ) ;\n      for ( auto node : group_by_node [ vertex_v ] ) group_by_node = update ( group_by_node , node , vertex_u ) ;\n    }\n  }\n  return min_spanning_tree ;\n}\n",
        "set < WeightedEdge * > minimum_spanning_tree ( vector < WeightedEdge * > weighted_edges ) {\n  map < Node * , set < Node * >> group_by_node ;\n  set < WeightedEdge * > min_spanning_tree ;\n  sort ( weighted_edges . begin ( ) , weighted_edges . end ( ) ) ;\n  for ( auto edge : weighted_edges ) {\n    Node * vertex_u = edge -> node1 ;\n    Node * vertex_v = edge -> node2 ;\n    if ( ! group_by_node . count ( vertex_u ) ) group_by_node [ vertex_u ] . insert ( std :: make_pair ( vertex_u , std :: move ( vertex_u ) ) ) ;\n    if ( ! group_by_node . count ( vertex_v ) ) group_by_node [ vertex_v ] . insert ( std :: make_pair ( vertex_v , std :: move ( vertex_v ) ) ) ;\n    if ( group_by_node [ vertex_u ] != group_by_node [ vertex_v ] ) {\n      min_spanning_tree . insert ( edge ) ;\n      group_by_node = update ( group_by_node , vertex_u , vertex_v ) ;\n      for ( auto node : group_by_node [ vertex_v ] ) group_by_node = update ( group_by_node , node , vertex_u ) ;\n    }\n  }\n  return min_spanning_tree ;\n}\n"
      ],
      "output": [
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( ArrayList < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( ArrayList < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( ArrayList < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) . size ( ) != groupByNode . get ( vertexV ) . size ( ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( List < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < > ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < > ( ) ;\n  sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n",
        "public static Set < WeightedEdge > minimum_spanning_tree ( ArrayList < WeightedEdge > weightedEdges ) {\n  Map < Node , Set < Node >> groupByNode = new HashMap < Node , Set < Node >> ( ) ;\n  Set < WeightedEdge > minSpanningTree = new HashSet < WeightedEdge > ( ) ;\n  Collections . sort ( weightedEdges ) ;\n  for ( WeightedEdge edge : weightedEdges ) {\n    Node vertexU = edge . node1 ;\n    Node vertexV = edge . node2 ;\n    if ( ! groupByNode . containsKey ( vertexU ) ) {\n      groupByNode . put ( vertexU , new HashSet < Node > ( ) ) ;\n    }\n    if ( ! groupByNode . containsKey ( vertexV ) ) {\n      groupByNode . put ( vertexV , new HashSet < Node > ( ) ) ;\n    }\n    if ( groupByNode . get ( vertexU ) != groupByNode . get ( vertexV ) ) {\n      minSpanningTree . add ( edge ) ;\n      groupByNode = update ( groupByNode , vertexU , vertexV ) ;\n      for ( Node node : groupByNode . get ( vertexV ) ) {\n        groupByNode = update ( groupByNode , node , vertexU ) ;\n      }\n    }\n  }\n  return minSpanningTree ;\n}\n"
      ]
    },
    "NEXT_PALINDROME": {
      "loc": "35-36",
      "input": "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid != high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\n    otherwise.add(1);\n    otherwise.addAll(Collections.nCopies(digit_list.length, 0)); \n    otherwise.add(1);\n    return String.valueOf(otherwise);\n}",
      "target": "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid != high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\n    otherwise.add(1);\n    otherwise.addAll(Collections.nCopies(digit_list.length-1, 0)); \n    otherwise.add(1);\n    return String.valueOf(otherwise);\n}",
      "function range": "14,5-39,5",
      "raw_output": [
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Math . nthElement ( digit_list , 0 , digit_list . length - 1 ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return String . valueOf ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ 0 ] ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfTrailingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ 1 ] = digit_list [ 0 ] ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Arrays . toString ( otherwise ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDivide ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDivide ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Arrays . toString ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Arrays . toString ( otherwise ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Math . nthElement ( digit_list , 0 , digit_list . length - 1 ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return String . valueOf ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Math . nthElement ( digit_list , 0 , digit_list . length - 1 ) ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return String . valueOf ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length + 1 ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Math . nCopies ( digit_list . length - 1 , 0 ) ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return String . valueOf ( otherwise [ 0 ] ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Arrays . toString ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Arrays . toString ( otherwise ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return String . valueOf ( otherwise ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Arrays . toString ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Arrays . toString ( otherwise ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return String . valueOf ( otherwise ) ;\n}\n",
        "public static String nextPalindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n"
      ],
      "mid_translation": [
        "string next_palindrome ( vector < int > & digit_list ) {\n  int high_mid = floordiv ( digit_list . size ( ) , 2 ) ;\n  int low_mid = floordiv ( digit_list . size ( ) - 1 , 2 ) ;\n  while ( high_mid < digit_list . size ( ) && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) digit_list [ low_mid ] += 1 ;\n      return string ( digit_list . begin ( ) , digit_list . end ( ) ) ;\n    }\n  }\n  vector < int > otherwise ;\n  otherwise . push_back ( 1 ) ;\n  otherwise . insert ( otherwise . end ( ) , std :: nth_element ( digit_list . begin ( ) , digit_list . end ( ) ) ) ;\n  otherwise . push_back ( 1 ) ;\n  return string ( otherwise . begin ( ) , otherwise . end ( ) ) ;\n}\n",
        "string next_palindrome ( vector < int > & digit_list ) {\n  int high_mid = floordiv ( digit_list . size ( ) , 2 ) ;\n  int low_mid = floordiv ( digit_list . size ( ) - 1 , 2 ) ;\n  while ( high_mid < digit_list . size ( ) && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) digit_list [ low_mid ] += 1 ;\n      return to_string ( digit_list [ high_mid ] ) ;\n    }\n  }\n  vector < int > otherwise ;\n  otherwise . push_back ( 1 ) ;\n  otherwise . reserve ( std :: distance ( digit_list . begin ( ) , digit_list . end ( ) ) ) ;\n  otherwise . push_back ( 1 ) ;\n  return to_string ( otherwise ) ;\n}\n",
        "string next_palindrome ( vector < int > & digit_list ) {\n  int high_mid = floordiv ( digit_list . size ( ) , 2 ) ;\n  int low_mid = floordiv ( digit_list . size ( ) - 1 , 2 ) ;\n  while ( high_mid < digit_list . size ( ) && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) digit_list [ low_mid ] += 1 ;\n      return to_string ( digit_list ) ;\n    }\n  }\n  vector < int > otherwise ;\n  otherwise . push_back ( 1 ) ;\n  otherwise . insert ( otherwise . end ( ) , std :: nth_element ( digit_list . begin ( ) , digit_list . end ( ) , 0 ) ) ;\n  otherwise . push_back ( 1 ) ;\n  return to_string ( otherwise ) ;\n}\n",
        "string next_palindrome ( vector < int > & digit_list ) {\n  int high_mid = floordiv ( digit_list . size ( ) , 2 ) ;\n  int low_mid = floordiv ( digit_list . size ( ) - 1 , 2 ) ;\n  while ( high_mid < digit_list . size ( ) && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) digit_list [ low_mid ] += 1 ;\n      return string ( digit_list . begin ( ) , digit_list . end ( ) ) ;\n    }\n  }\n  vector < int > otherwise ;\n  otherwise . push_back ( 1 ) ;\n  otherwise . insert ( otherwise . end ( ) , std :: nth_element ( digit_list . begin ( ) , digit_list . end ( ) , 0 ) ) ;\n  otherwise . push_back ( 1 ) ;\n  return string ( otherwise . begin ( ) , otherwise . end ( ) ) ;\n}\n",
        "string next_palindrome ( vector < int > & digit_list ) {\n  int high_mid = floordiv ( digit_list . size ( ) , 2 ) ;\n  int low_mid = floordiv ( digit_list . size ( ) - 1 , 2 ) ;\n  while ( high_mid < digit_list . size ( ) && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) digit_list [ low_mid ] += 1 ;\n      return string ( digit_list ) ;\n    }\n  }\n  vector < int > otherwise ;\n  otherwise . push_back ( 1 ) ;\n  otherwise . insert ( otherwise . end ( ) , std :: nth_element ( digit_list . begin ( ) , digit_list . end ( ) , 0 ) ) ;\n  otherwise . push_back ( 1 ) ;\n  return string ( otherwise ) ;\n}\n"
      ],
      "output": [
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Math . nthElement ( digit_list , 0 , digit_list . length - 1 ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return String . valueOf ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ 0 ] ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfTrailingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ 1 ] = digit_list [ 0 ] ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Arrays . toString ( otherwise ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDivide ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDivide ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Arrays . toString ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Arrays . toString ( otherwise ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Integer . numberOfLeadingZeros ( digit_list [ digit_list . length - 1 ] ) ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Math . nthElement ( digit_list , 0 , digit_list . length - 1 ) ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return String . valueOf ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Math . nthElement ( digit_list , 0 , digit_list . length - 1 ) ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return String . valueOf ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list [ high_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length + 1 ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = Math . nCopies ( digit_list . length - 1 , 0 ) ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return String . valueOf ( otherwise [ 0 ] ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Arrays . toString ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return Arrays . toString ( otherwise ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] = 1 ;\n  return String . valueOf ( otherwise ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Arrays . toString ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Arrays . toString ( otherwise ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return String . valueOf ( digit_list ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return String . valueOf ( otherwise ) ;\n}\n",
        "public static String next_palindrome ( int [ ] digit_list ) {\n  int high_mid = Math . floorDiv ( digit_list . length , 2 ) ;\n  int low_mid = Math . floorDiv ( digit_list . length - 1 , 2 ) ;\n  while ( high_mid < digit_list . length && low_mid >= 0 ) {\n    if ( digit_list [ high_mid ] == 9 ) {\n      digit_list [ high_mid ] = 0 ;\n      digit_list [ low_mid ] = 0 ;\n      high_mid += 1 ;\n      low_mid -= 1 ;\n    }\n    else {\n      digit_list [ high_mid ] += 1 ;\n      if ( low_mid != high_mid ) {\n        digit_list [ low_mid ] += 1 ;\n      }\n      return Integer . toString ( digit_list [ low_mid ] ) ;\n    }\n  }\n  int [ ] otherwise = new int [ digit_list . length ] ;\n  otherwise [ 0 ] = 1 ;\n  otherwise [ digit_list . length - 1 ] = 0 ;\n  otherwise [ digit_list . length - 1 ] += 1 ;\n  return Integer . toString ( otherwise [ 0 ] ) ;\n}\n"
      ]
    },
    "NEXT_PERMUTATION": {
      "loc": "19-20",
      "input": "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) < perm.get(i)) { \n                    ArrayList<Integer> next_perm = perm;\n                    int temp_j = perm.get(j);\n                    int temp_i = perm.get(i);\n                    next_perm.set(i,temp_j);\n                    next_perm.set(j,temp_i);\n                    ArrayList<Integer> reversed = new ArrayList<Integer>(100);\n                    for (int k=next_perm.size()-1; k!=i; k--) {\n                        reversed.add(next_perm.get(k));\n                    }\n                    int q = i + 1;\n                    for (Integer replace : reversed) {\n                        next_perm.set(q, replace);\n                        q++;\n                    }\n                    return next_perm;\n                }\n            }\n        }\n    }\n    return new ArrayList<Integer>();\n}",
      "target": "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) { \n                    ArrayList<Integer> next_perm = perm;\n                    int temp_j = perm.get(j);\n                    int temp_i = perm.get(i);\n                    next_perm.set(i,temp_j);\n                    next_perm.set(j,temp_i);\n                    ArrayList<Integer> reversed = new ArrayList<Integer>(100);\n                    for (int k=next_perm.size()-1; k!=i; k--) {\n                        reversed.add(next_perm.get(k));\n                    }\n                    int q = i + 1;\n                    for (Integer replace : reversed) {\n                        next_perm.set(q, replace);\n                        q++;\n                    }\n                    return next_perm;\n                }\n            }\n        }\n    }\n    return new ArrayList<Integer>();\n}",
      "function range": "15,5-44,5",
      "raw_output": [
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( Integer replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] nextPermutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n"
      ],
      "mid_translation": [
        "vector < int > next_permutation ( vector < int > & perm ) {\n  for ( int i = perm . size ( ) - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . size ( ) - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          vector < int > next_perm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          next_perm [ i ] = temp_j ;\n          next_perm [ j ] = temp_i ;\n          vector < int > reversed ( 100 ) ;\n          for ( int k = next_perm . size ( ) - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = next_perm [ k ] ;\n          int q = i + 1 ;\n          for ( auto replace : reversed ) {\n            next_perm [ q ] = replace ;\n            q ++ ;\n          }\n          return next_perm ;\n        }\n      }\n    }\n  }\n  return {\n  }\n  ;\n}\n",
        "vector < int > next_permutation ( vector < int > & perm ) {\n  for ( int i = perm . size ( ) - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . size ( ) - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          vector < int > next_perm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          next_perm [ i ] = temp_j ;\n          next_perm [ j ] = temp_i ;\n          vector < int > reversed ( 100 ) ;\n          for ( int k = next_perm . size ( ) - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = next_perm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            next_perm [ q ] = replace ;\n            q ++ ;\n          }\n          return next_perm ;\n        }\n      }\n    }\n  }\n  return {\n  }\n  ;\n}\n",
        "vector < int > next_permutation ( vector < int > & perm ) {\n  for ( int i = perm . size ( ) - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . size ( ) - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          vector < int > next_perm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          next_perm [ i ] = temp_j ;\n          next_perm [ j ] = temp_i ;\n          vector < int > reversed ( 100 ) ;\n          for ( int k = next_perm . size ( ) - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = next_perm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( auto replace : reversed ) {\n            next_perm [ q ] = replace ;\n            q ++ ;\n          }\n          return next_perm ;\n        }\n      }\n    }\n  }\n  return {\n  }\n  ;\n}\n",
        "public : vector < int > next_permutation ( vector < int > & perm ) {\n  for ( int i = perm . size ( ) - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . size ( ) - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          vector < int > next_perm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          next_perm [ i ] = temp_j ;\n          next_perm [ j ] = temp_i ;\n          vector < int > reversed ( 100 ) ;\n          for ( int k = next_perm . size ( ) - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = next_perm [ k ] ;\n          int q = i + 1 ;\n          for ( auto replace : reversed ) {\n            next_perm [ q ] = replace ;\n            q ++ ;\n          }\n          return next_perm ;\n        }\n      }\n    }\n  }\n  return {\n  }\n  ;\n}\n",
        "vector < int > next_permutation ( vector < int > & perm ) {\n  for ( int i = perm . size ( ) - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . size ( ) - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          vector < int > next_perm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          next_perm [ i ] = temp_j ;\n          next_perm [ j ] = temp_i ;\n          vector < int > reversed ( 100 ) ;\n          for ( int k = next_perm . size ( ) - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = next_perm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            next_perm [ q ] = replace ;\n            q ++ ;\n          }\n          return next_perm ;\n        }\n      }\n    }\n  }\n  return {\n  }\n  ;\n}\n"
      ],
      "output": [
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( Integer replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ ] {\n  }\n  ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = new int [ perm . length ] ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int tempJ = perm [ j ] ;\n          int tempI = perm [ i ] ;\n          nextPerm [ i ] = tempJ ;\n          nextPerm [ j ] = tempI ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) {\n            reversed [ k ] = nextPerm [ k ] ;\n          }\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n",
        "public static int [ ] next_permutation ( int [ ] perm ) {\n  for ( int i = perm . length - 2 ;\n  i != - 1 ;\n  i -- ) {\n    if ( perm [ i ] < perm [ i + 1 ] ) {\n      for ( int j = perm . length - 1 ;\n      j != i ;\n      j -- ) {\n        if ( perm [ j ] < perm [ i ] ) {\n          int [ ] nextPerm = perm ;\n          int temp_j = perm [ j ] ;\n          int temp_i = perm [ i ] ;\n          nextPerm [ i ] = temp_j ;\n          nextPerm [ j ] = temp_i ;\n          int [ ] reversed = new int [ 100 ] ;\n          for ( int k = nextPerm . length - 1 ;\n          k != i ;\n          k -- ) reversed [ k ] = nextPerm [ k ] ;\n          int q = i + 1 ;\n          for ( int replace : reversed ) {\n            nextPerm [ q ] = replace ;\n            q ++ ;\n          }\n          return nextPerm ;\n        }\n      }\n    }\n  }\n  return new int [ 0 ] ;\n}\n"
      ]
    },
    "PASCAL": {
      "loc": "22-23",
      "input": "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int c=0; c<r; c++) { \n            int upleft, upright;\n            if (c > 0) {\n                upleft = rows.get(r-1).get(c-1);\n            } else {\n                upleft = 0;\n            }\n            if (c < r) {\n                upright = rows.get(r-1).get(c);\n            } else {\n                upright = 0;\n            }\n            row.add(upleft+upright);\n        }\n        rows.add(row);\n    }\n    return rows;\n}",
      "target": "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int c=0; c<r+1; c++) { \n            int upleft, upright;\n            if (c > 0) {\n                upleft = rows.get(r-1).get(c-1);\n            } else {\n                upleft = 0;\n            }\n            if (c < r) {\n                upright = rows.get(r-1).get(c);\n            } else {\n                upright = 0;\n            }\n            row.add(upleft+upright);\n        }\n        rows.add(row);\n    }\n    return rows;\n}",
      "function range": "14,5-40,5",
      "raw_output": [
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  List < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    List < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> pascal ( int n ) {\n  ArrayList < ArrayList < Integer >> rows = new ArrayList < ArrayList < Integer >> ( ) ;\n  ArrayList < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    ArrayList < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ n ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  List < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    List < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> pascal ( int n ) {\n  ArrayList < ArrayList < Integer >> rows = new ArrayList < ArrayList < Integer >> ( ) ;\n  ArrayList < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    ArrayList < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ n ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  List < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    List < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  List < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    List < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> pascal ( int n ) {\n  ArrayList < ArrayList < Integer >> rows = new ArrayList < ArrayList < Integer >> ( ) ;\n  ArrayList < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    ArrayList < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ n ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = {\n    1 }\n    ;\n    rows [ 0 ] = init ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      int [ ] row = new int [ r ] ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows [ r - 1 ] [ c - 1 ] ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows [ r - 1 ] [ c ] ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row [ r ] = upleft + upright ;\n      }\n      rows [ r ] = row ;\n    }\n    return rows ;\n  }\n  ",
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  int [ ] init = {\n    1 }\n    ;\n    rows . add ( init ) ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      List < Integer > row = new ArrayList < Integer > ( ) ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows . get ( r - 1 ) . get ( c ) ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row . add ( upleft + upright ) ;\n      }\n      rows . add ( row ) ;\n    }\n    return rows ;\n  }\n  ",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = {\n    1 }\n    ;\n    rows [ 0 ] = init ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      int [ ] row = new int [ r ] ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows [ r - 1 ] [ c - 1 ] ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows [ r - 1 ] [ c ] ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row [ c ] = upleft + upright ;\n      }\n      rows [ r ] = row ;\n    }\n    return rows ;\n  }\n  ",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = {\n    1 }\n    ;\n    rows [ 0 ] = init ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      int [ ] row = new int [ r ] ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows [ r - 1 ] [ c - 1 ] ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows [ r - 1 ] [ c ] ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row [ 0 ] = upleft + upright ;\n      }\n      rows [ r ] = row ;\n    }\n    return rows ;\n  }\n  ",
        "public static int [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = {\n    1 }\n    ;\n    rows [ 0 ] = init ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      int [ ] row = new int [ r ] ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows [ r - 1 ] [ c - 1 ] ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows [ r - 1 ] [ c ] ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row [ r ] = upleft + upright ;\n      }\n      rows [ r ] = row ;\n    }\n    return rows ;\n  }\n  "
      ],
      "mid_translation": [
        "vector < vector < int >> pascal ( int n ) {\n  vector < vector < int >> rows ;\n  vector < int > init ;\n  init . push_back ( 1 ) ;\n  rows . push_back ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    vector < int > row ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) upleft = rows [ r - 1 ] [ c - 1 ] ;\n      else upleft = 0 ;\n      if ( c < r ) upright = rows [ r - 1 ] [ c ] ;\n      else upright = 0 ;\n      row . push_back ( upleft + upright ) ;\n    }\n    rows . push_back ( row ) ;\n  }\n  return rows ;\n}\n",
        "vector < vector < int >> pascal ( int n ) {\n  vector < vector < int >> rows ;\n  vector < int > init ;\n  init . push_back ( 1 ) ;\n  rows . push_back ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    vector < int > row ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) upleft = rows [ r - 1 ] [ c - 1 ] ;\n      else upleft = 0 ;\n      if ( c < r ) upright = rows [ r - 1 ] [ c ] ;\n      else upright = 0 ;\n      row . push_back ( upleft + upright ) ;\n    }\n    rows . push_back ( row ) ;\n  }\n  return rows ;\n}\n",
        "public : vector < vector < int >> pascal ( int n ) {\n  vector < vector < int >> rows ;\n  vector < int > init ;\n  init . push_back ( 1 ) ;\n  rows . push_back ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    vector < int > row ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) upleft = rows [ r - 1 ] [ c - 1 ] ;\n      else upleft = 0 ;\n      if ( c < r ) upright = rows [ r - 1 ] [ c ] ;\n      else upright = 0 ;\n      row . push_back ( upleft + upright ) ;\n    }\n    rows . push_back ( row ) ;\n  }\n  return rows ;\n}\n",
        "vector < vector < int >> pascal ( int n ) {\n  vector < vector < int >> rows ;\n  vector < int > init ;\n  init . push_back ( 1 ) ;\n  rows . push_back ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    vector < int > row ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c ) upleft = rows [ r - 1 ] [ c - 1 ] ;\n      else upleft = 0 ;\n      if ( c < r ) upright = rows [ r - 1 ] [ c ] ;\n      else upright = 0 ;\n      row . push_back ( upleft + upright ) ;\n    }\n    rows . push_back ( row ) ;\n  }\n  return rows ;\n}\n",
        "vector < vector < int >> pascal ( int n ) {\n  vector < vector < int >> rows ;\n  vector < int > init = {\n    1 }\n    ;\n    rows . push_back ( init ) ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      vector < int > row ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) upleft = rows [ r - 1 ] [ c - 1 ] ;\n        else upleft = 0 ;\n        if ( c < r ) upright = rows [ r - 1 ] [ c ] ;\n        else upright = 0 ;\n        row . push_back ( upleft + upright ) ;\n      }\n      rows . push_back ( row ) ;\n    }\n    return rows ;\n  }\n  "
      ],
      "output": [
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  List < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    List < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> pascal ( int n ) {\n  ArrayList < ArrayList < Integer >> rows = new ArrayList < ArrayList < Integer >> ( ) ;\n  ArrayList < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    ArrayList < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ n ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  List < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    List < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> pascal ( int n ) {\n  ArrayList < ArrayList < Integer >> rows = new ArrayList < ArrayList < Integer >> ( ) ;\n  ArrayList < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    ArrayList < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ n ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  List < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    List < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  List < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    List < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> pascal ( int n ) {\n  ArrayList < ArrayList < Integer >> rows = new ArrayList < ArrayList < Integer >> ( ) ;\n  ArrayList < Integer > init = new ArrayList < Integer > ( ) ;\n  init . add ( 1 ) ;\n  rows . add ( init ) ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    ArrayList < Integer > row = new ArrayList < Integer > ( ) ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows . get ( r - 1 ) . get ( c ) ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row . add ( upleft + upright ) ;\n    }\n    rows . add ( row ) ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ r ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ r ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = new int [ n ] ;\n  init [ 0 ] = 1 ;\n  rows [ 0 ] = init ;\n  for ( int r = 1 ;\n  r < n ;\n  r ++ ) {\n    int [ ] row = new int [ n ] ;\n    for ( int c = 0 ;\n    c < r ;\n    c ++ ) {\n      int upleft , upright ;\n      if ( c > 0 ) {\n        upleft = rows [ r - 1 ] [ c - 1 ] ;\n      }\n      else {\n        upleft = 0 ;\n      }\n      if ( c < r ) {\n        upright = rows [ r - 1 ] [ c ] ;\n      }\n      else {\n        upright = 0 ;\n      }\n      row [ c ] = upleft + upright ;\n    }\n    rows [ r ] = row ;\n  }\n  return rows ;\n}\n",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = {\n    1 }\n    ;\n    rows [ 0 ] = init ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      int [ ] row = new int [ r ] ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows [ r - 1 ] [ c - 1 ] ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows [ r - 1 ] [ c ] ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row [ r ] = upleft + upright ;\n      }\n      rows [ r ] = row ;\n    }\n    return rows ;\n  }\n  ",
        "public static List < List < Integer >> pascal ( int n ) {\n  List < List < Integer >> rows = new ArrayList < List < Integer >> ( ) ;\n  int [ ] init = {\n    1 }\n    ;\n    rows . add ( init ) ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      List < Integer > row = new ArrayList < Integer > ( ) ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows . get ( r - 1 ) . get ( c - 1 ) ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows . get ( r - 1 ) . get ( c ) ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row . add ( upleft + upright ) ;\n      }\n      rows . add ( row ) ;\n    }\n    return rows ;\n  }\n  ",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = {\n    1 }\n    ;\n    rows [ 0 ] = init ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      int [ ] row = new int [ r ] ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows [ r - 1 ] [ c - 1 ] ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows [ r - 1 ] [ c ] ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row [ c ] = upleft + upright ;\n      }\n      rows [ r ] = row ;\n    }\n    return rows ;\n  }\n  ",
        "public static int [ ] [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = {\n    1 }\n    ;\n    rows [ 0 ] = init ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      int [ ] row = new int [ r ] ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows [ r - 1 ] [ c - 1 ] ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows [ r - 1 ] [ c ] ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row [ 0 ] = upleft + upright ;\n      }\n      rows [ r ] = row ;\n    }\n    return rows ;\n  }\n  ",
        "public static int [ ] pascal ( int n ) {\n  int [ ] [ ] rows = new int [ n ] [ n ] ;\n  int [ ] init = {\n    1 }\n    ;\n    rows [ 0 ] = init ;\n    for ( int r = 1 ;\n    r < n ;\n    r ++ ) {\n      int [ ] row = new int [ r ] ;\n      for ( int c = 0 ;\n      c < r ;\n      c ++ ) {\n        int upleft , upright ;\n        if ( c > 0 ) {\n          upleft = rows [ r - 1 ] [ c - 1 ] ;\n        }\n        else {\n          upleft = 0 ;\n        }\n        if ( c < r ) {\n          upright = rows [ r - 1 ] [ c ] ;\n        }\n        else {\n          upright = 0 ;\n        }\n        row [ r ] = upleft + upright ;\n      }\n      rows [ r ] = row ;\n    }\n    return rows ;\n  }\n  "
      ]
    },
    "POSSIBLE_CHANGE": {
      "loc": "17-18",
      "input": "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    if (total < 0) { \n        return 0;\n    }\n    int first = coins[0];\n    int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n    return possible_change(coins, total-first) + possible_change(rest, total);\n}",
      "target": "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    if (total < 0 ||coins.length==0) { \n        return 0;\n    }\n    int first = coins[0];\n    int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n    return possible_change(coins, total-first) + possible_change(rest, total);\n}",
      "function range": "13,5-24,5",
      "raw_output": [
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , coins . length ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , coins . length ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , coins . length ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , coins . length ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , first ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  if ( total < 0 ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , first , 1 ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , first ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possibleChange ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( first , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n"
      ],
      "mid_translation": [
        "public : int possibleChange ( vector < int > & coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  vector < int > rest = vector < int > ( coins . begin ( ) , coins . end ( ) ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "int possible_change ( vector < int > & coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  vector < int > rest = vector < int > ( coins . begin ( ) , coins . end ( ) ) ;\n  return possible_change ( coins , total - first ) + possible_change ( rest , total ) ;\n}\n",
        "public : int possible_change ( vector < int > & coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  vector < int > rest = vector < int > ( coins . begin ( ) , coins . end ( ) ) ;\n  return possible_change ( coins , total - first ) + possible_change ( rest , total ) ;\n}\n",
        "public : int possibleChange ( vector < int > & coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  vector < int > rest = vector < int > ( coins . begin ( ) , coins . end ( ) ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public : int possibleChange ( vector < int > & coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  vector < int > rest = vector < int > ( first , 1 ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n"
      ],
      "output": [
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , coins . length ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , coins . length ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , coins . length ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , coins . length ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOf ( coins , first ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  if ( total < 0 ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , first , 1 ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) {\n    return 1 ;\n  }\n  if ( total < 0 ) {\n    return 0 ;\n  }\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( coins , 1 , first ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n",
        "public static int possible_change ( int [ ] coins , int total ) {\n  if ( total == 0 ) return 1 ;\n  if ( total < 0 ) return 0 ;\n  int first = coins [ 0 ] ;\n  int [ ] rest = Arrays . copyOfRange ( first , 1 , total ) ;\n  return possibleChange ( coins , total - first ) + possibleChange ( rest , total ) ;\n}\n"
      ]
    },
    "QUICKSORT": {
      "loc": "26-27",
      "input": "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x > pivot) { \n            greater.add(x);\n        }\n    }\n    ArrayList<Integer> middle = new ArrayList<Integer>();\n    middle.add(pivot);\n    lesser = quicksort(lesser);\n    greater = quicksort(greater);\n    middle.addAll(greater);\n    lesser.addAll(middle);\n    return lesser;\n}",
      "target": "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x >= pivot) { \n            greater.add(x);\n        }\n    }\n    ArrayList<Integer> middle = new ArrayList<Integer>();\n    middle.add(pivot);\n    lesser = quicksort(lesser);\n    greater = quicksort(greater);\n    middle.addAll(greater);\n    lesser.addAll(middle);\n    return lesser;\n}",
      "function range": "14,5-38,5",
      "raw_output": [
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) lesser . add ( x ) ;\n    else if ( x > pivot ) greater . add ( x ) ;\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) lesser . add ( x ) ;\n    else if ( x > pivot ) greater . add ( x ) ;\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) lesser . add ( x ) ;\n    else if ( x > pivot ) greater . add ( x ) ;\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser . toArray ( new int [ 0 ] ) ;\n}\n",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return new int [ ] {\n    pivot }\n    ;\n  }\n  ",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return new int [ ] {\n    pivot }\n    ;\n  }\n  ",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( lesser ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) lesser . add ( x ) ;\n    else if ( x > pivot ) greater . add ( x ) ;\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return new int [ ] {\n    pivot }\n    ;\n  }\n  ",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser . toArray ( new int [ 0 ] ) ;\n}\n"
      ],
      "mid_translation": [
        "vector < int > quicksort ( vector < int > arr ) {\n  if ( arr . empty ( ) ) return {\n  }\n  ;\n  int pivot = arr [ 0 ] ;\n  vector < int > lesser ;\n  vector < int > greater ;\n  for ( auto x : arr [ 1 : ] ) {\n    if ( x < pivot ) lesser . push_back ( x ) ;\n    else if ( x > pivot ) greater . push_back ( x ) ;\n  }\n  vector < int > middle ;\n  middle . push_back ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . swap ( greater ) ;\n  lesser . swap ( middle ) ;\n  return lesser ;\n}\n",
        "vector < int > quicksort ( vector < int > arr ) {\n  if ( arr . empty ( ) ) return {\n  }\n  ;\n  int pivot = arr [ 0 ] ;\n  vector < int > lesser ;\n  vector < int > greater ;\n  for ( auto x : arr [ 1 : ] ) {\n    if ( x < pivot ) lesser . push_back ( x ) ;\n    else if ( x > pivot ) greater . push_back ( x ) ;\n  }\n  vector < int > middle ;\n  middle . push_back ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . insert ( middle . end ( ) , greater . begin ( ) , greater . end ( ) ) ;\n  lesser . insert ( lesser . end ( ) , middle . begin ( ) , middle . end ( ) ) ;\n  return lesser ;\n}\n",
        "vector < int > quicksort ( vector < int > arr ) {\n  if ( arr . empty ( ) ) {\n    return {\n    }\n    ;\n  }\n  int pivot = arr [ 0 ] ;\n  vector < int > lesser ;\n  vector < int > greater ;\n  for ( auto x : arr [ 1 : ] ) {\n    if ( x < pivot ) {\n      lesser . push_back ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . push_back ( x ) ;\n    }\n  }\n  vector < int > middle ;\n  middle . push_back ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . insert ( middle . end ( ) , greater . begin ( ) , greater . end ( ) ) ;\n  lesser . insert ( lesser . end ( ) , middle . begin ( ) , middle . end ( ) ) ;\n  return lesser ;\n}\n",
        "vector < int > quicksort ( vector < int > arr ) {\n  if ( arr . empty ( ) ) {\n    return {\n    }\n    ;\n  }\n  int pivot = arr [ 0 ] ;\n  vector < int > lesser ;\n  vector < int > greater ;\n  for ( auto x : arr [ 1 : ] ) {\n    if ( x < pivot ) {\n      lesser . push_back ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . push_back ( x ) ;\n    }\n  }\n  vector < int > middle ;\n  middle . push_back ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . swap ( greater ) ;\n  lesser . swap ( middle ) ;\n  return lesser ;\n}\n",
        "vector < int > quicksort ( vector < int > arr ) {\n  if ( arr . empty ( ) ) return {\n  }\n  ;\n  int pivot = arr [ 0 ] ;\n  vector < int > lesser ;\n  vector < int > greater ;\n  for ( auto x : arr ) {\n    if ( x < pivot ) lesser . push_back ( x ) ;\n    else if ( x > pivot ) greater . push_back ( x ) ;\n  }\n  vector < int > middle ;\n  middle . push_back ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . insert ( middle . end ( ) , greater . begin ( ) , greater . end ( ) ) ;\n  lesser . insert ( lesser . end ( ) , middle . begin ( ) , middle . end ( ) ) ;\n  return lesser ;\n}\n"
      ],
      "output": [
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) lesser . add ( x ) ;\n    else if ( x > pivot ) greater . add ( x ) ;\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) lesser . add ( x ) ;\n    else if ( x > pivot ) greater . add ( x ) ;\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) lesser . add ( x ) ;\n    else if ( x > pivot ) greater . add ( x ) ;\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser . toArray ( new int [ 0 ] ) ;\n}\n",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return new int [ ] {\n    pivot }\n    ;\n  }\n  ",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return new int [ ] {\n    pivot }\n    ;\n  }\n  ",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( lesser ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr . length == 0 ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) lesser . add ( x ) ;\n    else if ( x > pivot ) greater . add ( x ) ;\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static ArrayList < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new ArrayList < Integer > ( ) ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static List < Integer > quicksort ( int [ ] arr ) {\n  if ( arr == null ) {\n    return new ArrayList < Integer > ( ) ;\n  }\n  int pivot = arr [ 0 ] ;\n  List < Integer > lesser = new ArrayList < Integer > ( ) ;\n  List < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  List < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser ;\n}\n",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return new int [ ] {\n    pivot }\n    ;\n  }\n  ",
        "public static int [ ] quicksort ( int [ ] arr ) {\n  if ( arr == null ) return new int [ 0 ] ;\n  int pivot = arr [ 0 ] ;\n  ArrayList < Integer > lesser = new ArrayList < Integer > ( ) ;\n  ArrayList < Integer > greater = new ArrayList < Integer > ( ) ;\n  for ( int x : arr ) {\n    if ( x < pivot ) {\n      lesser . add ( x ) ;\n    }\n    else if ( x > pivot ) {\n      greater . add ( x ) ;\n    }\n  }\n  ArrayList < Integer > middle = new ArrayList < Integer > ( ) ;\n  middle . add ( pivot ) ;\n  lesser = quicksort ( lesser ) ;\n  greater = quicksort ( greater ) ;\n  middle . addAll ( greater ) ;\n  lesser . addAll ( middle ) ;\n  return lesser . toArray ( new int [ 0 ] ) ;\n}\n"
      ]
    },
    "REVERSE_LINKED_LIST": {
      "loc": "19-19",
      "input": "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node != null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode); \n        node = nextnode;\n    }\n    return prevnode;\n}",
      "target": "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node != null) { \n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}",
      "function range": "14,5-23,5",
      "raw_output": [
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static Node reverseLinkedListNode ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getNext ( ) ;\n    node . setNext ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getNext ( ) ;\n    node . setNext ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getNextSibling ( ) ;\n    node . setNext ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static node reverseLinkedList ( node node ) {\n  node prevnode = null ;\n  node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getNext ( ) ;\n    node . setNext ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static node reverseLinkedList ( node node ) {\n  node prevnode = null ;\n  node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode = null ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "static public Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverseLinkedList ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode = null ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node < ? > reverseLinkedList ( Node < ? > node ) {\n  Node < ? > prevnode = null ;\n  Node < ? > nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n"
      ],
      "mid_translation": [
        "Node * reverse_linked_list ( Node * node ) {\n  Node * prevnode = NULL ;\n  Node * nextnode ;\n  while ( node ) {\n    nextnode = node -> successor ;\n    node -> successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "Node * reverse_linked_list ( Node * node ) {\n  Node * prevnode = NULL ;\n  Node * nextnode ;\n  while ( node ) {\n    nextnode = node -> next ;\n    node -> next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "node * reverse_linked_list ( node * node ) {\n  node * prevnode = NULL ;\n  node * nextnode ;\n  while ( node ) {\n    nextnode = node -> successor ;\n    node -> successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "node * reverse_linked_list ( node * node ) {\n  node * prevnode = NULL ;\n  node * nextnode ;\n  while ( node ) {\n    nextnode = node -> next ;\n    node -> next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "Node * reverseLinkedList ( Node * node ) {\n  Node * prevnode = NULL ;\n  Node * nextnode ;\n  while ( node ) {\n    nextnode = node -> getSuccessor ( ) ;\n    node -> setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n"
      ],
      "output": [
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getNext ( ) ;\n    node . setNext ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getNext ( ) ;\n    node . setNext ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getNextSibling ( ) ;\n    node . setNext ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static node reverse_linked_list ( node node ) {\n  node prevnode = null ;\n  node nextnode ;\n  while ( node != null ) {\n    nextnode = node . successor ;\n    node . successor = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getNext ( ) ;\n    node . setNext ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static node reverse_linked_list ( node node ) {\n  node prevnode = null ;\n  node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode = null ;\n  while ( node != null ) {\n    nextnode = node . next ;\n    node . next = prevnode ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static public Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node reverse_linked_list ( Node node ) {\n  Node prevnode = null ;\n  Node nextnode = null ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n",
        "public static Node < ? > reverse_linked_list ( Node < ? > node ) {\n  Node < ? > prevnode = null ;\n  Node < ? > nextnode ;\n  while ( node != null ) {\n    nextnode = node . getSuccessor ( ) ;\n    node . setSuccessor ( prevnode ) ;\n    node = nextnode ;\n  }\n  return prevnode ;\n}\n"
      ]
    },
    "RPN_EVAL": {
      "loc": "34-35",
      "input": "public static Double rpn_eval(ArrayList tokens) {\n    Map<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\n    op.put(\"+\", (a, b) -> a + b);\n    op.put(\"-\", (a, b) -> a - b);\n    op.put(\"*\", (a, b) -> a * b);\n    op.put(\"/\", (a, b) -> a / b);\n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\n            token = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\n            Double c = 0.0;\n            BinaryOperator<Double> bin_op = op.get(token);\n            c = bin_op.apply(a,b); \n            stack.push(c);\n        }\n    }\n    return (Double) stack.pop();\n}",
      "target": "public static Double rpn_eval(ArrayList tokens) {\n    Map<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\n    op.put(\"+\", (a, b) -> a + b);\n    op.put(\"-\", (a, b) -> a - b);\n    op.put(\"*\", (a, b) -> a * b);\n    op.put(\"/\", (a, b) -> a / b);\n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\n            token = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\n            Double c = 0.0;\n            BinaryOperator<Double> bin_op = op.get(token);\n            c = bin_op.apply(b,a); \n            stack.push(c);\n        }\n    }\n    return (Double) stack.pop();\n}",
      "function range": "15,5-40,5",
      "raw_output": [
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . peek ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . peek ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . pop ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpnEval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . peek ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . peek ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . pop ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) stack . push ( ( Double ) token ) ;\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . pop ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) stack . push ( ( Double ) token ) ;\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . peek ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) stack . push ( ( Double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . pop ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . pop ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) stack . push ( ( Double ) token ) ;\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . peek ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isInfinite ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . pop ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n"
      ],
      "mid_translation": [
        "double rpn_eval ( vector < string > tokens ) {\n  map < string , BinaryOperator < double >> op ;\n  op [ \"+\" ] = ( a , b ) -> operator + ( a , b ) ;\n  op [ \"-\" ] = ( a , b ) -> operator - ( a , b ) ;\n  op [ \"*\" ] = ( a , b ) -> operator * ( a , b ) ;\n  op [ \"/\" ] = ( a , b ) -> operator / ( a , b ) ;\n  stack < double > stack ;\n  for ( auto token : tokens ) {\n    if ( double ( token ) == 0.0 ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( string ) token ;\n      double a = ( double ) stack . top ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < double > bin_op = op [ token ] ;\n      c = bin_op ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . top ( ) ;\n}\n",
        "double rpn_eval ( vector < string > tokens ) {\n  map < string , BinaryOperator < double >> op ;\n  op [ \"+\" ] = ( a , b ) -> operator + ( a , b ) ;\n  op [ \"-\" ] = ( a , b ) -> operator - ( a , b ) ;\n  op [ \"*\" ] = ( a , b ) -> operator * ( a , b ) ;\n  op [ \"/\" ] = ( a , b ) -> operator / ( a , b ) ;\n  stack < double > stack ;\n  for ( auto token : tokens ) {\n    if ( Double == token ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( string ) token ;\n      double a = ( double ) stack . top ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < double > bin_op = op [ token ] ;\n      c = bin_op ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . top ( ) ;\n}\n",
        "double rpn_eval ( vector < string > tokens ) {\n  map < string , BinaryOperator < double >> op ;\n  op [ \"+\" ] = ( a , b ) -> operator + ( a , b ) ;\n  op [ \"-\" ] = ( a , b ) -> operator - ( a , b ) ;\n  op [ \"*\" ] = ( a , b ) -> operator * ( a , b ) ;\n  op [ \"/\" ] = ( a , b ) -> operator / ( a , b ) ;\n  stack < double > stack ;\n  for ( auto token : tokens ) {\n    if ( Double == token ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( string ) token ;\n      double a = ( double ) stack . top ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < double > bin_op = op [ token ] ;\n      c = bin_op ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . top ( ) ;\n}\n",
        "double rpn_eval ( vector < string > tokens ) {\n  map < string , BinaryOperator < double >> op ;\n  op [ \"+\" ] = ( a , b ) -> operator + ( a , b ) ;\n  op [ \"-\" ] = ( a , b ) -> operator - ( a , b ) ;\n  op [ \"*\" ] = ( a , b ) -> operator * ( a , b ) ;\n  op [ \"/\" ] = ( a , b ) -> operator / ( a , b ) ;\n  stack < double > stack ;\n  for ( auto token : tokens ) {\n    if ( double ( token ) == 0.0 ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( string ) token ;\n      double a = ( double ) stack . top ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < double > bin_op = op [ token ] ;\n      c = bin_op ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . top ( ) ;\n}\n",
        "double rpn_eval ( vector < string > tokens ) {\n  map < string , BinaryOperator < double >> op ;\n  op [ \"+\" ] = ( a , b ) -> operator + ( a , b ) ;\n  op [ \"-\" ] = ( a , b ) -> operator - ( a , b ) ;\n  op [ \"*\" ] = ( a , b ) -> operator * ( a , b ) ;\n  op [ \"/\" ] = ( a , b ) -> operator / ( a , b ) ;\n  stack < double > stack ;\n  for ( auto token : tokens ) {\n    if ( double ( token ) == 0.0 ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( string ) token ;\n      double a = ( double ) stack . top ( ) ;\n      double b = ( double ) stack . top ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < double > bin_op = op [ token ] ;\n      c = bin_op ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . top ( ) ;\n}\n"
      ],
      "output": [
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . peek ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . peek ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . pop ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . peek ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . peek ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . pop ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) stack . push ( ( Double ) token ) ;\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . pop ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) stack . push ( ( Double ) token ) ;\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . peek ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) stack . push ( ( Double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . pop ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . pop ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . class . equals ( token ) ) stack . push ( ( Double ) token ) ;\n    else {\n      token = ( String ) token ;\n      Double a = ( Double ) stack . peek ( ) ;\n      Double b = ( Double ) stack . pop ( ) ;\n      Double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . peek ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . peek ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isInfinite ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > bin_op = op . get ( token ) ;\n      c = bin_op . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) stack . push ( ( double ) token ) ;\n    else {\n      token = ( String ) token ;\n      double a = ( double ) stack . pop ( ) ;\n      double b = ( double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( double ) stack . pop ( ) ;\n}\n",
        "public static double rpn_eval ( String [ ] tokens ) {\n  Map < String , BinaryOperator < Double >> op = new HashMap < String , BinaryOperator < Double >> ( ) ;\n  op . put ( \"+\" , ( a , b ) -> a + b ) ;\n  op . put ( \"-\" , ( a , b ) -> a - b ) ;\n  op . put ( \"*\" , ( a , b ) -> a * b ) ;\n  op . put ( \"/\" , ( a , b ) -> a / b ) ;\n  Stack < Double > stack = new Stack < Double > ( ) ;\n  for ( String token : tokens ) {\n    if ( Double . isNaN ( token ) ) {\n      stack . push ( ( Double ) token ) ;\n    }\n    else {\n      token = ( String ) token ;\n      double a = ( Double ) stack . pop ( ) ;\n      double b = ( Double ) stack . pop ( ) ;\n      double c = 0.0 ;\n      BinaryOperator < Double > binOp = op . get ( token ) ;\n      c = binOp . apply ( a , b ) ;\n      stack . push ( c ) ;\n    }\n  }\n  return ( Double ) stack . pop ( ) ;\n}\n"
      ]
    },
    "SHORTEST_PATH_LENGTH": {
      "loc": "38-39",
      "input": "public static int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n                    unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode)))); \n        }\n    }\n    return Integer.MAX_VALUE;\n}",
      "target": "public static int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n                    distance + length_by_edge.get(Arrays.asList(node, nextnode))));\n        }\n    }\n    return Integer.MAX_VALUE;\n}",
      "function range": "10,5-43,5",
      "raw_output": [
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . value . equals ( goalnode . value ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . successors ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Edge ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Edge ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    Integer distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Edge ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortestPathLength ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n"
      ],
      "mid_translation": [
        "int shortest_path_length ( std :: map < std :: vector < Node * > , int > length_by_edge , Node * startnode , Node * goalnode ) {\n  int n = length_by_edge . size ( ) ;\n  std :: map < Node * , int > unvisited_nodes ;\n  std :: set < Node * > visited_nodes ;\n  unvisited_nodes [ startnode ] = 0 ;\n  while ( ! unvisited_nodes . empty ( ) ) {\n    Node * node = get_node_with_min_distance ( unvisited_nodes ) ;\n    int distance = unvisited_nodes [ node ] ;\n    unvisited_nodes . erase ( node ) ;\n    if ( node -> value == goalnode -> value ) return distance ;\n    visited_nodes . insert ( node ) ;\n    for ( Node * nextnode : node -> successors ) {\n      if ( visited_nodes . count ( nextnode ) ) continue ;\n      if ( unvisited_nodes . find ( nextnode ) == unvisited_nodes . end ( ) ) unvisited_nodes [ nextnode ] = INT_MAX ;\n      unvisited_nodes [ nextnode ] = std :: min ( unvisited_nodes [ nextnode ] , unvisited_nodes [ nextnode ] + length_by_edge [ std :: make_pair ( node , nextnode ) ] ) ;\n    }\n  }\n  return INT_MAX ;\n}\n",
        "int shortest_path_length ( std :: map < std :: vector < Node * > , int > & length_by_edge , Node * startnode , Node * goalnode ) {\n  int n = length_by_edge . size ( ) ;\n  std :: map < Node * , int > unvisited_nodes ;\n  std :: set < Node * > visited_nodes ;\n  unvisited_nodes [ startnode ] = 0 ;\n  while ( ! unvisited_nodes . empty ( ) ) {\n    Node * node = get_node_with_min_distance ( unvisited_nodes ) ;\n    int distance = unvisited_nodes [ node ] ;\n    unvisited_nodes . erase ( node ) ;\n    if ( node -> value == goalnode -> value ) return distance ;\n    visited_nodes . insert ( node ) ;\n    for ( Node * nextnode : node -> successors ) {\n      if ( visited_nodes . count ( nextnode ) ) continue ;\n      if ( unvisited_nodes . find ( nextnode ) == unvisited_nodes . end ( ) ) unvisited_nodes [ nextnode ] = INT_MAX ;\n      unvisited_nodes [ nextnode ] = std :: min ( unvisited_nodes [ nextnode ] , unvisited_nodes [ nextnode ] + length_by_edge [ std :: make_pair ( node , nextnode ) ] ) ;\n    }\n  }\n  return INT_MAX ;\n}\n",
        "int shortest_path_length ( std :: map < std :: vector < Node > , int > length_by_edge , Node startnode , Node goalnode ) {\n  int n = length_by_edge . size ( ) ;\n  std :: map < Node , int > unvisited_nodes ;\n  std :: set < Node > visited_nodes ;\n  unvisited_nodes [ startnode ] = 0 ;\n  while ( ! unvisited_nodes . empty ( ) ) {\n    Node node = get_node_with_min_distance ( unvisited_nodes ) ;\n    int distance = unvisited_nodes [ node ] ;\n    unvisited_nodes . erase ( node ) ;\n    if ( node . value == goalnode . value ) return distance ;\n    visited_nodes . insert ( node ) ;\n    for ( Node nextnode : node . successors ) {\n      if ( visited_nodes . count ( nextnode ) ) continue ;\n      if ( unvisited_nodes . find ( nextnode ) == unvisited_nodes . end ( ) ) unvisited_nodes [ nextnode ] = INT_MAX ;\n      unvisited_nodes [ nextnode ] = std :: min ( unvisited_nodes [ nextnode ] , unvisited_nodes [ nextnode ] + length_by_edge [ std :: make_pair ( node , nextnode ) ] ) ;\n    }\n  }\n  return INT_MAX ;\n}\n",
        "int shortest_path_length ( std :: map < std :: vector < Node > , int > & length_by_edge , Node startnode , Node goalnode ) {\n  int n = length_by_edge . size ( ) ;\n  std :: map < Node , int > unvisited_nodes ;\n  std :: set < Node > visited_nodes ;\n  unvisited_nodes [ startnode ] = 0 ;\n  while ( ! unvisited_nodes . empty ( ) ) {\n    Node node = get_node_with_min_distance ( unvisited_nodes ) ;\n    int distance = unvisited_nodes [ node ] ;\n    unvisited_nodes . erase ( node ) ;\n    if ( node . value == goalnode . value ) return distance ;\n    visited_nodes . insert ( node ) ;\n    for ( Node nextnode : node . successors ) {\n      if ( visited_nodes . count ( nextnode ) ) continue ;\n      if ( unvisited_nodes . find ( nextnode ) == unvisited_nodes . end ( ) ) unvisited_nodes [ nextnode ] = INT_MAX ;\n      unvisited_nodes [ nextnode ] = std :: min ( unvisited_nodes [ nextnode ] , unvisited_nodes [ nextnode ] + length_by_edge [ std :: make_pair ( node , nextnode ) ] ) ;\n    }\n  }\n  return INT_MAX ;\n}\n",
        "int shortest_path_length ( std :: map < std :: vector < Node > , int > length_by_edge , Node startnode , Node goalnode ) {\n  int n = length_by_edge . size ( ) ;\n  std :: map < Node , int > unvisited_nodes ;\n  std :: set < Node > visited_nodes ;\n  unvisited_nodes [ startnode ] = 0 ;\n  while ( ! unvisited_nodes . empty ( ) ) {\n    Node node = get_node_with_min_distance ( unvisited_nodes ) ;\n    int distance = unvisited_nodes [ node ] ;\n    unvisited_nodes . erase ( node ) ;\n    if ( node . value == goalnode . value ) return distance ;\n    visited_nodes . insert ( node ) ;\n    for ( Node nextnode : node . successors ) {\n      if ( visited_nodes . count ( nextnode ) ) continue ;\n      if ( unvisited_nodes . find ( nextnode ) == unvisited_nodes . end ( ) ) unvisited_nodes [ nextnode ] = std :: numeric_limits < int > :: max ( ) ;\n      unvisited_nodes [ nextnode ] = std :: min ( unvisited_nodes [ nextnode ] , unvisited_nodes [ nextnode ] + length_by_edge [ std :: make_pair ( node , nextnode ) ] ) ;\n    }\n  }\n  return std :: numeric_limits < int > :: max ( ) ;\n}\n"
      ],
      "output": [
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . value . equals ( goalnode . value ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . successors ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Edge ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Edge ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    Integer distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Edge ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) return distance ;\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) continue ;\n      if ( unvisitedNodes . get ( nextnode ) == null ) unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      unvisitedNodes . get ( nextnode ) = Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Node ( node , nextnode ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n",
        "public static int shortest_path_length ( Map < List < Node > , Integer > lengthByEdge , Node startnode , Node goalnode ) {\n  int n = lengthByEdge . size ( ) ;\n  Map < Node , Integer > unvisitedNodes = new HashMap < Node , Integer > ( ) ;\n  Set < Node > visitedNodes = new HashSet < Node > ( ) ;\n  unvisitedNodes . put ( startnode , 0 ) ;\n  while ( ! unvisitedNodes . isEmpty ( ) ) {\n    Node node = getNodeWithMinDistance ( unvisitedNodes ) ;\n    int distance = unvisitedNodes . get ( node ) ;\n    unvisitedNodes . remove ( node ) ;\n    if ( node . getValue ( ) == goalnode . getValue ( ) ) {\n      return distance ;\n    }\n    visitedNodes . add ( node ) ;\n    for ( Node nextnode : node . getSuccessors ( ) ) {\n      if ( visitedNodes . contains ( nextnode ) ) {\n        continue ;\n      }\n      if ( unvisitedNodes . get ( nextnode ) == null ) {\n        unvisitedNodes . put ( nextnode , Integer . MAX_VALUE ) ;\n      }\n      unvisitedNodes . put ( nextnode , Math . min ( unvisitedNodes . get ( nextnode ) , unvisitedNodes . get ( nextnode ) + lengthByEdge . get ( new Pair < Node , Node > ( node , nextnode ) ) ) ) ;\n    }\n  }\n  return Integer . MAX_VALUE ;\n}\n"
      ]
    },
    "SHORTEST_PATH_LENGTHS": {
      "loc": "37-38",
      "input": "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                             sumLengths(length_by_path.get(Arrays.asList(i,k)),\n                                                        length_by_path.get(Arrays.asList(j,k)))); \n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}",
      "target": "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                             sumLengths(length_by_path.get(Arrays.asList(i,k)),\n                                                        length_by_path.get(Arrays.asList(k,j)))); \n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}",
      "function range": "17,5-43,5",
      "raw_output": [
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge ) ) {\n        lengthByPath . put ( edge , lengthByEdge . get ( edge ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new ArrayList < Integer > ( i , j ) ) , sumLengths ( lengthByPath . get ( new ArrayList < Integer > ( i , k ) ) , lengthByPath . get ( new ArrayList < Integer > ( j , k ) ) ) ) ;\n        lengthByPath . put ( new ArrayList < Integer > ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new ArrayList < Integer > ( i , j ) ) , sumLengths ( lengthByPath . get ( new ArrayList < Integer > ( i , k ) ) , lengthByPath . get ( new ArrayList < Integer > ( j , k ) ) ) ) ;\n        lengthByPath . put ( new ArrayList < Integer > ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge ) ) {\n        lengthByPath . put ( edge , lengthByEdge . get ( edge ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new ArrayList < Integer > ( i , j ) ) , sumLengths ( lengthByPath . get ( new ArrayList < Integer > ( i , k ) ) , lengthByPath . get ( new ArrayList < Integer > ( j , k ) ) ) ) ;\n        lengthByPath . put ( new ArrayList < Integer > ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( List . of ( i , j ) ) , sumLengths ( lengthByPath . get ( List . of ( i , k ) ) , lengthByPath . get ( List . of ( j , k ) ) ) ) ;\n        lengthByPath . put ( List . of ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new ArrayList < Integer > ( i , j ) ) , sumLengths ( lengthByPath . get ( new ArrayList < Integer > ( i , k ) ) , lengthByPath . get ( new ArrayList < Integer > ( j , k ) ) ) ) ;\n        lengthByPath . put ( new ArrayList < Integer > ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( List . of ( i , j ) ) , sumLengths ( lengthByPath . get ( List . of ( i , k ) ) , lengthByPath . get ( List . of ( j , k ) ) ) ) ;\n        lengthByPath . put ( List . of ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortestPathLengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n"
      ],
      "mid_translation": [
        "map < vector < int > , int > shortest_path_lengths ( int numNodes , map < vector < int > , int > length_by_edge ) {\n  map < vector < int > , int > length_by_path ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      vector < int > edge ( std :: begin ( i ) , std :: end ( i ) ) ;\n      if ( i == j ) length_by_path [ edge [ 0 ] ] = 0 ;\n      else if ( length_by_edge . count ( edge [ 0 ] ) > 0 ) length_by_path [ edge [ 0 ] ] = length_by_edge [ edge [ 0 ] ] ;\n      else length_by_path [ edge [ 0 ] ] = INF ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int update_length = min ( length_by_path [ vector < int > ( i , j ) ] , sum_lengths ( length_by_path [ vector < int > ( i , k ) ] , length_by_path [ vector < int > ( j , k ) ] ) ) ;\n        length_by_path [ vector < int > ( i , j ) ] = update_length ;\n      }\n    }\n  }\n  return length_by_path ;\n}\n",
        "map < vector < int > , int > shortest_path_lengths ( int numNodes , map < vector < int > , int > & length_by_edge ) {\n  map < vector < int > , int > length_by_path ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      vector < int > edge ( std :: begin ( i ) , std :: end ( i ) ) ;\n      if ( i == j ) {\n        length_by_path [ edge [ 0 ] ] = 0 ;\n      }\n      else if ( length_by_edge . count ( edge [ 0 ] ) > 0 ) {\n        length_by_path [ edge [ 0 ] ] = length_by_edge [ edge [ 1 ] ] ;\n      }\n      else {\n        length_by_path [ edge [ 0 ] ] = INF ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int update_length = min ( length_by_path [ vector < int > ( i , j ) ] , sum_lengths ( length_by_path [ vector < int > ( i , k ) ] , length_by_path [ vector < int > ( j , k ) ] ) ) ;\n        length_by_path [ vector < int > ( i , j ) ] = update_length ;\n      }\n    }\n  }\n  return length_by_path ;\n}\n",
        "map < vector < int > , int > shortest_path_lengths ( int numNodes , map < vector < int > , int > & length_by_edge ) {\n  map < vector < int > , int > length_by_path ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      vector < int > edge ( std :: begin ( i ) , std :: end ( i ) ) ;\n      if ( i == j ) length_by_path [ edge [ 0 ] ] = 0 ;\n      else if ( length_by_edge . count ( edge [ 0 ] ) > 0 ) length_by_path [ edge [ 0 ] ] = length_by_edge [ edge [ 0 ] ] ;\n      else length_by_path [ edge [ 0 ] ] = INF ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int update_length = min ( length_by_path [ vector < int > ( i , j ) ] , sum_lengths ( length_by_path [ vector < int > ( i , k ) ] , length_by_path [ vector < int > ( j , k ) ] ) ) ;\n        length_by_path [ vector < int > ( i , j ) ] = update_length ;\n      }\n    }\n  }\n  return length_by_path ;\n}\n",
        "map < vector < int > , int > shortest_path_lengths ( int numNodes , map < vector < int > , int > length_by_edge ) {\n  map < vector < int > , int > length_by_path ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      vector < int > edge ( std :: begin ( i ) , std :: end ( i ) ) ;\n      if ( i == j ) {\n        length_by_path [ edge [ 0 ] ] = 0 ;\n      }\n      else if ( length_by_edge . count ( edge [ 0 ] ) > 0 ) {\n        length_by_path [ edge [ 0 ] ] = length_by_edge [ edge [ 1 ] ] ;\n      }\n      else {\n        length_by_path [ edge [ 0 ] ] = INF ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int update_length = min ( length_by_path [ vector < int > ( i , j ) ] , sum_lengths ( length_by_path [ vector < int > ( i , k ) ] , length_by_path [ vector < int > ( j , k ) ] ) ) ;\n        length_by_path [ vector < int > ( i , j ) ] = update_length ;\n      }\n    }\n  }\n  return length_by_path ;\n}\n",
        "map < vector < int > , int > shortest_path_lengths ( int numNodes , map < vector < int > , int > & length_by_edge ) {\n  map < vector < int > , int > length_by_path ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      vector < int > edge ( std :: begin ( i ) , std :: end ( i ) ) ;\n      if ( i == j ) length_by_path [ edge [ 0 ] ] = 0 ;\n      else if ( length_by_edge . count ( edge [ 0 ] ) ) length_by_path [ edge [ 0 ] ] = length_by_edge [ edge [ 1 ] ] ;\n      else length_by_path [ edge [ 0 ] ] = INF ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int update_length = min ( length_by_path [ vector < int > ( i , j ) ] , sum_lengths ( length_by_path [ vector < int > ( i , k ) ] , length_by_path [ vector < int > ( j , k ) ] ) ) ;\n        length_by_path [ vector < int > ( i , j ) ] = update_length ;\n      }\n    }\n  }\n  return length_by_path ;\n}\n"
      ],
      "output": [
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge ) ) {\n        lengthByPath . put ( edge , lengthByEdge . get ( edge ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new ArrayList < Integer > ( i , j ) ) , sumLengths ( lengthByPath . get ( new ArrayList < Integer > ( i , k ) ) , lengthByPath . get ( new ArrayList < Integer > ( j , k ) ) ) ) ;\n        lengthByPath . put ( new ArrayList < Integer > ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new ArrayList < Integer > ( i , j ) ) , sumLengths ( lengthByPath . get ( new ArrayList < Integer > ( i , k ) ) , lengthByPath . get ( new ArrayList < Integer > ( j , k ) ) ) ) ;\n        lengthByPath . put ( new ArrayList < Integer > ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge ) ) {\n        lengthByPath . put ( edge , lengthByEdge . get ( edge ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new ArrayList < Integer > ( i , j ) ) , sumLengths ( lengthByPath . get ( new ArrayList < Integer > ( i , k ) ) , lengthByPath . get ( new ArrayList < Integer > ( j , k ) ) ) ) ;\n        lengthByPath . put ( new ArrayList < Integer > ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 0 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( List . of ( i , j ) ) , sumLengths ( lengthByPath . get ( List . of ( i , k ) ) , lengthByPath . get ( List . of ( j , k ) ) ) ) ;\n        lengthByPath . put ( List . of ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      else lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new ArrayList < Integer > ( i , j ) ) , sumLengths ( lengthByPath . get ( new ArrayList < Integer > ( i , k ) ) , lengthByPath . get ( new ArrayList < Integer > ( j , k ) ) ) ) ;\n        lengthByPath . put ( new ArrayList < Integer > ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( new Integer ( i ) ) , sumLengths ( lengthByPath . get ( new Integer ( i ) ) , lengthByPath . get ( new Integer ( j ) ) ) ) ;\n        lengthByPath . put ( new Integer ( i ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j , k ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( List . of ( i , j ) ) , sumLengths ( lengthByPath . get ( List . of ( i , k ) ) , lengthByPath . get ( List . of ( j , k ) ) ) ) ;\n        lengthByPath . put ( List . of ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n",
        "public static Map < List < Integer > , Integer > shortest_path_lengths ( int numNodes , Map < List < Integer > , Integer > lengthByEdge ) {\n  Map < List < Integer > , Integer > lengthByPath = new HashMap < List < Integer > , Integer > ( ) ;\n  for ( int i = 0 ;\n  i < numNodes ;\n  i ++ ) {\n    for ( int j = 0 ;\n    j < numNodes ;\n    j ++ ) {\n      List < Integer > edge = new ArrayList < Integer > ( Arrays . asList ( i , j ) ) ;\n      if ( i == j ) {\n        lengthByPath . put ( edge . get ( 0 ) , 0 ) ;\n      }\n      else if ( lengthByEdge . containsKey ( edge . get ( 0 ) ) ) {\n        lengthByPath . put ( edge . get ( 0 ) , lengthByEdge . get ( edge . get ( 1 ) ) ) ;\n      }\n      else {\n        lengthByPath . put ( edge . get ( 0 ) , INF ) ;\n      }\n    }\n  }\n  for ( int k = 0 ;\n  k < numNodes ;\n  k ++ ) {\n    for ( int i = 0 ;\n    i < numNodes ;\n    i ++ ) {\n      for ( int j = 0 ;\n      j < numNodes ;\n      j ++ ) {\n        int updateLength = Math . min ( lengthByPath . get ( Arrays . asList ( i , j ) ) , sumLengths ( lengthByPath . get ( Arrays . asList ( i , k ) ) , lengthByPath . get ( Arrays . asList ( j ) ) ) ) ;\n        lengthByPath . put ( Arrays . asList ( i , j ) , updateLength ) ;\n      }\n    }\n  }\n  return lengthByPath ;\n}\n"
      ]
    },
    "SHORTEST_PATHS": {
      "loc": "30-31",
      "input": "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_edge.put(edge, update_weight); \n        }\n    }\n    return weight_by_node;\n}",
      "target": "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min( \n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n}",
      "function range": "16,5-34,5",
      "raw_output": [
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      Integer updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      Integer updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      Integer updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( String edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge ) . intValue ( ) + weightByEdge . get ( edge ) . intValue ( ) , weightByNode . get ( edge ) . intValue ( ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( 0 ) ) + weightByEdge . get ( edge . get ( 1 ) ) , weightByNode . get ( edge . get ( 1 ) ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( 0 ) ) + weightByEdge . get ( edge . get ( 1 ) ) , weightByNode . get ( edge . get ( 1 ) ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( String edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge ) . get ( 0 ) + weightByEdge . get ( edge ) . get ( 1 ) , weightByNode . get ( edge ) . get ( 1 ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( String edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge ) . intValue ( ) + weightByEdge . get ( edge ) . intValue ( ) , weightByNode . get ( edge ) . intValue ( ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortestPaths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( 0 ) ) + weightByEdge . get ( edge . get ( 1 ) ) , weightByNode . get ( edge . get ( 1 ) ) ) ;\n      weightByEdge . put ( edge . get ( 0 ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n"
      ],
      "mid_translation": [
        "map < string , int > shortest_paths ( string source , map < vector < string > , int > weight_by_edge ) {\n  map < string , int > weight_by_node ;\n  for ( vector < string > :: iterator edge = weight_by_edge . begin ( ) ;\n  edge != weight_by_edge . end ( ) ;\n  ++ edge ) {\n    weight_by_node [ edge -> second ] = INF ;\n    weight_by_node [ edge -> first ] = INF ;\n  }\n  weight_by_node [ source ] = 0 ;\n  for ( int i = 0 ;\n  i < weight_by_node . size ( ) ;\n  ++ i ) {\n    for ( vector < string > :: iterator edge = weight_by_edge . begin ( ) ;\n    edge != weight_by_edge . end ( ) ;\n    ++ edge ) {\n      int update_weight = min ( weight_by_node [ edge -> first ] + weight_by_edge [ edge -> second ] , weight_by_node [ edge -> second ] ) ;\n      weight_by_edge [ edge -> first ] = update_weight ;\n    }\n  }\n  return weight_by_node ;\n}\n",
        "map < string , int > shortest_paths ( string source , map < vector < string > , int > weight_by_edge ) {\n  map < string , int > weight_by_node ;\n  for ( vector < string > :: iterator edge = weight_by_edge . begin ( ) ;\n  edge != weight_by_edge . end ( ) ;\n  edge ++ ) {\n    weight_by_node [ edge -> second ] = INF ;\n    weight_by_node [ edge -> first ] = INF ;\n  }\n  weight_by_node [ source ] = 0 ;\n  for ( int i = 0 ;\n  i < weight_by_node . size ( ) ;\n  i ++ ) {\n    for ( vector < string > :: iterator edge = weight_by_edge . begin ( ) ;\n    edge != weight_by_edge . end ( ) ;\n    edge ++ ) {\n      int update_weight = min ( weight_by_node [ edge -> first ] + weight_by_edge [ edge -> second ] , weight_by_node [ edge -> second ] ) ;\n      weight_by_edge [ edge -> first ] = update_weight ;\n    }\n  }\n  return weight_by_node ;\n}\n",
        "map < string , int > shortest_paths ( string source , map < list < string > , int > weight_by_edge ) {\n  map < string , int > weight_by_node ;\n  for ( list < string > :: iterator edge = weight_by_edge . begin ( ) ;\n  edge != weight_by_edge . end ( ) ;\n  ++ edge ) {\n    weight_by_node [ edge -> second ] = INF ;\n    weight_by_node [ edge -> first ] = INF ;\n  }\n  weight_by_node [ source ] = 0 ;\n  for ( int i = 0 ;\n  i < weight_by_node . size ( ) ;\n  ++ i ) {\n    for ( list < string > :: iterator edge = weight_by_edge . begin ( ) ;\n    edge != weight_by_edge . end ( ) ;\n    ++ edge ) {\n      int update_weight = min ( weight_by_node [ edge -> first ] + weight_by_edge [ edge -> second ] , weight_by_node [ edge -> second ] ) ;\n      weight_by_edge [ edge -> first ] = update_weight ;\n    }\n  }\n  return weight_by_node ;\n}\n",
        "map < string , int > shortest_paths ( string source , map < vector < string > , int > weight_by_edge ) {\n  map < string , int > weight_by_node ;\n  for ( auto edge : weight_by_edge ) {\n    weight_by_node [ edge [ 1 ] ] = INF ;\n    weight_by_node [ edge [ 0 ] ] = INF ;\n  }\n  weight_by_node [ source ] = 0 ;\n  for ( int i = 0 ;\n  i < weight_by_node . size ( ) ;\n  i ++ ) {\n    for ( auto edge : weight_by_edge ) {\n      int update_weight = min ( weight_by_node [ edge [ 0 ] ] + weight_by_edge [ edge [ 1 ] ] , weight_by_node [ edge [ 1 ] ] ) ;\n      weight_by_edge [ edge ] = update_weight ;\n    }\n  }\n  return weight_by_node ;\n}\n",
        "map < string , int > shortest_paths ( string source , map < vector < string > , int > weight_by_edge ) {\n  map < string , int > weight_by_node ;\n  for ( vector < string > :: iterator edge = weight_by_edge . begin ( ) ;\n  edge != weight_by_edge . end ( ) ;\n  ++ edge ) {\n    weight_by_node [ edge -> second ] = INF ;\n    weight_by_node [ edge -> first ] = INF ;\n  }\n  weight_by_node [ source ] = 0 ;\n  for ( int i = 0 ;\n  i < weight_by_node . size ( ) ;\n  ++ i ) {\n    for ( vector < string > :: iterator edge = weight_by_edge . begin ( ) ;\n    edge != weight_by_edge . end ( ) ;\n    ++ edge ) {\n      int update_weight = min ( weight_by_node [ edge -> first ] + weight_by_edge [ edge -> second ] , weight_by_node [ edge -> second ] ) ;\n      weight_by_edge [ edge -> first ] += update_weight ;\n    }\n  }\n  return weight_by_node ;\n}\n"
      ],
      "output": [
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      Integer updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      Integer updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      Integer updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( String edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge ) . intValue ( ) + weightByEdge . get ( edge ) . intValue ( ) , weightByNode . get ( edge ) . intValue ( ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( 0 ) ) + weightByEdge . get ( edge . get ( 1 ) ) , weightByNode . get ( edge . get ( 1 ) ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( 0 ) ) + weightByEdge . get ( edge . get ( 1 ) ) , weightByNode . get ( edge . get ( 1 ) ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( String edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge ) . get ( 0 ) + weightByEdge . get ( edge ) . get ( 1 ) , weightByNode . get ( edge ) . get ( 1 ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( String edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge ) . intValue ( ) + weightByEdge . get ( edge ) . intValue ( ) , weightByNode . get ( edge ) . intValue ( ) ) ;\n      weightByEdge . put ( edge , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( i ) ) + weightByEdge . get ( edge . get ( i + 1 ) ) , weightByNode . get ( edge . get ( i ) ) ) ;\n      weightByEdge . put ( edge . get ( i ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n",
        "public static Map < String , Integer > shortest_paths ( String source , Map < List < String > , Integer > weightByEdge ) {\n  Map < String , Integer > weightByNode = new HashMap < String , Integer > ( ) ;\n  for ( List < String > edge : weightByEdge . keySet ( ) ) {\n    weightByNode . put ( edge . get ( 1 ) , INF ) ;\n    weightByNode . put ( edge . get ( 0 ) , INF ) ;\n  }\n  weightByNode . put ( source , 0 ) ;\n  for ( int i = 0 ;\n  i < weightByNode . size ( ) ;\n  i ++ ) {\n    for ( List < String > edge : weightByEdge . keySet ( ) ) {\n      int updateWeight = Math . min ( weightByNode . get ( edge . get ( 0 ) ) + weightByEdge . get ( edge . get ( 1 ) ) , weightByNode . get ( edge . get ( 1 ) ) ) ;\n      weightByEdge . put ( edge . get ( 0 ) , updateWeight ) ;\n    }\n  }\n  return weightByNode ;\n}\n"
      ]
    },
    "SHUNTING_YARD": {
      "loc": "32-32",
      "input": "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            } \n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}",
      "target": "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\", 1);\n    precedence.put(\"-\", 1);\n    precedence.put(\"*\", 2);\n    precedence.put(\"/\", 2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token : tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop()); \n            }\n            opstack.push(token);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}",
      "function range": "14,5-41,5",
      "raw_output": [
        "public static int [ ] shuntingYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27",
        "public static int [ ] shuntingYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ] ;\n}\n",
        "public static int [ ] shuntingYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ] ;\n  return",
        "public static int [ ] shuntYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ]",
        "public static int [ ] shuntingYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . get ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . get ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static List < Integer > shuntingYard ( List < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  List < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  List < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static List < Integer > shuntingYard ( List < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  List < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  List < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static int [ ] shuntingYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27",
        "public static int [ ] shuntingYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ] ;\n}\n",
        "public static int [ ] shuntYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ]",
        "public static int [ ] shuntingYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ] ;\n  return",
        "public static int [ ] shuntingYard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  return rpntokens ;\n}\n",
        "public static int [ ] shuntingYard ( String [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static int [ ] shuntingYard ( String [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shuntingYard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n"
      ],
      "mid_translation": [
        "vector < int > shunting_yard ( vector < int > tokens ) {\n  map < string , int > precedence ;\n  precedence [ \"+\" ] = 1 ;\n  precedence [ \"-\" ] = 1 ;\n  precedence [ \"*\" ] = 2 ;\n  precedence [ \"/\" ] = 2 ;\n  vector < int > rpntokens ;\n  rpntokens . reserve ( 100 ) ;\n  vector < string > opstack ;\n  for ( auto token : tokens ) {\n    if ( int ( token ) == 0 ) rpntokens . push_back ( ( int ) token ) ;\n    else {\n      string operator = ( string ) token ;\n      while ( ! opstack . empty ( ) && precedence [ operator ] <= precedence [ opstack . back ( ) ] ) rpntokens . push_back ( opstack . back ( ) ) ;\n    }\n  }\n  while ( ! opstack . empty ( ) ) rpntokens . push_back ( opstack . back ( ) ) ;\n  return rpntokens ;\n}\n",
        "vector < int > shunting_yard ( vector < string > tokens ) {\n  map < string , int > precedence = {\n    {\n      \"+\" , 1 }\n      , {\n        \"-\" , 1 }\n        , {\n          \"*\" , 2 }\n          , {\n            \"/\" , 2 }\n          }\n          ;\n          vector < int > rpntokens ;\n          rpntokens . reserve ( 100 ) ;\n          vector < string > opstack ;\n          for ( auto token : tokens ) {\n            if ( int ( token ) == 0 ) rpntokens . push_back ( ( int ) token ) ;\n            else {\n              string operator = ( token ) ;\n              while ( ! opstack . empty ( ) && precedence [ operator ] <= precedence [ opstack . back ( ) ] ) rpntokens . push_back ( opstack . back ( ) ) ;\n            }\n          }\n          while ( ! opstack . empty ( ) ) rpntokens . push_back ( opstack . back ( ) ) ;\n          return rpntokens ;\n        }\n        ",
        "vector < int > shunting_yard ( vector < int > tokens ) {\n  map < string , int > precedence = {\n    {\n      \"+\" , 1 }\n      , {\n        \"-\" , 1 }\n        , {\n          \"*\" , 2 }\n          , {\n            \"/\" , 2 }\n          }\n          ;\n          vector < int > rpntokens ;\n          rpntokens . reserve ( 100 ) ;\n          vector < string > opstack ;\n          for ( auto token : tokens ) {\n            if ( int ( token ) == 0 ) {\n              rpntokens . push_back ( ( int ) token ) ;\n            }\n            else {\n              string operator = ( string ) token ;\n              while ( ! opstack . empty ( ) && precedence [ operator ] <= precedence [ opstack . back ( ) ] ) {\n                rpntokens . push_back ( opstack . back ( ) ) ;\n              }\n            }\n          }\n          while ( ! opstack . empty ( ) ) {\n            rpntokens . push_back ( opstack . back ( ) ) ;\n          }\n          return rpntokens ;\n        }\n        ",
        "vector < int > shunting_yard ( vector < string > tokens ) {\n  map < string , int > precedence = {\n    {\n      \"+\" , 1 }\n      , {\n        \"-\" , 1 }\n        , {\n          \"*\" , 2 }\n          , {\n            \"/\" , 2 }\n          }\n          ;\n          vector < int > rpntokens ;\n          rpntokens . reserve ( 100 ) ;\n          vector < string > opstack ;\n          for ( auto token : tokens ) {\n            if ( int ( token ) == 0 ) {\n              rpntokens . push_back ( ( int ) token ) ;\n            }\n            else {\n              string operator = ( string ) token ;\n              while ( ! opstack . empty ( ) && precedence [ operator ] <= precedence [ opstack . back ( ) ] ) {\n                rpntokens . push_back ( opstack . back ( ) ) ;\n              }\n            }\n          }\n          while ( ! opstack . empty ( ) ) {\n            rpntokens . push_back ( opstack . back ( ) ) ;\n          }\n          return rpntokens ;\n        }\n        ",
        "vector < int > shunting_yard ( vector < string > tokens ) {\n  map < string , int > precedence = {\n    {\n      \"+\" , 1 }\n      , {\n        \"-\" , 1 }\n        , {\n          \"*\" , 2 }\n          , {\n            \"/\" , 2 }\n          }\n          ;\n          vector < int > rpntokens ( 100 ) ;\n          vector < string > opstack ;\n          for ( auto token : tokens ) {\n            if ( int ( token ) == 0 ) {\n              rpntokens . push_back ( ( int ) token ) ;\n            }\n            else {\n              string operator = ( string ) token ;\n              while ( ! opstack . empty ( ) && precedence [ operator ] <= precedence [ opstack . back ( ) ] ) {\n                rpntokens . push_back ( opstack . back ( ) ) ;\n              }\n            }\n          }\n          while ( ! opstack . empty ( ) ) {\n            rpntokens . push_back ( opstack . back ( ) ) ;\n          }\n          return rpntokens ;\n        }\n        "
      ],
      "output": [
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27",
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ] ;\n}\n",
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ] ;\n  return",
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ]",
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . get ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . get ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static List < Integer > shunting_yard ( List < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  List < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  List < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static List < Integer > shunting_yard ( List < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  List < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  List < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27",
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ] ;\n}\n",
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ]",
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27 ] ;\n  return",
        "public static int [ ] shunting_yard ( int [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  return rpntokens ;\n}\n",
        "public static int [ ] shunting_yard ( String [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  rpntokens [ 27 ] = ( int ) tokens [ 27",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static int [ ] shunting_yard ( String [ ] tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  int [ ] rpntokens = new int [ 100 ] ;\n  rpntokens [ 0 ] = ( int ) tokens [ 0 ] ;\n  rpntokens [ 1 ] = ( int ) tokens [ 1 ] ;\n  rpntokens [ 2 ] = ( int ) tokens [ 2 ] ;\n  rpntokens [ 3 ] = ( int ) tokens [ 3 ] ;\n  rpntokens [ 4 ] = ( int ) tokens [ 4 ] ;\n  rpntokens [ 5 ] = ( int ) tokens [ 5 ] ;\n  rpntokens [ 6 ] = ( int ) tokens [ 6 ] ;\n  rpntokens [ 7 ] = ( int ) tokens [ 7 ] ;\n  rpntokens [ 8 ] = ( int ) tokens [ 8 ] ;\n  rpntokens [ 9 ] = ( int ) tokens [ 9 ] ;\n  rpntokens [ 10 ] = ( int ) tokens [ 10 ] ;\n  rpntokens [ 11 ] = ( int ) tokens [ 11 ] ;\n  rpntokens [ 12 ] = ( int ) tokens [ 12 ] ;\n  rpntokens [ 13 ] = ( int ) tokens [ 13 ] ;\n  rpntokens [ 14 ] = ( int ) tokens [ 14 ] ;\n  rpntokens [ 15 ] = ( int ) tokens [ 15 ] ;\n  rpntokens [ 16 ] = ( int ) tokens [ 16 ] ;\n  rpntokens [ 17 ] = ( int ) tokens [ 17 ] ;\n  rpntokens [ 18 ] = ( int ) tokens [ 18 ] ;\n  rpntokens [ 19 ] = ( int ) tokens [ 19 ] ;\n  rpntokens [ 20 ] = ( int ) tokens [ 20 ] ;\n  rpntokens [ 21 ] = ( int ) tokens [ 21 ] ;\n  rpntokens [ 22 ] = ( int ) tokens [ 22 ] ;\n  rpntokens [ 23 ] = ( int ) tokens [ 23 ] ;\n  rpntokens [ 24 ] = ( int ) tokens [ 24 ] ;\n  rpntokens [ 25 ] = ( int ) tokens [ 25 ] ;\n  rpntokens [ 26 ] = ( int ) tokens [ 26 ] ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . contains ( operator ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) rpntokens . add ( ( Integer ) token ) ;\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  return rpntokens ;\n}\n",
        "public static ArrayList < Integer > shunting_yard ( ArrayList < String > tokens ) {\n  Map < String , Integer > precedence = new HashMap < String , Integer > ( ) ;\n  precedence . put ( \"+\" , 1 ) ;\n  precedence . put ( \"-\" , 1 ) ;\n  precedence . put ( \"*\" , 2 ) ;\n  precedence . put ( \"/\" , 2 ) ;\n  ArrayList < Integer > rpntokens = new ArrayList < Integer > ( 100 ) ;\n  ArrayList < String > opstack = new ArrayList < String > ( ) ;\n  for ( String token : tokens ) {\n    if ( Integer . parseInt ( token ) == 0 ) {\n      rpntokens . add ( ( Integer ) token ) ;\n    }\n    else {\n      String operator = ( String ) token ;\n      while ( ! opstack . isEmpty ( ) && precedence . get ( operator ) <= precedence . get ( opstack . get ( opstack . size ( ) - 1 ) ) ) {\n        rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n      }\n    }\n  }\n  while ( ! opstack . isEmpty ( ) ) {\n    rpntokens . add ( opstack . remove ( opstack . size ( ) - 1 ) ) ;\n  }\n  return rpntokens ;\n}\n"
      ]
    },
    "SIEVE": {
      "loc": "41-42",
      "input": "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n        if (any(list_comp(n, primes))) { \n            primes.add(n);\n        }\n    }\n    return primes;\n}",
      "target": "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n        if (all(list_comp(n, primes))) { \n            primes.add(n);\n        }\n    }\n    return primes;\n}",
      "function range": "38,5-46,5",
      "raw_output": [
        "public static ArrayList < Integer > sieve ( int max ) {\n  ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . isPrime ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static ArrayList < Integer > sieve ( int max ) {\n  ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( CollectionUtils . isPrime ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Objects . nonNull ( listComp ( n , primes ) ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . isPrime ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static ArrayList < Integer > sieve ( int max ) {\n  ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Objects . nonNull ( listComp ( n , primes ) ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . isPrime ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n ) , primes ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n"
      ],
      "mid_translation": [
        "vector < int > sieve ( int max ) {\n  vector < int > primes ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( any ( list_comp ( n , primes ) ) ) primes . push_back ( n ) ;\n  }\n  return primes ;\n}\n",
        "vector < int > sieve ( int max ) {\n  vector < int > primes ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( any ( list_comp ( n , primes ) ) ) primes . push_back ( n ) ;\n  }\n  return primes ;\n}\n",
        "public : vector < int > sieve ( int max ) {\n  vector < int > primes ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( any ( list_comp ( n , primes ) ) ) primes . push_back ( n ) ;\n  }\n  return primes ;\n}\n",
        "vector < int > sieve ( int max ) {\n  vector < int > primes ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( any ( list_comp ( n , primes ) ) ) primes . emplace_back ( n ) ;\n  }\n  return primes ;\n}\n",
        "public : vector < int > sieve ( int max ) {\n  vector < int > primes ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( any ( list_comp ( n , primes ) ) ) primes . push_back ( n ) ;\n  }\n  return primes ;\n}\n"
      ],
      "output": [
        "public static ArrayList < Integer > sieve ( int max ) {\n  ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . isPrime ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static ArrayList < Integer > sieve ( int max ) {\n  ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( CollectionUtils . isPrime ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Objects . nonNull ( listComp ( n , primes ) ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . isPrime ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static ArrayList < Integer > sieve ( int max ) {\n  ArrayList < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Objects . nonNull ( listComp ( n , primes ) ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . isPrime ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  n ++ ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static List < Integer > sieve ( int max ) {\n  List < Integer > primes = new ArrayList < Integer > ( ) ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( CollectionUtils . listComp ( n , primes ) ) {\n      primes . add ( n ) ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max + 1 ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n ) , primes ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n",
        "public static int [ ] sieve ( int max ) {\n  int [ ] primes = new int [ max + 1 ] ;\n  for ( int n = 2 ;\n  n < max ;\n  ++ n ) {\n    if ( Arrays . binarySearch ( listComp ( n , primes ) , n ) >= 0 ) {\n      primes [ n ] = n ;\n    }\n  }\n  return primes ;\n}\n"
      ]
    },
    "SQRT": {
      "loc": "16-17",
      "input": "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2d;\n    while (Math.abs(x-approx) > epsilon) { \n        approx = 0.5d * (approx + x / approx);\n    }\n    return approx;\n}",
      "target": "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2d;\n    while (Math.abs(x-approx*approx) > epsilon) { \n        approx = 0.5d * (approx + x / approx);\n    }\n    return approx;\n}",
      "function range": "14,5-20,5",
      "raw_output": [
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 ;\n  while ( Math . abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( FastMath . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon = 0.000001 ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n"
      ],
      "mid_translation": [
        "double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( fabs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( fabs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( std :: abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "double sqrt ( double x , double epsilon = 0.000001 ) {\n  double approx = x / 2 d ;\n  while ( fabs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n"
      ],
      "output": [
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 ;\n  while ( Math . abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) approx = 0.5d * ( approx + x / approx ) ;\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( FastMath . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon = 0.000001 ) {\n  double approx = x / 2 d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 . d ;\n  while ( Math . abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n",
        "public static double sqrt ( double x , double epsilon ) {\n  double approx = x / 2 d ;\n  while ( abs ( x - approx ) > epsilon ) {\n    approx = 0.5d * ( approx + x / approx ) ;\n  }\n  return approx ;\n}\n"
      ]
    },
    "SUBSEQUENCES": {
      "loc": "16-17",
      "input": "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        return new ArrayList(); \n    }\n    ArrayList ret = new ArrayList(50);\n    for (int i=a; i<b+1-k; i++) {\n        ArrayList base = new ArrayList(50);\n        for (ArrayList rest : subsequences(i+1, b, k-1)) {\n            rest.add(0,i);\n            base.add(rest);\n        }\n        ret.addAll(base);\n    }\n    return ret;\n}",
      "target": "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList empty_set = new ArrayList<ArrayList>(); \n        empty_set.add(new ArrayList());\n        return empty_set;\n    }\n    ArrayList ret = new ArrayList(50);\n    for (int i=a; i<b+1-k; i++) {\n        ArrayList base = new ArrayList(50);\n        for (ArrayList rest : subsequences(i+1, b, k-1)) {\n            rest.add(0,i);\n            base.add(rest);\n        }\n        ret.addAll(base);\n    }\n    return ret;\n}",
      "function range": "14,5-31,5",
      "raw_output": [
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < List < Integer >> ( ) ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < > ( ) ;\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < List < Integer >> ( ) ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < ArrayList < Integer >> ( ) ;\n  ArrayList < ArrayList < Integer >> ret = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    ArrayList < ArrayList < Integer >> base = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n    for ( ArrayList < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < ArrayList < Integer >> ( ) ;\n  }\n  ArrayList < ArrayList < Integer >> ret = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    ArrayList < ArrayList < Integer >> base = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n    for ( ArrayList < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < ArrayList < Integer >> ( ) ;\n  }\n  ArrayList < ArrayList < Integer >> ret = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    ArrayList < ArrayList < Integer >> base = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n    for ( ArrayList < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return null ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return null ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return Collections . emptyList ( ) ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return null ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < List < Integer >> ( ) ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n"
      ],
      "mid_translation": [
        "vector < vector < int >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return {\n  }\n  ;\n  vector < vector < int >> ret ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    vector < vector < int >> base ( 50 ) ;\n    for ( vector < int > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . emplace_back ( 0 , i ) ;\n      base . emplace_back ( rest ) ;\n    }\n    ret . insert ( ret . end ( ) , base . begin ( ) , base . end ( ) ) ;\n  }\n  return ret ;\n}\n",
        "vector < vector < int >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return {\n    }\n    ;\n  }\n  vector < vector < int >> ret ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    vector < vector < int >> base ( 50 ) ;\n    for ( vector < int > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . emplace_back ( 0 , i ) ;\n      base . emplace_back ( rest ) ;\n    }\n    ret . insert ( ret . end ( ) , base . begin ( ) , base . end ( ) ) ;\n  }\n  return ret ;\n}\n",
        "vector < vector < int >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return {\n    }\n    ;\n  }\n  vector < vector < int >> ret ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    vector < vector < int >> base ( 50 ) ;\n    for ( vector < int > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . insert ( 0 , i ) ;\n      base . push_back ( rest ) ;\n    }\n    ret . insert ( ret . end ( ) , base . begin ( ) , base . end ( ) ) ;\n  }\n  return ret ;\n}\n",
        "vector < vector < int >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return {\n    }\n    ;\n  }\n  vector < vector < int >> ret ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    vector < vector < int >> base ( 50 ) ;\n    for ( auto rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . emplace_back ( 0 , i ) ;\n      base . emplace_back ( rest ) ;\n    }\n    ret . insert ( ret . end ( ) , base . begin ( ) , base . end ( ) ) ;\n  }\n  return ret ;\n}\n",
        "vector < vector < int >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return vector < vector < int >> ( ) ;\n  vector < vector < int >> ret ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    vector < vector < int >> base ( 50 ) ;\n    for ( vector < int > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . emplace_back ( 0 , i ) ;\n      base . emplace_back ( rest ) ;\n    }\n    ret . insert ( ret . end ( ) , base . begin ( ) , base . end ( ) ) ;\n  }\n  return ret ;\n}\n"
      ],
      "output": [
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < List < Integer >> ( ) ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < > ( ) ;\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < List < Integer >> ( ) ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < ArrayList < Integer >> ( ) ;\n  ArrayList < ArrayList < Integer >> ret = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    ArrayList < ArrayList < Integer >> base = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n    for ( ArrayList < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < ArrayList < Integer >> ( ) ;\n  }\n  ArrayList < ArrayList < Integer >> ret = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    ArrayList < ArrayList < Integer >> base = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n    for ( ArrayList < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    throw new IllegalArgumentException ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < List < Integer >> ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < > ( ) ;\n  }\n  List < List < Integer >> ret = new ArrayList < > ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < > ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static ArrayList < ArrayList < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return new ArrayList < ArrayList < Integer >> ( ) ;\n  }\n  ArrayList < ArrayList < Integer >> ret = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    ArrayList < ArrayList < Integer >> base = new ArrayList < ArrayList < Integer >> ( 50 ) ;\n    for ( ArrayList < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return null ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return null ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . set ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return Collections . emptyList ( ) ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) {\n    return null ;\n  }\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n",
        "public static List < List < Integer >> subsequences ( int a , int b , int k ) {\n  if ( k == 0 ) return new ArrayList < List < Integer >> ( ) ;\n  List < List < Integer >> ret = new ArrayList < List < Integer >> ( 50 ) ;\n  for ( int i = a ;\n  i < b + 1 - k ;\n  i ++ ) {\n    List < List < Integer >> base = new ArrayList < List < Integer >> ( 50 ) ;\n    for ( List < Integer > rest : subsequences ( i + 1 , b , k - 1 ) ) {\n      rest . add ( 0 , i ) ;\n      base . add ( rest ) ;\n    }\n    ret . addAll ( base ) ;\n  }\n  return ret ;\n}\n"
      ]
    },
    "TO_BASE": {
      "loc": "21-22",
      "input": "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = result + String.valueOf(alphabet.charAt(i)); \n    }\n    return result;\n}",
      "target": "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = String.valueOf(alphabet.charAt(i))+result; \n    }\n    return result;\n}",
      "function range": "14,5-25,5",
      "raw_output": [
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . format ( alphabet , i ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet [ i ] , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet . charAt ( i ) , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  StringBuffer sb = new StringBuffer ( ) ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    sb . append ( alphabet . charAt ( i ) ) ;\n  }\n  return sb . toString ( ) ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  StringBuilder sb = new StringBuilder ( ) ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    sb . append ( alphabet . charAt ( i ) ) ;\n  }\n  return sb . toString ( ) ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . format ( alphabet , i ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . format ( alphabet , i ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet [ i ] , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet . charAt ( i ) , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  StringBuffer sb = new StringBuffer ( ) ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    sb . append ( alphabet . charAt ( i ) ) ;\n  }\n  return sb . toString ( ) ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  StringBuilder sb = new StringBuilder ( ) ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    sb . append ( alphabet . charAt ( i ) ) ;\n  }\n  return sb . toString ( ) ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . format ( alphabet , i ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet [ i ] , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet . charAt ( i ) , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String toBase ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n"
      ],
      "mid_translation": [
        "public : string to_base ( int num , int b ) {\n  string result = \"\" ;\n  string alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + string ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public : string to_base ( int num , int b ) {\n  string result ;\n  string alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + string ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "string to_base ( int num , int b ) {\n  string result = \"\" ;\n  string alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + string ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "string to_base ( int num , int b ) {\n  string result ;\n  string alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + string ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public : string to_base ( int num , int b ) {\n  string result = \"\" ;\n  string alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + to_string ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n"
      ],
      "output": [
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . format ( alphabet , i ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet [ i ] , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet . charAt ( i ) , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  StringBuffer sb = new StringBuffer ( ) ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    sb . append ( alphabet . charAt ( i ) ) ;\n  }\n  return sb . toString ( ) ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  StringBuilder sb = new StringBuilder ( ) ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    sb . append ( alphabet . charAt ( i ) ) ;\n  }\n  return sb . toString ( ) ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . format ( alphabet , i ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . format ( alphabet , i ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet [ i ] , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet . charAt ( i ) , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  StringBuffer sb = new StringBuffer ( ) ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    sb . append ( alphabet . charAt ( i ) ) ;\n  }\n  return sb . toString ( ) ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  StringBuilder sb = new StringBuilder ( ) ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    sb . append ( alphabet . charAt ( i ) ) ;\n  }\n  return sb . toString ( ) ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . format ( alphabet , i ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet [ i ] ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet [ i ] , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + Integer . toString ( alphabet . charAt ( i ) , 16 ) ;\n  }\n  return result ;\n}\n",
        "public static String to_base ( int num , int b ) {\n  String result = \"\" ;\n  String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ;\n  int i ;\n  while ( num > 0 ) {\n    i = num % b ;\n    num = num / b ;\n    result = result + String . valueOf ( alphabet . charAt ( i ) ) ;\n  }\n  return result ;\n}\n"
      ]
    },
    "TOPOLOGICAL_ORDERING": {
      "loc": "17-18",
      "input": "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) { \n                orderedNodes.add(nextNode);\n                listSize++;\n            }\n        }\n    }\n    return orderedNodes;\n}",
      "target": "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i); \n        for (Node nextNode : node.getSuccessors()) {\n            if (orderedNodes.containsAll(nextNode.getPredecessors()) && !orderedNodes.contains(nextNode)) {\n                orderedNodes.add(nextNode);\n                listSize++;\n            }\n        }\n    }\n    return orderedNodes;\n}",
      "function range": "5,5-24,5",
      "raw_output": [
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . predecessors . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . predecessors . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . predecessors ) && ! orderedNodes . contains ( nextNode . predecessors ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . successors . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . successors . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessor ( ) ) && ! orderedNodes . contains ( nextNode . getSuccessor ( ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( listSize - 1 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessorsList ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessorsList ( ) . get ( listSize - 1 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( listSize - 1 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessorsList ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessorsList ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . predecessors ) && ! orderedNodes . contains ( nextNode . predecessors ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . predecessors ) && ! orderedNodes . contains ( nextNode . predecessors ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topologicalOrdering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topologicalOrdering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n"
      ],
      "mid_translation": [
        "vector < Node * > topological_ordering ( const vector < Node * > & directed_graph ) {\n  vector < Node * > ordered_nodes ;\n  for ( Node * node : directed_graph ) {\n    if ( node -> predecessors . empty ( ) ) ordered_nodes . push_back ( node ) ;\n  }\n  int list_size = ordered_nodes . size ( ) ;\n  for ( int i = 0 ;\n  i < list_size ;\n  i ++ ) {\n    Node * node = ordered_nodes [ i ] ;\n    for ( Node * nextNode = node -> successors . begin ( ) ;\n    nextNode != node -> successors . end ( ) ;\n    nextNode ++ ) {\n      if ( ordered_nodes . count ( nextNode -> successors . begin ( ) ) && ! ordered_nodes . count ( nextNode -> successors . end ( ) ) ) {\n        ordered_nodes . push_back ( nextNode ) ;\n        list_size ++ ;\n      }\n    }\n  }\n  return ordered_nodes ;\n}\n",
        "vector < Node * > topological_ordering ( const vector < Node * > & directed_graph ) {\n  vector < Node * > ordered_nodes ;\n  for ( Node * node : directed_graph ) {\n    if ( node -> predecessors . empty ( ) ) ordered_nodes . push_back ( node ) ;\n  }\n  int list_size = ordered_nodes . size ( ) ;\n  for ( int i = 0 ;\n  i < list_size ;\n  i ++ ) {\n    Node * node = ordered_nodes [ i ] ;\n    for ( Node * nextNode = node -> successors . begin ( ) ;\n    nextNode != node -> successors . end ( ) ;\n    nextNode ++ ) {\n      if ( ordered_nodes . count ( nextNode -> predecessors . begin ( ) ) && ! ordered_nodes . count ( nextNode -> predecessors . end ( ) ) ) {\n        ordered_nodes . push_back ( nextNode ) ;\n        list_size ++ ;\n      }\n    }\n  }\n  return ordered_nodes ;\n}\n",
        "vector < Node * > topological_ordering ( vector < Node * > directed_graph ) {\n  vector < Node * > ordered_nodes ;\n  for ( Node * node : directed_graph ) {\n    if ( node -> predecessors . empty ( ) ) ordered_nodes . push_back ( node ) ;\n  }\n  int list_size = ordered_nodes . size ( ) ;\n  for ( int i = 0 ;\n  i < list_size ;\n  i ++ ) {\n    Node * node = ordered_nodes [ i ] ;\n    for ( Node * nextNode = node -> successors . begin ( ) ;\n    nextNode != node -> successors . end ( ) ;\n    nextNode ++ ) {\n      if ( ordered_nodes . count ( nextNode -> successors . begin ( ) ) && ! ordered_nodes . count ( nextNode -> successors . end ( ) ) ) {\n        ordered_nodes . push_back ( nextNode ) ;\n        list_size ++ ;\n      }\n    }\n  }\n  return ordered_nodes ;\n}\n",
        "vector < Node * > topological_ordering ( const vector < Node * > & directed_graph ) {\n  vector < Node * > ordered_nodes ;\n  for ( Node * node : directed_graph ) {\n    if ( node -> predecessors . empty ( ) ) ordered_nodes . push_back ( node ) ;\n  }\n  int list_size = ordered_nodes . size ( ) ;\n  for ( int i = 0 ;\n  i < list_size ;\n  i ++ ) {\n    Node * node = ordered_nodes [ i ] ;\n    for ( Node * nextNode = node -> successors . back ( ) ;\n    nextNode != NULL ;\n    nextNode = nextNode -> successors . back ( ) ) {\n      if ( ordered_nodes . count ( nextNode -> successors . back ( ) ) && ! ordered_nodes . count ( nextNode ) ) {\n        ordered_nodes . push_back ( nextNode ) ;\n        list_size ++ ;\n      }\n    }\n  }\n  return ordered_nodes ;\n}\n",
        "vector < Node * > topological_ordering ( const vector < Node * > & directed_graph ) {\n  vector < Node * > ordered_nodes ;\n  for ( Node * node : directed_graph ) {\n    if ( node -> predecessors . empty ( ) ) ordered_nodes . push_back ( node ) ;\n  }\n  int list_size = ordered_nodes . size ( ) ;\n  for ( int i = 0 ;\n  i < list_size ;\n  i ++ ) {\n    Node * node = ordered_nodes [ i ] ;\n    for ( Node * nextNode = node -> successors . begin ( ) ;\n    nextNode != node -> successors . end ( ) ;\n    nextNode ++ ) {\n      if ( ordered_nodes . count ( nextNode -> predecessors ) && ! ordered_nodes . count ( nextNode -> predecessors ) ) {\n        ordered_nodes . push_back ( nextNode ) ;\n        list_size ++ ;\n      }\n    }\n  }\n  return ordered_nodes ;\n}\n"
      ],
      "output": [
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( List < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( List < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . predecessors . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . predecessors . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . predecessors ) && ! orderedNodes . contains ( nextNode . predecessors ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . successors . get ( 0 ) ) && ! orderedNodes . contains ( nextNode . successors . get ( 1 ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessor ( ) ) && ! orderedNodes . contains ( nextNode . getSuccessor ( ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( listSize - 1 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessorsList ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessorsList ( ) . get ( listSize - 1 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessors ( ) . get ( listSize - 1 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessorsList ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getSuccessorsList ( ) . get ( 0 ) ) && ! orderedNodes . contains ( nextNode ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . predecessors ) && ! orderedNodes . contains ( nextNode . predecessors ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . predecessors == null ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . successors ) {\n      if ( orderedNodes . contains ( nextNode . predecessors ) && ! orderedNodes . contains ( nextNode . predecessors ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static List < Node > topological_ordering ( List < Node > directedGraph ) {\n  List < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n",
        "public static ArrayList < Node > topological_ordering ( ArrayList < Node > directedGraph ) {\n  ArrayList < Node > orderedNodes = new ArrayList < Node > ( ) ;\n  for ( Node node : directedGraph ) {\n    if ( node . getPredecessors ( ) . isEmpty ( ) ) {\n      orderedNodes . add ( node ) ;\n    }\n  }\n  int listSize = orderedNodes . size ( ) ;\n  for ( int i = 0 ;\n  i < listSize ;\n  i ++ ) {\n    Node node = orderedNodes . get ( i ) ;\n    for ( Node nextNode : node . getSuccessors ( ) ) {\n      if ( orderedNodes . contains ( nextNode . getPredecessors ( ) ) && ! orderedNodes . contains ( nextNode . getPredecessors ( ) ) ) {\n        orderedNodes . add ( nextNode ) ;\n        listSize ++ ;\n      }\n    }\n  }\n  return orderedNodes ;\n}\n"
      ]
    },
    "WRAP": {
      "loc": "31-31",
      "input": "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    return lines;\n}",
      "target": "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    lines.add(text); \n    return lines;\n}",
      "function range": "18,5-33,5",
      "raw_output": [
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) end = cols ;\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) end = cols ;\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n"
      ],
      "mid_translation": [
        "vector < string > wrap ( string text , int cols ) {\n  vector < string > lines ;\n  string line ;\n  while ( text . length ( ) > cols ) {\n    size_t end = text . find_last_of ( \" \" , cols ) ;\n    if ( end == string :: npos ) end = cols ;\n    line = text . substr ( 0 , end ) ;\n    text . erase ( end ) ;\n    lines . push_back ( line ) ;\n  }\n  return lines ;\n}\n",
        "vector < string > wrap ( string text , int cols ) {\n  vector < string > lines ;\n  string line ;\n  while ( text . length ( ) > cols ) {\n    size_t end = text . rfind ( \" \" , cols ) ;\n    if ( end == string :: npos ) end = cols ;\n    line = text . substr ( 0 , end ) ;\n    text . erase ( end ) ;\n    lines . push_back ( line ) ;\n  }\n  return lines ;\n}\n",
        "vector < string > wrap ( string text , int cols ) {\n  vector < string > lines ;\n  string line ;\n  while ( text . length ( ) > cols ) {\n    size_t end = text . find_last_of ( \" \" , cols ) ;\n    if ( end == string :: npos ) end = cols ;\n    line = text . substr ( 0 , end ) ;\n    text = text . substr ( end ) ;\n    lines . push_back ( line ) ;\n  }\n  return lines ;\n}\n",
        "vector < string > wrap ( string text , int cols ) {\n  vector < string > lines ;\n  string line ;\n  while ( text . length ( ) > cols ) {\n    size_t end = text . rfind ( \" \" , cols ) ;\n    if ( end == string :: npos ) end = cols ;\n    line = text . substr ( 0 , end ) ;\n    text = text . substr ( end ) ;\n    lines . push_back ( line ) ;\n  }\n  return lines ;\n}\n",
        "vector < string > wrap ( string text , int cols ) {\n  vector < string > lines ;\n  string line ;\n  while ( text . length ( ) > cols ) {\n    size_t end = text . rfind ( \" \" , cols ) ;\n    if ( end == string :: npos ) end = cols ;\n    line . erase ( 0 , end ) ;\n    text . erase ( end ) ;\n    lines . push_back ( line ) ;\n  }\n  return lines ;\n}\n"
      ],
      "output": [
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = null ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) end = cols ;\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end + 1 ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static List < String > wrap ( String text , int cols ) {\n  List < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) end = cols ;\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n",
        "public static ArrayList < String > wrap ( String text , int cols ) {\n  ArrayList < String > lines = new ArrayList < String > ( ) ;\n  String line = \"\" ;\n  while ( text . length ( ) > cols ) {\n    int end = text . lastIndexOf ( \" \" , cols ) ;\n    if ( end == - 1 ) {\n      end = cols ;\n    }\n    line = text . substring ( 0 , end ) ;\n    text = text . substring ( end ) ;\n    lines . add ( line ) ;\n  }\n  return lines ;\n}\n"
      ]
    },
    "POWERSET": {
      "loc": "23-30",
      "input": "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        to_add.add(first); \n        for (ArrayList subset : rest_subsets) { \n            to_add.addAll(subset); \n        } \n        output.add(to_add); \n        return output; \n    } else {\n        ArrayList empty_set = new ArrayList<ArrayList>();\n        empty_set.add(new ArrayList());\n        return empty_set;\n    }\n}",
      "target": "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100); \n        for (ArrayList subset : rest_subsets) { \n            ArrayList r = new ArrayList(); \n            r.add(first); \n            r.addAll(subset); \n            to_add.add(r); \n        }\n        output.addAll(to_add);\n        rest_subsets.addAll(output);\n        return rest_subsets;\n    } else {\n        ArrayList empty_set = new ArrayList<ArrayList>();\n        empty_set.add(new ArrayList());\n        return empty_set;\n    }\n}",
      "function range": "14,5-35,5",
      "raw_output": [
        "public static ArrayList < ArrayList < Integer >> powerset ( ArrayList < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    ArrayList < Integer > rest = arr ;\n    ArrayList < Integer > restSubsets = powerset ( rest ) ;\n    ArrayList < ArrayList < Integer >> output = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    ArrayList < ArrayList < Integer >> toAdd = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( ArrayList < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    ArrayList < ArrayList < Integer >> emptySet = new ArrayList < ArrayList < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( null ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static ArrayList < ArrayList < Integer >> powerset ( ArrayList < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    ArrayList < Integer > rest = arr ;\n    ArrayList < Integer > restSubsets = powerset ( rest ) ;\n    ArrayList < ArrayList < Integer >> output = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    ArrayList < ArrayList < Integer >> toAdd = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( ArrayList < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    ArrayList < ArrayList < Integer >> emptySet = new ArrayList < ArrayList < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < List < Integer >> restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    Integer rest = arr . get ( 1 ) ;\n    List < List < Integer >> restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static ArrayList < ArrayList < Integer >> powerset ( ArrayList < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    Integer rest = arr . get ( 1 ) ;\n    ArrayList < ArrayList < Integer >> restSubsets = powerset ( rest ) ;\n    ArrayList < ArrayList < Integer >> output = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    ArrayList < ArrayList < Integer >> toAdd = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( ArrayList < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    ArrayList < ArrayList < Integer >> emptySet = new ArrayList < ArrayList < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    Integer rest = arr . get ( 1 ) ;\n    List < List < Integer >> restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < List < Integer >> restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( null ) ;\n    return emptySet ;\n  }\n}\n"
      ],
      "mid_translation": [
        "vector < vector < int >> powerset ( vector < int > arr ) {\n  if ( ! arr . empty ( ) ) {\n    auto first = arr . front ( ) ;\n    arr . pop ( ) ;\n    auto rest = arr ;\n    auto rest_subsets = powerset ( rest ) ;\n    vector < vector < int >> output ( 100 ) ;\n    vector < vector < int >> to_add ( 100 ) ;\n    to_add . push_back ( first ) ;\n    for ( auto subset : rest_subsets ) to_add . insert ( subset ) ;\n    output . push_back ( to_add ) ;\n    return output ;\n  }\n  else {\n    vector < vector < int >> empty_set ;\n    empty_set . push_back ( vector < int > ( ) ) ;\n    return empty_set ;\n  }\n}\n",
        "vector < vector < int >> powerset ( vector < int > arr ) {\n  if ( ! arr . empty ( ) ) {\n    auto first = arr . begin ( ) ;\n    arr . erase ( arr . begin ( ) ) ;\n    auto rest = arr ;\n    auto rest_subsets = powerset ( rest ) ;\n    vector < vector < int >> output ( 100 ) ;\n    vector < vector < int >> to_add ( 100 ) ;\n    to_add . push_back ( first ) ;\n    for ( auto subset : rest_subsets ) {\n      to_add . insert ( to_add . end ( ) , subset ) ;\n    }\n    output . push_back ( to_add ) ;\n    return output ;\n  }\n  else {\n    vector < vector < int >> empty_set ;\n    empty_set . push_back ( vector < int > ( ) ) ;\n    return empty_set ;\n  }\n}\n",
        "vector < vector < int >> powerset ( vector < int > arr ) {\n  if ( ! arr . empty ( ) ) {\n    auto first = arr . begin ( ) ;\n    arr . erase ( arr . begin ( ) ) ;\n    auto rest = arr ;\n    auto rest_subsets = powerset ( rest ) ;\n    vector < vector < int >> output ( 100 ) ;\n    vector < vector < int >> to_add ( 100 ) ;\n    to_add . push_back ( first ) ;\n    for ( auto subset : rest_subsets ) to_add . insert ( subset ) ;\n    output . push_back ( to_add ) ;\n    return output ;\n  }\n  else {\n    vector < vector < int >> empty_set ;\n    empty_set . push_back ( vector < int > ( ) ) ;\n    return empty_set ;\n  }\n}\n",
        "vector < vector < int >> powerset ( vector < int > arr ) {\n  if ( ! arr . empty ( ) ) {\n    auto first = arr . front ( ) ;\n    arr . pop ( ) ;\n    auto rest = arr ;\n    vector < vector < int >> rest_subsets = powerset ( rest ) ;\n    vector < vector < int >> output ( 100 ) ;\n    vector < vector < int >> to_add ( 100 ) ;\n    to_add . push_back ( first ) ;\n    for ( auto subset : rest_subsets ) {\n      to_add . insert ( to_add . end ( ) , subset ) ;\n    }\n    output . push_back ( to_add ) ;\n    return output ;\n  }\n  else {\n    vector < vector < int >> empty_set ;\n    empty_set . push_back ( vector < int > ( ) ) ;\n    return empty_set ;\n  }\n}\n",
        "vector < vector < int >> powerset ( vector < int > arr ) {\n  if ( ! arr . empty ( ) ) {\n    auto first = arr [ 0 ] ;\n    arr . erase ( arr . begin ( ) ) ;\n    auto rest = arr ;\n    auto rest_subsets = powerset ( rest ) ;\n    vector < vector < int >> output ( 100 ) ;\n    vector < vector < int >> to_add ( 100 ) ;\n    to_add . push_back ( first ) ;\n    for ( auto subset : rest_subsets ) {\n      to_add . insert ( to_add . end ( ) , subset ) ;\n    }\n    output . push_back ( to_add ) ;\n    return output ;\n  }\n  else {\n    vector < vector < int >> empty_set ;\n    empty_set . push_back ( vector < int > ( ) ) ;\n    return empty_set ;\n  }\n}\n"
      ],
      "output": [
        "public static ArrayList < ArrayList < Integer >> powerset ( ArrayList < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    ArrayList < Integer > rest = arr ;\n    ArrayList < Integer > restSubsets = powerset ( rest ) ;\n    ArrayList < ArrayList < Integer >> output = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    ArrayList < ArrayList < Integer >> toAdd = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( ArrayList < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    ArrayList < ArrayList < Integer >> emptySet = new ArrayList < ArrayList < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( null ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static ArrayList < ArrayList < Integer >> powerset ( ArrayList < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    ArrayList < Integer > rest = arr ;\n    ArrayList < Integer > restSubsets = powerset ( rest ) ;\n    ArrayList < ArrayList < Integer >> output = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    ArrayList < ArrayList < Integer >> toAdd = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( ArrayList < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    ArrayList < ArrayList < Integer >> emptySet = new ArrayList < ArrayList < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . add ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < List < Integer >> restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    Integer rest = arr . get ( 1 ) ;\n    List < List < Integer >> restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static ArrayList < ArrayList < Integer >> powerset ( ArrayList < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    Integer rest = arr . get ( 1 ) ;\n    ArrayList < ArrayList < Integer >> restSubsets = powerset ( rest ) ;\n    ArrayList < ArrayList < Integer >> output = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    ArrayList < ArrayList < Integer >> toAdd = new ArrayList < ArrayList < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( ArrayList < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    ArrayList < ArrayList < Integer >> emptySet = new ArrayList < ArrayList < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    Integer rest = arr . get ( 1 ) ;\n    List < List < Integer >> restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < List < Integer >> restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( new ArrayList < Integer > ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . < Integer > emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr = arr . subList ( 1 , arr . size ( ) ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( Collections . emptyList ( ) ) ;\n    return emptySet ;\n  }\n}\n",
        "public static List < List < Integer >> powerset ( List < Integer > arr ) {\n  if ( ! arr . isEmpty ( ) ) {\n    Integer first = arr . get ( 0 ) ;\n    arr . remove ( 0 ) ;\n    List < Integer > rest = arr ;\n    List < Integer > restSubsets = powerset ( rest ) ;\n    List < List < Integer >> output = new ArrayList < List < Integer >> ( 100 ) ;\n    List < List < Integer >> toAdd = new ArrayList < List < Integer >> ( 100 ) ;\n    toAdd . add ( first ) ;\n    for ( List < Integer > subset : restSubsets ) {\n      toAdd . addAll ( subset ) ;\n    }\n    output . add ( toAdd ) ;\n    return output ;\n  }\n  else {\n    List < List < Integer >> emptySet = new ArrayList < List < Integer >> ( ) ;\n    emptySet . add ( null ) ;\n    return emptySet ;\n  }\n}\n"
      ]
    }
  },
  "model": "transcoder-java-cpp-java",
  "seed": 432093
}