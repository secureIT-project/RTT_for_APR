{
  "config": "CODET5_REFINE_CODEFORM_NOCOMMENT",
  "data": {
    "FIND_IN_SORTED": {
      "loc": "20-21",
      "input": "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) {\n        return binsearch(arr, x, mid, end); \n    } else {\n        return mid;\n    }\n}",
      "target": "public static int binsearch(int[] arr, int x, int start, int end) {\n    if (start == end) {\n        return -1;\n    }\n    int mid = start + (end - start) / 2; \n    if (x < arr[mid]) {\n        return binsearch(arr, x, start, mid);\n    } else if (x > arr[mid]) { \n        return binsearch(arr, x, mid+1, end);\n    } else {\n        return mid;\n    }\n}",
      "function range": "12,5-24,5",
      "raw_output": [
        "int function ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg2 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = - 1 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 = loc1 ; break ; } } return loc0 ; }",
        "int function ( double [ ] arg0, double arg1, double arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( T [ ] arg0, T arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( int [ ] arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( double [ ] arg0, double arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( double [ ] arg0, double arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( int [ ] arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg0 [ loc0 ] == arg1 ) return loc0 ; return - 1 ; }",
        "int function ( double [ ] arg0, double arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg1 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( double [ ] arg0, double arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( double [ ] arg0, double arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg0 [ loc0 ] > arg1 ) return loc0 ; return - 1 ; }",
        "int function ( double [ ] arg0, double arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] > arg1 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( T [ ] arg0, T arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg2 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( double [ ] arg0, double arg1, double arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( double [ ] arg0, double arg1, double arg2 ) { boolean loc0 = false ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 = true ; break ; } } return loc0? loc0 : - 1 ; }",
        "int function ( int [ ] arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg0 [ loc0 ] ) { return loc0 ; } } return - 1 ; }",
        "int function ( int [ ] arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) if ( arg0 [ loc0 ] == arg0 [ loc0 ] ) return loc0 ; return - 1 ; }",
        "int function ( double [ ] arg0, double arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
        "int function ( int [ ] arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg0 [ loc0 + 1 ] ) { return loc0 ; } } return - 1 ; }",
        "int function ( double [ ] arg0, double arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }"
      ],
      "mid_translation": [
        "Returns the index of the first occurrence of x in the array that is greater than or equal to the given value.",
        "Returns the index of the first occurrence of x in the array.",
        "Returns the index of the first occurrence of x in the array that is greater than or equal to x.",
        "Returns the index of the first occurrence of x in the array that is greater than or equal to the specified value.",
        "Returns the index of the first occurrence of x in the specified range of the array."
      ],
      "output": [
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg2 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = - 1 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 = loc1 ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( T [ ] arg0, T arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( int [ ] arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( int [ ] arg0, int arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg0 [ loc0 ] == arg1 ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg1 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg0 [ loc0 ] > arg1 ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] > arg1 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( T [ ] arg0, T arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg2 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, double arg2 ) { boolean loc0 = false ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg2 ) { loc0 = true ; break ; } } return loc0? loc0 : - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( int [ ] arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg0 [ loc0 ] ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( int [ ] arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) if ( arg0 [ loc0 ] == arg0 [ loc0 ] ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, int arg2 ) { for ( int loc0 = arg2 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( int [ ] arg0, int arg1, int arg2 ) { for ( int loc0 = arg1 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg0 [ loc0 + 1 ] ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int binsearch ( double [ ] arg0, double arg1, int arg2 ) { for ( int loc0 = 0 ; loc0 < arg2 ; loc0 ++ ) { if ( arg0 [ loc0 ] > arg1 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "DETECT_CYCLE": {
      "loc": "18-19",
      "input": "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n        if (hare.getSuccessor() == null) \n            return false;\n        tortoise = tortoise.getSuccessor();\n        hare = hare.getSuccessor().getSuccessor();\n        if (hare == tortoise)\n            return true;\n    }\n}",
      "target": "public static boolean detect_cycle(Node node) {\n    Node hare = node;\n    Node tortoise = node;\n    while (true) {\n        if (null==hare ||hare.getSuccessor() == null)\n            return false;\n        tortoise = tortoise.getSuccessor();\n        hare = hare.getSuccessor().getSuccessor();\n        if (hare == tortoise)\n            return true;\n    }\n}",
      "function range": "13,5-27,5",
      "raw_output": [
        "Set < T > function ( Set < T > arg0, List < T > arg1 ) { Set < T > loc0 = new HashSet < T > ( arg0 ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "Set < T > function ( Set < T > arg0, Set < T > arg1 ) { Set < T > loc0 = new HashSet < T > ( arg0 ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "Set < T > function ( Set < T > arg0, Set < T > arg1 ) { Set < T > loc0 = new HashSet < > ( arg0 ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "Set < T > function ( Set < T > arg0, List < T > arg1 ) { Set < T > loc0 = new HashSet < > ( arg0 ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "Set < T > function ( Set < T > arg0, List < T > arg1 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "void function ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } loc0 = loc2 ; } } }",
        "void function ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } } } } }",
        "void function ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } } } }",
        "void function ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } } arg0 = loc0 ; } }",
        "void function ( DiGraph arg0, DiGraph arg1 ) { for ( DiGraphNode loc0 : arg0. getDirectories ( ) ) { Node loc1 = loc0. getFirstChild ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { arg1. add ( loc2 ) ; } loc2 = loc2. getNextSibling ( ) ; } } }",
        "void function ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } } } }",
        "void function ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { loc1 = loc1. getNextSibling ( ) ; } arg0 = loc0. getNextSibling ( ) ; } } }",
        "void function ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { loc0 = loc1. getNextSibling ( ) ; } arg0 = loc0. getNextSibling ( ) ; } } }",
        "void function ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { loc0 = loc1. getNextSibling ( ) ; } } arg0 = loc0. getNextSibling ( ) ; } }",
        "void function ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc0 = loc2. getNextSibling ( ) ; } } } }",
        "Cycle function ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { T loc1 = arg0. get ( loc0 ) ; if ( loc1 instanceof Cycle ) { Ccycle loc2 = ( Ccycle ) loc1 ; arg1. add ( loc2 ) ; } } return null ; }",
        "Cycle function ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { T loc1 = arg0. get ( loc0 ) ; if ( loc1 instanceof cycle ) return cycle ; arg1. add ( ( cycle ) loc1 ) ; } return null ; }",
        "Cycle function ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { T loc1 = arg0. get ( loc0 ) ; if ( loc1 instanceof Cycle ) { Ccycle loc2 = ( CCycle ) loc1 ; arg1. add ( loc2 ) ; } } return null ; }",
        "Cycle function ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { T loc1 = arg0. get ( loc0 ) ; if ( loc1 instanceof Cycle ) { Cycle loc2 = ( CCycle ) loc1 ; arg1. add ( loc2 ) ; } } return null ; }",
        "boolean function ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { if ( arg1. contains ( arg0. get ( loc0 ) ) ) { return true ; } } return false ; }",
        "Set < T > function ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = ( T ) loc1. next ( ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
        "Set < T > function ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = loc1. next ( ) ; while ( loc2. hasNext ( ) ) { T loc3 = ( T ) loc2. next ( ) ; loc0. add ( loc3 ) ; } } return loc0 ; }",
        "Set < T > function ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = ( T ) loc1. next ( ) ; while ( loc2. hasNext ( ) ) { loc0. add ( ( T ) loc2. next ( ) ) ; } } return loc0 ; }",
        "Set < T > function ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = ( T ) loc1. next ( ) ; while ( loc2. hasNext ( ) ) { loc0. add ( loc2. next ( ) ) ; } } return loc0 ; }",
        "Set < T > function ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = ( T ) loc1. next ( ) ; while ( loc2. hasNext ( ) ) { loc0. add ( loc2 ) ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Detect cycle.",
        "Detect a cycle of a node.",
        "Detect the cycle of a node.",
        "Detects a cycle.",
        "Detects a cycle of nodes."
      ],
      "output": [
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0, List < T > arg1 ) { Set < T > loc0 = new HashSet < T > ( arg0 ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0, Set < T > arg1 ) { Set < T > loc0 = new HashSet < T > ( arg0 ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0, Set < T > arg1 ) { Set < T > loc0 = new HashSet < > ( arg0 ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0, List < T > arg1 ) { Set < T > loc0 = new HashSet < > ( arg0 ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0, List < T > arg1 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( T loc1 : arg1 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } loc0 = loc2 ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } } } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } } arg0 = loc0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( DiGraph arg0, DiGraph arg1 ) { for ( DiGraphNode loc0 : arg0. getDirectories ( ) ) { Node loc1 = loc0. getFirstChild ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { arg1. add ( loc2 ) ; } loc2 = loc2. getNextSibling ( ) ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc2 = loc2. getNextSibling ( ) ; } } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { loc1 = loc1. getNextSibling ( ) ; } arg0 = loc0. getNextSibling ( ) ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { loc0 = loc1. getNextSibling ( ) ; } arg0 = loc0. getNextSibling ( ) ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { loc0 = loc1. getNextSibling ( ) ; } } arg0 = loc0. getNextSibling ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void detect_cycle ( ASTNode arg0 ) { while ( arg0!= null ) { Node loc0 = arg0. getFirstChild ( ) ; while ( loc0!= null ) { Node loc1 = loc0. getNextSibling ( ) ; while ( loc1!= null ) { Node loc2 = loc1. getNextSibling ( ) ; while ( loc2!= null ) { loc0 = loc2. getNextSibling ( ) ; } } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Cycle detect_cycle ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { T loc1 = arg0. get ( loc0 ) ; if ( loc1 instanceof Cycle ) { Ccycle loc2 = ( Ccycle ) loc1 ; arg1. add ( loc2 ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Cycle detect_cycle ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { T loc1 = arg0. get ( loc0 ) ; if ( loc1 instanceof cycle ) return cycle ; arg1. add ( ( cycle ) loc1 ) ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Cycle detect_cycle ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { T loc1 = arg0. get ( loc0 ) ; if ( loc1 instanceof Cycle ) { Ccycle loc2 = ( CCycle ) loc1 ; arg1. add ( loc2 ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Cycle detect_cycle ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { T loc1 = arg0. get ( loc0 ) ; if ( loc1 instanceof Cycle ) { Cycle loc2 = ( CCycle ) loc1 ; arg1. add ( loc2 ) ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean detect_cycle ( List < T > arg0, List < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. size ( ) ; loc0 ++ ) { if ( arg1. contains ( arg0. get ( loc0 ) ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = ( T ) loc1. next ( ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = loc1. next ( ) ; while ( loc2. hasNext ( ) ) { T loc3 = ( T ) loc2. next ( ) ; loc0. add ( loc3 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = ( T ) loc1. next ( ) ; while ( loc2. hasNext ( ) ) { loc0. add ( ( T ) loc2. next ( ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = ( T ) loc1. next ( ) ; while ( loc2. hasNext ( ) ) { loc0. add ( loc2. next ( ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < T > detect_cycle ( Set < T > arg0 ) { Set < T > loc0 = new HashSet < T > ( ) ; for ( Iterator < T > loc1 = arg0. iterator ( ) ; loc1. hasNext ( ) ; ) { T loc2 = ( T ) loc1. next ( ) ; while ( loc2. hasNext ( ) ) { loc0. add ( loc2 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "FIND_FIRST_IN_SORTED": {
      "loc": "19-20",
      "input": "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo <= hi) { \n        int mid = (lo + hi) / 2; \n        if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n            return mid;\n        } else if (x <= arr[mid]) {\n            hi = mid;\n        } else {\n            lo = mid + 1;\n        }\n    }\n    return -1;\n}",
      "target": "public static int find_first_in_sorted(int[] arr, int x) {\n    int lo = 0;\n    int hi = arr.length;\n    while (lo < hi) { \n        int mid = (lo + hi) / 2; \n        if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n            return mid;\n        } else if (x <= arr[mid]) {\n            hi = mid;\n        } else {\n            lo = mid + 1;\n        }\n    }\n    return -1;\n}",
      "function range": "15,5-32,5",
      "raw_output": [
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return arg0 [ loc0 ] ; return null ; }",
        "T function ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) >= 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return arg0 [ loc0 ] ; return arg1 ; }",
        "T function ( T [ ] arg0, Comparator < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg1. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) == 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, Comparator < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg1. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) == 0 ) return arg0 [ loc0 ] ; return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) == 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) == 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "int function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return loc0 ; } } return - 1 ; }",
        "int function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return loc0 ; return - 1 ; }",
        "int function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) >= 0 ) { return loc0 ; } } return - 1 ; }",
        "int function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) < 0 ) { return loc0 ; } } return - 1 ; }",
        "int function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return loc0 ; } loc0 ++ ; } return - 1 ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) < 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) < 0 ) return arg0 [ loc0 ] ; return arg1 ; }",
        "T function ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) < 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return arg0 [ loc0 ] ; return null ; }",
        "T function ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) < 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
        "T function ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return arg0 [ loc0 ] ; return arg1 ; }"
      ],
      "mid_translation": [
        "Find the first element in the array that is greater or equal to x in sorted order.",
        "Find the first element in the array that is equal to x in sorted order.",
        "Returns the index of the first element in the array that is greater or equal to x in sorted order.",
        "Find the first element in the array that is less than or equal to x in sorted order.",
        "Find the first element in the array that is greater than or equal to x in sorted order."
      ],
      "output": [
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return arg0 [ loc0 ] ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) >= 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return arg0 [ loc0 ] ; return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, Comparator < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg1. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) == 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, Comparator < T > arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg1. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) == 0 ) return arg0 [ loc0 ] ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) == 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) == 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg0 [ loc0 ] == arg1 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return loc0 ; return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) >= 0 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) < 0 ) { return loc0 ; } } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return loc0 ; } loc0 ++ ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) < 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) < 0 ) return arg0 [ loc0 ] ; return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) < 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return arg0 [ loc0 ] ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, int arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg0 [ loc0 ] ) > 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) { if ( arg2. compare ( arg0 [ loc0 ], arg1 ) < 0 ) { return arg0 [ loc0 ] ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T find_first_in_sorted ( T [ ] arg0, T arg1, Comparator < T > arg2 ) { for ( int loc0 = 0 ; loc0 < arg0. length ; loc0 ++ ) if ( arg2. compare ( arg0 [ loc0 ], arg1 ) > 0 ) return arg0 [ loc0 ] ; return arg1 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "GET_FACTORS": {
      "loc": "27-28",
      "input": "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    return new ArrayList<Integer>(); \n}",
      "target": "public static ArrayList<Integer> get_factors(int n) {\n    if (n == 1) {\n        return new ArrayList<Integer>();\n    }\n    int max = (int)(Math.sqrt(n) + 1.0);\n    for (int i=2; i < max; i++) {\n        if (n % i == 0) {\n            ArrayList<Integer> prepend = new ArrayList<Integer>(0);\n            prepend.add(i);\n            prepend.addAll(get_factors(n / i));\n            return prepend;\n        }\n    }\n    return new ArrayList<Integer>(Arrays.asList(n));\n}",
      "function range": "14,5-28,5",
      "raw_output": [
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 10 ] ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( 5 ) ; } return loc0 ; }",
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 5 ] ; for ( int loc1 = 0 ; loc1 < 5 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( 5 ) ; } return loc0 ; }",
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 10 ] ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( 10 ) ; } return loc0 ; }",
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 10 ] ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( ) ; } return loc0 ; }",
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 5 ] ; PolynomialFunction2D loc1 = new PolynomialFunction2D ( ) ; return loc0 ; }",
        "Factor [ ] function ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "Factor [ ] function ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; return loc0 ; }",
        "Factor [ ] function ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "Factor [ ] function ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0 [ loc1 ++ ] = new Factor ( arg0. get ( loc2 ) ) ; } return loc0 ; }",
        "Factor [ ] function ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0 [ loc2 ] = new Factor ( arg0. get ( loc2 ) ) ; } return loc0 ; }",
        "Factor [ ] function ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "Factor [ ] function ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; return loc0 ; }",
        "Factor [ ] function ( final Random arg0 ) { final int loc0 = arg0. nextInt ( ) ; final Factor [ ] loc1 = new Factor [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = new Factor ( arg0 ) ; } return loc1 ; }",
        "Factor [ ] function ( final Random arg0 ) { final int loc0 = arg0. nextInt ( ) ; final Factor [ ] loc1 = new Factor [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = new Factor ( arg0. nextInt ( ) ) ; } return loc1 ; }",
        "ArrayList < Factor > function ( int arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new Factor ( loc1 ) ) ; } return loc0 ; }",
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 3 ] ; for ( int loc1 = 0 ; loc1 < 3 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( loc1 ) ; } return loc0 ; }",
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 1 ] ; for ( int loc1 = 0 ; loc1 < 5 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( loc1 ) ; } return loc0 ; }",
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 9 ] ; for ( int loc1 = 0 ; loc1 < 9 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( loc1 ) ; } return loc0 ; }",
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 1 ] ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( loc1 ) ; } return loc0 ; }",
        "Factor [ ] function ( ) { Factor [ ] loc0 = new Factor [ 3 ] ; for ( int loc1 = 0 ; loc1 < 3 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( ) ; } return loc0 ; }",
        "ArrayList < Factor > function ( N arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. get_degree ( ) ; loc1 ++ ) { loc0. add ( new Factor ( arg0. get_degree ( loc1 ) ) ) ; } return loc0 ; }",
        "ArrayList < Factor > function ( N arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getN ( ) ; loc1 ++ ) { loc0. add ( new Factor ( arg0. get ( loc1 ) ) ) ; } return loc0 ; }",
        "ArrayList < AbstractFactor > function ( AbstractFactor arg0 ) { ArrayList < AbstractFactor > loc0 = new ArrayList < AbstractFactor > ( ) ; for ( AbstractFactor loc1 : arg0. factors ( ) ) { loc0. add ( new AbstractFactor ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < Factor > function ( N arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getCardinality ( ) ; loc1 ++ ) { loc0. add ( new Factor ( arg0. getCardinality ( loc1 ) ) ) ; } return loc0 ; }",
        "ArrayList < Factor > function ( N arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getFactors ( ). size ( ) ; loc1 ++ ) { loc0. add ( new Factor ( arg0. getFactors ( loc1 ) ) ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Method get_factors.",
        "Get the factors of n.",
        "Gets the factors of n.",
        "get_factors Method.",
        "get_factors This method returns a list of the factors of n."
      ],
      "output": [
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 10 ] ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( 5 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 5 ] ; for ( int loc1 = 0 ; loc1 < 5 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( 5 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 10 ] ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( 10 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 10 ] ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 5 ] ; PolynomialFunction2D loc1 = new PolynomialFunction2D ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < loc0. length ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0 [ loc1 ++ ] = new Factor ( arg0. get ( loc2 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0 [ loc2 ] = new Factor ( arg0. get ( loc2 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( final N arg0 ) { final Factor [ ] loc0 = new Factor [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 [ loc1 ] = new Factor ( arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( final Random arg0 ) { final int loc0 = arg0. nextInt ( ) ; final Factor [ ] loc1 = new Factor [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = new Factor ( arg0 ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( final Random arg0 ) { final int loc0 = arg0. nextInt ( ) ; final Factor [ ] loc1 = new Factor [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = new Factor ( arg0. nextInt ( ) ) ; } return loc1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < Factor > get_factors ( int arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new Factor ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 3 ] ; for ( int loc1 = 0 ; loc1 < 3 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 1 ] ; for ( int loc1 = 0 ; loc1 < 5 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 9 ] ; for ( int loc1 = 0 ; loc1 < 9 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 1 ] ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Factor [ ] get_factors ( ) { Factor [ ] loc0 = new Factor [ 3 ] ; for ( int loc1 = 0 ; loc1 < 3 ; loc1 ++ ) { loc0 [ loc1 ] = new Factor ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < Factor > get_factors ( N arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. get_degree ( ) ; loc1 ++ ) { loc0. add ( new Factor ( arg0. get_degree ( loc1 ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < Factor > get_factors ( N arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getN ( ) ; loc1 ++ ) { loc0. add ( new Factor ( arg0. get ( loc1 ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < AbstractFactor > get_factors ( AbstractFactor arg0 ) { ArrayList < AbstractFactor > loc0 = new ArrayList < AbstractFactor > ( ) ; for ( AbstractFactor loc1 : arg0. factors ( ) ) { loc0. add ( new AbstractFactor ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < Factor > get_factors ( N arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getCardinality ( ) ; loc1 ++ ) { loc0. add ( new Factor ( arg0. getCardinality ( loc1 ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < Factor > get_factors ( N arg0 ) { ArrayList < Factor > loc0 = new ArrayList < Factor > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. getFactors ( ). size ( ) ; loc1 ++ ) { loc0. add ( new Factor ( arg0. getFactors ( loc1 ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "HANOI": {
      "loc": "27-28",
      "input": "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(start, helper)); \n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}",
      "target": "public static List<Pair<Integer,Integer>> hanoi(int height, int start, int end) {\n    ArrayList<Pair<Integer,Integer>> steps = new ArrayList<Pair<Integer,Integer>>();\n    if (height > 0) {\n        PriorityQueue<Integer> crap_set = new PriorityQueue<Integer>();\n        crap_set.add(1);\n        crap_set.add(2);\n        crap_set.add(3);\n        crap_set.remove(start);\n        crap_set.remove(end);\n        int helper = crap_set.poll();\n        steps.addAll(hanoi(height-1, start, helper));\n        steps.add(new Pair<Integer,Integer>(start, end)); \n        steps.addAll(hanoi(height-1, helper, end));\n    }\n    return steps;\n}",
      "function range": "15,5-32,5",
      "raw_output": [
        "List < HANOIStep > function ( List < HANOIStep > arg0 ) { List < HANOIStep > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( loc1. getHANOIStep ( ) ) ; } return loc0 ; }",
        "List < HANOIStep > function ( List < HANOIStep > arg0 ) { List < HANOIStep > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( new HANOIStep ( loc1 ) ) ; } return loc0 ; }",
        "List < HANOISteps > function ( List < HANOIStep > arg0 ) { List < HANOISteps > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( new HANOIStep ( loc1 ) ) ; } return loc0 ; }",
        "List < HANOIStep > function ( List < HANOIStep > arg0 ) { List < HANOIStep > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( loc1. getStep ( ) ) ; } return loc0 ; }",
        "List < HANOISteps > function ( List < HANOIStep > arg0 ) { List < HANOISteps > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( loc1. getHANOIStep ( ) ) ; } return loc0 ; }",
        "int function ( ) { return 31 ; }",
        "Hanoi function ( int arg0 ) { return new Hanoi ( arg0 ) ; }",
        "Hanoi function ( ) { return new Hanoi ( ) ; }",
        "int function ( T arg0 ) { return arg0. hashCode ( ) ; }",
        "HanoiMethod function ( ) { return new Hanoi ( ) ; }",
        "List < String > function ( List < String > arg0 ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < String > function ( List < String > arg0 ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1. toUpperCase ( ) ) ; } return loc0 ; }",
        "List < String > function ( ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( HANOStep loc1 : HANOSteps. values ( ) ) { loc0. add ( loc1. getName ( ) ) ; } return loc0 ; }",
        "List < String > function ( List < String > arg0 ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1. trim ( ) ) ; } return loc0 ; }",
        "List < String > function ( ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( HANOStep loc1 : HANOSteps. values ( ) ) { loc0. add ( loc1. getDisplayName ( ) ) ; } return loc0 ; }",
        "HanoiAlgorithm function ( ) { HanoiAlgorithm loc0 = new HanoiAlgorithm ( ) ; loc0. init ( ) ; return loc0 ; }",
        "int function ( String arg0, int arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } if ( arg1 == 0 ) { arg1 = \"srini_string\" ; } return ( arg0. compareTo ( arg0. toLowerCase ( ) ) ) ; }",
        "int function ( String arg0, int arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } if ( arg1 == 0 ) { arg1 = \"srini_string\" ; } return ( arg0. compareTo ( arg0. toUpperCase ( ) ) ) ; }",
        "int function ( String arg0, int arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } if ( arg1 == 0 ) { arg1 = \"srini_string\" ; } return ( arg0. compareTo ( arg1 ) ) ; }",
        "int function ( String arg0, int arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } if ( arg1 == 0 ) { arg1 = \"srini_string\" ; } return ( arg0. compareTo ( arg0 ) ) ; }",
        "HANOAlgorithmSteps function ( final int arg0 ) { return new HANOAlgorithmSteps ( arg0 ) ; }",
        "HANOAlgorithmSteps function ( ) { return new HANOAlgorithmSteps ( ) ; }",
        "HANOAlgorithmSteps function ( final int arg0, final int arg1 ) { return steps ( arg0, arg1, null ) ; }",
        "HANOAlgorithmSteps function ( final String arg0 ) { return new HANOAlgorithmSteps ( arg0 ) ; }",
        "HANOAlgorithmSteps function ( final int arg0, final int arg1 ) { return steps ( arg0, arg1, false ) ; }"
      ],
      "mid_translation": [
        "Gets the HANOI steps.",
        "Hanoi method.",
        "Gets the HANO steps.",
        "Hanoi algorithm.",
        "Gets the HANO algorithm steps."
      ],
      "output": [
        {
          "patch": "public static List < HANOIStep > hanoi ( List < HANOIStep > arg0 ) { List < HANOIStep > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( loc1. getHANOIStep ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < HANOIStep > hanoi ( List < HANOIStep > arg0 ) { List < HANOIStep > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( new HANOIStep ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < HANOISteps > hanoi ( List < HANOIStep > arg0 ) { List < HANOISteps > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( new HANOIStep ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < HANOIStep > hanoi ( List < HANOIStep > arg0 ) { List < HANOIStep > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( loc1. getStep ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < HANOISteps > hanoi ( List < HANOIStep > arg0 ) { List < HANOISteps > loc0 = Lists. newArrayList ( ) ; for ( HANOIStep loc1 : arg0 ) { loc0. add ( loc1. getHANOIStep ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int hanoi ( ) { return 31 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Hanoi hanoi ( int arg0 ) { return new Hanoi ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Hanoi hanoi ( ) { return new Hanoi ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int hanoi ( T arg0 ) { return arg0. hashCode ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static HanoiMethod hanoi ( ) { return new Hanoi ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > hanoi ( List < String > arg0 ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > hanoi ( List < String > arg0 ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1. toUpperCase ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > hanoi ( ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( HANOStep loc1 : HANOSteps. values ( ) ) { loc0. add ( loc1. getName ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > hanoi ( List < String > arg0 ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1. trim ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > hanoi ( ) { List < String > loc0 = Lists. newArrayList ( ) ; for ( HANOStep loc1 : HANOSteps. values ( ) ) { loc0. add ( loc1. getDisplayName ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static HanoiAlgorithm hanoi ( ) { HanoiAlgorithm loc0 = new HanoiAlgorithm ( ) ; loc0. init ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int hanoi ( String arg0, int arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } if ( arg1 == 0 ) { arg1 = \"srini_string\" ; } return ( arg0. compareTo ( arg0. toLowerCase ( ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int hanoi ( String arg0, int arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } if ( arg1 == 0 ) { arg1 = \"srini_string\" ; } return ( arg0. compareTo ( arg0. toUpperCase ( ) ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int hanoi ( String arg0, int arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } if ( arg1 == 0 ) { arg1 = \"srini_string\" ; } return ( arg0. compareTo ( arg1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int hanoi ( String arg0, int arg1 ) { if ( arg0 == null ) { arg0 = \"srini_string\" ; } if ( arg1 == 0 ) { arg1 = \"srini_string\" ; } return ( arg0. compareTo ( arg0 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static HANOAlgorithmSteps hanoi ( final int arg0 ) { return new HANOAlgorithmSteps ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static HANOAlgorithmSteps hanoi ( ) { return new HANOAlgorithmSteps ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static HANOAlgorithmSteps hanoi ( final int arg0, final int arg1 ) { return steps ( arg0, arg1, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static HANOAlgorithmSteps hanoi ( final String arg0 ) { return new HANOAlgorithmSteps ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static HANOAlgorithmSteps hanoi ( final int arg0, final int arg1 ) { return steps ( arg0, arg1, false ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "DEPTH_FIRST_SEARCH": {
      "loc": "22-22",
      "input": "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true;\n    } else {\n        for (Node successornodes : node.getSuccessors()) { \n            if (search(successornodes)) { return true; }\n        }\n    }\n    return false;\n}",
      "target": "boolean search(Node node) {\n    if (nodesvisited.contains(node)) {\n        return false;\n    } else if (node == goalnode) {\n        return true; \n    } else {\n            nodesvisited.add(node);\n        for (Node successornodes : node.getSuccessors()) {\n            if (search(successornodes)) { return true; }\n        }\n    }\n    return false;\n}",
      "function range": "16,13-27,13",
      "raw_output": [
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } else { return null ; } }",
        "TreeNode function ( Tree arg0, int arg1 ) { Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } else { return null ; } }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } return null ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = search ( arg0. getLeft ( ), arg0. getRight ( ) ) ; if ( loc0!= null ) { return loc0 ; } return null ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0 == null ) { return null ; } return loc0 ; }",
        "boolean function ( ASTNode arg0 ) { return arg0 == arg0 ; }",
        "boolean function ( PsiNode arg0 ) { return arg0 == arg0 ; }",
        "boolean function ( ASTNode arg0 ) { return arg0 == arg0 || ( arg0 == null ||! ( arg0 instanceof goalNode ) ) ; }",
        "boolean function ( PsiNode arg0 ) { return arg0 == null || arg0. getType ( ) == TokenTypes. goalNode ; }",
        "boolean function ( ASTNode arg0 ) { return arg0 == arg0 || ( arg0 == null || arg0. getType ( ) == Token. WORD ) ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) return null ; Node loc0 = arg0. findFirstChild ( arg1 ) ; if ( loc0!= null ) return loc0 ; return null ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0 == null ) { return null ; } return loc0 ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } return search ( arg0. getLeft ( ), arg0. getRight ( ), arg1 ) ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } return null ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. getChild ( arg1 ) ; if ( loc0 == null ) { return null ; } return loc0 ; }",
        "boolean function ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == Token. EOF ) { return false ; } loc0 = loc0. getNextSibling ( ) ; } return true ; }",
        "boolean function ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getFirstChild ( ) == null ) return true ; loc0 = loc0. getNextSibling ( ) ; } return false ; }",
        "boolean function ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getFirstChild ( ) == arg0 ) { return true ; } loc0 = loc0. getNextSibling ( ) ; } return false ; }",
        "boolean function ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getFirstChild ( ) == null ) { return true ; } loc0 = loc0. getNextSibling ( ) ; } return false ; }",
        "boolean function ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getData ( ) == null ) return true ; loc0 = loc0. getNextSibling ( ) ; } return false ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0 == null ) { return null ; } return loc0 ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } else { return null ; } }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } return null ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0. hasNode ( arg1 ) ) { Node loc0 = arg0. getNode ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } } return null ; }",
        "TreeNode function ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } else { return null ; } }"
      ],
      "mid_translation": [
        "Search for a node in the tree.",
        "Returns true if the node is the goal node.",
        "Searches for a node in the tree.",
        "Returns true if the node is in the tree.",
        "Search for the node in the tree."
      ],
      "output": [
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = search ( arg0. getLeft ( ), arg0. getRight ( ) ) ; if ( loc0!= null ) { return loc0 ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0 == null ) { return null ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( ASTNode arg0 ) { return arg0 == arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( PsiNode arg0 ) { return arg0 == arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( ASTNode arg0 ) { return arg0 == arg0 || ( arg0 == null ||! ( arg0 instanceof goalNode ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( PsiNode arg0 ) { return arg0 == null || arg0. getType ( ) == TokenTypes. goalNode ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( ASTNode arg0 ) { return arg0 == arg0 || ( arg0 == null || arg0. getType ( ) == Token. WORD ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) return null ; Node loc0 = arg0. findFirstChild ( arg1 ) ; if ( loc0!= null ) return loc0 ; return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0 == null ) { return null ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } return search ( arg0. getLeft ( ), arg0. getRight ( ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. getChild ( arg1 ) ; if ( loc0 == null ) { return null ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getType ( ) == Token. EOF ) { return false ; } loc0 = loc0. getNextSibling ( ) ; } return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getFirstChild ( ) == null ) return true ; loc0 = loc0. getNextSibling ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getFirstChild ( ) == arg0 ) { return true ; } loc0 = loc0. getNextSibling ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getFirstChild ( ) == null ) { return true ; } loc0 = loc0. getNextSibling ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "boolean search ( ASTNode arg0 ) { ASTNode loc0 = arg0 ; while ( loc0!= null ) { if ( loc0. getData ( ) == null ) return true ; loc0 = loc0. getNextSibling ( ) ; } return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0 == null ) { return null ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } else { return null ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0. hasNode ( arg1 ) ) { Node loc0 = arg0. getNode ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } } return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "TreeNode search ( Tree arg0, int arg1 ) { if ( arg0 == null ) { return null ; } Node loc0 = arg0. search ( arg1 ) ; if ( loc0!= null ) { return loc0 ; } else { return null ; } }",
          "correctness": "uncompilable"
        }
      ]
    },
    "KTH": {
      "loc": "25-26",
      "input": "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    }\n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k); \n    } else {\n        return pivot;\n    }\n}",
      "target": "public static Integer kth(ArrayList<Integer> arr, int k) {\n    int pivot = arr.get(0);\n    ArrayList<Integer> below, above;\n    below = new ArrayList<Integer>(arr.size());\n    above = new ArrayList<Integer>(arr.size());\n    for (Integer x : arr) {\n        if (x < pivot) {\n            below.add(x);\n        } else if (x > pivot) {\n            above.add(x);\n        }\n    } \n    int num_less = below.size();\n    int num_lessoreq = arr.size() - above.size();\n    if (k < num_less) {\n        return kth(below, k);\n    } else if (k >= num_lessoreq) {\n        return kth(above, k-num_lessoreq);\n    } else {\n        return pivot;\n    }\n}",
      "function range": "7,5-29,5",
      "raw_output": [
        "Kth function ( ) { return new Kth ( ) ; }",
        "Kth function ( Integer arg0 ) { return new Kth ( arg0 ) ; }",
        "R function ( Integer arg0 ) { R loc0 = null ; if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return loc0 ; }",
        "Kth function ( Kth arg0 ) { return arg0 ; }",
        "R function ( Integer arg0 ) { R loc0 = new R ( arg0 ) ; return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; break ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < 0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = arg0 [ loc1 ] ; if ( loc0 == null ) { break ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < 0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } if ( loc0 == null ) { loc0 = arg0 [ arg1 ] ; } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; break ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1, Class < T > arg2 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; break ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = arg0 [ loc1 ] ; if ( loc0 == null ) { break ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; break ; } } return loc0 ; }",
        "T function ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 = arg0 [ loc1 ] ; if ( loc0 == null ) { break ; } } return loc0 ; }",
        "void function ( Kth arg0 ) { }",
        "String function ( ) { return \"srini_string\" ; }",
        "void function ( Kth arg0 ) { Kth loc0 = arg0 ; }",
        "int function ( ) { return 31 ; }",
        "int [ ] function ( ) { return new int [ ] { 1, 2, 3 } ; }"
      ],
      "mid_translation": [
        "Kth method.",
        "Get the kth value of the array.",
        "Get the kth value of an array.",
        "Get the kth element of the array.",
        "kth method."
      ],
      "output": [
        {
          "patch": "public static Kth kth ( ) { return new Kth ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Kth kth ( Integer arg0 ) { return new Kth ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static R kth ( Integer arg0 ) { R loc0 = null ; if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Kth kth ( Kth arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static R kth ( Integer arg0 ) { R loc0 = new R ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < 0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = arg0 [ loc1 ] ; if ( loc0 == null ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < 0 ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } if ( loc0 == null ) { loc0 = arg0 [ arg1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1, Class < T > arg2 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = arg0 [ loc1 ] ; if ( loc0 == null ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] == null ) { loc0 = arg0 [ loc1 ] ; break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T kth ( T [ ] arg0, int arg1 ) { T loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 = arg0 [ loc1 ] ; if ( loc0 == null ) { break ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void kth ( Kth arg0 ) { }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String kth ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void kth ( Kth arg0 ) { Kth loc0 = arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int kth ( ) { return 31 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] kth ( ) { return new int [ ] { 1, 2, 3 } ; }",
          "correctness": "wrong"
        }
      ]
    },
    "FLATTEN": {
      "loc": "21-26",
      "input": "public static Object flatten(Object arr) {\n    if (arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n        ArrayList result = new ArrayList(50);\n        for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else {\n                result.add(flatten(x)); \n            } \n        } \n        return result; \n    } else { \n        return flatten(arr);\n    }\n}",
      "target": "public static Object flatten(Object arr) {\n    if (arr instanceof ArrayList) {\n        ArrayList narr = (ArrayList) arr;\n        ArrayList result = new ArrayList(50);\n        for (Object x : narr) {\n            if (x instanceof ArrayList) {\n                result.addAll((ArrayList) flatten(x));\n            } else { \n                result.add((x)); \n            } \n        } \n        return result; \n    } else {\n        return arr;\n    }\n}",
      "function range": "13,5-28,5",
      "raw_output": [
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. add ( arg0. get ( loc1 ) ) ; return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { ArrayList < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length * 2 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; flatten ( arg0, loc0 ) ; return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( T ) arg0 [ loc1 ] ; } return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { if ( arg0 == null ) { return null ; } T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "T [ ] function ( T [ ] arg0, Class < T > arg1 ) { T [ ] loc0 = ( T [ ] ) arg0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg1. cast ( loc0 [ loc1 ] ) ; } return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length * 2 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; flatten ( arg0, loc0 ) ; return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; flatten ( arg0, loc0, 0 ) ; return loc0 ; }",
        "T [ ] function ( T [ ] arg0 ) { return Flattens. flatten ( arg0 ) ; }",
        "T [ ] function ( T [ ] arg0 ) { return flatten ( arg0, new T [ arg0. length ] ) ; }",
        "String [ ] function ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0 [ loc2 ] ; } return loc1 ; }",
        "List < T > function ( T... arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. length ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "String [ ] function ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 / 2 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 / 2 ] = arg0 [ loc2 % 2 ] ; } return loc1 ; }",
        "String [ ] function ( String [ ] arg0 ) { String [ ] loc0 = new String [ arg0. length ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. length ; loc2 ++ ) { loc0 [ loc1 ++ ] = arg0 [ loc2 ] ; } return loc0 ; }",
        "String [ ] function ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0 [ loc2 ]. trim ( ) ; } return loc1 ; }"
      ],
      "mid_translation": [
        "Flatten the array.",
        "Flattens an array into a single array.",
        "Flattens an array to a single array.",
        "Flattens the array into a single array.",
        "Flattens the array."
      ],
      "output": [
        {
          "patch": "public static List < T > flatten ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > flatten ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. add ( arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > flatten ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > flatten ( List < T > arg0 ) { ArrayList < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > flatten ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length * 2 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; flatten ( arg0, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = ( T ) arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { if ( arg0 == null ) { return null ; } T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0, Class < T > arg1 ) { T [ ] loc0 = ( T [ ] ) arg0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg1. cast ( loc0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length * 2 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; flatten ( arg0, loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { T [ ] loc0 = new T [ arg0. length ] ; flatten ( arg0, loc0, 0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { return Flattens. flatten ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static T [ ] flatten ( T [ ] arg0 ) { return flatten ( arg0, new T [ arg0. length ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String [ ] flatten ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0 [ loc2 ] ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < T > flatten ( T... arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. length ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String [ ] flatten ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 / 2 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 / 2 ] = arg0 [ loc2 % 2 ] ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String [ ] flatten ( String [ ] arg0 ) { String [ ] loc0 = new String [ arg0. length ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. length ; loc2 ++ ) { loc0 [ loc1 ++ ] = arg0 [ loc2 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String [ ] flatten ( String [ ] arg0 ) { int loc0 = arg0. length ; String [ ] loc1 = new String [ loc0 ] ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 [ loc2 ] = arg0 [ loc2 ]. trim ( ) ; } return loc1 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "KHEAPSORT": {
      "loc": "27-28",
      "input": "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>();\n    for (Integer x : arr) { \n        heap.add(x);\n        Integer popped = heap.poll();\n        output.add(popped);\n    }\n    while (!heap.isEmpty()) {\n        output.add(heap.poll());\n    }\n    return output;\n}",
      "target": "public static ArrayList<Integer> kheapsort(ArrayList<Integer> arr, int k) {\n    PriorityQueue<Integer> heap = new PriorityQueue<Integer>();\n    for (Integer v : arr.subList(0,k)) {\n        heap.add(v);\n    }\n    ArrayList<Integer> output = new ArrayList<Integer>(); \n    for (Integer x : arr.subList(k, arr.size())) {\n        heap.add(x);\n        Integer popped = heap.poll();\n        output.add(popped);\n    }\n    while (!heap.isEmpty()) {\n        output.add(heap.poll());\n    }\n    return output;\n}",
      "function range": "20,5-39,5",
      "raw_output": [
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. set ( loc1, loc0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < E > function ( List < E > arg0 ) { List < E > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. set ( loc1, arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { if ( loc0. get ( loc1 ) > 0 ) { loc0. remove ( loc1 ) ; } } return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) if ( loc0. get ( loc1 ) > 0 ) loc0. remove ( loc1 ) ; return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. set ( loc1, loc0. get ( loc1 + 1 ) ) ; } return loc0 ; }",
        "void function ( int [ ] arg0 ) { while ( arg0 [ arg0. length - 1 ] < arg0 [ arg0. length - 1 ] ) { int loc0 = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = loc0 ; arg0 [ arg0. length - 1 ] = loc0 ; } }",
        "void function ( int [ ] arg0 ) { while ( arg0 [ arg0. length - 1 ] < arg0 [ arg0. length - 1 ] ) { int loc0 = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = loc0 ; arg0 [ arg0. length - 1 ] = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = loc0 ; } }",
        "void function ( int [ ] arg0 ) { while ( arg0 [ arg0. length - 1 ] < arg0 [ arg0. length - 1 ] ) { int loc0 = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = arg0 [ arg0. length - 2 ] ; arg0 [ arg0. length - 1 ] = loc0 ; arg0 [ arg0. length - 1 ] = loc0 ; } }",
        "void function ( int [ ] arg0 ) { while ( arg0 [ arg0. length - 1 ] < arg0 [ arg0. length - 1 ] ) { int loc0 = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = arg0 [ arg0. length - 2 ] ; arg0 [ arg0. length - 2 ] = loc0 ; arg0 [ arg0. length - 1 ] = loc0 ; } }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. set ( loc1, loc0. get ( loc1 ) ) ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] > arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] > arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] < arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] < arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 8 ] = arg0 [ 7 ] ; arg0 [ 8 ] = arg0 [ 8 ] ; arg0 [ 9 ] = arg0 [ 10 ] = arg0 [ 11 ] = arg0 [ 12 ] ; return arg0 [ 0 ] ; }",
        "int function ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 7 ] = arg0 [ 8 ] ; arg0 [ 8 ] = arg0 [ 9 ] ; arg0 [ 9 ] = arg0 [ 10 ] = arg0 [ 11 ] = arg0 [ 12 ] ; return arg0 [ 0 ] ; }",
        "int function ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 7 ] = arg0 [ 8 ] ; arg0 [ 8 ] = arg0 [ 9 ] ; return arg0 [ 10 ] ; }",
        "int function ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 8 ] = arg0 [ 7 ] ; arg0 [ 8 ] = arg0 [ 8 ] ; arg0 [ 9 ] = arg0 [ 10 ] = arg0 [ 11 ] = arg0 [ 12 ] ; arg0 [ 11 ] = arg0 [ 12 ] ; return arg0 [ 11 ]",
        "int function ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 7 ] = arg0 [ 8 ] ; arg0 [ 8 ] = arg0 [ 9 ] ; arg0 [ 9 ] = arg0 [ 10 ] = arg0 [ 11 ] = arg0 [ 12 ] ; arg0 [ 11 ] = arg0 [ 11 ] ; return arg0 [ 11 ]",
        "int function ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { T loc2 = arg0 [ loc1 - 1 ] ; arg0 [ loc1 ] = arg0 [ loc1 ] ; arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { T loc2 = arg0 [ loc1 - 1 ] ; arg0 [ loc1 ] = arg0 [ loc1 ] ; arg0 [ loc1 - 1 ] = loc2 ; } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] > arg0 [ loc0 - 1 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { T loc2 = arg0 [ loc1 - 1 ] ; arg0 [ loc1 ] = arg0 [ loc1 ] ; arg0 [ loc1 ] = loc2 ; arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { T loc2 = arg0 [ loc1 - 1 ] ; arg0 [ loc1 ] = arg0 [ loc1 ] ; arg0 [ loc1 ] = loc2 ; loc1 -- ; while ( loc1 > 0 && arg0 [ loc1 - 1 ] < loc2 ) { loc1 -- ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "K - heap sort.",
        "k - heap sort.",
        "K - heapsort.",
        "k - heap sort",
        "K - heap sort method."
      ],
      "output": [
        {
          "patch": "public static List < T > kheapsort ( List < T > arg0 ) { List < T > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. set ( loc1, loc0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < E > kheapsort ( List < E > arg0 ) { List < E > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. set ( loc1, arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > kheapsort ( List < T > arg0 ) { List < T > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { if ( loc0. get ( loc1 ) > 0 ) { loc0. remove ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > kheapsort ( List < T > arg0 ) { List < T > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) if ( loc0. get ( loc1 ) > 0 ) loc0. remove ( loc1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > kheapsort ( List < T > arg0 ) { List < T > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. set ( loc1, loc0. get ( loc1 + 1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void kheapsort ( int [ ] arg0 ) { while ( arg0 [ arg0. length - 1 ] < arg0 [ arg0. length - 1 ] ) { int loc0 = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = loc0 ; arg0 [ arg0. length - 1 ] = loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void kheapsort ( int [ ] arg0 ) { while ( arg0 [ arg0. length - 1 ] < arg0 [ arg0. length - 1 ] ) { int loc0 = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = loc0 ; arg0 [ arg0. length - 1 ] = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void kheapsort ( int [ ] arg0 ) { while ( arg0 [ arg0. length - 1 ] < arg0 [ arg0. length - 1 ] ) { int loc0 = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = arg0 [ arg0. length - 2 ] ; arg0 [ arg0. length - 1 ] = loc0 ; arg0 [ arg0. length - 1 ] = loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void kheapsort ( int [ ] arg0 ) { while ( arg0 [ arg0. length - 1 ] < arg0 [ arg0. length - 1 ] ) { int loc0 = arg0 [ arg0. length - 1 ] ; arg0 [ arg0. length - 1 ] = arg0 [ arg0. length - 2 ] ; arg0 [ arg0. length - 2 ] = loc0 ; arg0 [ arg0. length - 1 ] = loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > kheapsort ( List < Integer > arg0 ) { List < Integer > loc0 = arg0 ; for ( int loc1 = loc0. size ( ) - 1 ; loc1 >= 0 ; loc1 -- ) { loc0. set ( loc1, loc0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int kheapsort ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] > arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int kheapsort ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] > arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int kheapsort ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] < arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int kheapsort ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] < arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int kheapsort ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc0 - 1 ] ) { loc0 -- ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int kheapsort ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 8 ] = arg0 [ 7 ] ; arg0 [ 8 ] = arg0 [ 8 ] ; arg0 [ 9 ] = arg0 [ 10 ] = arg0 [ 11 ] = arg0 [ 12 ] ; return arg0 [ 0 ] ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int kheapsort ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 7 ] = arg0 [ 8 ] ; arg0 [ 8 ] = arg0 [ 9 ] ; arg0 [ 9 ] = arg0 [ 10 ] = arg0 [ 11 ] = arg0 [ 12 ] ; return arg0 [ 0 ] ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int kheapsort ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 7 ] = arg0 [ 8 ] ; arg0 [ 8 ] = arg0 [ 9 ] ; return arg0 [ 10 ] ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int kheapsort ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 8 ] = arg0 [ 7 ] ; arg0 [ 8 ] = arg0 [ 8 ] ; arg0 [ 9 ] = arg0 [ 10 ] = arg0 [ 11 ] = arg0 [ 12 ] ; arg0 [ 11 ] = arg0 [ 12 ] ; return arg0 [ 11 ]",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int kheapsort ( int [ ] arg0 ) { arg0 [ 0 ] = arg0 [ 1 ] ; arg0 [ 1 ] = arg0 [ 2 ] ; arg0 [ 2 ] = arg0 [ 3 ] ; arg0 [ 3 ] = arg0 [ 4 ] ; arg0 [ 4 ] = arg0 [ 5 ] ; arg0 [ 6 ] = arg0 [ 6 ] ; arg0 [ 7 ] = arg0 [ 8 ] ; arg0 [ 8 ] = arg0 [ 9 ] ; arg0 [ 9 ] = arg0 [ 10 ] = arg0 [ 11 ] = arg0 [ 12 ] ; arg0 [ 11 ] = arg0 [ 11 ] ; return arg0 [ 11 ]",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int kheapsort ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { T loc2 = arg0 [ loc1 - 1 ] ; arg0 [ loc1 ] = arg0 [ loc1 ] ; arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int kheapsort ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { T loc2 = arg0 [ loc1 - 1 ] ; arg0 [ loc1 ] = arg0 [ loc1 ] ; arg0 [ loc1 - 1 ] = loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int kheapsort ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 -- ) { if ( arg0 [ loc1 ] < arg0 [ loc1 - 1 ] ) { loc0 = loc1 ; } else if ( arg0 [ loc1 ] > arg0 [ loc0 - 1 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int kheapsort ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { T loc2 = arg0 [ loc1 - 1 ] ; arg0 [ loc1 ] = arg0 [ loc1 ] ; arg0 [ loc1 ] = loc2 ; arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int kheapsort ( T [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = loc0 / 2 ; loc1 > 0 ; loc1 -- ) { T loc2 = arg0 [ loc1 - 1 ] ; arg0 [ loc1 ] = arg0 [ loc1 ] ; arg0 [ loc1 ] = loc2 ; loc1 -- ; while ( loc1 > 0 && arg0 [ loc1 - 1 ] < loc2 ) { loc1 -- ; } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "KNAPSACK": {
      "loc": "30-31",
      "input": "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            }\n            else if (weight < j) { \n                memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n            }\n            else {\n                memo[i][j] = memo [i-1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}",
      "target": "public static int knapsack(int capacity, int [][] items) {\n    int weight = 0, value = 0;\n    int n = items.length;\n    int memo[][] = new int[n + 1][capacity + 1];\n    for (int i = 0; i <= n ; i++)\n    {\n        if (i - 1 >= 0) {\n            weight = items[i - 1][0];\n            value = items[i - 1][1];\n        }\n        for (int j = 0; j <= capacity; j++)\n        {\n            if (i == 0 || j == 0) {\n                memo[i][j] = 0;\n            } \n            else if (weight <= j) {\n                memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n            }\n            else {\n                memo[i][j] = memo [i-1][j];\n            }\n        }\n    }\n    return memo[n][capacity];\n}",
      "function range": "14,5-40,5",
      "raw_output": [
        "Knapsack function ( ) { return new Knapsack ( ) ; }",
        "Knapsack function ( Map < String, String > arg0 ) { Knapsack loc0 = Knapsack. create ( arg0 ) ; return loc0 ; }",
        "Knapsack function ( ) { return Knapsack. create ( ) ; }",
        "Map < String, String > function ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; return loc0 ; }",
        "Knapsack function ( byte [ ] arg0 ) { Knapsack loc0 = new Knapsack ( arg0 ) ; return loc0 ; }",
        "Knapsack function ( ) { return new Knapsack ( ) ; }",
        "Knapsack function ( ) { return new Jnapsack ( ) ; }",
        "Knapsack function ( ) { return new Znapsack ( ) ; }",
        "Knapsack function ( ) { return new DefaultKnapsack ( ) ; }",
        "Knapsack function ( ) { return new SimpleKnapsack ( ) ; }",
        "Knapsack function ( ) { return new Knapsack ( ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "int function ( ) { return 0 ; }",
        "IgniteKnapsack function ( ) { return new SimpleKnapsack ( ) ; }",
        "Knapsack function ( ) { return new KnapsackImpl ( ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "Knapsack function ( ) { return new Knapsack ( ) ; }",
        "String function ( String arg0 ) { return arg0. trim ( ). toLowerCase ( ) ; }",
        "String function ( int arg0 ) { return \"srini_string\" ; }",
        "String function ( String arg0 ) { return \"srini_string\" ; }",
        "Knapsack function ( ) { return new Knapsack ( ) ; }",
        "Knapsack function ( byte [ ] arg0 ) { return new Knapsack ( arg0 ) ; }",
        "Knapsack function ( List < T > arg0 ) { return new Knapsack ( arg0 ) ; }",
        "Knapsack function ( Function0 arg0 ) { return new Knapsack ( arg0 ) ; }",
        "byte [ ] function ( byte [ ] arg0 ) { return arg0 ; }"
      ],
      "mid_translation": [
        "Knapsack.",
        "Knapsack implementation of the knapsack.",
        "Knapsack implementation of knapsack.",
        "Knapsack method.",
        "Knapsack function."
      ],
      "output": [
        {
          "patch": "public static Knapsack knapsack ( ) { return new Knapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( Map < String, String > arg0 ) { Knapsack loc0 = Knapsack. create ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return Knapsack. create ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Map < String, String > knapsack ( Map < String, String > arg0 ) { Map < String, String > loc0 = new HashMap < > ( arg0 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Knapsack knapsack ( byte [ ] arg0 ) { Knapsack loc0 = new Knapsack ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return new Knapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return new Jnapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return new Znapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return new DefaultKnapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return new SimpleKnapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return new Knapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String knapsack ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int knapsack ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static IgniteKnapsack knapsack ( ) { return new SimpleKnapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return new KnapsackImpl ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String knapsack ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return new Knapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String knapsack ( String arg0 ) { return arg0. trim ( ). toLowerCase ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String knapsack ( int arg0 ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String knapsack ( String arg0 ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Knapsack knapsack ( ) { return new Knapsack ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( byte [ ] arg0 ) { return new Knapsack ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( List < T > arg0 ) { return new Knapsack ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Knapsack knapsack ( Function0 arg0 ) { return new Knapsack ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static byte [ ] knapsack ( byte [ ] arg0 ) { return arg0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "LONGEST_COMMON_SUBSEQUENCE": {
      "loc": "18-19",
      "input": "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a.charAt(0) + longest_common_subsequence(a.substring(1), b); \n    } else {\n        String fst = longest_common_subsequence(a, b.substring(1));\n        String snd = longest_common_subsequence(a.substring(1), b);\n        return fst.length() >= snd.length() ? fst : snd;\n    }\n}",
      "target": "public static String longest_common_subsequence(String a, String b) {\n    if (a.isEmpty() || b.isEmpty()) {\n        return \"\";\n    } else if (a.charAt(0) == b.charAt(0)) {\n        return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1)); \n    } else {\n        String fst = longest_common_subsequence(a, b.substring(1));\n        String snd = longest_common_subsequence(a.substring(1), b);\n        return fst.length() >= snd.length() ? fst : snd;\n    }\n}",
      "function range": "14,5-25,5",
      "raw_output": [
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
        "int function ( String [ ] arg0, String [ ] arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ]. equals ( arg1 [ loc1 ] ) ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( String [ ] arg0, String [ ] arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ]. equals ( arg1 [ loc0 ] ) ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { return longestCommonSubsequence ( arg0, arg1, 0, arg0. length ( ) ) ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
        "int function ( String [ ] arg0, String [ ] arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ]. equals ( arg1 [ loc1 ] ) ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
        "int function ( String [ ] arg0, String [ ] arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ]. equals ( arg1 [ loc0 ] ) ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { if ( arg0. length ( ) == arg1. length ( ) ) { return longestCommonSubsequence ( arg0, arg1 ) ; } else if ( arg0. length ( ) == arg1. length ( ) ) { return longestCommonSubsequence ( arg0, arg1 ) ; } else { return 0 ; } }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { if ( arg0. length ( ) == arg1. length ( ) ) { return longestCommonSubsequence ( arg0, arg1 ) ; } else if ( arg0. length ( ) == arg1. length ( ) ) { return longestCommonSubsequence ( arg0, arg1 ) ; } else { return 0 ; } }",
        "int function ( String arg0, String arg1 ) { return longestCommonSubsequence ( arg0, arg1, 0, arg0. length ( ) ) ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { return longestCommonSubsequence ( arg0, arg1, 0, arg0. length ( ) ) ; }",
        "int function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = arg0. lastIndexOf ( arg1 ) ; } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { return longestCommonSubsequence ( arg0, arg1, 0, arg0. length ( ) ) ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = arg0. length ( ) ; } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 == - 1 ) { loc0 = arg0. length ( ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Returns the longest common subsequence of two strings.",
        "Get the longest common subsequence of two strings.",
        "Returns the longest common subsequence of the two strings.",
        "Returns the longest common subsequence between two strings.",
        "Returns the longest common subsequence between the two strings."
      ],
      "output": [
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String [ ] arg0, String [ ] arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ]. equals ( arg1 [ loc1 ] ) ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int longest_common_subsequence ( String [ ] arg0, String [ ] arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ]. equals ( arg1 [ loc0 ] ) ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { return longestCommonSubsequence ( arg0, arg1, 0, arg0. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String [ ] arg0, String [ ] arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ]. equals ( arg1 [ loc1 ] ) ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String [ ] arg0, String [ ] arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ]. equals ( arg1 [ loc0 ] ) ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { if ( arg0. length ( ) == arg1. length ( ) ) { return longestCommonSubsequence ( arg0, arg1 ) ; } else if ( arg0. length ( ) == arg1. length ( ) ) { return longestCommonSubsequence ( arg0, arg1 ) ; } else { return 0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { if ( arg0. length ( ) == arg1. length ( ) ) { return longestCommonSubsequence ( arg0, arg1 ) ; } else if ( arg0. length ( ) == arg1. length ( ) ) { return longestCommonSubsequence ( arg0, arg1 ) ; } else { return 0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { return longestCommonSubsequence ( arg0, arg1, 0, arg0. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { return longestCommonSubsequence ( arg0, arg1, 0, arg0. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = arg0. lastIndexOf ( arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { return longestCommonSubsequence ( arg0, arg1, 0, arg0. length ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = arg0. length ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 < 0 ) { loc0 = 0 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int longest_common_subsequence ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } int loc0 = longestCommonSubsequence ( arg0, arg1 ) ; if ( loc0 == - 1 ) { loc0 = arg0. length ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "LIS": {
      "loc": "31-32",
      "input": "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = length + 1; \n        }\n        i++;\n    }\n    return longest;\n}",
      "target": "public static int lis(int[] arr) {\n    Map<Integer,Integer> ends = new HashMap<Integer, Integer>(100);\n    int longest = 0;\n    int i = 0;\n    for (int val : arr) {\n        ArrayList<Integer> prefix_lengths = new ArrayList<Integer>(100);\n        for (int j=1; j < longest+1; j++) {\n            if (arr[ends.get(j)] < val) {\n                prefix_lengths.add(j);\n            }\n        }\n        int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n        if (length == longest || val < arr[ends.get(length+1)]) {\n            ends.put(length+1, i);\n            longest = Math.max(longest,length + 1); \n        }\n        i++;\n    }\n    return longest;\n}",
      "function range": "13,5-37,5",
      "raw_output": [
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ]. length ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ]. length ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "Lis function ( Integer arg0 ) { return new Lis ( arg0 ) ; }",
        "void function ( Lis arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; }",
        "Lis function ( ) { return new Lis ( ) ; }",
        "void function ( Lis arg0 ) { Lis loc0 = new Lis ( arg0 ) ; }",
        "void function ( Lis arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; Lis loc0 = ( Lis ) arg0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ]. length ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ]. length ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] instanceof T ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] instanceof T ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 += arg0 [ loc1 ]. length ; return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) loc0 += arg0 [ loc1 ]. length ; return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] == null ) { ++ loc0 ; } } return loc0 ; }",
        "java. util. Date function ( ) { return new java. util. Date ( ) ; }",
        "int function ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
        "int function ( ) { return 0 ; }",
        "List < Integer > function ( List <? extends Integer > arg0 ) { return arg0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { return arg0 ; }"
      ],
      "mid_translation": [
        "Get the longest length of the array.",
        "Lis method.",
        "Get the longest length of an array.",
        "Get the length of the array.",
        "Method lis."
      ],
      "output": [
        {
          "patch": "public static int lis ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ]. length ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ]. length ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Lis lis ( Integer arg0 ) { return new Lis ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void lis ( Lis arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Lis lis ( ) { return new Lis ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void lis ( Lis arg0 ) { Lis loc0 = new Lis ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void lis ( Lis arg0 ) { if ( arg0 == null ) throw new NullPointerException ( \"srini_string\" ) ; Lis loc0 = ( Lis ) arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ]. length ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ]. length ; if ( loc2 > loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < loc0 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] instanceof T ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] instanceof T ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 += arg0 [ loc1 ]. length ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) loc0 += arg0 [ loc1 ]. length ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lis ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] == null ) { ++ loc0 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static java. util. Date lis ( ) { return new java. util. Date ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lis ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lis ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > lis ( List <? extends Integer > arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > lis ( List < Integer > arg0 ) { return arg0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "BUCKETSORT": {
      "loc": "22-23",
      "input": "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n    int i = 0;\n    for (Integer count : arr) {  \n        sorted_arr.addAll(Collections.nCopies(count, i));\n        i++;\n    }\n    return sorted_arr;\n}",
      "target": "public static ArrayList<Integer> bucketsort(ArrayList<Integer> arr, int k) {\n    ArrayList<Integer> counts = new ArrayList<Integer>(Collections.nCopies(k,0));\n    for (Integer x : arr) {\n        counts.set(x,counts.get(x)+1);\n    }\n    ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n    int i = 0;\n    for (Integer count : counts) { \n        sorted_arr.addAll(Collections.nCopies(count, i));\n        i++;\n    }\n    return sorted_arr;\n}",
      "function range": "14,5-28,5",
      "raw_output": [
        "int function ( T arg0, T arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { loc0 = - loc0 ; } else if ( loc0 > 0 ) { loc0 = 1 ; } else if ( loc0 < arg1 ) { loc0 = arg1 ; } return loc0 ; }",
        "int function ( T arg0, T arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { loc0 = - loc0 ; } else if ( loc0 > 0 ) { loc0 = loc0 + 1 ; } else if ( loc0 < arg1 ) { loc0 = arg1 ; } return loc0 ; }",
        "int function ( T arg0, T arg1, Comparator < T > arg2 ) { return arg2. compare ( arg0, arg1 ) ; }",
        "int function ( T arg0, T arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { loc0 = - loc0 ; } else if ( loc0 < arg1 ) { loc0 = arg1 ; } return loc0 ; }",
        "int function ( T arg0, T arg1, Comparator < T > arg2 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { loc0 = - loc0 ; } else if ( loc0 > 0 ) { loc0 = 1 ; } else if ( loc0 < arg1 ) { loc0 = arg1 ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
        "List < Integer > function ( Collection <? extends Comparable > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
        "List < Integer > function ( Collection <? extends Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = arg0 ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
        "List < T > function ( T... arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; Collections. sort ( loc0, new Comparator < T > ( ) ) ; return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } Collections. sort ( loc0, new Comparator < T > ( ) ) ; return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } Collections. sort ( loc0, new Comparator < T > ( ) ) ; return loc0 ; }",
        "List < T > function ( T... arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } Collections. sort ( loc0, new Comparator < T > ( ) ) ; return loc0 ; }",
        "List < T > function ( T... arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; Collections. sort ( loc0, new Comparator < T > ( ) { @ Override public int compare ( T arg1, T arg2 ) { return arg1. length - 1 ; } } ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { int loc0 = arg0. loc0 ( ) ; Collections. sort ( arg0, new Comparator < Integer > ( ) { @ Override public int compare ( int arg1, int arg2 ) { return arg1 - arg2 ; } } ) ; return arg0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { int loc0 = arg0. loc0 ( ) ; Collections. sort ( arg0, new Comparator < Integer > ( ) { @ Override public int compare ( Integer arg1, Integer arg2 ) { return arg1 - arg2 ; } } ) ; return arg0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { int loc0 = arg0. loc0 ( ) ; Collections. sort ( arg0, new Comparator < Integer > ( ) { public int compare ( Integer arg1, Integer arg2 ) { return arg1 - arg2 ; } } ) ; return arg0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int loc0 = arg0. loc0 ; Collections. sort ( arg0, new Comparator < Integer > ( ) { @ Override public int compare ( int arg1, int arg2 ) { return arg1 - arg2 ; } } ) ; return arg0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { int loc0 = arg0. loc0 ( ) ; Collections. sort ( arg0, new Comparator < Integer > ( ) { @ Override public int compare ( int arg1, int arg2 ) { return arg1 - arg2 ; } } ) ; return arg0. subList ( 0, loc0 - 1 ) ; }",
        "void function ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc2 ) - loc3 ) ; arg0. set ( loc2 + 1, loc4 ) ; } }",
        "void function ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc3 ) ) ; arg0. set ( loc3 + 1, arg0. get ( loc3 + 1 ) ) ; } }",
        "void function ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc3 ) ) ; arg0. set ( loc3 + 1, arg0. get ( loc3 ) ) ; } }",
        "int [ ] function ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc2 ) - loc3 ) ; arg0. set ( loc2 + 1, loc4 ) ; } return arg0. toArray ( new int [ loc1 ] ) ; }",
        "int [ ] function ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc2 ) - loc3 ) ; arg0. set ( loc2 + 1, loc4 ) ; } return arg0. toArray ( new int [ loc1 - 1 ] ) ; }"
      ],
      "mid_translation": [
        "Bucketsort method.",
        "Method bucketsort.",
        "Bucket sort.",
        "Bucketsort a list of integers.",
        "Bucketsort method for ArrayList<Integer >"
      ],
      "output": [
        {
          "patch": "public static int bucketsort ( T arg0, T arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { loc0 = - loc0 ; } else if ( loc0 > 0 ) { loc0 = 1 ; } else if ( loc0 < arg1 ) { loc0 = arg1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bucketsort ( T arg0, T arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { loc0 = - loc0 ; } else if ( loc0 > 0 ) { loc0 = loc0 + 1 ; } else if ( loc0 < arg1 ) { loc0 = arg1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bucketsort ( T arg0, T arg1, Comparator < T > arg2 ) { return arg2. compare ( arg0, arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bucketsort ( T arg0, T arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { loc0 = - loc0 ; } else if ( loc0 < arg1 ) { loc0 = arg1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bucketsort ( T arg0, T arg1, Comparator < T > arg2 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { loc0 = - loc0 ; } else if ( loc0 > 0 ) { loc0 = 1 ; } else if ( loc0 < arg1 ) { loc0 = arg1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > bucketsort ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > bucketsort ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > bucketsort ( Collection <? extends Comparable > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > bucketsort ( Collection <? extends Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > bucketsort ( List < Integer > arg0 ) { List < Integer > loc0 = arg0 ; Collections. sort ( loc0, new Comparator < Integer > ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > bucketsort ( T... arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; Collections. sort ( loc0, new Comparator < T > ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > bucketsort ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } Collections. sort ( loc0, new Comparator < T > ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > bucketsort ( List < T > arg0 ) { List < T > loc0 = new ArrayList < > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } Collections. sort ( loc0, new Comparator < T > ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > bucketsort ( T... arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } Collections. sort ( loc0, new Comparator < T > ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bucketsort ( T arg1, T arg2 ) { return arg1. length - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bucketsort ( int arg1, int arg2 ) { return arg1 - arg2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bucketsort ( Integer arg1, Integer arg2 ) { return arg1 - arg2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bucketsort ( Integer arg1, Integer arg2 ) { return arg1 - arg2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bucketsort ( int arg1, int arg2 ) { return arg1 - arg2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bucketsort ( int arg1, int arg2 ) { return arg1 - arg2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void bucketsort ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc2 ) - loc3 ) ; arg0. set ( loc2 + 1, loc4 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void bucketsort ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc3 ) ) ; arg0. set ( loc3 + 1, arg0. get ( loc3 + 1 ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void bucketsort ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc3 ) ) ; arg0. set ( loc3 + 1, arg0. get ( loc3 ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] bucketsort ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc2 ) - loc3 ) ; arg0. set ( loc2 + 1, loc4 ) ; } return arg0. toArray ( new int [ loc1 ] ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int [ ] bucketsort ( ArrayList < Integer > arg0 ) { int loc0 = arg0. size ( ) ; int loc1 = loc0 / 2 ; for ( int loc2 = loc1 - 1 ; loc2 >= 0 ; loc2 -- ) { int loc3 = arg0. get ( loc2 ) ; int loc4 = arg0. get ( loc2 + 1 ) ; arg0. set ( loc2 + 1, arg0. get ( loc2 ) - loc3 ) ; arg0. set ( loc2 + 1, loc4 ) ; } return arg0. toArray ( new int [ loc1 - 1 ] ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "MAX_SUBLIST_SUM": {
      "loc": "19-20",
      "input": "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n        max_ending_here = max_ending_here + x; \n        max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n}",
      "target": "public static int max_sublist_sum(int[] arr) {\n    int max_ending_here = 0;\n    int max_so_far = 0;\n    for (int x : arr) {\n        max_ending_here = Math.max(0,max_ending_here + x); \n        max_so_far = Math.max(max_so_far, max_ending_here);\n    }\n    return max_so_far;\n}",
      "function range": "14,5-24,5",
      "raw_output": [
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { loc0 = Math. max ( loc0, loc1 ) ; } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; } catch ( Exception loc1 ) { throw new RuntimeException ( \"srini_string\" + arg0 [ loc0 ]. getClass ( ). getName ( ) ) ; } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; } catch ( Exception loc0 ) { throw new RuntimeException ( \"srini_string\" + arg0 [ loc0 ]. getClass ( ). getName ( ) ) ; } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc1 ] ) { loc0 = loc1 ; } } return loc0 ; } catch ( Exception loc1 ) { throw new RuntimeException ( \"srini_string\" + arg0 [ loc0 ]. getClass ( ). getName ( ) ) ; } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; } catch ( Exception loc1 ) { throw new RuntimeException ( \"srini_string\" + arg0 [ 0 ]. getClass ( ). getName ( ) ) ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. loc0 ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
        "long function ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 > loc0 ) { loc0 = loc1 ; } } if ( loc0 < arg0. size ( ) ) { loc0 = Math. max ( loc0, arg0. size ( ) ) ; } return loc0 ; }",
        "long function ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 > loc0 ) { loc0 = loc1 ; } } if ( loc0 < arg0. size ( ) ) { loc0 = Math. max ( loc0, arg0. get ( loc0 ) ) ; } return loc0 ; }",
        "long function ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 = loc1 ; } } if ( loc0 > 0 ) { loc0 = Math. max ( loc0, loc0 / arg0. size ( ) ) ; } return loc0 ; }",
        "long function ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 = loc1 ; } } if ( loc0 < loc0 / arg0. size ( ) ) { loc0 = loc0 + 1 ; } return loc0 ; } catch ( Exception loc1 ) { loc0 = arg0. size ( ) ; } return Math. max ( loc0, 0 ) ; }",
        "long function ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 = loc1 ; } } return loc0 ; } catch ( Exception loc1 ) { loc0 = Math. loc0 ( loc0, arg0. size ( ) - 1 ) ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc1 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. loc0 ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. loc0 ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc1 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "max_sublist_sum.",
        "Returns the max_sublist sum of the elements in the array.",
        "Gets the max_sublist_sum.",
        "Get the max_sublist_sum of the array.",
        "Gets the max_sublist_sum of the array."
      ],
      "output": [
        {
          "patch": "public static int max_sublist_sum ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { loc0 = Math. max ( loc0, loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max_sublist_sum ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max_sublist_sum ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc1 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max_sublist_sum ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( T [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. loc0 ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long max_sublist_sum ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 > loc0 ) { loc0 = loc1 ; } } if ( loc0 < arg0. size ( ) ) { loc0 = Math. max ( loc0, arg0. size ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long max_sublist_sum ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 > loc0 ) { loc0 = loc1 ; } } if ( loc0 < arg0. size ( ) ) { loc0 = Math. max ( loc0, arg0. get ( loc0 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long max_sublist_sum ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 = loc1 ; } } if ( loc0 > 0 ) { loc0 = Math. max ( loc0, loc0 / arg0. size ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long max_sublist_sum ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 = loc1 ; } } if ( loc0 < loc0 / arg0. size ( ) ) { loc0 = loc0 + 1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static long max_sublist_sum ( List < T > arg0 ) { long loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc1 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. loc0 ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 = Math. loc0 ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc1 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > arg0 [ loc0 ] ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int max_sublist_sum ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 = Math. max ( loc0, arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "IS_VALID_PARENTHESIZATION": {
      "loc": "24-25",
      "input": "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\n    for (int i = 0; i < parens.length(); i++) {\n        Character paren = parens.charAt(i);\n        if (paren.equals('(')) {\n            depth++;\n        } else {\n            depth--;\n            if (depth < 0) { return false; }\n        }\n    }\n    return true; \n}",
      "target": "public static Boolean is_valid_parenthesization(String parens) {\n    int depth = 0;\n    for (int i = 0; i < parens.length(); i++) {\n        Character paren = parens.charAt(i);\n        if (paren.equals('(')) {\n            depth++;\n        } else {\n            depth--;\n            if (depth < 0) { return false; }\n        }\n    } \n    return depth==0;\n}",
      "function range": "13,5-25,5",
      "raw_output": [
        "boolean function ( String arg0 ) { return arg0. contains ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) && arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) || arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { return ( arg0!= null && arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { return arg0. contains ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0!= null && arg0. contains ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return arg0. contains ( '(' ) ; }",
        "boolean function ( String arg0 ) { return ( arg0!= null && arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { return arg0. contains ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) && arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) || arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { String [ ] loc0 = arg0. split ( \"srini_string\" ) ; return loc0. length > 0 && loc0 [ 0 ] == '(' ; }",
        "boolean function ( String arg0 ) { return arg0. contains ( \"srini_string\" ) ; }",
        "boolean function ( String arg0 ) { return is_valid_parenthesization ( arg0 ) ; }",
        "boolean function ( String arg0 ) { return arg0. contains ( '(' ) ; }",
        "boolean function ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) ) ; }",
        "boolean function ( String arg0 ) { return arg0. indexOf ( '(' ) > - 1 ; }",
        "boolean function ( Parenthesis arg0 ) { if (! ( arg0 instanceof Parenthesis ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ( ( Parenthesis ) arg0 ). is_valid_parenthesization ( ) ; }",
        "boolean function ( Parenthesis arg0 ) { if (! ( arg0 instanceof Parenthesis ) ) return false ; Parenthesis loc0 = ( Parenthesis ) arg0 ; if (! is_valid_parenthesization ( loc0 ) ) return false ; return true ; }",
        "boolean function ( Parenthesis arg0 ) { if (! ( arg0 instanceof Parenthesis ) ) return false ; Parenthesis loc0 = ( Parenthesis ) arg0 ; if (! ( loc0 instanceof Parenthesis ) ) return false ; return true ; }",
        "boolean function ( Parenthesis arg0 ) { if (! ( arg0 instanceof Parenthesis ) ) return false ; Parenthesis loc0 = ( Parenthesis ) arg0 ; if ( loc0. is_valid_parenthesization ( ) ) return true ; return false ; }",
        "boolean function ( Parenthesis arg0 ) { if ( arg0 instanceof Parenthesis ) { Parenthesis loc0 = ( Parenthesis ) arg0 ; if ( loc0. is_valid_parenthesization ( ) ) { return true ; } } return false ; }"
      ],
      "mid_translation": [
        "is_valid_parenthesization This method checks if the string contains a valid parentheses.",
        "is_valid_parenthesization This method checks if the given string contains a valid parentheses.",
        "is_valid_parenthesization This method checks if the string contains a valid parens.",
        "is_valid_parenthesization This method checks if the given string is a valid parens string.",
        "is_valid_parenthesization Method."
      ],
      "output": [
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return arg0. contains ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) && arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) || arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0!= null && arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return arg0. contains ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return arg0!= null && arg0. contains ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return arg0. contains ( '(' ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0!= null && arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return arg0. contains ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) && arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) || arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { String [ ] loc0 = arg0. split ( \"srini_string\" ) ; return loc0. length > 0 && loc0 [ 0 ] == '(' ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return arg0. contains ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return is_valid_parenthesization ( arg0 ) ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return arg0. contains ( '(' ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return ( arg0. contains ( \"srini_string\" ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( String arg0 ) { return arg0. indexOf ( '(' ) > - 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( Parenthesis arg0 ) { if (! ( arg0 instanceof Parenthesis ) ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ( ( Parenthesis ) arg0 ). is_valid_parenthesization ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( Parenthesis arg0 ) { if (! ( arg0 instanceof Parenthesis ) ) return false ; Parenthesis loc0 = ( Parenthesis ) arg0 ; if (! is_valid_parenthesization ( loc0 ) ) return false ; return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( Parenthesis arg0 ) { if (! ( arg0 instanceof Parenthesis ) ) return false ; Parenthesis loc0 = ( Parenthesis ) arg0 ; if (! ( loc0 instanceof Parenthesis ) ) return false ; return true ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( Parenthesis arg0 ) { if (! ( arg0 instanceof Parenthesis ) ) return false ; Parenthesis loc0 = ( Parenthesis ) arg0 ; if ( loc0. is_valid_parenthesization ( ) ) return true ; return false ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static boolean is_valid_parenthesization ( Parenthesis arg0 ) { if ( arg0 instanceof Parenthesis ) { Parenthesis loc0 = ( Parenthesis ) arg0 ; if ( loc0. is_valid_parenthesization ( ) ) { return true ; } } return false ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "BREADTH_FIRST_SEARCH": {
      "loc": "24-25",
      "input": "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode);\n    while (true) { \n        Node node = queue.removeFirst();\n        if (node == goalnode) {\n            return true;\n        } else {\n            for (Node successor_node : node.getSuccessors()) {\n                if (!nodesvisited.contains(successor_node)) {\n                    queue.addFirst(successor_node);\n                    nodesvisited.add(successor_node);\n                }\n            }\n        }\n    }\n    return false;\n}",
      "target": "public static boolean breadth_first_search(Node startnode, Node goalnode) {\n    Deque<Node> queue = new ArrayDeque<>();\n    queue.addLast(startnode);\n    nodesvisited.add(startnode); \n    while (!queue.isEmpty()) {\n        Node node = queue.removeFirst();\n        if (node == goalnode) {\n            return true;\n        } else {\n            for (Node successor_node : node.getSuccessors()) {\n                if (!nodesvisited.contains(successor_node)) {\n                    queue.addFirst(successor_node);\n                    nodesvisited.add(successor_node);\n                }\n            }\n        }\n    }\n     return false;\n}",
      "function range": "18,5-39,5",
      "raw_output": [
        "int function ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc2 = loc1 + 1 ; } arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
        "int function ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg1 ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int [ ] arg0, int arg1, int arg2 ) { int loc0 = arg2 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc0 = loc1 ; } arg0 [ loc1 ] = loc0 ; } return loc0 ; }",
        "int function ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { break ; } loc0 = loc1 ; } return loc0 ; }",
        "int function ( int [ ] arg0, int arg1, int arg2 ) { int loc0 = arg2 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc0 = loc1 ; } else if ( loc2 >= arg1 ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int arg0, int arg1, int arg2 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == arg2 ) { return - 1 ; } else { return bfs ( arg0, arg1 - 1, arg2 - 1 ) ; } }",
        "int function ( int arg0, int arg1, int arg2 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == arg2 ) { return - 1 ; } else if ( arg1 == arg2 ) { return + 1 ; } else { return binarySearch ( arg0, arg1 - 1, arg2 - 1 ) ; } }",
        "int function ( int arg0, int arg1, int arg2 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == arg2 ) { return - 1 ; } else if ( arg1 == arg2 ) { return + 1 ; } else { return binarySearch ( arg0, arg1 - 1, arg2 ) ; } }",
        "int function ( int arg0, int arg1, int arg2 ) { if ( arg0 < arg1 ) { if ( arg0 == arg2 ) { return 0 ; } else if ( arg1 < arg2 ) { return - 1 ; } else if ( arg1 > arg2 ) { return 1 ; } else { return arg0 ; } } }",
        "int function ( int arg0, int arg1, int arg2 ) { if ( arg0 < arg1 ) { if ( arg0 == arg2 ) { return 0 ; } else if ( arg1 < arg2 ) { return - 1 ; } else if ( arg1 > arg2 ) { return + 1 ; } else { return arg0 ; } } }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Comparable > function ( Comparable [ ] arg0, int arg1 ) { List < Comparable > loc0 = new ArrayList < Comparable > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { Comparable loc2 = arg0 [ loc1 ] ; if ( loc2. compareTo ( loc1 ) >= 0 ) loc0. add ( loc2 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < > ( ) ; for ( Integer loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. indexOf ( loc1 ) ; if ( loc2 < 0 ) { loc0. add ( loc1 ) ; } loc0. remove ( loc2 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. indexOf ( loc1 ) ; if ( loc2 < 0 ) { loc0. add ( loc1 ) ; } loc0. remove ( loc2 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; if ( loc2 < 0 ) { loc0. add ( loc1 ) ; } loc0. remove ( loc2 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; if ( loc2 < 0 ) { loc0. add ( loc1 ) ; } loc0. add ( loc2 ) ; } return loc0 ; }",
        "int function ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc2 = loc1 + 1 ; } arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc2 = loc1 + 1 ; } arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
        "int function ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { break ; } arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
        "int function ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg1 ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int [ ] arg0, int arg1, int arg2 ) { int loc0 = arg2 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; int loc3 = ( loc1 + 1 ) / 2 ; if ( loc2 < loc3 ) { loc0 = loc2 ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Breadth - first search.",
        "Breadth - first search of two nodes.",
        "Method breadth_first_search.",
        "Breadth first search.",
        "breadth - first search."
      ],
      "output": [
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc2 = loc1 + 1 ; } arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg1 ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0, int arg1, int arg2 ) { int loc0 = arg2 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc0 = loc1 ; } arg0 [ loc1 ] = loc0 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { break ; } loc0 = loc1 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0, int arg1, int arg2 ) { int loc0 = arg2 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc0 = loc1 ; } else if ( loc2 >= arg1 ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int arg0, int arg1, int arg2 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == arg2 ) { return - 1 ; } else { return bfs ( arg0, arg1 - 1, arg2 - 1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int breadth_first_search ( int arg0, int arg1, int arg2 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == arg2 ) { return - 1 ; } else if ( arg1 == arg2 ) { return + 1 ; } else { return binarySearch ( arg0, arg1 - 1, arg2 - 1 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int breadth_first_search ( int arg0, int arg1, int arg2 ) { if ( arg0 == arg1 ) { return 0 ; } else if ( arg1 == arg2 ) { return - 1 ; } else if ( arg1 == arg2 ) { return + 1 ; } else { return binarySearch ( arg0, arg1 - 1, arg2 ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int breadth_first_search ( int arg0, int arg1, int arg2 ) { if ( arg0 < arg1 ) { if ( arg0 == arg2 ) { return 0 ; } else if ( arg1 < arg2 ) { return - 1 ; } else if ( arg1 > arg2 ) { return 1 ; } else { return arg0 ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int breadth_first_search ( int arg0, int arg1, int arg2 ) { if ( arg0 < arg1 ) { if ( arg0 == arg2 ) { return 0 ; } else if ( arg1 < arg2 ) { return - 1 ; } else if ( arg1 > arg2 ) { return + 1 ; } else { return arg0 ; } } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > breadth_first_search ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > breadth_first_search ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Comparable > breadth_first_search ( Comparable [ ] arg0, int arg1 ) { List < Comparable > loc0 = new ArrayList < Comparable > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { Comparable loc2 = arg0 [ loc1 ] ; if ( loc2. compareTo ( loc1 ) >= 0 ) loc0. add ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > breadth_first_search ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > breadth_first_search ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < > ( ) ; for ( Integer loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > breadth_first_search ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. indexOf ( loc1 ) ; if ( loc2 < 0 ) { loc0. add ( loc1 ) ; } loc0. remove ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > breadth_first_search ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. indexOf ( loc1 ) ; if ( loc2 < 0 ) { loc0. add ( loc1 ) ; } loc0. remove ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > breadth_first_search ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; if ( loc2 < 0 ) { loc0. add ( loc1 ) ; } loc0. remove ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > breadth_first_search ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > breadth_first_search ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; if ( loc2 < 0 ) { loc0. add ( loc1 ) ; } loc0. add ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc2 = loc1 + 1 ; } arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { loc2 = loc1 + 1 ; } arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; if ( loc2 < 0 ) { break ; } arg0 [ loc1 ] = loc2 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0, int arg1 ) { int loc0 = arg0. length ; for ( int loc1 = 0 ; loc1 < loc0 ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg1 ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int breadth_first_search ( int [ ] arg0, int arg1, int arg2 ) { int loc0 = arg2 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { int loc2 = arg0 [ loc1 ] ; int loc3 = ( loc1 + 1 ) / 2 ; if ( loc2 < loc3 ) { loc0 = loc2 ; } } return loc0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "GCD": {
      "loc": "19-20",
      "input": "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(a % b, b); \n    }\n}",
      "target": "public static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a%b); \n    }\n}",
      "function range": "15,5-21,5",
      "raw_output": [
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return greatestCommonDivisor ( arg0, arg1 - 1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return gcd ( arg1, arg0 ) ; } else { return arg1 ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( final int arg0, final int arg1 ) { return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( final int arg0, final int arg1 ) { if ( arg0 == arg1 ) { return gcd ( arg0, arg1 ) ; } else if ( arg1 == 0 ) { return arg0 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
        "int function ( final int arg0, final int arg1 ) { if ( arg0 == arg1 ) { return gcd ( arg0, arg1 ) ; } else if ( arg1 == arg0 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
        "int function ( final int arg0, final int arg1 ) { if ( arg0 == arg1 ) { return gcd ( arg0, arg1 ) ; } else if ( arg1 == arg0 ) { return arg1 ; } else if ( arg1 == arg1 ) { return gcd ( arg0, arg1 ) ; } else { return arg1 ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg0, arg1 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg0 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return greatestCommonDivisor ( arg0, arg1 - 1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return greatestCommonDivisor ( arg0, arg1 - 1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg1 % arg0 == 0 ) return arg0 ; else return gcd ( arg1, arg0 % arg0 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return greatestCommonDivisor ( arg0, arg1 - 1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg0, arg1 % arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }"
      ],
      "mid_translation": [
        "Compute the greatest common divisor of two sets of tokens.",
        "Greatest common divisor of two sets of tokens.",
        "Get the greatest common divisor of two sets of tokens.",
        "Compute the greatest common divisor of two tokens.",
        "Calculate the greatest common divisor of two sets of tokens."
      ],
      "output": [
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return greatestCommonDivisor ( arg0, arg1 - 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return gcd ( arg1, arg0 ) ; } else { return arg1 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static int gcd ( final int arg0, final int arg1 ) { return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( final int arg0, final int arg1 ) { if ( arg0 == arg1 ) { return gcd ( arg0, arg1 ) ; } else if ( arg1 == 0 ) { return arg0 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( final int arg0, final int arg1 ) { if ( arg0 == arg1 ) { return gcd ( arg0, arg1 ) ; } else if ( arg1 == arg0 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( final int arg0, final int arg1 ) { if ( arg0 == arg1 ) { return gcd ( arg0, arg1 ) ; } else if ( arg1 == arg0 ) { return arg1 ; } else if ( arg1 == arg1 ) { return gcd ( arg0, arg1 ) ; } else { return arg1 ; } }",
          "correctness": "timeout"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg0, arg1 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg0 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return greatestCommonDivisor ( arg0, arg1 - 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return greatestCommonDivisor ( arg0, arg1 - 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg1 % arg0 == 0 ) return arg0 ; else return gcd ( arg1, arg0 % arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; else return gcd ( arg1, arg0 % arg1 ) ; }",
          "correctness": "plausible"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return greatestCommonDivisor ( arg0, arg1 - 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) return arg1 ; return gcd ( arg0, arg1 % arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int gcd ( int arg0, int arg1 ) { if ( arg0 % arg1 == 0 ) { return arg1 ; } else if ( arg0 % arg1 == 1 ) { return arg1 ; } else { return gcd ( arg1, arg0 % arg1 ) ; } }",
          "correctness": "wrong"
        }
      ]
    },
    "LEVENSHTEIN": {
      "loc": "17-18",
      "input": "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty() ? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return 1 + levenshtein(source.substring(1), target.substring(1)); \n    } else {\n        return 1 + Math.min(Math.min(\n                levenshtein(source,              target.substring(1)),\n                levenshtein(source.substring(1), target.substring(1))),\n                levenshtein(source.substring(1), target)\n    );\n    }\n}",
      "target": "public static int levenshtein(String source, String target) {\n    if (source.isEmpty() || target.isEmpty()) {\n        return source.isEmpty() ? target.length() : source.length();\n    } else if (source.charAt(0) == target.charAt(0)) {\n        return levenshtein(source.substring(1), target.substring(1)); \n    } else {\n        return 1 + Math.min(Math.min(\n                levenshtein(source,              target.substring(1)),\n                levenshtein(source.substring(1), target.substring(1))),\n                levenshtein(source.substring(1), target)\n    );\n    }\n}",
      "function range": "13,5-25,5",
      "raw_output": [
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return loc0 ; }",
        "long function ( String arg0, String arg1 ) { long loc0 = Long. parseLong ( arg0 ) ; long loc1 = Long. parseLong ( arg1 ) ; return ( loc0 - loc1 ) / ( loc1 + loc0 ) ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else if ( loc0 < 0 ) { return 1 ; } else { return loc0 ; } }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 == 0 ) { return arg0. compareTo ( arg1 ) ; } else { return loc0 ; } }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else { return loc0 ; } }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else if ( loc0 < 0 ) { return 1 ; } else { return loc0 ; } }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return loc0 ; } else { return 0 ; } }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 == 0 ) { return 0 ; } else if ( loc0 > 0 ) { return 1 ; } else { return loc0 ; } }",
        "long function ( String arg0, String arg1 ) { long loc0 = Long. parseLong ( arg0 ) ; long loc1 = Long. parseLong ( arg1 ) ; return ( loc0 - loc1 ) / ( loc1 + loc0 ) ; }",
        "double function ( String arg0, String arg1 ) { return levenshtein ( arg0, arg1 ) ; }",
        "double function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } if ( arg0 == null || arg1 == null ) { return 0 ; } return levenshtein ( arg0, arg1 ) ; }",
        "double function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } else if ( arg0 == null || arg1 == null ) { return 0 ; } else { return levenshtein ( arg0, arg1 ) ; } }",
        "double function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } if ( arg0 == null || arg1 == null ) { return - 1 ; } return levenshtein ( arg0, arg1 ) ; }",
        "double function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } return levenshtein ( arg0, arg1 ) ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return loc0 ; }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else if ( loc0 < 0 ) { return 1 ; } else { return loc0 ; } }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 == 0 ) { return 0 ; } else if ( loc0 > 0 ) { return 1 ; } else { return loc0 ; } }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else { return loc0 ; } }",
        "int function ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 == 0 ) { return arg0. compareTo ( arg1 ) ; } else { return loc0 ; } }",
        "double function ( String arg0, String arg1 ) { return ( Math. abs ( arg0. compareTo ( arg1 ) ) ) ; }",
        "double function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return 0 ; } else if ( arg0 == null || arg1 == null ) { return - 1 ; } else if ( arg1 == null ) { return arg0. compareTo ( arg1 ) ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "double function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return 0 ; } else if ( arg0 == null || arg1 == null ) { return - 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
        "double function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } if ( arg0 == null || arg1 == null ) { return 0 ; } return arg0. compareTo ( arg1 ) ; }",
        "double function ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } else if ( arg0 == null || arg1 == null ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }"
      ],
      "mid_translation": [
        "Get the levenshtein distance between two strings.",
        "Get the levenshtein distance between two strings",
        "Compute the levenshtein distance between two strings.",
        "Gets the levenshtein distance between two strings.",
        "Get the Levenshtein distance between two strings"
      ],
      "output": [
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static long levenshtein ( String arg0, String arg1 ) { long loc0 = Long. parseLong ( arg0 ) ; long loc1 = Long. parseLong ( arg1 ) ; return ( loc0 - loc1 ) / ( loc1 + loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else if ( loc0 < 0 ) { return 1 ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 == 0 ) { return arg0. compareTo ( arg1 ) ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else if ( loc0 < 0 ) { return 1 ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return loc0 ; } else { return 0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 == 0 ) { return 0 ; } else if ( loc0 > 0 ) { return 1 ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static long levenshtein ( String arg0, String arg1 ) { long loc0 = Long. parseLong ( arg0 ) ; long loc1 = Long. parseLong ( arg1 ) ; return ( loc0 - loc1 ) / ( loc1 + loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { return levenshtein ( arg0, arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } if ( arg0 == null || arg1 == null ) { return 0 ; } return levenshtein ( arg0, arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } else if ( arg0 == null || arg1 == null ) { return 0 ; } else { return levenshtein ( arg0, arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } if ( arg0 == null || arg1 == null ) { return - 1 ; } return levenshtein ( arg0, arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } return levenshtein ( arg0, arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" + arg0 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else if ( loc0 < 0 ) { return 1 ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 == 0 ) { return 0 ; } else if ( loc0 > 0 ) { return 1 ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 > 0 ) { return 1 ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int levenshtein ( String arg0, String arg1 ) { int loc0 = arg0. compareTo ( arg1 ) ; if ( loc0 < 0 ) { return - 1 ; } else if ( loc0 == 0 ) { return arg0. compareTo ( arg1 ) ; } else { return loc0 ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { return ( Math. abs ( arg0. compareTo ( arg1 ) ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return 0 ; } else if ( arg0 == null || arg1 == null ) { return - 1 ; } else if ( arg1 == null ) { return arg0. compareTo ( arg1 ) ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return 0 ; } else if ( arg0 == null || arg1 == null ) { return - 1 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } if ( arg0 == null || arg1 == null ) { return 0 ; } return arg0. compareTo ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double levenshtein ( String arg0, String arg1 ) { if ( arg0 == null || arg1 == null ) { return - 1 ; } else if ( arg0 == null || arg1 == null ) { return 0 ; } else { return arg0. compareTo ( arg1 ) ; } }",
          "correctness": "wrong"
        }
      ]
    },
    "BITCOUNT": {
      "loc": "15-16",
      "input": "public static int bitcount(int n) {\nint count = 0;\nwhile (n != 0) {\n    n = (n ^ (n - 1)); \n    count++;\n}\nreturn count;\n}",
      "target": "public static int bitcount(int n) {\nint count = 0;\nwhile (n != 0) { \n    n = (n & (n - 1));\n    count++;\n}\nreturn count;\n}",
      "function range": "12,5-19,5",
      "raw_output": [
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( 1 << loc0 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >>> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( 0x1 << loc0 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> loc0 )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 += Long. bitCount ( arg0 ) ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >>> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >>> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> loc0 )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 += Long. bitCount ( arg0 ) ; } return loc0 ; }",
        "int function ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 |= ( arg0. getByte ( loc1 ) << loc1 ) ; } return loc0 ; }",
        "int function ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 |= ( arg0. charAt ( loc1 ) << loc1 ) ; } return loc0 ; }",
        "int function ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 |= ( arg0. getByte ( loc1 ) & ( 1 << loc1 ) ) ; } return loc0 ; }",
        "int function ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 |= ( arg0. getByte ( loc1 ) << ( 8 * loc1 ) ) ; } return loc0 ; }",
        "int function ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. bitCount ( ) ; loc1 ++ ) { loc0 <<= 1 ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >>> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( 0x1 << loc0 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( 1 << loc0 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Returns the number of bits in a given integer.",
        "Count the number of bits in a given integer.",
        "Count the number of bits in an integer.",
        "bitcount returns the number of bits of n.",
        "Returns the number of bits in the given integer."
      ],
      "output": [
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( 1 << loc0 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >>> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( 0x1 << loc0 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> loc0 )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 += Long. bitCount ( arg0 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >>> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >>> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> loc0 )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 += Long. bitCount ( arg0 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 |= ( arg0. getByte ( loc1 ) << loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bitcount ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ( ) ; loc1 ++ ) { loc0 |= ( arg0. charAt ( loc1 ) << loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bitcount ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 |= ( arg0. getByte ( loc1 ) & ( 1 << loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bitcount ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < 32 ; loc1 ++ ) { loc0 |= ( arg0. getByte ( loc1 ) << ( 8 * loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bitcount ( Integer arg0 ) { if ( arg0 == null ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. bitCount ( ) ; loc1 ++ ) { loc0 <<= 1 ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "timeout"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 >>> ( arg0 - 1 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( 0x1 << loc0 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int bitcount ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } int loc0 = 0 ; while ( ( arg0 & ( 1 << loc0 ) )!= 0 ) { loc0 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "MINIMUM_SPANNING_TREE": {
      "loc": "28-29",
      "input": "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge);\n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                groupByNode = update(groupByNode, node, vertex_u); \n            }\n        }\n    }\n    return minSpanningTree;\n}",
      "target": "public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n    Map<Node,Set<Node>> groupByNode = new HashMap<>();\n    Set<WeightedEdge> minSpanningTree = new HashSet<>();\n    Collections.sort(weightedEdges);\n    for (WeightedEdge edge : weightedEdges) {\n        Node vertex_u = edge.node1;\n        Node vertex_v = edge.node2;\n        if (!groupByNode.containsKey(vertex_u)){\n            groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n        }\n        if (!groupByNode.containsKey(vertex_v)){\n            groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n        }\n        if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n            minSpanningTree.add(edge); \n            groupByNode = update(groupByNode, vertex_u, vertex_v);\n            for (Node node : groupByNode.get(vertex_v)) {\n                groupByNode.put(node,  groupByNode.get(vertex_u));\n            }\n        }\n    }\n    return minSpanningTree;\n}",
      "function range": "7,5-33,5",
      "raw_output": [
        "List < Integer > function ( List < Integer > arg0 ) { return minimum_spanning_tree ( arg0, null ) ; }",
        "List < Integer > function ( List < Integer > arg0 ) { return minimum_spanning_tree ( arg0, 0 ) ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = arg0 ; while ( loc0 < arg1 ) { int loc1 = ( arg1 + loc0 ) / 2 ; if ( loc1 < arg0 ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = arg0 ; while ( loc0 < arg1 ) { int loc1 = ( loc0 + 1 ) % arg1 ; if ( loc1 < arg0 ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = arg0 ; while ( loc0 < arg1 ) { int loc1 = ( arg0 + arg1 - 1 ) ; if ( loc1 < loc0 ) { loc0 = loc1 ; } } return loc0 ; }",
        "SpanningTree function ( Graph arg0 ) { int loc0 = arg0. edgeSet. loc0 ( ) ; int loc1 = arg0. edgeSet. loc1 ( ) ; return new MinSpanningTree ( loc0, loc1 ) ; }",
        "SpanningTree function ( Graph arg0 ) { int loc0 = arg0. edgeSet. loc0 ( ) ; int loc1 = arg0. edgeSet. loc1 ( ) ; return new SpanningTree ( loc0, loc1 ) ; }",
        "SpanningTree function ( Graph arg0 ) { int loc0 = arg0. edgeSet. loc0 ( ) ; int loc1 = arg0. edgeSet. loc1 ( ) ; while ( loc0 > loc1 ) { loc0 = loc0 / 2 ; loc1 -- ; } return new MinSpanningTree ( arg0, loc1 ) ; }",
        "SpanningTree function ( Graph arg0 ) { int loc0 = arg0. edgeSet. loc0 ( ) ; int loc1 = arg0. edgeSet. loc1 ( ) ; while ( loc0 > loc1 ) { loc0 -- ; loc1 = loc0 + 1 ; } return new MinSpanningTree ( arg0, loc1 ) ; }",
        "SpanningTree function ( Graph arg0 ) { return new MinSpanningTree ( arg0 ) ; }",
        "SPanningTree function ( ) { return new MinSpanningTree ( ) ; }",
        "Tree < Integer > function ( ) { return null ; }",
        "Tree function ( ) { return Sponge. getSpanningTree ( ) ; }",
        "Tree < Integer > function ( ) { return new Tree < Integer > ( ) ; }",
        "Tree < Integer > function ( ) { return new Tree < > ( ) ; }",
        "SPanningTree function ( ) { return null ; }",
        "Tree function ( ) { return null ; }",
        "Tree < Integer > function ( ) { return null ; }",
        "SPanningTree function ( ) { return new MinSpanningTree ( ) ; }",
        "Tree function ( ) { return Sponge. getSpanningTree ( ) ; }",
        "SPanningTree function ( ) { return null ; }",
        "Tree function ( ) { return null ; }",
        "SPanningTreeNode function ( ) { return null ; }",
        "SpanningTree function ( ) { return null ; }",
        "SPanningTree function ( ) { return new MinSpanningTree ( ) ; }"
      ],
      "mid_translation": [
        "Method minimum_spanning_tree.",
        "This method returns the minimum spanning tree of edges.",
        "Get minimum spanning tree.",
        "Get the minimum spanning tree.",
        "Method to get the minimum spanning tree."
      ],
      "output": [
        {
          "patch": "public static List < Integer > minimum_spanning_tree ( List < Integer > arg0 ) { return minimum_spanning_tree ( arg0, null ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > minimum_spanning_tree ( List < Integer > arg0 ) { return minimum_spanning_tree ( arg0, 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int minimum_spanning_tree ( int arg0, int arg1 ) { int loc0 = arg0 ; while ( loc0 < arg1 ) { int loc1 = ( arg1 + loc0 ) / 2 ; if ( loc1 < arg0 ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int minimum_spanning_tree ( int arg0, int arg1 ) { int loc0 = arg0 ; while ( loc0 < arg1 ) { int loc1 = ( loc0 + 1 ) % arg1 ; if ( loc1 < arg0 ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int minimum_spanning_tree ( int arg0, int arg1 ) { int loc0 = arg0 ; while ( loc0 < arg1 ) { int loc1 = ( arg0 + arg1 - 1 ) ; if ( loc1 < loc0 ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static SpanningTree minimum_spanning_tree ( Graph arg0 ) { int loc0 = arg0. edgeSet. loc0 ( ) ; int loc1 = arg0. edgeSet. loc1 ( ) ; return new MinSpanningTree ( loc0, loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SpanningTree minimum_spanning_tree ( Graph arg0 ) { int loc0 = arg0. edgeSet. loc0 ( ) ; int loc1 = arg0. edgeSet. loc1 ( ) ; return new SpanningTree ( loc0, loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SpanningTree minimum_spanning_tree ( Graph arg0 ) { int loc0 = arg0. edgeSet. loc0 ( ) ; int loc1 = arg0. edgeSet. loc1 ( ) ; while ( loc0 > loc1 ) { loc0 = loc0 / 2 ; loc1 -- ; } return new MinSpanningTree ( arg0, loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SpanningTree minimum_spanning_tree ( Graph arg0 ) { int loc0 = arg0. edgeSet. loc0 ( ) ; int loc1 = arg0. edgeSet. loc1 ( ) ; while ( loc0 > loc1 ) { loc0 -- ; loc1 = loc0 + 1 ; } return new MinSpanningTree ( arg0, loc1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SpanningTree minimum_spanning_tree ( Graph arg0 ) { return new MinSpanningTree ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SPanningTree minimum_spanning_tree ( ) { return new MinSpanningTree ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Tree < Integer > minimum_spanning_tree ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Tree minimum_spanning_tree ( ) { return Sponge. getSpanningTree ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Tree < Integer > minimum_spanning_tree ( ) { return new Tree < Integer > ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Tree < Integer > minimum_spanning_tree ( ) { return new Tree < > ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SPanningTree minimum_spanning_tree ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Tree minimum_spanning_tree ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Tree < Integer > minimum_spanning_tree ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SPanningTree minimum_spanning_tree ( ) { return new MinSpanningTree ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Tree minimum_spanning_tree ( ) { return Sponge. getSpanningTree ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SPanningTree minimum_spanning_tree ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Tree minimum_spanning_tree ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SPanningTreeNode minimum_spanning_tree ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SpanningTree minimum_spanning_tree ( ) { return null ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static SPanningTree minimum_spanning_tree ( ) { return new MinSpanningTree ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "NEXT_PALINDROME": {
      "loc": "35-36",
      "input": "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid != high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\n    otherwise.add(1);\n    otherwise.addAll(Collections.nCopies(digit_list.length, 0)); \n    otherwise.add(1);\n    return String.valueOf(otherwise);\n}",
      "target": "public static String next_palindrome(int[] digit_list) {\n    int high_mid = Math.floorDiv(digit_list.length, 2);\n    int low_mid = Math.floorDiv(digit_list.length - 1, 2);\n    while (high_mid < digit_list.length && low_mid >= 0) {\n        if (digit_list[high_mid] == 9) {\n            digit_list[high_mid] = 0;\n            digit_list[low_mid] = 0;\n            high_mid += 1;\n            low_mid -= 1;\n        } else {\n            digit_list[high_mid] += 1;\n            if (low_mid != high_mid) {\n                digit_list[low_mid] += 1;\n            }\n            return Arrays.toString(digit_list);\n        }\n    }\n    ArrayList<Integer> otherwise = new ArrayList<Integer>();\n    otherwise.add(1);\n    otherwise.addAll(Collections.nCopies(digit_list.length-1, 0)); \n    otherwise.add(1);\n    return String.valueOf(otherwise);\n}",
      "function range": "14,5-39,5",
      "raw_output": [
        "int function ( ) { return next_palindrome ( ) ; }",
        "String function ( ) { return \"srini_string\" ; }",
        "int function ( ) { return ( next_palindrome ( ) ) ; }",
        "int function ( ) { return ( 30 ) ; }",
        "int function ( ) { throw new UnsupportedOperationException ( ) ; }",
        "String function ( ) { return ( \"srini_string\" ) ; }",
        "Graphics2D function ( ) { return ( Graphics2D ) next ( ) ; }",
        "Object function ( ) { return ( null ) ; }",
        "Object function ( ) { return next ( 0 ) ; }",
        "Object function ( ) { return getNext ( 0 ) ; }",
        " palindrome_1 function ( ) { return ( palindrome_1 ) ; }",
        " palindrome function ( ) { palindrome_1 loc0 = new palindrome_1 ( ) ; return ( loc0 ) ; }",
        " palindrome function ( ) { palindrome_1 loc0 = new palindrome_1 ( ) ; return loc0 ; }",
        " palindrome function ( ) { return ( palindrome ) ( Math. next ( 30 ) ) ; }",
        " palindrome function ( ) { return ( palindrome ) ( Math. next ( 10 ) ) ; }",
        "Graphics2D function ( ) { return ( Graphics2D ) this. palindrome. next ( ) ; }",
        "Graphics2D function ( ) { return ( Graphics2D ) next ( ) ; }",
        "Graphics2D function ( ) { return ( Graphics2D ) this. palindrome. getNext ( ) ; }",
        "Graphics2D function ( ) { return ( Graphics2D ) this. palindrome ( ) ; }",
        "Graphics2D function ( ) { return ( Graphics2D ) this. palindrome_Next ( ) ; }",
        " palindrome function ( ) { return ( palindrome ) ( Math. next ( 10 ) ) ; }",
        "URI function ( ) { return ( URI ) palindrome. getNext ( ) ; }",
        " palindrome function ( ) { return ( palindrome ) ; }",
        " palindrome function ( ) { return ( palindrome ) ( Math. next ( 30 ) ) ; }",
        " palindrome function ( ) { return ( palindrome ) ( Math. random ( ) ) ; }"
      ],
      "mid_translation": [
        "Method next_palindrome.",
        "Method to get the next palindrome.",
        "Get the next palindrome.",
        "This method returns the next palindrome.",
        "Gets the next palindrome."
      ],
      "output": [
        {
          "patch": "public static int next_palindrome ( ) { return next_palindrome ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String next_palindrome ( ) { return \"srini_string\" ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int next_palindrome ( ) { return ( next_palindrome ( ) ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int next_palindrome ( ) { return ( 30 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int next_palindrome ( ) { throw new UnsupportedOperationException ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String next_palindrome ( ) { return ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Graphics2D next_palindrome ( ) { return ( Graphics2D ) next ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Object next_palindrome ( ) { return ( null ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Object next_palindrome ( ) { return next ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Object next_palindrome ( ) { return getNext ( 0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static  palindrome_1 next_palindrome ( ) { return ( palindrome_1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static  palindrome next_palindrome ( ) { palindrome_1 loc0 = new palindrome_1 ( ) ; return ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static  palindrome next_palindrome ( ) { palindrome_1 loc0 = new palindrome_1 ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static  palindrome next_palindrome ( ) { return ( palindrome ) ( Math. next ( 30 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static  palindrome next_palindrome ( ) { return ( palindrome ) ( Math. next ( 10 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Graphics2D next_palindrome ( ) { return ( Graphics2D ) this. palindrome. next ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Graphics2D next_palindrome ( ) { return ( Graphics2D ) next ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Graphics2D next_palindrome ( ) { return ( Graphics2D ) this. palindrome. getNext ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Graphics2D next_palindrome ( ) { return ( Graphics2D ) this. palindrome ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Graphics2D next_palindrome ( ) { return ( Graphics2D ) this. palindrome_Next ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static  palindrome next_palindrome ( ) { return ( palindrome ) ( Math. next ( 10 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static URI next_palindrome ( ) { return ( URI ) palindrome. getNext ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static  palindrome next_palindrome ( ) { return ( palindrome ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static  palindrome next_palindrome ( ) { return ( palindrome ) ( Math. next ( 30 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static  palindrome next_palindrome ( ) { return ( palindrome ) ( Math. random ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "POSSIBLE_CHANGE": {
      "loc": "17-18",
      "input": "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    if (total < 0) { \n        return 0;\n    }\n    int first = coins[0];\n    int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n    return possible_change(coins, total-first) + possible_change(rest, total);\n}",
      "target": "public static int possible_change(int[] coins, int total) {\n    if (total == 0) {\n        return 1;\n    }\n    if (total < 0 ||coins.length==0) { \n        return 0;\n    }\n    int first = coins[0];\n    int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n    return possible_change(coins, total-first) + possible_change(rest, total);\n}",
      "function range": "13,5-24,5",
      "raw_output": [
        "int function ( List < T > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) > arg1 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < T > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) == arg1 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 > loc0 ) { loc0 = loc1 ; } } return loc0 ; }",
        "int function ( List < T > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) == arg1 ) { return loc0 ; } loc0 ++ ; } return - 1 ; }",
        "int function ( List < T > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) == arg1 ) { return loc0 ; } loc0 ++ ; } } return - 1 ; }",
        "int function ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } return loc0 ; }",
        "int function ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1!= null ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { loc0 += 1 ; } } } return loc0 ; }",
        "int function ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; ++ loc2 ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } return loc0 ; }",
        "int function ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1!= null ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } } return loc0 ; }",
        "int function ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1!= null ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; ++ loc2 ) { loc0 += 1 ; } } } return loc0 ; }",
        "int function ( List < Change > arg0 ) { int loc0 = 0 ; for ( Change loc1 : arg0 ) { int loc2 = loc1. getNumberOfPossibleChanges ( ) ; if ( loc2 > 0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Change > arg0 ) { int loc0 = 0 ; for ( Change loc1 : arg0 ) { int loc2 = loc1. getNumberOfPossibleChanges ( ) ; if ( loc2 > 0 ) { ++ loc0 ; } } return loc0 ; }",
        "int function ( List < Change > arg0 ) { int loc0 = 0 ; for ( Change loc1 : arg0 ) { if ( loc1!= null ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Change > arg0 ) { int loc0 = 0 ; for ( Change loc1 : arg0 ) { if ( loc1!= null ) { ++ loc0 ; } } return loc0 ; }",
        "int function ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } return loc0 ; }",
        "int function ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg1. getCoins ( ). size ( ) ; loc2 ++ ) { if ( arg0. getCoins ( loc1 ). contains ( arg1. getCoins ( loc2 ) ) ) loc0 ++ ; } } return loc0 ; }",
        "int function ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg1. getCoins ( ). size ( ) ; loc2 ++ ) { if ( arg1. getCoins ( loc1 ). contains ( arg0. getCoins ( loc2 ) ) ) loc0 ++ ; } } return loc0 ; }",
        "int function ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. getCoins ( ). size ( ) ; loc2 ++ ) { if ( arg1. getCoins ( loc1 ). contains ( arg0. getCoins ( loc2 ) ) ) loc0 ++ ; } } return loc0 ; }",
        "int function ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { if ( arg1. getCoins ( loc1 ). contains ( arg0. getCoins ( loc1 ) ) ) loc0 ++ ; } return loc0 ; }",
        "int function ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. getCoins ( ). size ( ) ; loc2 ++ ) { if ( arg1. getCoins ( loc1 ). contains ( arg1. getCoins ( loc2 ) ) ) loc0 ++ ; } } return loc0 ; }",
        "int function ( List < T > arg0, List < T > arg1 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < arg1. size ( ) ; loc2 ++ ) { if ( arg1. get ( loc2 ) == null ) { loc0 ++ ; } } } return loc0 ; }",
        "int function ( List < T > arg0, List < T > arg1 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < arg1. size ( ) ; loc2 ++ ) { if ( arg1. get ( loc2 )!= null ) { ++ loc0 ; } } } return loc0 ; }",
        "int function ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } return loc0 ; }",
        "int function ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc1. getCoins ( ). contains ( loc2 ) ) loc0 ++ ; } } return loc0 ; }",
        "int function ( List < T > arg0, List < T > arg1 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < arg1. size ( ) ; loc2 ++ ) { if ( arg1. get ( loc2 )!= null ) loc0 ++ ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Get the possible change of a list of coins.",
        "Get the number of possible changes in a list of coins.",
        "Returns the number of possible changes in a list of coins.",
        "Get the number of possible change of a set of coins.",
        "Get the number of possible changes in a list of coins"
      ],
      "output": [
        {
          "patch": "public static int possible_change ( List < T > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) > arg1 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) == arg1 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 > loc0 ) { loc0 = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) == arg1 ) { return loc0 ; } loc0 ++ ; } return - 1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) == arg1 ) { return loc0 ; } loc0 ++ ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1!= null ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { loc0 += 1 ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; ++ loc2 ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1!= null ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { if ( loc1!= null ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; ++ loc2 ) { loc0 += 1 ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < Change > arg0 ) { int loc0 = 0 ; for ( Change loc1 : arg0 ) { int loc2 = loc1. getNumberOfPossibleChanges ( ) ; if ( loc2 > 0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < Change > arg0 ) { int loc0 = 0 ; for ( Change loc1 : arg0 ) { int loc2 = loc1. getNumberOfPossibleChanges ( ) ; if ( loc2 > 0 ) { ++ loc0 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < Change > arg0 ) { int loc0 = 0 ; for ( Change loc1 : arg0 ) { if ( loc1!= null ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < Change > arg0 ) { int loc0 = 0 ; for ( Change loc1 : arg0 ) { if ( loc1!= null ) { ++ loc0 ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg1. getCoins ( ). size ( ) ; loc2 ++ ) { if ( arg0. getCoins ( loc1 ). contains ( arg1. getCoins ( loc2 ) ) ) loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg1. getCoins ( ). size ( ) ; loc2 ++ ) { if ( arg1. getCoins ( loc1 ). contains ( arg0. getCoins ( loc2 ) ) ) loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. getCoins ( ). size ( ) ; loc2 ++ ) { if ( arg1. getCoins ( loc1 ). contains ( arg0. getCoins ( loc2 ) ) ) loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { if ( arg1. getCoins ( loc1 ). contains ( arg0. getCoins ( loc1 ) ) ) loc0 ++ ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( Coins arg0, Coins arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. getCoins ( ). size ( ) ; loc1 ++ ) { for ( int loc2 = 0 ; loc2 < arg0. getCoins ( ). size ( ) ; loc2 ++ ) { if ( arg1. getCoins ( loc1 ). contains ( arg1. getCoins ( loc2 ) ) ) loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0, List < T > arg1 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < arg1. size ( ) ; loc2 ++ ) { if ( arg1. get ( loc2 ) == null ) { loc0 ++ ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0, List < T > arg1 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < arg1. size ( ) ; loc2 ++ ) { if ( arg1. get ( loc2 )!= null ) { ++ loc0 ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc2 > loc0 ) { loc0 ++ ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < loc1. getPrice ( ) ; loc2 ++ ) { if ( loc1. getCoins ( ). contains ( loc2 ) ) loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int possible_change ( List < T > arg0, List < T > arg1 ) { int loc0 = 0 ; for ( T loc1 : arg0 ) { for ( int loc2 = 0 ; loc2 < arg1. size ( ) ; loc2 ++ ) { if ( arg1. get ( loc2 )!= null ) loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "NEXT_PERMUTATION": {
      "loc": "19-20",
      "input": "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) < perm.get(i)) { \n                    ArrayList<Integer> next_perm = perm;\n                    int temp_j = perm.get(j);\n                    int temp_i = perm.get(i);\n                    next_perm.set(i,temp_j);\n                    next_perm.set(j,temp_i);\n                    ArrayList<Integer> reversed = new ArrayList<Integer>(100);\n                    for (int k=next_perm.size()-1; k!=i; k--) {\n                        reversed.add(next_perm.get(k));\n                    }\n                    int q = i + 1;\n                    for (Integer replace : reversed) {\n                        next_perm.set(q, replace);\n                        q++;\n                    }\n                    return next_perm;\n                }\n            }\n        }\n    }\n    return new ArrayList<Integer>();\n}",
      "target": "public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n    for (int i=perm.size()-2; i!=-1; i--) {\n        if (perm.get(i) < perm.get(i+1)) {\n            for (int j=perm.size()-1; j!=i; j--) {\n                if (perm.get(j) > perm.get(i)) { \n                    ArrayList<Integer> next_perm = perm;\n                    int temp_j = perm.get(j);\n                    int temp_i = perm.get(i);\n                    next_perm.set(i,temp_j);\n                    next_perm.set(j,temp_i);\n                    ArrayList<Integer> reversed = new ArrayList<Integer>(100);\n                    for (int k=next_perm.size()-1; k!=i; k--) {\n                        reversed.add(next_perm.get(k));\n                    }\n                    int q = i + 1;\n                    for (Integer replace : reversed) {\n                        next_perm.set(q, replace);\n                        q++;\n                    }\n                    return next_perm;\n                }\n            }\n        }\n    }\n    return new ArrayList<Integer>();\n}",
      "function range": "15,5-44,5",
      "raw_output": [
        "PermutationFunction2 function ( int arg0 ) { PermutationFunction2 loc0 = ( PermutationFunction2 ) next_permutation ( arg0 ) ; return loc0 ; }",
        "Permutations function ( int arg0 ) { while ( arg0 < arg0 ) { arg0 = next_permutation ( ) ; } return new Permutations ( arg0 ) ; }",
        "PermutationList function ( int arg0 ) { PermutationList loc0 = new PermutationList ( ) ; loc0. set ( arg0 ) ; return loc0 ; }",
        "PermutationType function ( ) { PermutationType loc0 = ( PermutationType ) next_permutation ( ) ; return loc0 ; }",
        "Permutations function ( ) { return next_permutation ( ) ; }",
        "int function ( int arg0, List < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. size ( ) ; loc1 ++ ) { if ( arg1. get ( loc1 ) < 0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) == arg1 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; } return ( loc0 ) ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = ( List < Integer > ) arg0. get ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "int function ( int arg0 ) { while ( arg0 < permutation. arg0 ) { arg0 ++ ; } return ( arg0 < permutation. arg0 )? permutation. arg0 : arg0 ; }",
        "int function ( int arg0 ) { while ( arg0 < permutation. arg0 ) { arg0 += permutation. arg0 ; } return arg0 ; }",
        "Permutations function ( int arg0 ) { return new Permutations ( ) ; }",
        "int function ( int arg0 ) { while ( arg0 < permutation. arg0 ) { arg0 ++ ; } return arg0 ; }",
        "int function ( int arg0 ) { while ( arg0 < permutation. arg0 ( ) ) { arg0 ++ ; } return arg0 ; }",
        "IntUnaryOperator function ( int arg0 ) { return ( IntUnaryOperator ) next ( arg0 ) ; }",
        "Permutations < E > function ( int arg0 ) { return new Permutations < E > ( ) ; }",
        "Permutations function ( int arg0 ) { return new Permutations ( ) ; }",
        "int function ( int arg0 ) { return ( arg0 < 0? 1 : arg0 ) ; }",
        "IntUnaryOperator function ( ) { return ( IntUnaryOperator ) next ( ) ; }"
      ],
      "mid_translation": [
        "Method next_permutation.",
        "Get the next permutation of a list of integers.",
        "This method returns the next permutation in the list.",
        "Get the next permutation.",
        "Gets the next permutation."
      ],
      "output": [
        {
          "patch": "public static PermutationFunction2 next_permutation ( int arg0 ) { PermutationFunction2 loc0 = ( PermutationFunction2 ) next_permutation ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Permutations next_permutation ( int arg0 ) { while ( arg0 < arg0 ) { arg0 = next_permutation ( ) ; } return new Permutations ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static PermutationList next_permutation ( int arg0 ) { PermutationList loc0 = new PermutationList ( ) ; loc0. set ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static PermutationType next_permutation ( ) { PermutationType loc0 = ( PermutationType ) next_permutation ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Permutations next_permutation ( ) { return next_permutation ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int next_permutation ( int arg0, List < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg1. size ( ) ; loc1 ++ ) { if ( arg1. get ( loc1 ) < 0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int next_permutation ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int next_permutation ( List < Integer > arg0, int arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) == arg1 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int next_permutation ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int next_permutation ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > next_permutation ( List < Integer > arg0 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > next_permutation ( List < Integer > arg0, int arg1 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > next_permutation ( List < Integer > arg0 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = arg0. get ( loc1 ) ; } return ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > next_permutation ( List < Integer > arg0 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 = ( List < Integer > ) arg0. get ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > next_permutation ( List < Integer > arg0 ) { List < Integer > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int next_permutation ( int arg0 ) { while ( arg0 < permutation. arg0 ) { arg0 ++ ; } return ( arg0 < permutation. arg0 )? permutation. arg0 : arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int next_permutation ( int arg0 ) { while ( arg0 < permutation. arg0 ) { arg0 += permutation. arg0 ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Permutations next_permutation ( int arg0 ) { return new Permutations ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int next_permutation ( int arg0 ) { while ( arg0 < permutation. arg0 ) { arg0 ++ ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int next_permutation ( int arg0 ) { while ( arg0 < permutation. arg0 ( ) ) { arg0 ++ ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static IntUnaryOperator next_permutation ( int arg0 ) { return ( IntUnaryOperator ) next ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Permutations < E > next_permutation ( int arg0 ) { return new Permutations < E > ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Permutations next_permutation ( int arg0 ) { return new Permutations ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int next_permutation ( int arg0 ) { return ( arg0 < 0? 1 : arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static IntUnaryOperator next_permutation ( ) { return ( IntUnaryOperator ) next ( ) ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "RPN_EVAL": {
      "loc": "34-35",
      "input": "public static Double rpn_eval(ArrayList tokens) {\n    Map<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\n    op.put(\"+\", (a, b) -> a + b);\n    op.put(\"-\", (a, b) -> a - b);\n    op.put(\"*\", (a, b) -> a * b);\n    op.put(\"/\", (a, b) -> a / b);\n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\n            token = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\n            Double c = 0.0;\n            BinaryOperator<Double> bin_op = op.get(token);\n            c = bin_op.apply(a,b); \n            stack.push(c);\n        }\n    }\n    return (Double) stack.pop();\n}",
      "target": "public static Double rpn_eval(ArrayList tokens) {\n    Map<String, BinaryOperator<Double>> op = new HashMap<String, BinaryOperator<Double>>();\n    op.put(\"+\", (a, b) -> a + b);\n    op.put(\"-\", (a, b) -> a - b);\n    op.put(\"*\", (a, b) -> a * b);\n    op.put(\"/\", (a, b) -> a / b);\n    Stack stack = new Stack();\n    for (Object token : tokens) {\n        if (Double.class.isInstance(token)) {\n            stack.push((Double) token);\n        } else {\n            token = (String) token;\n            Double a = (Double) stack.pop();\n            Double b = (Double) stack.pop();\n            Double c = 0.0;\n            BinaryOperator<Double> bin_op = op.get(token);\n            c = bin_op.apply(b,a); \n            stack.push(c);\n        }\n    }\n    return (Double) stack.pop();\n}",
      "function range": "15,5-40,5",
      "raw_output": [
        "List < P > function ( List < P > arg0 ) { List < P > loc0 = null ; if ( arg0!= null ) { for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = ( P ) arg0. get ( loc1 ) ; if ( loc2!= null ) { loc0 = evaluate ( loc2, arg0. get ( loc1 ) ) ; } } } return loc0 ; }",
        "List < P > function ( List < P > arg0 ) { List < P > loc0 = null ; if ( arg0!= null ) { for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = arg0. get ( loc1 ) ; if ( loc2!= null ) { loc0 = evaluate ( loc2, arg0. get ( loc1 ) ) ; } } } return loc0 ; }",
        "List < P > function ( List < P > arg0 ) { List < P > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = ( P ) arg0. get ( loc1 ) ; if ( loc2!= null ) { loc0 = evaluate ( loc2, arg0. get ( loc1 ) ) ; } } return loc0 ; }",
        "List < P > function ( List < P > arg0 ) { List < P > loc0 = null ; if ( arg0!= null ) { for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = ( P ) arg0. get ( loc1 ) ; if ( loc2!= null ) loc0 = evaluate ( loc2, arg0. get ( loc1 ) ) ; } } return loc0 ; }",
        "List < P > function ( List < P > arg0 ) { List < P > loc0 = null ; if ( arg0!= null ) { for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = arg0. get ( loc1 ) ; if ( loc2!= null ) { loc0 = evaluate ( loc2, loc1 ) ; } } } return loc0 ; }",
        "RPN function ( RPN arg0 ) { RPN loc0 = new RPN ( arg0 ) ; return loc0 ; }",
        "RPN function ( List arg0 ) { RPN loc0 = new RPN ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. set ( loc1, arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "RPN function ( List arg0 ) { RPN loc0 = new RPN ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 = loc0. eval ( arg0. get ( loc1 ) ) ; return loc0 ; }",
        "RPN function ( List arg0 ) { RPN loc0 = new RPN ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. set ( loc1, arg0. get ( loc1 ) ) ; return loc0 ; }",
        "RPN function ( List arg0 ) { RPN loc0 = new RPN ( arg0 ) ; return loc0 ; }",
        "double function ( List arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += evaluate ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "double function ( List arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += RPN ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "double function ( List arg0, List arg1 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += evaluate ( arg0. get ( loc1 ), arg1 ) ; } return loc0 ; }",
        "double function ( List arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += evaluate ( arg0. get ( loc1 ) ) ; return loc0 ; }",
        "double function ( List arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; loc0 += RPN ( loc2 ) ; } return loc0 ; }",
        "List < Token > function ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( ) ; for ( Token loc1 : arg0 ) { loc0. add ( evaluate ( loc1. getToken ( ) ) ) ; } return loc0 ; }",
        "List < Token > function ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( ) ; for ( Token loc1 : arg0 ) { loc0. add ( eval ( loc1. getToken ( ) ) ) ; } return loc0 ; }",
        "List < Token > function ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( ) ; for ( Token loc1 : arg0 ) { if ( loc1!= null ) { loc0. add ( loc1. getToken ( ) ) ; } } return loc0 ; }",
        "List < Token > function ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( ) ; for ( Token loc1 : arg0 ) { loc0. add ( loc1. getToken ( ) ) ; } return loc0 ; }",
        "List < String > function ( List < String > arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( String loc1 : arg0 ) { loc0. add ( RPN. evaluate ( loc1 ) ) ; } return loc0 ; }",
        "RPN < Integer > function ( Integer arg0 ) { RPN < Integer > loc0 = new RPN < Integer > ( arg0 ) ; return loc0 ; }",
        "RPN_Eval function ( P arg0 ) { RPN_Eval loc0 = new RPN_Eval ( arg0 ) ; return loc0 ; }",
        "RPN < Integer > function ( Integer arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return ( RPN < Integer > ) eval ( arg0 ) ; }",
        "RPN < Integer > function ( Integer arg0 ) { RPN < Integer > loc0 = new RPN < Integer > ( arg0 ) ; return eval ( loc0 ) ; }",
        "RPN < Integer > function ( Integer arg0 ) { RPN < Integer > loc0 = new RPN < Integer > ( arg0 ) ; return ( RPN < Integer > ) loc0 ; }"
      ],
      "mid_translation": [
        "RPN - Evaluate a list of tokens.",
        "RPN eval method.",
        "Evaluate the RPN of a list of tokens",
        "Evaluate a list of tokens using RPN.",
        "RPN - Eval method."
      ],
      "output": [
        {
          "patch": "public static List < P > rpn_eval ( List < P > arg0 ) { List < P > loc0 = null ; if ( arg0!= null ) { for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = ( P ) arg0. get ( loc1 ) ; if ( loc2!= null ) { loc0 = evaluate ( loc2, arg0. get ( loc1 ) ) ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < P > rpn_eval ( List < P > arg0 ) { List < P > loc0 = null ; if ( arg0!= null ) { for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = arg0. get ( loc1 ) ; if ( loc2!= null ) { loc0 = evaluate ( loc2, arg0. get ( loc1 ) ) ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < P > rpn_eval ( List < P > arg0 ) { List < P > loc0 = null ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = ( P ) arg0. get ( loc1 ) ; if ( loc2!= null ) { loc0 = evaluate ( loc2, arg0. get ( loc1 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < P > rpn_eval ( List < P > arg0 ) { List < P > loc0 = null ; if ( arg0!= null ) { for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = ( P ) arg0. get ( loc1 ) ; if ( loc2!= null ) loc0 = evaluate ( loc2, arg0. get ( loc1 ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < P > rpn_eval ( List < P > arg0 ) { List < P > loc0 = null ; if ( arg0!= null ) { for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { P loc2 = arg0. get ( loc1 ) ; if ( loc2!= null ) { loc0 = evaluate ( loc2, loc1 ) ; } } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN rpn_eval ( RPN arg0 ) { RPN loc0 = new RPN ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN rpn_eval ( List arg0 ) { RPN loc0 = new RPN ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. set ( loc1, arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN rpn_eval ( List arg0 ) { RPN loc0 = new RPN ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 = loc0. eval ( arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN rpn_eval ( List arg0 ) { RPN loc0 = new RPN ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. set ( loc1, arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN rpn_eval ( List arg0 ) { RPN loc0 = new RPN ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double rpn_eval ( List arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += evaluate ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double rpn_eval ( List arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += RPN ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double rpn_eval ( List arg0, List arg1 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += evaluate ( arg0. get ( loc1 ), arg1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double rpn_eval ( List arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0 += evaluate ( arg0. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static double rpn_eval ( List arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { double loc2 = arg0. get ( loc1 ) ; loc0 += RPN ( loc2 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Token > rpn_eval ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( ) ; for ( Token loc1 : arg0 ) { loc0. add ( evaluate ( loc1. getToken ( ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Token > rpn_eval ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( ) ; for ( Token loc1 : arg0 ) { loc0. add ( eval ( loc1. getToken ( ) ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Token > rpn_eval ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( ) ; for ( Token loc1 : arg0 ) { if ( loc1!= null ) { loc0. add ( loc1. getToken ( ) ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Token > rpn_eval ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( ) ; for ( Token loc1 : arg0 ) { loc0. add ( loc1. getToken ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > rpn_eval ( List < String > arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( String loc1 : arg0 ) { loc0. add ( RPN. evaluate ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN < Integer > rpn_eval ( Integer arg0 ) { RPN < Integer > loc0 = new RPN < Integer > ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN_Eval rpn_eval ( P arg0 ) { RPN_Eval loc0 = new RPN_Eval ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN < Integer > rpn_eval ( Integer arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } return ( RPN < Integer > ) eval ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN < Integer > rpn_eval ( Integer arg0 ) { RPN < Integer > loc0 = new RPN < Integer > ( arg0 ) ; return eval ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static RPN < Integer > rpn_eval ( Integer arg0 ) { RPN < Integer > loc0 = new RPN < Integer > ( arg0 ) ; return ( RPN < Integer > ) loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "MERGESORT": {
      "loc": "38-39",
      "input": "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n    if (arr.size() == 0) {  \n        return arr;\n    } else {\n        int middle = arr.size() / 2;\n        ArrayList<Integer> left = new ArrayList<Integer>(100);\n        left.addAll(arr.subList(0,middle));\n        left = mergesort(left);\n        ArrayList<Integer> right = new ArrayList<Integer>(100);\n        right.addAll(arr.subList(middle, arr.size()));\n        right = mergesort(right);\n        return merge(left, right);\n    }\n}",
      "target": "public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n    if (arr.size() <= 1) { \n        return arr;\n    } else {\n        int middle = arr.size() / 2;\n        ArrayList<Integer> left = new ArrayList<Integer>(100);\n        left.addAll(arr.subList(0,middle));\n        left = mergesort(left);\n        ArrayList<Integer> right = new ArrayList<Integer>(100);\n        right.addAll(arr.subList(middle, arr.size()));\n        right = mergesort(right);\n        return merge(left, right);\n    }\n}",
      "function range": "37,5-51,5",
      "raw_output": [
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; int loc1 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc1 = arg1. get ( loc2 ) ; loc0. add ( loc1 ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; arg1. add ( loc2 ) ; loc0 += loc2 ; } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = arg0. size ( ) ; Collections. sort ( arg1, new Comparator < Integer > ( ) { @ Override public int compare ( Integer arg2, int arg3 ) { return arg3 - arg1. size ( ) ; } } ) ; return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } else if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1, Comparator < Integer > arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. compare ( arg0. get ( loc1 ), arg1 ) >= 0 ) { loc0 ++ ; } } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1, Comparator < Integer > arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg2. compare ( arg0. get ( loc1 ), arg1 ) >= 0 ) { loc0 ++ ; } } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = arg0. size ( ) ; Collections. sort ( arg1, new Comparator < Integer > ( ) { @ Override public int compare ( Integer arg2, int arg3 ) { return arg3 - arg1. size ( ) ; } } ) ; return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } arg1. add ( arg0. get ( loc1 ) ) ; } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } arg1. add ( loc0 ) ; } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } arg1. add ( arg0. get ( loc0 ) ) ; } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, Comparator < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; int loc1 ; for ( loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; int loc1 ; for ( loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < Integer > function ( ArrayList < Integer > arg0, int arg1, Comparator < Integer > arg2 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; int loc1 ; for ( loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) + arg1 ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Merges an ArrayList<Integer > to an ArrayList<Integer >",
        "Merges an ArrayList<Integer > to an ArrayList<Integer >.",
        "Merges an ArrayList<Integer > to a sorted ArrayList<Integer >",
        "Merges an ArrayList<Integer > to a sorted ArrayList<Integer >.",
        "Merges an ArrayList<Integer > into a sorted ArrayList<Integer >."
      ],
      "output": [
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; int loc1 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc1 = arg1. get ( loc2 ) ; loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; arg1. add ( loc2 ) ; loc0 += loc2 ; } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int mergesort ( Integer arg2, int arg3 ) { return arg3 - arg1. size ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } else if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1, Comparator < Integer > arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. compare ( arg0. get ( loc1 ), arg1 ) >= 0 ) { loc0 ++ ; } } return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1, Comparator < Integer > arg2 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg2. compare ( arg0. get ( loc1 ), arg1 ) >= 0 ) { loc0 ++ ; } } return arg1 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int mergesort ( Integer arg2, int arg3 ) { return arg3 - arg1. size ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } arg1. add ( arg0. get ( loc1 ) ) ; } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } arg1. add ( loc0 ) ; } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } arg1. add ( arg0. get ( loc0 ) ) ; } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, ArrayList < Integer > arg1 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg1. contains ( arg0. get ( loc1 ) ) ) { loc0 ++ ; } } return arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, Comparator < Integer > arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; int loc1 ; for ( loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; int loc1 ; for ( loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, int arg1 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > mergesort ( ArrayList < Integer > arg0, int arg1, Comparator < Integer > arg2 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; int loc1 ; for ( loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) + arg1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "QUICKSORT": {
      "loc": "26-27",
      "input": "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x > pivot) { \n            greater.add(x);\n        }\n    }\n    ArrayList<Integer> middle = new ArrayList<Integer>();\n    middle.add(pivot);\n    lesser = quicksort(lesser);\n    greater = quicksort(greater);\n    middle.addAll(greater);\n    lesser.addAll(middle);\n    return lesser;\n}",
      "target": "public static ArrayList<Integer> quicksort(ArrayList<Integer> arr) {\n    if (arr.isEmpty()) {\n        return new ArrayList<Integer>();\n    }\n    Integer pivot = arr.get(0);\n    ArrayList<Integer> lesser = new ArrayList<Integer>();\n    ArrayList<Integer> greater = new ArrayList<Integer>();\n    for (Integer x : arr.subList(1, arr.size())) {\n        if (x < pivot) {\n            lesser.add(x);\n        } else if (x >= pivot) { \n            greater.add(x);\n        }\n    }\n    ArrayList<Integer> middle = new ArrayList<Integer>();\n    middle.add(pivot);\n    lesser = quicksort(lesser);\n    greater = quicksort(greater);\n    middle.addAll(greater);\n    lesser.addAll(middle);\n    return lesser;\n}",
      "function range": "14,5-38,5",
      "raw_output": [
        "int [ ] function ( ArrayList < Integer > arg0, int arg1 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0 [ loc2 ] = arg0. get ( loc2 ) ; loc1 ++ ; } return loc0 ; }",
        "void function ( int [ ] arg0, int arg1, Comparator < Integer > arg2 ) { sort ( arg0, 0, arg0. length - 1, arg1 ) ; for ( int loc0 = arg0. length - 1 ; loc0 >= arg1 ; loc0 -- ) { int loc1 = arg0 [ loc0 ] ; arg0 [ loc0 ] = arg0 [ loc0 - 1 ] ; arg0 [ loc0 - 1 ] = arg0 [ loc0 ] ; arg0 [ loc0 ] = loc1 ; } }",
        "void function ( int [ ] arg0, int arg1, Comparator < Integer > arg2 ) { sort ( arg0, 0, arg0. length - 1, arg1, arg2 ) ; }",
        "void function ( ArrayList < Integer > arg0, int arg1, int arg2 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = arg1 - 1 ; loc1 >= 0 ; loc1 -- ) { if ( arg0. get ( loc1 ) > arg0. get ( loc1 ) ) { loc0 = arg0. get ( loc1 ) ; arg0. set ( loc1, arg0. get ( loc1 ) ) ; } } }",
        "void function ( ArrayList < Integer > arg0, int arg1, int arg2 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = arg1 - 1 ; loc1 >= 0 ; loc1 -- ) { int loc2 = arg0. get ( loc1 ) ; arg0. set ( loc1, arg0. get ( loc1 ) + 1, arg0. get ( loc1 ) ) ; arg0. set ( loc1, arg0. get ( loc1 ) - 1 ) ; } sort ( arg0, arg1, arg2 ) ; }",
        "void function ( int [ ] arg0 ) { sort ( arg0, 0, arg0. length - 1 ) ; }",
        "void function ( int [ ] arg0 ) { Quicksort. sort ( arg0, 0, arg0. length - 1 ) ; for ( int loc0 = arg0. length - 1 ; loc0 >= 0 ; loc0 -- > 0 ) { arg0 [ loc0 ] = arg0 [ loc0 ] ; arg0 [ loc0 - 1 ] = loc0 ; } }",
        "void function ( int [ ] arg0, int arg1, Comparator < Integer > arg2 ) { sort ( arg0, 0, arg0. length - 1, arg1, arg2 ) ; }",
        "void function ( int [ ] arg0 ) { Quicksort. sort ( arg0, 0, arg0. length - 1 ) ; for ( int loc0 = arg0. length - 1 ; loc0 >= 0 ; loc0 -- > 0 ) { arg0 [ loc0 ] = arg0 [ loc0 - 1 ] ; arg0 [ loc0 ] = loc0 ; } }",
        "void function ( int [ ] arg0 ) { Quicksort. sort ( arg0, 0, arg0. length - 1 ) ; for ( int loc0 = arg0. length - 1 ; loc0 >= 0 ; loc0 -- ) { Integer loc1 = arg0 [ loc0 ] ; arg0 [ loc0 - 1 ] = loc1 ; } }",
        "void function ( ArrayList < Integer > arg0, int arg1, int arg2 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2 + 1, arg0. get ( loc2 ) ) ; } }",
        "void function ( ArrayList < Integer > arg0, int arg1 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2, loc1 ) ; } }",
        "void function ( ArrayList < Integer > arg0, int arg1, int arg2 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2, loc1 ) ; } }",
        "void function ( ArrayList < Integer > arg0, int arg1 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2 + 1, loc1 ) ; } }",
        "void function ( ArrayList < Integer > arg0, int arg1, int arg2 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2, arg0. get ( loc2 ) ) ; } }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) { @ Override public int compare ( Integer arg1, Integer arg2 ) { return arg1. compareTo ( arg2 ) ; } } ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) { @ Override public int compare ( Integer arg1, Integer arg2 ) { return ( arg1 - arg2 ) / 2 ; } } ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) { @ Override public int compare ( int arg1, int arg2 ) { return arg1 - arg2 ; } } ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { int loc0 = arg0. loc0 ( ) ; Collections. sort ( arg0, new Comparator < Integer > ( ) { @ Override public int compare ( int arg1, int arg2 ) { return arg1 - arg2 ; } } ) ; return arg0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Integer > ( ) { @ Override public int compare ( Integer arg1, Integer arg2 ) { return arg1. intValue ( ) - arg2. intValue ( ) ; } } ) ; return loc0 ; }",
        "void function ( int [ ] arg0 ) { sort ( arg0, 0, arg0. length - 1 ) ; }",
        "int [ ] function ( int [ ] arg0 ) { int loc0 = arg0. length ; Collections. sort ( arg0, new Comparator < Integer > ( ) { public int compare ( int arg1, int arg2 ) { return arg1 - arg2 ; } } ) ; return arg0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int loc0 = arg0. length ; Collections. sort ( arg0, 0, loc0 - 1 ) ; return arg0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0. get ( loc1 - 1 ) ; int loc3 = arg0. get ( loc1 ) ; arg0. set ( loc1, loc2, arg0. get ( loc3 ) ) ; arg0. set ( loc3, loc1, loc2 ) ; } return arg0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0. get ( loc1 - 1 ) ; int loc3 = arg0. get ( loc1 ) ; arg0. set ( loc1, loc2, arg0. get ( loc3 ) ) ; arg0. set ( loc3, loc1 ) ; } return arg0 ; }"
      ],
      "mid_translation": [
        "Quick sort an ArrayList<Integer >.",
        "Quicksort an ArrayList<Integer >.",
        "Quick sort an ArrayList<Integer >",
        "Quick sort a list of integers.",
        "Quick sort an ArrayList of integers."
      ],
      "output": [
        {
          "patch": "public static int [ ] quicksort ( ArrayList < Integer > arg0, int arg1 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0 [ loc2 ] = arg0. get ( loc2 ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void quicksort ( int [ ] arg0, int arg1, Comparator < Integer > arg2 ) { sort ( arg0, 0, arg0. length - 1, arg1 ) ; for ( int loc0 = arg0. length - 1 ; loc0 >= arg1 ; loc0 -- ) { int loc1 = arg0 [ loc0 ] ; arg0 [ loc0 ] = arg0 [ loc0 - 1 ] ; arg0 [ loc0 - 1 ] = arg0 [ loc0 ] ; arg0 [ loc0 ] = loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void quicksort ( int [ ] arg0, int arg1, Comparator < Integer > arg2 ) { sort ( arg0, 0, arg0. length - 1, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void quicksort ( ArrayList < Integer > arg0, int arg1, int arg2 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = arg1 - 1 ; loc1 >= 0 ; loc1 -- ) { if ( arg0. get ( loc1 ) > arg0. get ( loc1 ) ) { loc0 = arg0. get ( loc1 ) ; arg0. set ( loc1, arg0. get ( loc1 ) ) ; } } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void quicksort ( ArrayList < Integer > arg0, int arg1, int arg2 ) { int loc0 = arg0. size ( ) ; for ( int loc1 = arg1 - 1 ; loc1 >= 0 ; loc1 -- ) { int loc2 = arg0. get ( loc1 ) ; arg0. set ( loc1, arg0. get ( loc1 ) + 1, arg0. get ( loc1 ) ) ; arg0. set ( loc1, arg0. get ( loc1 ) - 1 ) ; } sort ( arg0, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void quicksort ( int [ ] arg0 ) { sort ( arg0, 0, arg0. length - 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void quicksort ( int [ ] arg0 ) { Quicksort. sort ( arg0, 0, arg0. length - 1 ) ; for ( int loc0 = arg0. length - 1 ; loc0 >= 0 ; loc0 -- > 0 ) { arg0 [ loc0 ] = arg0 [ loc0 ] ; arg0 [ loc0 - 1 ] = loc0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void quicksort ( int [ ] arg0, int arg1, Comparator < Integer > arg2 ) { sort ( arg0, 0, arg0. length - 1, arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void quicksort ( int [ ] arg0 ) { Quicksort. sort ( arg0, 0, arg0. length - 1 ) ; for ( int loc0 = arg0. length - 1 ; loc0 >= 0 ; loc0 -- > 0 ) { arg0 [ loc0 ] = arg0 [ loc0 - 1 ] ; arg0 [ loc0 ] = loc0 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void quicksort ( int [ ] arg0 ) { Quicksort. sort ( arg0, 0, arg0. length - 1 ) ; for ( int loc0 = arg0. length - 1 ; loc0 >= 0 ; loc0 -- ) { Integer loc1 = arg0 [ loc0 ] ; arg0 [ loc0 - 1 ] = loc1 ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void quicksort ( ArrayList < Integer > arg0, int arg1, int arg2 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2 + 1, arg0. get ( loc2 ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void quicksort ( ArrayList < Integer > arg0, int arg1 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2, loc1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void quicksort ( ArrayList < Integer > arg0, int arg1, int arg2 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2, loc1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void quicksort ( ArrayList < Integer > arg0, int arg1 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2 + 1, loc1 ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void quicksort ( ArrayList < Integer > arg0, int arg1, int arg2 ) { for ( int loc0 = 1 ; loc0 < arg0. size ( ) ; loc0 ++ ) { int loc1 = arg0. get ( loc0 ) ; int loc2 = arg0. get ( loc0 - 1 ) ; arg0. set ( loc0 + 1, arg0. get ( loc2 ) ) ; arg0. set ( loc2, arg0. get ( loc2 ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int quicksort ( Integer arg1, Integer arg2 ) { return arg1. compareTo ( arg2 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int quicksort ( Integer arg1, Integer arg2 ) { return ( arg1 - arg2 ) / 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int quicksort ( int arg1, int arg2 ) { return arg1 - arg2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int quicksort ( int arg1, int arg2 ) { return arg1 - arg2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int quicksort ( Integer arg1, Integer arg2 ) { return arg1. intValue ( ) - arg2. intValue ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void quicksort ( int [ ] arg0 ) { sort ( arg0, 0, arg0. length - 1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int quicksort ( int arg1, int arg2 ) { return arg1 - arg2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] quicksort ( int [ ] arg0 ) { int loc0 = arg0. length ; Collections. sort ( arg0, 0, loc0 - 1 ) ; return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int [ ] quicksort ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0. get ( loc1 - 1 ) ; int loc3 = arg0. get ( loc1 ) ; arg0. set ( loc1, loc2, arg0. get ( loc3 ) ) ; arg0. set ( loc3, loc1, loc2 ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int [ ] quicksort ( int [ ] arg0 ) { int loc0 = arg0. length ; for ( int loc1 = 1 ; loc1 < loc0 ; loc1 ++ ) { int loc2 = arg0. get ( loc1 - 1 ) ; int loc3 = arg0. get ( loc1 ) ; arg0. set ( loc1, loc2, arg0. get ( loc3 ) ) ; arg0. set ( loc3, loc1 ) ; } return arg0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "REVERSE_LINKED_LIST": {
      "loc": "19-19",
      "input": "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node != null) {\n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode); \n        node = nextnode;\n    }\n    return prevnode;\n}",
      "target": "public static Node reverse_linked_list(Node node) {\n    Node prevnode = null;\n    Node nextnode;\n    while (node != null) { \n        nextnode = node.getSuccessor();\n        node.setSuccessor(prevnode);\n        prevnode = node;\n        node = nextnode;\n    }\n    return prevnode;\n}",
      "function range": "14,5-23,5",
      "raw_output": [
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) loc0. add ( loc1. reverse ( ) ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Node > function ( Collection < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( loc1 ) ; } Collections. reverse ( loc0 ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; int loc3 = arg0. get ( loc1 + 1 ) ; loc0. add ( loc2, loc3 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { Integer loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. reverse ( loc0 ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; Collections. reverse ( loc0 ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) loc0. add ( loc1. reverse ( ) ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Reverse linked list of nodes.",
        "Get a reverse linked list of nodes.",
        "Reverse linked list of a node.",
        "Reverses a list of nodes.",
        "Returns a reverse linked list of nodes."
      ],
      "output": [
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < T > reverse_linked_list ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) loc0. add ( loc1. reverse ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( Collection < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > reverse_linked_list ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( loc1 ) ; } Collections. reverse ( loc0 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > reverse_linked_list ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > reverse_linked_list ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > reverse_linked_list ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; int loc3 = arg0. get ( loc1 + 1 ) ; loc0. add ( loc2, loc3 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > reverse_linked_list ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { Integer loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. reverse ( loc0 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; Collections. reverse ( loc0 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) loc0. add ( loc1. reverse ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1. reverse ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Node > reverse_linked_list ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; for ( Node loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "PASCAL": {
      "loc": "22-23",
      "input": "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int c=0; c<r; c++) { \n            int upleft, upright;\n            if (c > 0) {\n                upleft = rows.get(r-1).get(c-1);\n            } else {\n                upleft = 0;\n            }\n            if (c < r) {\n                upright = rows.get(r-1).get(c);\n            } else {\n                upright = 0;\n            }\n            row.add(upleft+upright);\n        }\n        rows.add(row);\n    }\n    return rows;\n}",
      "target": "public static ArrayList<ArrayList<Integer>> pascal(int n) {\n    ArrayList<ArrayList<Integer>> rows = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> init = new ArrayList<Integer>();\n    init.add(1);\n    rows.add(init);\n    for (int r=1; r<n; r++) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n        for (int c=0; c<r+1; c++) { \n            int upleft, upright;\n            if (c > 0) {\n                upleft = rows.get(r-1).get(c-1);\n            } else {\n                upleft = 0;\n            }\n            if (c < r) {\n                upright = rows.get(r-1).get(c);\n            } else {\n                upright = 0;\n            }\n            row.add(upleft+upright);\n        }\n        rows.add(row);\n    }\n    return rows;\n}",
      "function range": "14,5-40,5",
      "raw_output": [
        "int function ( ) { System. out. println ( \"srini_string\" ) ; return 0 ; }",
        "int function ( ) { Calendar loc0 = Calendar. getInstance ( ) ; return loc0. get ( Calendar. HOUR_OF_DAY ) ; }",
        "int function ( ) { Calendar loc0 = Calendar. getInstance ( ) ; return loc0. get ( Calendar. DAY_OF_YEAR ) ; }",
        "int function ( ) { System. out. println ( \"srini_string\" ) ; return 11 ; }",
        "int function ( ) { System. out. println ( \"srini_string\" ) ; return 01 ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return new ArrayList < ArrayList < Integer >> ( ) ; }",
        "ArrayList < ArrayList < Integer >> function ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
        "ArrayList < ArrayList < Integer >> function ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "ArrayList < ArrayList < Integer >> function ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { int loc2 = loc1 ; loc0. add ( new ArrayList < Integer > ( ) ) ; loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
        "ArrayList < ArrayList < Integer >> function ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new ArrayList < Integer > ( ) ) ; loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return new ArrayList < ArrayList < Integer >> ( ) ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return null ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return ( ArrayList < ArrayList < Integer >> ) new ArrayList < Integer > ( ) ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return table ( Integer. class ) ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return getArrayList ( Integer. class ) ; }",
        "ArrayList < ArrayList < Integer >> function ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
        "ArrayList < ArrayList < Integer >> function ( int arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
        "ArrayList < ArrayList < Integer >> function ( int arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( ( ArrayList < Integer > ) new Integer ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < ArrayList < Integer >> function ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( new ArrayList < Integer > ( ) ) ; return loc0 ; }",
        "ArrayList < ArrayList < Integer >> function ( int arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return new ArrayList < ArrayList < Integer >> ( ) ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return ( ArrayList < ArrayList < Integer >> ) new ArrayList < ArrayList < Integer >> ( ) ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return ( ArrayList < ArrayList < Integer >> ) new ArrayList < Integer > ( ) ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { return null ; }",
        "ArrayList < ArrayList < Integer >> function ( ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 : table ( ). values ( ) ) { loc0. add ( loc1 ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Method pascal.",
        "Returns an ArrayList of ArrayList<ArrayList<Integer>> where each element in the returned ArrayList<ArrayList<Integer>> is the number of rows.",
        "Returns an ArrayList of ArrayList<ArrayList<Integer>> where each element in the returned ArrayList<ArrayList<Integer>> is the number of rows in the table.",
        "Returns an ArrayList of ArrayList<ArrayList<Integer>> where each element in the returned ArrayList<ArrayList<Integer>> is the number of rows of n.",
        "Returns an ArrayList of ArrayList<ArrayList<Integer>> where each element of the returned ArrayList<ArrayList<Integer>> is the number of rows in the table."
      ],
      "output": [
        {
          "patch": "public static int pascal ( ) { System. out. println ( \"srini_string\" ) ; return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int pascal ( ) { Calendar loc0 = Calendar. getInstance ( ) ; return loc0. get ( Calendar. HOUR_OF_DAY ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int pascal ( ) { Calendar loc0 = Calendar. getInstance ( ) ; return loc0. get ( Calendar. DAY_OF_YEAR ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int pascal ( ) { System. out. println ( \"srini_string\" ) ; return 11 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int pascal ( ) { System. out. println ( \"srini_string\" ) ; return 01 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return new ArrayList < ArrayList < Integer >> ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { int loc2 = loc1 ; loc0. add ( new ArrayList < Integer > ( ) ) ; loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new ArrayList < Integer > ( ) ) ; loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return new ArrayList < ArrayList < Integer >> ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return ( ArrayList < ArrayList < Integer >> ) new ArrayList < Integer > ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return table ( Integer. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return getArrayList ( Integer. class ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( int arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( new ArrayList < Integer > ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( int arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( ( ArrayList < Integer > ) new Integer ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( int arg0 ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( new ArrayList < Integer > ( ) ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( int arg0 ) { ArrayList < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return new ArrayList < ArrayList < Integer >> ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return ( ArrayList < ArrayList < Integer >> ) new ArrayList < ArrayList < Integer >> ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return ( ArrayList < ArrayList < Integer >> ) new ArrayList < Integer > ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { return null ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList < Integer >> pascal ( ) { ArrayList < ArrayList < Integer >> loc0 = new ArrayList < ArrayList < Integer >> ( ) ; for ( int loc1 : table ( ). values ( ) ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "TOPOLOGICAL_ORDERING": {
      "loc": "17-18",
      "input": "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i);\n        for (Node nextNode : node.getSuccessors()) {\n            if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) { \n                orderedNodes.add(nextNode);\n                listSize++;\n            }\n        }\n    }\n    return orderedNodes;\n}",
      "target": "public static ArrayList<Node> topological_ordering (List<Node> directedGraph) {\n    ArrayList<Node> orderedNodes = new ArrayList<Node>();\n    for (Node node : directedGraph) {\n        if (node.getPredecessors().isEmpty()) {\n            orderedNodes.add(node);\n        }\n    }\n    int listSize = orderedNodes.size();\n    for (int i = 0; i < listSize; i++) {\n        Node node = orderedNodes.get(i); \n        for (Node nextNode : node.getSuccessors()) {\n            if (orderedNodes.containsAll(nextNode.getPredecessors()) && !orderedNodes.contains(nextNode)) {\n                orderedNodes.add(nextNode);\n                listSize++;\n            }\n        }\n    }\n    return orderedNodes;\n}",
      "function range": "5,5-24,5",
      "raw_output": [
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < N > function ( List < N > arg0 ) { List < N > loc0 = new ArrayList < N > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < Node > function ( Collection < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { return sortNodes ( arg0, new NodeComparator ( ) ) ; }",
        "int function ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; else return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; }",
        "int function ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) { return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; } else { return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; } }",
        "int function ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) { return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; } return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; }",
        "int function ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; }",
        "int function ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) return ( ( DirectedGraph ) arg0 ). getTopologicalOrder ( ) ; else return ( ( DirectedGraph ) arg0 ). getTopologicalOrder ( ) ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new Comparator < Node > ( ) { public int compare ( Node arg1, Node arg2 ) { return arg1. compareTo ( arg2 ) ; } } ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { return sortNodes ( arg0, new NodeComparator ( ) ) ; }",
        "int function ( List < Node > arg0 ) { int loc0 = 0 ; for ( Node loc1 : arg0 ) { if ( loc1!= null ) { loc0 = loc1. compareTo ( loc1 ) ; } } return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < Node > function ( List < Node > arg0 ) { return sortNodes ( arg0, new NodeComparator ( ) ) ; }",
        "List < N > function ( List < N > arg0 ) { List < N > loc0 = new ArrayList < N > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
        "List < N > function ( List < N > arg0 ) { List < N > loc0 = new ArrayList < N > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; Collections. sort ( loc0, new Comparator < T > ( ) { @ Override public int compare ( T arg1, T arg2 ) { return arg1. compareTo ( arg2 ) ; } } ) ; return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; Collections. sort ( loc0, new Comparator < T > ( ) { @ Override public int compare ( T arg1, T arg2 ) { return arg1. compareTo ( arg2 ) ; } } ) ; return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < N > function ( List < N > arg0 ) { List < N > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Topological ordering of a list of nodes.",
        "Topological ordering of a directed graph.",
        "Topological order of a list of nodes.",
        "Topological ordering of the list of nodes.",
        "Topological ordering of nodes."
      ],
      "output": [
        {
          "patch": "public static List < Node > topological_ordering ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < N > topological_ordering ( List < N > arg0 ) { List < N > loc0 = new ArrayList < N > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > topological_ordering ( Collection < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > topological_ordering ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > topological_ordering ( List < Node > arg0 ) { return sortNodes ( arg0, new NodeComparator ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int topological_ordering ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; else return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int topological_ordering ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) { return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; } else { return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int topological_ordering ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) { return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; } return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int topological_ordering ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; return ( ( DirectedGraph ) arg0 ). topologicalOrder ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int topological_ordering ( DirectedGraph arg0 ) { if ( arg0 instanceof DirectedGraph ) return ( ( DirectedGraph ) arg0 ). getTopologicalOrder ( ) ; else return ( ( DirectedGraph ) arg0 ). getTopologicalOrder ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > topological_ordering ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int topological_ordering ( Node arg1, Node arg2 ) { return arg1. compareTo ( arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > topological_ordering ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > topological_ordering ( List < Node > arg0 ) { return sortNodes ( arg0, new NodeComparator ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int topological_ordering ( List < Node > arg0 ) { int loc0 = 0 ; for ( Node loc1 : arg0 ) { if ( loc1!= null ) { loc0 = loc1. compareTo ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > topological_ordering ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > topological_ordering ( List < Node > arg0 ) { List < Node > loc0 = new ArrayList < Node > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Node > topological_ordering ( List < Node > arg0 ) { return sortNodes ( arg0, new NodeComparator ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < N > topological_ordering ( List < N > arg0 ) { List < N > loc0 = new ArrayList < N > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > topological_ordering ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; Collections. sort ( loc0, new NodeComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < N > topological_ordering ( List < N > arg0 ) { List < N > loc0 = new ArrayList < N > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int topological_ordering ( T arg1, T arg2 ) { return arg1. compareTo ( arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int topological_ordering ( T arg1, T arg2 ) { return arg1. compareTo ( arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > topological_ordering ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < N > topological_ordering ( List < N > arg0 ) { List < N > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "SHORTEST_PATH_LENGTH": {
      "loc": "38-39",
      "input": "public static int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n                    unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode)))); \n        }\n    }\n    return Integer.MAX_VALUE;\n}",
      "target": "public static int shortest_path_length(Map<List<Node>, Integer> length_by_edge, Node startnode, Node goalnode) {\n    int n = length_by_edge.size();\n    Map<Node, Integer> unvisitedNodes = new HashMap<>();\n    Set<Node> visitedNodes = new HashSet<>();\n    unvisitedNodes.put(startnode, 0);\n    while (!unvisitedNodes.isEmpty()) {\n        Node node = getNodeWithMinDistance(unvisitedNodes);\n        int distance = unvisitedNodes.get(node);\n        unvisitedNodes.remove(node);\n        if (node.getValue() == goalnode.getValue()) {\n            return distance;\n        }\n        visitedNodes.add(node);\n        for (Node nextnode : node.getSuccessors()) {\n            if (visitedNodes.contains(nextnode)) {\n                continue;\n            }\n            if (unvisitedNodes.get(nextnode) == null) {\n                unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n            }\n            unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n                    distance + length_by_edge.get(Arrays.asList(node, nextnode))));\n        }\n    }\n    return Integer.MAX_VALUE;\n}",
      "function range": "10,5-43,5",
      "raw_output": [
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 < 0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) > 0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < List < Integer >> arg0 ) { int loc0 = 0 ; for ( List < List < Integer >> loc1 : arg0 ) { if ( loc1. size ( ) > loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < List < Integer >> arg0 ) { int loc0 = 0 ; for ( List < List < Integer >> loc1 : arg0 ) { if ( loc1. size ( ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 - 1 ) < 0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < List < Integer >> arg0 ) { int loc0 = 0 ; for ( List < List < Integer >> loc1 : arg0 ) { if ( loc1. size ( ) > loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < List < Integer >> arg0 ) { int loc0 = 0 ; for ( List < List < Integer >> loc1 : arg0 ) { if ( loc1. size ( ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < LatLong > arg0 ) { int loc0 = 0 ; for ( LatLong loc1 : arg0 ) { if ( loc1. compareTo ( loc0 ) < 0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) > 0 ) { loc0 ++ ; } } return loc0 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc2 ) / 2 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc3 ) / 2 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( ( loc0 + loc1 ) / 2 ) + loc2 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc1 ) + loc2 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
        "int function ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }"
      ],
      "mid_translation": [
        "Gets the shortest path length.",
        "Get shortest path length.",
        "Get the shortest path length.",
        "Returns the shortest path length of the path between two nodes.",
        "This method returns the shortest path length of the path between two nodes."
      ],
      "output": [
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 < 0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 += arg0. get ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) > 0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( List < List < Integer >> arg0 ) { int loc0 = 0 ; for ( List < List < Integer >> loc1 : arg0 ) { if ( loc1. size ( ) > loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int shortest_path_length ( List < List < Integer >> arg0 ) { int loc0 = 0 ; for ( List < List < Integer >> loc1 : arg0 ) { if ( loc1. size ( ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 - 1 ) < 0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( Integer loc1 : arg0 ) { if ( loc1 < loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( List < List < Integer >> arg0 ) { int loc0 = 0 ; for ( List < List < Integer >> loc1 : arg0 ) { if ( loc1. size ( ) > loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int shortest_path_length ( List < List < Integer >> arg0 ) { int loc0 = 0 ; for ( List < List < Integer >> loc1 : arg0 ) { if ( loc1. size ( ) < loc0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int shortest_path_length ( List < LatLong > arg0 ) { int loc0 = 0 ; for ( LatLong loc1 : arg0 ) { if ( loc1. compareTo ( loc0 ) < 0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int shortest_path_length ( List < Integer > arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { if ( arg0. get ( loc1 ) > 0 ) { loc0 ++ ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc2 ) / 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc3 ) / 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( ( loc0 + loc1 ) / 2 ) + loc2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc1 ) + loc2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg0 + arg1 ) / 2 ; int loc3 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shortest_path_length ( int arg0, int arg1 ) { int loc0 = ( arg0 + arg1 ) / 2 ; int loc1 = ( arg0 + arg1 ) / 2 ; int loc2 = ( arg1 + arg1 ) / 2 ; return ( loc0 + loc1 ) / 2 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "SIEVE": {
      "loc": "41-42",
      "input": "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n        if (any(list_comp(n, primes))) { \n            primes.add(n);\n        }\n    }\n    return primes;\n}",
      "target": "public static ArrayList<Integer> sieve(Integer max) {\n    ArrayList<Integer> primes = new ArrayList<Integer>();\n    for (int n=2; n<max+1; n++) {\n        if (all(list_comp(n, primes))) { \n            primes.add(n);\n        }\n    }\n    return primes;\n}",
      "function range": "38,5-46,5",
      "raw_output": [
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < T > function ( List <? extends T > arg0 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg0 ) loc0. add ( loc1 ) ; return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; return loc0 ; }",
        "List < T > function ( List <? extends T > arg0 ) { return arg0 ; }",
        "Sieve function ( ) { return Sieve. create ( \"srini_string\" ) ; }",
        "Sieve function ( ) { return Sieve. current ( ) ; }",
        "Sieve function ( ) { return Sieve. mono ( ) ; }",
        "Rope function ( ) { Rope loc0 = new Rope ( ) ; loc0. sieve ( ) ; return loc0 ; }",
        "void function ( ) { Sieve loc0 = new Sieve ( ) ; System. out. println ( loc0. toString ( ) ) ; }",
        "Sieve function ( ) { Sieve loc0 = new Sieve ( ) ; loc0. init ( ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < T > function ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( int arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( int arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( arg1 ) ; } return loc0 ; }",
        "List < Integer > function ( int arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( loc1 ) ; return loc0 ; }",
        "List < Integer > function ( int arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( int arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( arg1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; int loc1 = 0 ; for ( Integer loc2 : arg0 ) { loc0. add ( loc2 ) ; loc1 ++ ; } return loc0 ; }",
        "List < String > function ( List < Integer > arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1. toString ( ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( int arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Sieve.",
        "Sieve method.",
        "Sieve list.",
        "Sieve a list of integers.",
        "Sieve a list of codes."
      ],
      "output": [
        {
          "patch": "public static List < T > sieve ( List < T > arg0 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > sieve ( List <? extends T > arg0 ) { List < T > loc0 = Lists. newArrayList ( ) ; for ( T loc1 : arg0 ) loc0. add ( loc1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > sieve ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < T > sieve ( List <? extends T > arg0 ) { return arg0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Sieve sieve ( ) { return Sieve. create ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Sieve sieve ( ) { return Sieve. current ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Sieve sieve ( ) { return Sieve. mono ( ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Rope sieve ( ) { Rope loc0 = new Rope ( ) ; loc0. sieve ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void sieve ( ) { Sieve loc0 = new Sieve ( ) ; System. out. println ( loc0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Sieve sieve ( ) { Sieve loc0 = new Sieve ( ) ; loc0. init ( ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > sieve ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > sieve ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < T > sieve ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > sieve ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < T > sieve ( List < T > arg0 ) { List < T > loc0 = new ArrayList < T > ( arg0. size ( ) ) ; for ( T loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > sieve ( int arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > sieve ( int arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( arg1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > sieve ( int arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. add ( loc1 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > sieve ( int arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0 ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > sieve ( int arg0, int arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( arg1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > sieve ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > sieve ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; int loc1 = 0 ; for ( Integer loc2 : arg0 ) { loc0. add ( loc2 ) ; loc1 ++ ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > sieve ( List < Integer > arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1. toString ( ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > sieve ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > sieve ( int arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "SHORTEST_PATHS": {
      "loc": "30-31",
      "input": "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min(\n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_edge.put(edge, update_weight); \n        }\n    }\n    return weight_by_node;\n}",
      "target": "public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n    Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n    for (List<String> edge : weight_by_edge.keySet()) {\n            weight_by_node.put(edge.get(1), INF);\n            weight_by_node.put(edge.get(0), INF);\n    }\n    weight_by_node.put(source, 0);\n    for (int i = 0; i < weight_by_node.size(); i++) {\n        for (List<String> edge : weight_by_edge.keySet()) {\n            int update_weight = Math.min( \n                    weight_by_node.get(edge.get(0))\n                            + weight_by_edge.get(edge),\n                    weight_by_node.get(edge.get(1)));\n            weight_by_node.put(edge.get(1), update_weight);\n        }\n    }\n    return weight_by_node;\n}",
      "function range": "16,5-34,5",
      "raw_output": [
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( ( Integer ) arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( ( Integer ) arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "void function ( ) { ShortestPaths loc0 = new ShortestPaths ( \"srini_string\", \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. get ( 0 ) ) ; Assert. assertEquals ( \"srini_string\", loc0. get ( 1 ) ) ; }",
        "void function ( ) { Shortest_paths loc0 = new Shortest_paths ( \"srini_string\", \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. getName ( ) ) ; Assert. assertEquals ( \"srini_string\", loc0. getName ( ) ) ; }",
        "void function ( ) { Shortest_paths loc0 = new Shortest_paths ( \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. get ( 0 ) ) ; Assert. assertEquals ( \"srini_string\", loc0. get ( 1 ) ) ; }",
        "void function ( ) { Shortest_paths loc0 = new Shortest_paths ( \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. shortest_path ( ) ) ; }",
        "void function ( ) { Shortest_paths loc0 = new Shortest_paths ( \"srini_string\", \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. shortest_path ( ) ) ; }",
        "List < String > function ( List < List < String >> arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( List < String > loc1 : arg0 ) { loc0. add ( loc1. get ( 0 ) ) ; } return loc0 ; }",
        "List < String > function ( List < List < String >> arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( List < String > loc1 : arg0 ) { loc0. add ( loc1. getName ( ) ) ; } return loc0 ; }",
        "Set < String > function ( Set < String > arg0 ) { Set < String > loc0 = new HashSet < String > ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < String > function ( List < Dot > arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Dot loc1 : arg0 ) { loc0. add ( loc1. getPath ( ) ) ; } return loc0 ; }",
        "List < String > function ( List < String > arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < String > function ( Coordinate arg0, Coordinate arg1 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < String > ( ) ; loc1. add ( arg0. toString ( ) ) ; loc1. add ( arg1. toString ( ) ) ; return loc0 ; }",
        "List < String > function ( Coordinate arg0, Coordinate arg1 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < > ( ) ; loc1. add ( arg0. toString ( ) ) ; loc1. add ( arg1. toString ( ) ) ; return loc0 ; }",
        "List < String > function ( Coordinate arg0, Coordinate arg1, double arg2 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < String > ( ) ; loc1. add ( arg0. toString ( ) ) ; loc1. add ( arg1. toString ( ) ) ; return loc0 ; }",
        "List < String > function ( Coordinate arg0, Coordinate arg1, double arg2 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < > ( ) ; loc1. add ( arg0. toString ( ) ) ; loc1. add ( arg1. toString ( ) ) ; return loc0 ; }",
        "List < String > function ( Coordinate arg0, Coordinate arg1, double arg2 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < > ( ) ; for ( Coordinate loc2 : arg0. getCoordinates ( ) ) { loc1. add ( loc2. toString ( ) ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Get shortest paths.",
        "Shortest_paths Method.",
        "Method to get the shortest paths.",
        "Get the shortest paths.",
        "Method to get the shortest paths for a source and edge."
      ],
      "output": [
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( ( Integer ) arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( ( Integer ) arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void shortest_paths ( ) { ShortestPaths loc0 = new ShortestPaths ( \"srini_string\", \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. get ( 0 ) ) ; Assert. assertEquals ( \"srini_string\", loc0. get ( 1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void shortest_paths ( ) { Shortest_paths loc0 = new Shortest_paths ( \"srini_string\", \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. getName ( ) ) ; Assert. assertEquals ( \"srini_string\", loc0. getName ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void shortest_paths ( ) { Shortest_paths loc0 = new Shortest_paths ( \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. get ( 0 ) ) ; Assert. assertEquals ( \"srini_string\", loc0. get ( 1 ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void shortest_paths ( ) { Shortest_paths loc0 = new Shortest_paths ( \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. shortest_path ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void shortest_paths ( ) { Shortest_paths loc0 = new Shortest_paths ( \"srini_string\", \"srini_string\" ) ; Assert. assertEquals ( \"srini_string\", loc0. shortest_path ( ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > shortest_paths ( List < List < String >> arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( List < String > loc1 : arg0 ) { loc0. add ( loc1. get ( 0 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > shortest_paths ( List < List < String >> arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( List < String > loc1 : arg0 ) { loc0. add ( loc1. getName ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < String > shortest_paths ( Set < String > arg0 ) { Set < String > loc0 = new HashSet < String > ( ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > shortest_paths ( List < Dot > arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Dot loc1 : arg0 ) { loc0. add ( loc1. getPath ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > shortest_paths ( List < String > arg0 ) { List < String > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( String loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_paths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > shortest_paths ( Coordinate arg0, Coordinate arg1 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < String > ( ) ; loc1. add ( arg0. toString ( ) ) ; loc1. add ( arg1. toString ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > shortest_paths ( Coordinate arg0, Coordinate arg1 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < > ( ) ; loc1. add ( arg0. toString ( ) ) ; loc1. add ( arg1. toString ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > shortest_paths ( Coordinate arg0, Coordinate arg1, double arg2 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < String > ( ) ; loc1. add ( arg0. toString ( ) ) ; loc1. add ( arg1. toString ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > shortest_paths ( Coordinate arg0, Coordinate arg1, double arg2 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < > ( ) ; loc1. add ( arg0. toString ( ) ) ; loc1. add ( arg1. toString ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > shortest_paths ( Coordinate arg0, Coordinate arg1, double arg2 ) { List < String > loc0 = new ArrayList < > ( ) ; Set < String > loc1 = new HashSet < > ( ) ; for ( Coordinate loc2 : arg0. getCoordinates ( ) ) { loc1. add ( loc2. toString ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "SHUNTING_YARD": {
      "loc": "32-32",
      "input": "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\",1);\n    precedence.put(\"-\",1);\n    precedence.put(\"*\",2);\n    precedence.put(\"/\",2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token: tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop());\n            } \n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}",
      "target": "public static List shunting_yard(ArrayList tokens) {\n    Map<String, Integer> precedence = new HashMap<String, Integer>();\n    precedence.put(\"+\", 1);\n    precedence.put(\"-\", 1);\n    precedence.put(\"*\", 2);\n    precedence.put(\"/\", 2);\n    ArrayList rpntokens = new ArrayList(100);\n    ArrayDeque opstack = new ArrayDeque();\n    for (Object token : tokens) {\n        if (Integer.class.isInstance(token)) {\n            rpntokens.add((Integer) token);\n        } else {\n            String operator = (String) token;\n            while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                rpntokens.add(opstack.pop()); \n            }\n            opstack.push(token);\n        }\n    }\n    while (!opstack.isEmpty()) {\n        rpntokens.add(opstack.pop());\n    }\n    return rpntokens;\n}",
      "function range": "14,5-41,5",
      "raw_output": [
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "int [ ] function ( int [ ] arg0, int arg1 ) { int [ ] loc0 = new int [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "int [ ] function ( int arg0, int arg1 ) { int [ ] loc0 = new int [ arg0 ] ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0 [ loc1 ] = arg1 ; } return loc0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
        "void function ( int arg0, int arg1 ) { System. out. println ( \"srini_string\" + arg0 + \"srini_string\" + arg1 ) ; }",
        "int function ( int arg0 ) { return ( int ) ( Math. random ( ) * arg0 ) ; }",
        "void function ( int arg0 ) { System. out. println ( \"srini_string\" + arg0 ) ; }",
        "void function ( int arg0 ) { System. out. println ( \"srini_string\" ) ; Thread. sleep ( arg0 ) ; }",
        "void function ( int arg0 ) { System. out. println ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { arg0 = 0 ; } else { arg0 = arg0 + 1 ; } return arg0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == 0 ) { loc0 [ loc1 ] = loc1 ; } } return loc0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < 0 ) { arg0 = 0 ; } if ( arg1 < arg0 ) { arg1 = arg0 + arg1 ; } return arg0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 [ loc1 ] ) { loc0 [ loc1 ] = loc0 [ loc1 ] ; } } return loc0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 [ loc1 ] ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } } return loc0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == 0 ) { loc0 [ loc1 ] = loc1 ; } } return loc0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > loc0 [ loc1 ] ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } } return loc0 ; }",
        "List < Token > function ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( arg0 ) ; Collections. shuffle ( loc0 ) ; return loc0 ; }",
        "List < Token > function ( List < Token > arg0, int arg1 ) { List < Token > loc0 = new ArrayList < Token > ( arg0 ) ; Collections. shuffle ( loc0, arg1 ) ; return loc0 ; }",
        "List < String > function ( List < String > arg0 ) { List < String > loc0 = new ArrayList < String > ( arg0 ) ; Collections. shuffle ( loc0 ) ; return loc0 ; }",
        "List < Token > function ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( arg0 ) ; Collections. sort ( loc0, new TokenComparator ( ) ) ; return loc0 ; }",
        "List < Token > function ( List < Token > arg0, int arg1 ) { List < Token > loc0 = new ArrayList < Token > ( arg0 ) ; Collections. shuffle ( loc0 ) ; return loc0 ; }"
      ],
      "mid_translation": [
        "Method shunting_yard.",
        "Shunting yard.",
        "Shunting yard algorithm.",
        "Shunting - Yard algorithm.",
        "Shunting a list of tokens."
      ],
      "output": [
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0, int arg1 ) { int [ ] loc0 = new int [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int arg0, int arg1 ) { int [ ] loc0 = new int [ arg0 ] ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0 [ loc1 ] = arg1 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length - 1 ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void shunting_yard ( int arg0, int arg1 ) { System. out. println ( \"srini_string\" + arg0 + \"srini_string\" + arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shunting_yard ( int arg0 ) { return ( int ) ( Math. random ( ) * arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void shunting_yard ( int arg0 ) { System. out. println ( \"srini_string\" + arg0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static void shunting_yard ( int arg0 ) { System. out. println ( \"srini_string\" ) ; Thread. sleep ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static void shunting_yard ( int arg0 ) { System. out. println ( \"srini_string\" + arg0 + \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shunting_yard ( int arg0 ) { if ( arg0 < 0 ) { arg0 = 0 ; } else { arg0 = arg0 + 1 ; } return arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 [ loc1 ] = arg0 [ loc1 ] ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == 0 ) { loc0 [ loc1 ] = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int shunting_yard ( int arg0, int arg1 ) { if ( arg0 < 0 ) { arg0 = 0 ; } if ( arg1 < arg0 ) { arg1 = arg0 + arg1 ; } return arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 [ loc1 ] ) { loc0 [ loc1 ] = loc0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0 [ loc1 ] ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] == 0 ) { loc0 [ loc1 ] = loc1 ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shunting_yard ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] > loc0 [ loc1 ] ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Token > shunting_yard ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( arg0 ) ; Collections. shuffle ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Token > shunting_yard ( List < Token > arg0, int arg1 ) { List < Token > loc0 = new ArrayList < Token > ( arg0 ) ; Collections. shuffle ( loc0, arg1 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > shunting_yard ( List < String > arg0 ) { List < String > loc0 = new ArrayList < String > ( arg0 ) ; Collections. shuffle ( loc0 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Token > shunting_yard ( List < Token > arg0 ) { List < Token > loc0 = new ArrayList < Token > ( arg0 ) ; Collections. sort ( loc0, new TokenComparator ( ) ) ; return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Token > shunting_yard ( List < Token > arg0, int arg1 ) { List < Token > loc0 = new ArrayList < Token > ( arg0 ) ; Collections. shuffle ( loc0 ) ; return loc0 ; }",
          "correctness": "uncompilable"
        }
      ]
    },
    "SHORTEST_PATH_LENGTHS": {
      "loc": "37-38",
      "input": "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                             sumLengths(length_by_path.get(Arrays.asList(i,k)),\n                                                        length_by_path.get(Arrays.asList(j,k)))); \n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}",
      "target": "public static Map<List<Integer>,Integer> shortest_path_lengths(int numNodes, Map<List<Integer>,Integer> length_by_edge) {\n    Map<List<Integer>,Integer> length_by_path = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n        for (int j =0; j < numNodes; j++) {\n            List<Integer> edge = new ArrayList<>(Arrays.asList(i,j));\n            if (i == j) {\n                length_by_path.put(edge, 0);\n            }\n            else if (length_by_edge.containsKey(edge) ) {\n                length_by_path.put(edge, length_by_edge.get(edge));\n            } else {\n                length_by_path.put(edge, INF);\n            }\n        }\n    }\n    for (int k = 0; k < numNodes; k++) {\n        for (int i = 0; i < numNodes; i++) {\n            for (int j = 0; j < numNodes; j++) {\n                int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                             sumLengths(length_by_path.get(Arrays.asList(i,k)),\n                                                        length_by_path.get(Arrays.asList(k,j)))); \n                length_by_path.put(Arrays.asList(i,j), update_length);\n            }\n        }\n    }\n    return length_by_path;\n}",
      "function range": "17,5-43,5",
      "raw_output": [
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 - 1 ) ) ; } return loc0 ; }",
        "int [ ] function ( List < Integer > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 [ loc1 ] = arg0. get ( loc1 ) ; } return loc0 ; }",
        "int [ ] function ( List < Integer > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0 [ loc2 ] = arg0. get ( loc2 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "int [ ] function ( List < Integer > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( Integer loc2 : arg0 ) { loc0 [ loc1 ++ ] = loc2 ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 - 1 ) ) ; } return loc0 ; }",
        "Set < Integer > function ( List < Integer > arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 - 1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
        "int [ ] function ( Set < Integer > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( Integer loc2 : arg0 ) { loc0 [ loc1 ++ ] = loc2 ; } return loc0 ; }",
        "int [ ] function ( Set < Node > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( Node loc2 : arg0 ) { loc0 [ loc1 ++ ] = loc2. getPathLength ( ) ; } return loc0 ; }",
        "Set < Integer > function ( Set < Integer > arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "Set < Integer > function ( Set < Integer > arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ). intValue ( ) ) ; } return loc0 ; }",
        "int [ ] function ( Set < Integer > arg0, Set < Integer > arg1 ) { int [ ] loc0 = new int [ arg1. size ( ) ] ; int loc1 = 0 ; for ( Integer loc2 : arg1 ) { loc0 [ loc1 ++ ] = loc2 ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Gets the shortest path lengths.",
        "Shortest path lengths.",
        "Get shortest path lengths.",
        "Gets shortest path lengths.",
        "Get the shortest path lengths for a set of nodes"
      ],
      "output": [
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 - 1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shortest_path_lengths ( List < Integer > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0 [ loc1 ] = arg0. get ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shortest_path_lengths ( List < Integer > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( int loc2 = 0 ; loc2 < arg0. size ( ) ; loc2 ++ ) { loc0 [ loc2 ] = arg0. get ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shortest_path_lengths ( List < Integer > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( Integer loc2 : arg0 ) { loc0 [ loc1 ++ ] = loc2 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 - 1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > shortest_path_lengths ( List < Integer > arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 1 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 - 1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > shortest_path_lengths ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { int loc2 = arg0. get ( loc1 ) ; loc0. add ( loc2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shortest_path_lengths ( Set < Integer > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( Integer loc2 : arg0 ) { loc0 [ loc1 ++ ] = loc2 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] shortest_path_lengths ( Set < Node > arg0 ) { int [ ] loc0 = new int [ arg0. size ( ) ] ; int loc1 = 0 ; for ( Node loc2 : arg0 ) { loc0 [ loc1 ++ ] = loc2. getPathLength ( ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < Integer > shortest_path_lengths ( Set < Integer > arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < Integer > shortest_path_lengths ( Set < Integer > arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ). intValue ( ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int [ ] shortest_path_lengths ( Set < Integer > arg0, Set < Integer > arg1 ) { int [ ] loc0 = new int [ arg1. size ( ) ] ; int loc1 = 0 ; for ( Integer loc2 : arg1 ) { loc0 [ loc1 ++ ] = loc2 ; } return loc0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "SUBSEQUENCES": {
      "loc": "16-17",
      "input": "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        return new ArrayList(); \n    }\n    ArrayList ret = new ArrayList(50);\n    for (int i=a; i<b+1-k; i++) {\n        ArrayList base = new ArrayList(50);\n        for (ArrayList rest : subsequences(i+1, b, k-1)) {\n            rest.add(0,i);\n            base.add(rest);\n        }\n        ret.addAll(base);\n    }\n    return ret;\n}",
      "target": "public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n    if (k == 0) {\n        ArrayList empty_set = new ArrayList<ArrayList>(); \n        empty_set.add(new ArrayList());\n        return empty_set;\n    }\n    ArrayList ret = new ArrayList(50);\n    for (int i=a; i<b+1-k; i++) {\n        ArrayList base = new ArrayList(50);\n        for (ArrayList rest : subsequences(i+1, b, k-1)) {\n            rest.add(0,i);\n            base.add(rest);\n        }\n        ret.addAll(base);\n    }\n    return ret;\n}",
      "function range": "14,5-31,5",
      "raw_output": [
        "ArrayList < Integer > function ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) loc2. add ( arg1. intValue ( ) + loc3 ) ; return loc2 ; }",
        "ArrayList < Integer > function ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) loc2. add ( arg1. intValue ( ) - loc3 ) ; return loc2 ; }",
        "ArrayList < Integer > function ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) { loc2. add ( arg0. intValue ( ) - ( arg1. intValue ( ) * loc3 ) ) ; } return loc2 ; }",
        "ArrayList < Integer > function ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) loc2. add ( loc3 ) ; return loc2 ; }",
        "ArrayList < Integer > function ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) { loc2. add ( arg1. intValue ( ) - loc3 ) ; } return loc2 ; }",
        "ArrayList < Integer > function ( Integer arg0, Integer arg1 ) { ArrayList loc0 = new ArrayList ( ) ; int loc1 = arg0. compareTo ( arg1 ) ; while ( loc1 >= 0 ) { loc0. add ( loc1 ) ; loc1 /= 2 ; } return loc0 ; }",
        "ArrayList function ( int arg0, int arg1 ) { int loc0 = arg0 - arg1 + 1 ; ArrayList loc1 = new ArrayList ( ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( ( arg1 - arg0 ) / 2 ) ; loc1. add ( ( arg1 - arg0 ) / 2 ) ; } return loc1 ; }",
        "ArrayList function ( int arg0, int arg1 ) { int loc0 = arg0 - arg1 + 1 ; ArrayList loc1 = new ArrayList ( ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( ( arg1 - arg0 ) / 2 ) ; loc1. add ( ( arg0 + loc2 ) / 2 ) ; } return loc1 ; }",
        "ArrayList function ( int arg0, int arg1 ) { int loc0 = arg0 - arg1 + 1 ; ArrayList loc1 = new ArrayList ( ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( ( arg1 - arg0 ) / 2 ) ; loc1. add ( ( arg0 + arg1 ) / 2 ) ; } return loc1 ; }",
        "ArrayList function ( int arg0, int arg1 ) { int loc0 = arg0 - arg1 + 1 ; ArrayList loc1 = new ArrayList ( ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( ( arg0 - arg1 ) / 2 ) ; loc1. add ( ( arg1 - arg0 ) / 2 ) ; } return loc1 ; }",
        "ArrayList < ArrayList > function ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < ArrayList > function ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( arg0. size ( ) + 1 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < ArrayList > function ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList function ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
        "ArrayList < ArrayList > function ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return ( loc0 ) ; }",
        "ArrayList function ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) { loc1. add ( ( arg1 - arg0 ) / 2 ) ; loc0. add ( ( arg1 - arg0 ) / 2 ) ; } return loc0 ; }",
        "ArrayList function ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; for ( int loc2 = 0 ; loc2 < arg1 ; loc2 ++ ) loc0. add ( ( arg1 - arg0 ) / 2 ) ; return loc0 ; }",
        "ArrayList function ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; for ( int loc2 = 0 ; loc2 < arg1 ; loc2 ++ ) loc1. add ( ( arg0 - arg1 ) / 2 ) ; return loc0 ; }",
        "ArrayList function ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; for ( int loc2 = 0 ; loc2 < arg1 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; return loc0 ; }",
        "ArrayList function ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; for ( int loc2 = 0 ; loc2 < arg1 ; loc2 ++ ) loc0. add ( ( arg0 - arg1 ) / 2 ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. add ( arg1. get ( loc1 ) ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. add ( arg1. get ( loc1 ) ) ; return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) + 1 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }"
      ],
      "mid_translation": [
        "Get a list of ArrayLists representing the k subsequences of a and b.",
        "Returns a list of ArrayLists representing the k subsequences of a and b.",
        "Get a list of ArrayList of ArrayLists representing the subsequences of a and b.",
        "Get a list of ArrayList of ArrayLists representing the k subsequences of a and b",
        "Gets the subsequences of a and b."
      ],
      "output": [
        {
          "patch": "public static ArrayList < Integer > subsequences ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) loc2. add ( arg1. intValue ( ) + loc3 ) ; return loc2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > subsequences ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) loc2. add ( arg1. intValue ( ) - loc3 ) ; return loc2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > subsequences ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) { loc2. add ( arg0. intValue ( ) - ( arg1. intValue ( ) * loc3 ) ) ; } return loc2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > subsequences ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) loc2. add ( loc3 ) ; return loc2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > subsequences ( Integer arg0, Integer arg1 ) { int loc0 = arg0. intValue ( ) ; int loc1 = arg1. intValue ( ) ; ArrayList loc2 = new ArrayList ( loc0 ) ; for ( int loc3 = 0 ; loc3 < loc0 ; loc3 ++ ) { loc2. add ( arg1. intValue ( ) - loc3 ) ; } return loc2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < Integer > subsequences ( Integer arg0, Integer arg1 ) { ArrayList loc0 = new ArrayList ( ) ; int loc1 = arg0. compareTo ( arg1 ) ; while ( loc1 >= 0 ) { loc0. add ( loc1 ) ; loc1 /= 2 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList subsequences ( int arg0, int arg1 ) { int loc0 = arg0 - arg1 + 1 ; ArrayList loc1 = new ArrayList ( ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( ( arg1 - arg0 ) / 2 ) ; loc1. add ( ( arg1 - arg0 ) / 2 ) ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList subsequences ( int arg0, int arg1 ) { int loc0 = arg0 - arg1 + 1 ; ArrayList loc1 = new ArrayList ( ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( ( arg1 - arg0 ) / 2 ) ; loc1. add ( ( arg0 + loc2 ) / 2 ) ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList subsequences ( int arg0, int arg1 ) { int loc0 = arg0 - arg1 + 1 ; ArrayList loc1 = new ArrayList ( ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( ( arg1 - arg0 ) / 2 ) ; loc1. add ( ( arg0 + arg1 ) / 2 ) ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList subsequences ( int arg0, int arg1 ) { int loc0 = arg0 - arg1 + 1 ; ArrayList loc1 = new ArrayList ( ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( ( arg0 - arg1 ) / 2 ) ; loc1. add ( ( arg1 - arg0 ) / 2 ) ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList < ArrayList > subsequences ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList > subsequences ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( arg0. size ( ) + 1 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList > subsequences ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList subsequences ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList < ArrayList > subsequences ( Subsequence arg0, Subsequence arg1 ) { ArrayList loc0 = new ArrayList ( ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return ( loc0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static ArrayList subsequences ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) { loc1. add ( ( arg1 - arg0 ) / 2 ) ; loc0. add ( ( arg1 - arg0 ) / 2 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList subsequences ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; for ( int loc2 = 0 ; loc2 < arg1 ; loc2 ++ ) loc0. add ( ( arg1 - arg0 ) / 2 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList subsequences ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; for ( int loc2 = 0 ; loc2 < arg1 ; loc2 ++ ) loc1. add ( ( arg0 - arg1 ) / 2 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList subsequences ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; for ( int loc2 = 0 ; loc2 < arg1 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static ArrayList subsequences ( int arg0, int arg1 ) { ArrayList loc0 = new ArrayList ( arg0 ) ; ArrayList loc1 = new ArrayList ( arg1 ) ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc1. add ( ( arg1 - arg0 ) / 2 ) ; for ( int loc2 = 0 ; loc2 < arg1 ; loc2 ++ ) loc0. add ( ( arg0 - arg1 ) / 2 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > subsequences ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > subsequences ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. add ( arg1. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > subsequences ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > subsequences ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) loc0. add ( arg1. get ( loc1 ) ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > subsequences ( List < Integer > arg0, List < Integer > arg1 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) + 1 ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg1. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "SQRT": {
      "loc": "16-17",
      "input": "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2d;\n    while (Math.abs(x-approx) > epsilon) { \n        approx = 0.5d * (approx + x / approx);\n    }\n    return approx;\n}",
      "target": "public static double sqrt(double x, double epsilon) {\n    double approx = x / 2d;\n    while (Math.abs(x-approx*approx) > epsilon) { \n        approx = 0.5d * (approx + x / approx);\n    }\n    return approx;\n}",
      "function range": "14,5-20,5",
      "raw_output": [
        "double function ( double arg0 [ ] ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) loc0 *= arg0 [ loc1 ] ; return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] * arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { loc0 *= arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 += arg0 [ loc1 ] * arg0 [ loc1 ] ; return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { loc0 *= arg0 [ loc1 ] ; } return loc0 ; }",
        "float function ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { loc0 *= arg0 [ loc1 ] ; } return loc0 ; }",
        "float function ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { loc0 *= arg0 [ loc1 ] ; } return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( double loc1 : arg0 ) { loc0 += loc1 * loc1 ; } return loc0 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( double loc1 : arg0 ) { loc0 += loc1 ; } return loc0 ; }",
        "double function ( double arg0 ) { double loc0 = arg0 / arg0 ; double loc1 = 1 / ( loc0 * loc0 ) ; return loc1 ; }",
        "double function ( double arg0 ) { double loc0 = arg0 / arg0 ; double loc1 = ( double ) arg0 / arg0 ; double loc2 = ( double ) arg0 / arg0 ; double loc3 = ( double ) arg0 / arg0 ; return loc0 * loc1 + loc2 * loc3 ; }",
        "double function ( double arg0 ) { double loc0 = arg0 * arg0 ; double loc1 = 1 / ( loc0 * loc0 ) ; return loc1 ; }",
        "double function ( double arg0 ) { double loc0 = arg0 / arg0 ; double loc1 = ( double ) arg0 / arg0 ; double loc2 = ( double ) arg0 / arg0 ; double loc3 = ( double ) arg0 / arg0 ; return ( loc0 * loc0 ) + loc1 * loc1 ; }",
        "double function ( final double arg0 ) { double loc0 = arg0 * arg0 ; double loc1 = 1 / ( loc0 * loc0 ) ; return loc1 ; }",
        "double function ( double arg0 ) { double loc0 = arg0 * arg0 ; double loc1 = 1 / ( loc0 * loc0 ) ; double loc2 = 2 / ( loc0 * loc0 ) ; double loc3 = 2 / ( loc0 * loc0 ) ; return loc2 * loc1 ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0 += Math. pow ( loc2, loc1 ) ; } return Math. sqrt ( loc0 ) ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0 += Math. pow ( loc2, loc1 ) ; } return Math. sqrt ( loc0 ) ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0 += Math. pow ( ( double ) loc2, 2 ) ; } return Math. sqrt ( loc0 ) ; }",
        "double function ( double arg0 [ ] ) { double loc0 = 0 ; for ( double loc1 : arg0 ) { loc0 += Math. pow ( loc1, 2 ) ; } return Math. sqrt ( loc0 ) ; }",
        "double function ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] - arg0 [ loc1 ] ; loc0 += Math. pow ( loc2, loc1 ) ; } return Math. sqrt ( loc0 ) ; }",
        "double function ( final double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) loc1 *= loc2 ; return loc1 ; }",
        "double function ( double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) loc1 *= loc2 ; return loc1 ; }",
        "double function ( final double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) loc1 *= Math. pow ( loc2, loc2 ) ; return loc1 ; }",
        "double function ( final double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc0 *= Math. pow ( loc1, loc2 ) ; return loc0 ; }",
        "double function ( final double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 *= Math. pow ( loc2, loc2 ) ; } return loc1 ; }"
      ],
      "mid_translation": [
        "Compute the square of x.",
        "Compute the square root of x.",
        "Calculate the square of x.",
        "Compute the Euclidean norm of x.",
        "Compute the square of x"
      ],
      "output": [
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) loc0 *= arg0 [ loc1 ] ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 += arg0 [ loc1 ] * arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { loc0 *= arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 += arg0 [ loc1 ] * arg0 [ loc1 ] ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { loc0 *= arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static float sqrt ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; loc1 ++ ) { loc0 *= arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static float sqrt ( float arg0 [ ] ) { float loc0 = arg0 [ 0 ] ; for ( int loc1 = 1 ; loc1 < arg0. length ; ++ loc1 ) { loc0 *= arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = 0 ; for ( double loc1 : arg0 ) { loc0 += loc1 * loc1 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = 0 ; for ( double loc1 : arg0 ) { loc0 += loc1 ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 ) { double loc0 = arg0 / arg0 ; double loc1 = 1 / ( loc0 * loc0 ) ; return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 ) { double loc0 = arg0 / arg0 ; double loc1 = ( double ) arg0 / arg0 ; double loc2 = ( double ) arg0 / arg0 ; double loc3 = ( double ) arg0 / arg0 ; return loc0 * loc1 + loc2 * loc3 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 ) { double loc0 = arg0 * arg0 ; double loc1 = 1 / ( loc0 * loc0 ) ; return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 ) { double loc0 = arg0 / arg0 ; double loc1 = ( double ) arg0 / arg0 ; double loc2 = ( double ) arg0 / arg0 ; double loc3 = ( double ) arg0 / arg0 ; return ( loc0 * loc0 ) + loc1 * loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( final double arg0 ) { double loc0 = arg0 * arg0 ; double loc1 = 1 / ( loc0 * loc0 ) ; return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 ) { double loc0 = arg0 * arg0 ; double loc1 = 1 / ( loc0 * loc0 ) ; double loc2 = 2 / ( loc0 * loc0 ) ; double loc3 = 2 / ( loc0 * loc0 ) ; return loc2 * loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0 += Math. pow ( loc2, loc1 ) ; } return Math. sqrt ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0 += Math. pow ( loc2, loc1 ) ; } return Math. sqrt ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] ; loc0 += Math. pow ( ( double ) loc2, 2 ) ; } return Math. sqrt ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 [ ] ) { double loc0 = 0 ; for ( double loc1 : arg0 ) { loc0 += Math. pow ( loc1, 2 ) ; } return Math. sqrt ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double [ ] arg0 ) { double loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { double loc2 = arg0 [ loc1 ] - arg0 [ loc1 ] ; loc0 += Math. pow ( loc2, loc1 ) ; } return Math. sqrt ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( final double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) loc1 *= loc2 ; return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) loc1 *= loc2 ; return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( final double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) loc1 *= Math. pow ( loc2, loc2 ) ; return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( final double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < arg0 ; loc2 ++ ) loc0 *= Math. pow ( loc1, loc2 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static double sqrt ( final double arg0 ) { double loc0 = arg0 ; double loc1 = 1 ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1 *= Math. pow ( loc2, loc2 ) ; } return loc1 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "WRAP": {
      "loc": "31-31",
      "input": "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    return lines;\n}",
      "target": "public static ArrayList<String> wrap(String text, int cols) {\n    ArrayList<String> lines = new ArrayList<String>();\n    String line;\n    while (text.length() > cols) {\n        int end = text.lastIndexOf(\" \", cols); \n        if (end == -1) {\n            end = cols;\n        }\n        line = text.substring(0,end);\n        text = text.substring(end);\n        lines.add(line);\n    }\n    lines.add(text); \n    return lines;\n}",
      "function range": "18,5-33,5",
      "raw_output": [
        "String function ( String arg0, int arg1 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1 ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1, arg2 ) ; }",
        "String function ( String arg0 ) { return arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { return Joiner. on ( \"srini_string\" ). join ( arg0. split ( \"srini_string\" ) ) ; }",
        "List < String > function ( String arg0, int arg1 ) { if ( arg0 == null ) { return Collections. emptyList ( ) ; } else { return Collections. singletonList ( arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ) ; } }",
        "List < String > function ( String arg0, int arg1 ) { if ( arg0 == null ) { return Collections. emptyList ( ) ; } else { return Collections. singletonList ( arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ; } }",
        "List < String > function ( String arg0, int arg1 ) { if ( arg0 == null ) { return Collections. emptyList ( ) ; } else { return Collections. singletonList ( arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ) ; } }",
        "List < String > function ( String arg0, int arg1 ) { if ( arg0 == null ) return Collections. < String > emptyList ( ) ; List < String > loc0 = new ArrayList < > ( arg1 ) ; return loc0 ; }",
        "List < String > function ( String arg0, int arg1 ) { if ( arg0 == null ) return Collections. emptyList ( ) ; List < String > loc0 = new ArrayList < String > ( arg1 ) ; return loc0 ; }",
        "String function ( String arg0, int arg1 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1 ) ; }",
        "String function ( final String arg0, final int arg1 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1 ) ; }",
        "String function ( String arg0, int arg1, int arg2 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1, arg2 ) ; }",
        "String function ( String arg0, int arg1 ) { return wrapLines ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1 ) ; }",
        "String function ( String arg0, int arg1 ) { return new StringBuilder ( arg0 ). append ( \"srini_string\" ). append ( arg1 ). append ( \"srini_string\" ). toString ( ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( final String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { return arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
        "String function ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. split ( \"srini_string\" ) ; }",
        "List < String > function ( String arg0, int arg1 ) { int loc0 = arg0. length ( ) ; List < String > loc1 = new ArrayList < String > ( loc0 / arg1 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( arg0. substring ( 0, loc2 ) ) ; } return loc1 ; }",
        "List < String > function ( String arg0, int arg1 ) { if ( arg0 == null ) return null ; int loc0 = arg0. length ( ) ; List < String > loc1 = new ArrayList < String > ( loc0 / arg1 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( arg0. substring ( 0, loc2 ) ) ; } return loc1 ; }",
        "List < String > function ( String arg0, int arg1 ) { if ( arg0 == null ) return null ; int loc0 = arg0. length ( ) ; List < String > loc1 = new ArrayList < > ( loc0 / arg1 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( arg0. substring ( 0, loc2 ) ) ; } return loc1 ; }",
        "List < String > function ( String arg0, int arg1, int arg2 ) { return wrap ( arg0. split ( \"srini_string\" ), arg1, arg2 ) ; }",
        "List < String > function ( String arg0, int arg1 ) { if ( arg0 == null ) return null ; int loc0 = arg0. length ( ) ; List < String > loc1 = new ArrayList < String > ( loc0 * arg1 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( arg0. substring ( 0, loc2 ) ) ; } return loc1 ; }"
      ],
      "mid_translation": [
        "Wrap a string in a sequence of lines.",
        "Wrap a string in a list of lines.",
        "Wrap a string with a number of lines.",
        "Wraps a string in a sequence of lines.",
        "Wrap a string into a list of lines of size cols."
      ],
      "output": [
        {
          "patch": "public static String wrap ( String arg0, int arg1 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0, int arg1, int arg2 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1, arg2 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0 ) { return arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0 ) { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0 ) { return Joiner. on ( \"srini_string\" ). join ( arg0. split ( \"srini_string\" ) ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1 ) { if ( arg0 == null ) { return Collections. emptyList ( ) ; } else { return Collections. singletonList ( arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1 ) { if ( arg0 == null ) { return Collections. emptyList ( ) ; } else { return Collections. singletonList ( arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ; } }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1 ) { if ( arg0 == null ) { return Collections. emptyList ( ) ; } else { return Collections. singletonList ( arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ) ; } }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1 ) { if ( arg0 == null ) return Collections. < String > emptyList ( ) ; List < String > loc0 = new ArrayList < > ( arg1 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1 ) { if ( arg0 == null ) return Collections. emptyList ( ) ; List < String > loc0 = new ArrayList < String > ( arg1 ) ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0, int arg1 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( final String arg0, final int arg1 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0, int arg1, int arg2 ) { return wrap ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1, arg2 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0, int arg1 ) { return wrapLines ( arg0. replace ( \"srini_string\", \"srini_string\" ), arg1 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String wrap ( String arg0, int arg1 ) { return new StringBuilder ( arg0 ). append ( \"srini_string\" ). append ( arg1 ). append ( \"srini_string\" ). toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( final String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0 ) { return arg0. replace ( \"srini_string\", \"srini_string\" ). replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0 ) { return arg0. replace ( \"srini_string\", \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String wrap ( String arg0 ) { if ( arg0 == null ) { return \"srini_string\" ; } return arg0. split ( \"srini_string\" ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1 ) { int loc0 = arg0. length ( ) ; List < String > loc1 = new ArrayList < String > ( loc0 / arg1 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( arg0. substring ( 0, loc2 ) ) ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1 ) { if ( arg0 == null ) return null ; int loc0 = arg0. length ( ) ; List < String > loc1 = new ArrayList < String > ( loc0 / arg1 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( arg0. substring ( 0, loc2 ) ) ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1 ) { if ( arg0 == null ) return null ; int loc0 = arg0. length ( ) ; List < String > loc1 = new ArrayList < > ( loc0 / arg1 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( arg0. substring ( 0, loc2 ) ) ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1, int arg2 ) { return wrap ( arg0. split ( \"srini_string\" ), arg1, arg2 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < String > wrap ( String arg0, int arg1 ) { if ( arg0 == null ) return null ; int loc0 = arg0. length ( ) ; List < String > loc1 = new ArrayList < String > ( loc0 * arg1 ) ; for ( int loc2 = 0 ; loc2 < loc0 ; loc2 ++ ) { loc1. add ( arg0. substring ( 0, loc2 ) ) ; } return loc1 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "TO_BASE": {
      "loc": "21-22",
      "input": "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = result + String.valueOf(alphabet.charAt(i)); \n    }\n    return result;\n}",
      "target": "public static String to_base(int num, int b) {\n    String result = \"\";\n    String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    while (num > 0) {\n        i = num % b;\n        num = num / b; \n        result = String.valueOf(alphabet.charAt(i))+result; \n    }\n    return result;\n}",
      "function range": "14,5-25,5",
      "raw_output": [
        "String function ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; return new String ( loc0 ) ; }",
        "String function ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) loc0 [ loc1 ] = Character. forDigit ( ( arg0 >> loc1 ) & 0x0f, 16 ) ; return new String ( loc0 ) ; }",
        "String function ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; arg0 >>= 4 ; } return new String ( loc0 ) ; }",
        "String function ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; } return new String ( loc0 ) ; }",
        "String function ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 16 ) ; arg0 >>= 4 ; } return new String ( loc0 ) ; }",
        "String function ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( '0' ) ; } return loc0. toString ( ) ; }",
        "String function ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. append ( '0' ) ; return loc0. toString ( ) ; }",
        "String function ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0. append ( '0' ) ; } return loc0. append ( arg0 ) ; }",
        "String function ( int arg0, char arg1 ) { return String. valueOf ( arg0 ) + arg1 ; }",
        "String function ( int arg0, int arg1 ) { String loc0 = Integer. toString ( arg0 ) ; int loc1 = loc0. length ( ) - arg1 + 1 ; return loc0. substring ( 0, loc1 ) ; }",
        "String function ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 1 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( loc1 ) ; } return loc0. toString ( ) ; }",
        "String function ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( '0' ) ; } return loc0. toString ( ) ; }",
        "String function ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( loc1 ) ; } return loc0. toString ( ) ; }",
        "String function ( int arg0 ) { String loc0 = Integer. toString ( arg0 ) ; return loc0. substring ( 0, loc0. length ( ) - 1 ) ; }",
        "String function ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 1 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( '0' ) ; } return loc0. toString ( ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < 0 ) throw new ArithmeticException ( \"srini_string\" ) ; if ( arg1 < 0 ) throw new ArithmeticException ( \"srini_string\" ) ; return ( int ) arg0 ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < 0 ) throw new ArithmeticException ( \"srini_string\" + arg0 + \"srini_string\" ) ; return ( int ) ( arg0 / arg1 ) ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < 0 ) throw new ArithmeticException ( \"srini_string\" ) ; if ( arg1 < 0 ) throw new ArithmeticException ( \"srini_string\" ) ; return arg0 * arg1 ; }",
        "int function ( Number arg0, int arg1 ) { if ( arg0 == null ) { throw new ArithmeticException ( \"srini_string\" ) ; } return arg0. intValue ( ) << arg1 ; }",
        "int function ( int arg0, int arg1 ) { if ( arg0 < 0 ) throw new ArithmeticException ( \"srini_string\" + arg0 + \"srini_string\" ) ; return ( int ) arg0 ; }",
        "String function ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; } return String. valueOf ( loc0 ) ; }",
        "String function ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; } return new String ( loc0 ) ; }",
        "String function ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; return new String ( loc0 ) ; }",
        "String function ( int arg0, int arg1 ) { return String. valueOf ( arg0 ) + \"srini_string\" + String. valueOf ( arg1 ) ; }",
        "String function ( int arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0. append ( arg0 % loc1 ) ; } return loc0. toString ( ) ; }"
      ],
      "mid_translation": [
        "Convert an integer to a base string.",
        "Convert a number to a base string.",
        "Converts a number to a base string.",
        "Convert a number to a base.",
        "Converts an integer to a base string."
      ],
      "output": [
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) loc0 [ loc1 ] = Character. forDigit ( ( arg0 >> loc1 ) & 0x0f, 16 ) ; return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; arg0 >>= 4 ; } return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; } return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 16 ) ; arg0 >>= 4 ; } return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( '0' ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) loc0. append ( '0' ) ; return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < 10 ; loc1 ++ ) { loc0. append ( '0' ) ; } return loc0. append ( arg0 ) ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static String to_base ( int arg0, char arg1 ) { return String. valueOf ( arg0 ) + arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { String loc0 = Integer. toString ( arg0 ) ; int loc1 = loc0. length ( ) - arg1 + 1 ; return loc0. substring ( 0, loc1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 1 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( loc1 ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( '0' ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( loc1 ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0 ) { String loc0 = Integer. toString ( arg0 ) ; return loc0. substring ( 0, loc0. length ( ) - 1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 1 ; loc1 < arg0 ; loc1 ++ ) { loc0. append ( '0' ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int to_base ( int arg0, int arg1 ) { if ( arg0 < 0 ) throw new ArithmeticException ( \"srini_string\" ) ; if ( arg1 < 0 ) throw new ArithmeticException ( \"srini_string\" ) ; return ( int ) arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int to_base ( int arg0, int arg1 ) { if ( arg0 < 0 ) throw new ArithmeticException ( \"srini_string\" + arg0 + \"srini_string\" ) ; return ( int ) ( arg0 / arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int to_base ( int arg0, int arg1 ) { if ( arg0 < 0 ) throw new ArithmeticException ( \"srini_string\" ) ; if ( arg1 < 0 ) throw new ArithmeticException ( \"srini_string\" ) ; return arg0 * arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int to_base ( Number arg0, int arg1 ) { if ( arg0 == null ) { throw new ArithmeticException ( \"srini_string\" ) ; } return arg0. intValue ( ) << arg1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int to_base ( int arg0, int arg1 ) { if ( arg0 < 0 ) throw new ArithmeticException ( \"srini_string\" + arg0 + \"srini_string\" ) ; return ( int ) arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; } return String. valueOf ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; } return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { char [ ] loc0 = new char [ arg1 ] ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) loc0 [ loc1 ] = Character. forDigit ( arg0 & 0x0f, 10 ) ; return new String ( loc0 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { return String. valueOf ( arg0 ) + \"srini_string\" + String. valueOf ( arg1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static String to_base ( int arg0, int arg1 ) { StringBuilder loc0 = new StringBuilder ( ) ; for ( int loc1 = 0 ; loc1 < arg1 ; loc1 ++ ) { loc0. append ( arg0 % loc1 ) ; } return loc0. toString ( ) ; }",
          "correctness": "wrong"
        }
      ]
    },
    "POWERSET": {
      "loc": "23-30",
      "input": "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100);\n        to_add.add(first); \n        for (ArrayList subset : rest_subsets) { \n            to_add.addAll(subset); \n        } \n        output.add(to_add); \n        return output; \n    } else {\n        ArrayList empty_set = new ArrayList<ArrayList>();\n        empty_set.add(new ArrayList());\n        return empty_set;\n    }\n}",
      "target": "public static ArrayList<ArrayList> powerset(ArrayList arr) {\n    if (!arr.isEmpty()) {\n        Object first = arr.get(0);\n        arr.remove(0);\n        ArrayList rest = arr;\n        ArrayList<ArrayList> rest_subsets = powerset(rest);\n        ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n        ArrayList to_add = new ArrayList(100); \n        for (ArrayList subset : rest_subsets) { \n            ArrayList r = new ArrayList(); \n            r.add(first); \n            r.addAll(subset); \n            to_add.add(r); \n        }\n        output.addAll(to_add);\n        rest_subsets.addAll(output);\n        return rest_subsets;\n    } else {\n        ArrayList empty_set = new ArrayList<ArrayList>();\n        empty_set.add(new ArrayList());\n        return empty_set;\n    }\n}",
      "function range": "14,5-35,5",
      "raw_output": [
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { if ( loc1 < loc0. size ( ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "List < Integer > function ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "Set < Integer > function ( Set < Integer > arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( new Integer ( loc1 ) ) ; } return loc0 ; }",
        "Set < Integer > function ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "Set < Integer > function ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
        "Set < Integer > function ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "Set < Integer > function ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
        "Set < Integer > function ( Integer [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "List < Integer > function ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
        "List < Integer > function ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
        "Set < Integer > function ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "List < Integer > function ( int [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
        "Set < Integer > function ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
        "Set < Integer > function ( int... arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0. get ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Integer > function ( int... arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] < loc0. get ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
        "Set < Integer > function ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
        "List < Integer > function ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "Set < Integer > function ( int... arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0. get ( loc1 ) ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
        "List < Integer > function ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "int [ ] function ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
        "List < Integer > function ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
        "List < Integer > function ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
        "List < Integer > function ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }"
      ],
      "mid_translation": [
        "Returns the powerset of the given array.",
        "Get the powerset of the array.",
        "Returns the powerset of the array.",
        "Get the powerset of the given array.",
        "This method returns the powerset of the given array."
      ],
      "output": [
        {
          "patch": "public static List < Integer > powerset ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { if ( loc1 < loc0. size ( ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( Set < Integer > arg0 ) { if ( arg0 == null ) { throw new NullPointerException ( \"srini_string\" ) ; } Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( Integer loc1 : arg0 ) { loc0. add ( loc1 ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( Integer loc1 : arg0 ) { loc0. add ( new Integer ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( Integer [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( List < Integer > arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. size ( ) ) ; for ( int loc1 = 0 ; loc1 < arg0. size ( ) ; loc1 ++ ) { loc0. add ( arg0. get ( loc1 ) ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( int [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( int... arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0. get ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < Integer > powerset ( int... arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; ++ loc1 ) { if ( arg0 [ loc1 ] < loc0. get ( loc1 ) ) { loc0. add ( loc1 ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static Set < Integer > powerset ( int [ ] arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static Set < Integer > powerset ( int... arg0 ) { Set < Integer > loc0 = new HashSet < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < loc0. get ( loc1 ) ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static List < Integer > powerset ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int [ ] powerset ( int [ ] arg0 ) { int [ ] loc0 = new int [ arg0. length ] ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0 [ loc1 ] = arg0 [ loc1 ] ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { loc0. add ( arg0 [ loc1 ] ) ; } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( arg0. length ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static List < Integer > powerset ( Integer [ ] arg0 ) { List < Integer > loc0 = new ArrayList < Integer > ( ) ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) { if ( arg0 [ loc1 ] < arg0 [ loc1 ] ) { loc0. add ( arg0 [ loc1 ] ) ; } } return loc0 ; }",
          "correctness": "wrong"
        }
      ]
    },
    "LCS_LENGTH": {
      "loc": "35-37",
      "input": "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                if (dp.containsKey(i-1)) { \n                    Map<Integer, Integer> internal_map = dp.get(i); \n                    int insert_value = dp.get(i-1).get(j) + 1;\n                    internal_map.put(j, insert_value);\n                    dp.put(i,internal_map);\n                } else {\n                    Map<Integer, Integer> internal_map = dp.get(i);\n                    internal_map.put(j,1);\n                    dp.put(i,internal_map);\n                }\n            }\n        }\n    }\n    if (!dp.isEmpty()) {\n        List<Integer> ret_list = new ArrayList<Integer>();\n        for (int i=0; i<s.length(); i++) {\n            ret_list.add(!dp.get(i).isEmpty() ? Collections.max(dp.get(i).values()) : 0);\n        }\n        return Collections.max(ret_list);\n    } else {\n        return 0;\n    }\n}",
      "target": "public static Integer lcs_length(String s, String t) {\n    Map<Integer, Map<Integer,Integer>> dp = new HashMap<Integer,Map<Integer,Integer>>();\n    for (int i=0; i < s.length(); i++) {\n        Map<Integer,Integer> initialize = new HashMap<Integer,Integer>();\n        dp.put(i, initialize);\n        for (int j=0; j < t.length(); j++) {\n            Map<Integer,Integer> internal_map = dp.get(i);\n            internal_map.put(j,0);\n            dp.put(i, internal_map);\n        }\n    }\n    for (int i=0; i < s.length(); i++) {\n        for (int j=0; j < t.length(); j++) {\n            if (s.charAt(i) == t.charAt(j)) {\n                if (dp.containsKey(i-1)&&dp.get(i-1).containsKey(j-1)) {\n                    Map<Integer, Integer> internal_map = dp.get(i);\n                    int insert_value = dp.get(i-1).get(j-1) + 1;\n                    internal_map.put(j, insert_value);\n                    dp.put(i,internal_map);\n                } else {\n                    Map<Integer, Integer> internal_map = dp.get(i);\n                    internal_map.put(j,1);\n                    dp.put(i,internal_map);\n                }\n            }\n        }\n    }\n    if (!dp.isEmpty()) {\n        List<Integer> ret_list = new ArrayList<Integer>();\n        for (int i=0; i<s.length(); i++) {\n            ret_list.add(!dp.get(i).isEmpty() ? Collections.max(dp.get(i).values()) : 0);\n        }\n        return Collections.max(ret_list);\n    } else {\n        return 0;\n    }\n}",
      "function range": "13,5-58,5",
      "raw_output": [
        "int function ( ) { return 0 ; }",
        "int function ( ) { return 2 ; }",
        "int function ( ) { return 1 ; }",
        "int function ( ) { return 11 ; }",
        "int function ( int arg0 ) { return arg0 ; }",
        "int function ( ) { String loc0 = \"srini_string\" ; int loc1 = 0 ; for ( int loc2 = 1 ; loc2 < 5 ; loc2 ++ ) { if ( loc0. equals ( \"srini_string\" ) ) loc1 = loc2 ; else loc1 = loc0. length ( ) ; } return loc1 ; }",
        "int function ( ) { String loc0 = \"srini_string\" ; int loc1 = 0 ; for ( int loc2 = 1 ; loc2 < 5 ; loc2 ++ ) { if ( loc0. equals ( \"srini_string\" ) ) loc1 = loc2 ; else loc0 = \"srini_string\" ; } return loc1 ; }",
        "int function ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
        "int function ( ) { String loc0 = \"srini_string\" ; int loc1 = 0 ; for ( int loc2 = 1 ; loc2 < 5 ; loc2 ++ ) { loc0 += ( char ) ( loc2 * loc2 ) ; } return loc0. length ( ) ; }",
        "int function ( ) { String loc0 = \"srini_string\" ; int loc1 = 0 ; for ( int loc2 = 1 ; loc2 < 5 ; loc2 ++ ) { loc0 += ( char ) loc2 ; } return loc0. length ( ) ; }",
        "int function ( ) { return 0 ; }",
        "int function ( ) { return 2 ; }",
        "int function ( ) { return 4 ; }",
        "int function ( ) { return 1 ; }",
        "int function ( ) { return 11 ; }",
        "int function ( ) { return 0 ; }",
        "int function ( ) { return 2 ; }",
        "int function ( ) { LcsLength loc0 = new LcsLength ( ) ; return loc0. length ; }",
        "int function ( ) { return 4 ; }",
        "int function ( ) { return 11 ; }",
        "int function ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 += arg0 [ loc1 ] ; return loc0 ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ( arg0 + 1 ) ; }",
        "int function ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
        "int function ( Integer arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ( arg0 + 1 ) ; }",
        "int function ( Integer arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ( int ) Math. ceil ( arg0. toString ( ) ) ; }"
      ],
      "mid_translation": [
        "LCS length Method.",
        "Method lcs_length.",
        "LCS Length Method.",
        "lcs_length Method.",
        "LCS length method."
      ],
      "output": [
        {
          "patch": "public static int lcs_length ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 11 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( int arg0 ) { return arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { String loc0 = \"srini_string\" ; int loc1 = 0 ; for ( int loc2 = 1 ; loc2 < 5 ; loc2 ++ ) { if ( loc0. equals ( \"srini_string\" ) ) loc1 = loc2 ; else loc1 = loc0. length ( ) ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { String loc0 = \"srini_string\" ; int loc1 = 0 ; for ( int loc2 = 1 ; loc2 < 5 ; loc2 ++ ) { if ( loc0. equals ( \"srini_string\" ) ) loc1 = loc2 ; else loc0 = \"srini_string\" ; } return loc1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { throw new UnsupportedOperationException ( \"srini_string\" ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { String loc0 = \"srini_string\" ; int loc1 = 0 ; for ( int loc2 = 1 ; loc2 < 5 ; loc2 ++ ) { loc0 += ( char ) ( loc2 * loc2 ) ; } return loc0. length ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { String loc0 = \"srini_string\" ; int loc1 = 0 ; for ( int loc2 = 1 ; loc2 < 5 ; loc2 ++ ) { loc0 += ( char ) loc2 ; } return loc0. length ( ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 4 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 1 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 11 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 2 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { LcsLength loc0 = new LcsLength ( ) ; return loc0. length ; }",
          "correctness": "uncompilable"
        },
        {
          "patch": "public static int lcs_length ( ) { return 4 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( ) { return 11 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( int [ ] arg0 ) { int loc0 = 0 ; for ( int loc1 = 0 ; loc1 < arg0. length ; loc1 ++ ) loc0 += arg0 [ loc1 ] ; return loc0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ( arg0 + 1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( int arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return arg0 ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( Integer arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ( arg0 + 1 ) ; }",
          "correctness": "wrong"
        },
        {
          "patch": "public static int lcs_length ( Integer arg0 ) { if ( arg0 < 0 ) { throw new IllegalArgumentException ( \"srini_string\" ) ; } return ( int ) Math. ceil ( arg0. toString ( ) ) ; }",
          "correctness": "uncompilable"
        }
      ]
    }
  }
}